{
  "Jsoup-49": "protected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    int j \u003d children.length - 1;\n    while (0 \u003c\u003d j) {\n        Node child \u003d children[j];\n        reparentChild(child);\n        childNodes.add(index, child);\n        j -\u003d 1;\n    }\n    reindexChildren(index);\n}",
  "Jsoup-48": "void processResponseHeaders(Map\u003cString, List\u003cString\u003e\u003e resHeaders) {\n    for (Map.Entry\u003cString, List\u003cString\u003e\u003e headerEntry : resHeaders.entrySet()) {\n        String headerName \u003d headerEntry.getKey();\n        if (null \u003d\u003d headerName)\n            // http/1.1 line\n            continue;\n        List\u003cString\u003e items \u003d headerEntry.getValue();\n        if (!headerName.equalsIgnoreCase(\"Set-Cookie\")) {\n            // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n            if (!items.isEmpty())\n                header(headerName, items.get(0));\n        } else {\n            for (String item : items) {\n                if (null \u003d\u003d item)\n                    continue;\n                TokenQueue tokenQueue \u003d new TokenQueue(item);\n                String cookieKey \u003d tokenQueue.chompTo(\"\u003d\").trim();\n                String cookieValue \u003d tokenQueue.consumeTo(\";\").trim();\n                // ignores path, date, domain, validateTLSCertificates et al. req\u0027d?\n                // name not blank, value not null\n                if (0 \u003c cookieKey.length())\n                    cookie(cookieKey, cookieValue);\n            }\n        }\n    }\n}",
  "Time-5": "public Period normalizedStandard(PeriodType type) {\n    type \u003d DateTimeUtils.getPeriodType(type);\n    // no overflow can happen, even with Integer.MAX_VALUEs\n    long timeInMillis \u003d getMillis();\n    timeInMillis +\u003d (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    timeInMillis +\u003d (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    timeInMillis +\u003d (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    timeInMillis +\u003d (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    timeInMillis +\u003d (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period outcome \u003d new Period(timeInMillis, type, ISOChronology.getInstanceUTC());\n    int age \u003d getYears();\n    int numMonths \u003d getMonths();\n    if (0 !\u003d age || 0 !\u003d numMonths) {\n        age \u003d FieldUtils.safeAdd(age, numMonths / 12);\n        numMonths \u003d numMonths % 12;\n        if (0 !\u003d age) {\n            outcome \u003d outcome.withYears(age);\n        }\n        if (0 !\u003d numMonths) {\n            outcome \u003d outcome.withMonths(numMonths);\n        }\n    }\n    return outcome;\n}",
  "Time-4": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (null \u003d\u003d fieldType) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int position \u003d indexOf(fieldType);\n    if (-1 \u003d\u003d position) {\n        DateTimeFieldType[] expandedTypes \u003d new DateTimeFieldType[iTypes.length + 1];\n        int[] updatedValues \u003d new int[expandedTypes.length];\n        // find correct insertion point to keep largest-smallest order\n        int currentIndex \u003d 0;\n        DurationField durationField \u003d fieldType.getDurationType().getField(iChronology);\n        if (durationField.isSupported()) {\n            while (iTypes.length \u003e currentIndex) {\n                DateTimeFieldType currentFieldType \u003d iTypes[currentIndex];\n                DurationField currentUnitField \u003d currentFieldType.getDurationType().getField(iChronology);\n                if (currentUnitField.isSupported()) {\n                    int distinguish \u003d durationField.compareTo(currentUnitField);\n                    if (0 \u003e\u003d distinguish) {\n                        if (0 \u003d\u003d distinguish) {\n                            DurationField limitField \u003d fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeDurationField \u003d currentFieldType.getRangeDurationType().getField(iChronology);\n                            if (0 \u003c limitField.compareTo(loopRangeDurationField)) {\n                                break;\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                currentIndex +\u003d 1;\n            }\n        }\n        System.arraycopy(iTypes, 0, expandedTypes, 0, currentIndex);\n        System.arraycopy(iValues, 0, updatedValues, 0, currentIndex);\n        expandedTypes[currentIndex] \u003d fieldType;\n        updatedValues[currentIndex] \u003d value;\n        System.arraycopy(iTypes, currentIndex, expandedTypes, currentIndex + 1, expandedTypes.length - currentIndex - 1);\n        System.arraycopy(iValues, currentIndex, updatedValues, currentIndex + 1, updatedValues.length - currentIndex - 1);\n        // use public constructor to ensure full validation\n        // this isn\u0027t overly efficient, but is safe\n        Partial newComposite \u003d new Partial(iChronology, expandedTypes, updatedValues);\n        iChronology.validate(newComposite, updatedValues);\n        return newComposite;\n    }\n    if (getValue(position) \u003d\u003d value) {\n        return this;\n    }\n    int[] updatedValues \u003d getValues();\n    updatedValues \u003d getField(position).set(this, position, updatedValues, value);\n    return new Partial(this, updatedValues);\n}",
  "Time-7": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser dateTimeParser \u003d requireParser();\n    if (null \u003d\u003d instant) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long timestampMillis \u003d instant.getMillis();\n    Chronology calendar \u003d instant.getChronology();\n    long localInstantMillis \u003d timestampMillis + calendar.getZone().getOffset(timestampMillis);\n    calendar \u003d selectChronology(calendar);\n    int baseYear \u003d calendar.year().get(localInstantMillis);\n    DateTimeParserBucket context \u003d new DateTimeParserBucket(localInstantMillis, calendar, iLocale, iPivotYear, baseYear);\n    int parsedPosition \u003d dateTimeParser.parseInto(context, text, position);\n    instant.setMillis(context.computeMillis(false, text));\n    if (!iOffsetParsed || null \u003d\u003d context.getOffsetInteger()) {\n        if (null !\u003d context.getZone()) {\n            calendar \u003d calendar.withZone(context.getZone());\n        }\n    } else {\n        int parsedTimeOffset \u003d context.getOffsetInteger();\n        DateTimeZone timezoneParsed \u003d DateTimeZone.forOffsetMillis(parsedTimeOffset);\n        calendar \u003d calendar.withZone(timezoneParsed);\n    }\n    instant.setChronology(calendar);\n    if (null !\u003d iZone) {\n        instant.setZone(iZone);\n    }\n    return parsedPosition;\n}",
  "Time-8": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n    if (0 \u003d\u003d hoursOffset \u0026\u0026 0 \u003d\u003d minutesOffset) {\n        return DateTimeZone.UTC;\n    }\n    if (-23 \u003e hoursOffset || 23 \u003c hoursOffset) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (0 \u003e minutesOffset || 59 \u003c minutesOffset) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    int displacement \u003d 0;\n    try {\n        int hoursConvertedToMinutes \u003d hoursOffset * 60;\n        if (0 \u003c\u003d hoursConvertedToMinutes) {\n            minutesOffset \u003d hoursConvertedToMinutes + minutesOffset;\n        } else {\n            minutesOffset \u003d hoursConvertedToMinutes - minutesOffset;\n        }\n        displacement \u003d FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(displacement);\n}",
  "Closure-168": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n        return;\n    }\n    if (n.isReturn() \u0026\u0026 null !\u003d n.getFirstChild()) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n    }\n    if (2 \u003e\u003d t.getScopeDepth()) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there\u0027s\n        // no reason to do this extra computation for them.\n        return;\n    }\n    if (// Be careful of bleeding functions, which create variables\n    // in the inner scope, not the scope where the name appears.\n    !n.isName() || !NodeUtil.isLValue(n) || NodeUtil.isBleedingFunctionName(n)) {\n        if (n.isGetProp() \u0026\u0026 n.isUnscopedQualifiedName() \u0026\u0026 NodeUtil.isLValue(n)) {\n            String identifier \u003d NodeUtil.getRootOfQualifiedName(n).getString();\n            Scope context \u003d t.getScope();\n            Var symbol \u003d context.getVar(identifier);\n            if (null !\u003d symbol) {\n                Scope variableScope \u003d symbol.getScope();\n                if (variableScope !\u003d context \u0026\u0026 variableScope.isLocal()) {\n                    data.get(variableScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\n                }\n            }\n        }\n    } else {\n        String identifier \u003d n.getString();\n        Scope context \u003d t.getScope();\n        Var symbol \u003d context.getVar(identifier);\n        if (null !\u003d symbol) {\n            Scope variableScope \u003d symbol.getScope();\n            if (variableScope.isLocal()) {\n                data.get(variableScope.getRootNode()).recordAssignedName(identifier);\n            }\n            if (variableScope !\u003d context \u0026\u0026 variableScope.isLocal()) {\n                data.get(variableScope.getRootNode()).recordEscapedVarName(identifier);\n            }\n        }\n    }\n}",
  "Closure-176": "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String variableName \u003d left.getString();\n            Var declaration \u003d syntacticScope.getVar(variableName);\n            boolean isVariableDeclaration \u003d left.hasChildren();\n            // When looking at VAR initializers for declared VARs, we tend\n            // to use the declared type over the type it\u0027s being\n            // initialized to in the global scope.\n            //\n            // For example,\n            // /** @param {number} */ var f \u003d goog.abstractMethod;\n            // it\u0027s obvious that the programmer wants you to use\n            // the declared function signature, not the inferred signature.\n            //\n            // Or,\n            // /** @type {Object.\u003cstring\u003e} */ var x \u003d {};\n            // the one-time anonymous object on the right side\n            // is as narrow as it can possibly be, but we need to make\n            // sure we back-infer the \u003cstring\u003e element constraint on\n            // the left hand side, so we use the left hand side.\n            boolean isVarTypePreferred \u003d !isVariableDeclaration || null \u003d\u003d declaration || declaration.isTypeInferred();\n            // Makes it easier to check for NPEs.\n            // TODO(nicksantos): This might be a better check once we have\n            // back-inference of object/array constraints.  It will probably\n            // introduce more type warnings.  It uses the result type iff it\u0027s\n            // strictly narrower than the declared var type.\n            //\n            //boolean isVarTypeBetter \u003d isVarDeclaration \u0026\u0026\n            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n            //     || !resultType.isSubtype(varType));\n            if (isVarTypePreferred) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVariableDeclaration || null \u003d\u003d leftType ? resultType : null);\n            if (null !\u003d declaration \u0026\u0026 declaration.isTypeInferred()) {\n                JSType previousType \u003d declaration.getType();\n                declaration.setType(null \u003d\u003d previousType ? resultType : previousType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedIdentifier \u003d left.getQualifiedName();\n            if (null !\u003d qualifiedIdentifier) {\n                scope.inferQualifiedSlot(left, qualifiedIdentifier, null \u003d\u003d leftType ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}",
  "Closure-172": "private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (null \u003d\u003d valueType) {\n        return true;\n    }\n    // Prototypes of constructors and interfaces are always declared.\n    if (null !\u003d qName \u0026\u0026 qName.endsWith(\".prototype\")) {\n        return false;\n    }\n    boolean assumed \u003d true;\n    if (null !\u003d info) {\n        assumed \u003d !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) \u0026\u0026 null !\u003d valueType \u0026\u0026 !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (assumed \u0026\u0026 null !\u003d rhsValue \u0026\u0026 rhsValue.isFunction()) {\n        if (null \u003d\u003d info) {\n            if (!scope.isDeclared(qName, false) \u0026\u0026 n.isUnscopedQualifiedName()) {\n                Node parentNode \u003d n.getParent();\n                while (!(parentNode.isScript() || parentNode.isFunction())) {\n                    if (NodeUtil.isControlStructure(parentNode)) {\n                        return true;\n                    }\n                    parentNode \u003d parentNode.getParent();\n                }\n                // Check if this is in a conditional block.\n                // Check if this is assigned in an inner scope.\n                // Functions assigned in inner scopes are inferred.\n                AstFunctionContents functionAnalysisResults \u003d getFunctionAnalysisResults(scope.getRootNode());\n                if (null \u003d\u003d functionAnalysisResults || !functionAnalysisResults.getEscapedQualifiedNames().contains(qName)) {\n                    return false;\n                }\n            }\n        } else {\n            return false;\n        }\n    }\n    return assumed;\n}",
  "Jsoup-41": "public boolean equals(Object o) {\n    if (o \u003d\u003d this)\n        return true;\n    if (null \u003d\u003d o || o.getClass() !\u003d getClass())\n        return false;\n    if (!super.equals(o))\n        return false;\n    Element item \u003d (Element) o;\n    return o \u003d\u003d this;\n}",
  "Jsoup-40": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    Validate.notEmpty(name);\n    attr(\"name\", name);\n    attr(\"publicId\", publicId);\n    attr(\"systemId\", systemId);\n}",
  "Jsoup-43": "private static \u003cE extends Element\u003e Integer indexInList(Element search, List\u003cE\u003e elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    int index \u003d 0;\n    while (elements.size() \u003e index) {\n        E item \u003d elements.get(index);\n        if (item.equals(search))\n            return index;\n        index +\u003d 1;\n    }\n    return null;\n}",
  "Jsoup-42": "public List\u003cConnection.KeyVal\u003e formData() {\n    ArrayList\u003cConnection.KeyVal\u003e formValues \u003d new ArrayList\u003cConnection.KeyVal\u003e();\n    // iterate the form control elements and accumulate their values\n    for (Element element : elements) {\n        // contents are form listable, superset of submitable\n        if (!element.tag().isFormSubmittable())\n            continue;\n        String fieldName \u003d element.attr(\"name\");\n        if (0 \u003d\u003d fieldName.length())\n            continue;\n        String formType \u003d element.attr(\"type\");\n        if (!\"select\".equals(element.tagName())) {\n            if (!\"checkbox\".equalsIgnoreCase(formType) \u0026\u0026 !\"radio\".equalsIgnoreCase(formType)) {\n                formValues.add(HttpConnection.KeyVal.create(fieldName, element.val()));\n            } else {\n                // only add checkbox or radio if they have the checked attribute\n                if (element.hasAttr(\"checked\")) {\n                    final String value \u003d element.val();\n                    formValues.add(HttpConnection.KeyVal.create(fieldName, value));\n                }\n            }\n        } else {\n            Elements choices \u003d element.select(\"option[selected]\");\n            boolean isSet \u003d false;\n            for (Element candidate : choices) {\n                formValues.add(HttpConnection.KeyVal.create(fieldName, candidate.val()));\n                isSet \u003d true;\n            }\n            if (!isSet) {\n                Element candidate \u003d element.select(\"option\").first();\n                if (null !\u003d candidate)\n                    formValues.add(HttpConnection.KeyVal.create(fieldName, candidate.val()));\n            }\n        }\n    }\n    return formValues;\n}",
  "Jsoup-45": "void resetInsertionMode() {\n    boolean isLast \u003d false;\n    int index \u003d stack.size() - 1;\n    while (0 \u003c\u003d index) {\n        Element element \u003d stack.get(index);\n        if (0 \u003d\u003d index) {\n            isLast \u003d true;\n            element \u003d contextElement;\n        }\n        String elementName \u003d element.nodeName();\n        if (!\"select\".equals(elementName)) {\n            if (!((\"td\".equals(elementName) || \"td\".equals(elementName) \u0026\u0026 !isLast))) {\n                if (!\"tr\".equals(elementName)) {\n                    if (!\"tbody\".equals(elementName) \u0026\u0026 !\"thead\".equals(elementName) \u0026\u0026 !\"tfoot\".equals(elementName)) {\n                        if (!\"caption\".equals(elementName)) {\n                            if (!\"colgroup\".equals(elementName)) {\n                                if (!\"table\".equals(elementName)) {\n                                    if (!\"head\".equals(elementName)) {\n                                        if (!\"body\".equals(elementName)) {\n                                            if (!\"frameset\".equals(elementName)) {\n                                                if (!\"html\".equals(elementName)) {\n                                                    if (isLast) {\n                                                        transition(HtmlTreeBuilderState.InBody);\n                                                        // frag\n                                                        break;\n                                                    }\n                                                } else {\n                                                    transition(HtmlTreeBuilderState.BeforeHead);\n                                                    // frag\n                                                    break;\n                                                }\n                                            } else {\n                                                transition(HtmlTreeBuilderState.InFrameset);\n                                                // frag\n                                                break;\n                                            }\n                                        } else {\n                                            transition(HtmlTreeBuilderState.InBody);\n                                            break;\n                                        }\n                                    } else {\n                                        transition(HtmlTreeBuilderState.InBody);\n                                        // frag\n                                        break;\n                                    }\n                                } else {\n                                    transition(HtmlTreeBuilderState.InTable);\n                                    break;\n                                }\n                            } else {\n                                transition(HtmlTreeBuilderState.InColumnGroup);\n                                // frag\n                                break;\n                            }\n                        } else {\n                            transition(HtmlTreeBuilderState.InCaption);\n                            break;\n                        }\n                    } else {\n                        transition(HtmlTreeBuilderState.InTableBody);\n                        break;\n                    }\n                } else {\n                    transition(HtmlTreeBuilderState.InRow);\n                    break;\n                }\n            } else {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            }\n        } else {\n            transition(HtmlTreeBuilderState.InSelect);\n            // frag\n            break;\n        }\n        index -\u003d 1;\n    }\n}",
  "Jsoup-47": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhitespace \u003d false;\n    boolean isFirstNonWhitespace \u003d false;\n    final EscapeMode serializationMode \u003d out.escapeMode();\n    final CharsetEncoder charsetEncoder \u003d out.encoder();\n    final CoreCharset primaryCharset \u003d CoreCharset.byName(charsetEncoder.charset().name());\n    final Map\u003cCharacter, String\u003e escapeMap \u003d serializationMode.getMap();\n    final int size \u003d string.length();\n    int charCode;\n    int index \u003d 0;\n    while (size \u003e index) {\n        charCode \u003d string.codePointAt(index);\n        if (normaliseWhite) {\n            if (!StringUtil.isWhitespace(charCode)) {\n                lastWasWhitespace \u003d false;\n                isFirstNonWhitespace \u003d true;\n            } else {\n                if ((stripLeadingWhite \u0026\u0026 !isFirstNonWhitespace) || lastWasWhitespace)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWasWhitespace \u003d true;\n                continue;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (Character.MIN_SUPPLEMENTARY_CODE_POINT \u003c\u003d charCode) {\n            final String character \u003d new String(Character.toChars(charCode));\n            if (// uses fallback encoder for simplicity\n            charsetEncoder.canEncode(character))\n                accum.append(character);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(charCode)).append(\u0027;\u0027);\n        } else {\n            final char character \u003d (char) charCode;\n            // html specific and required escapes:\n            switch(character) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (EscapeMode.xhtml !\u003d serializationMode)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(\"\u0026#xa0;\");\n                    break;\n                case \u0027\u003c\u0027:\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(character);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(character);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(character);\n                    break;\n                default:\n                    if (!canEncode(primaryCharset, character, charsetEncoder)) {\n                        if (escapeMap.containsKey(character))\n                            accum.append(\u0027\u0026\u0027).append(escapeMap.get(character)).append(\u0027;\u0027);\n                        else\n                            accum.append(\"\u0026#x\").append(Integer.toHexString(charCode)).append(\u0027;\u0027);\n                    } else\n                        accum.append(character);\n            }\n        }\n        index +\u003d Character.charCount(charCode);\n    }\n}",
  "Jsoup-46": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWhitespaceEncountered \u003d false;\n    boolean reachedVisibleCharacter \u003d false;\n    final EscapeMode encodingMode \u003d out.escapeMode();\n    final CharsetEncoder charsetEncoder \u003d out.encoder();\n    final CoreCharset primaryCharset \u003d CoreCharset.byName(charsetEncoder.charset().name());\n    final Map\u003cCharacter, String\u003e escapeMap \u003d encodingMode.getMap();\n    final int size \u003d string.length();\n    int unicodePoint;\n    int index \u003d 0;\n    while (size \u003e index) {\n        unicodePoint \u003d string.codePointAt(index);\n        if (normaliseWhite) {\n            if (!StringUtil.isWhitespace(unicodePoint)) {\n                lastWhitespaceEncountered \u003d false;\n                reachedVisibleCharacter \u003d true;\n            } else {\n                if ((stripLeadingWhite \u0026\u0026 !reachedVisibleCharacter) || lastWhitespaceEncountered)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWhitespaceEncountered \u003d true;\n                continue;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (Character.MIN_SUPPLEMENTARY_CODE_POINT \u003c\u003d unicodePoint) {\n            final String character \u003d new String(Character.toChars(unicodePoint));\n            if (// uses fallback encoder for simplicity\n            charsetEncoder.canEncode(character))\n                accum.append(character);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(unicodePoint)).append(\u0027;\u0027);\n        } else {\n            final char character \u003d (char) unicodePoint;\n            // html specific and required escapes:\n            switch(character) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (EscapeMode.xhtml !\u003d encodingMode)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(character);\n                    break;\n                case \u0027\u003c\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(character);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(character);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(character);\n                    break;\n                default:\n                    if (!canEncode(primaryCharset, character, charsetEncoder)) {\n                        if (escapeMap.containsKey(character))\n                            accum.append(\u0027\u0026\u0027).append(escapeMap.get(character)).append(\u0027;\u0027);\n                        else\n                            accum.append(\"\u0026#x\").append(Integer.toHexString(unicodePoint)).append(\u0027;\u0027);\n                    } else\n                        accum.append(character);\n            }\n        }\n        index +\u003d Character.charCount(unicodePoint);\n    }\n}",
  "Jsoup-59": "final void newAttribute() {\n    if (null \u003d\u003d attributes)\n        attributes \u003d new Attributes();\n    if (null !\u003d pendingAttributeName) {\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName \u003d pendingAttributeName.trim();\n        Attribute property;\n        if (!hasPendingAttributeValue) {\n            if (hasEmptyAttributeValue)\n                property \u003d new Attribute(pendingAttributeName, \"\");\n            else\n                property \u003d new BooleanAttribute(pendingAttributeName);\n        } else\n            property \u003d new Attribute(pendingAttributeName, 0 \u003c pendingAttributeValue.length() ? pendingAttributeValue.toString() : pendingAttributeValueS);\n        attributes.put(property);\n    }\n    pendingAttributeName \u003d null;\n    hasEmptyAttributeValue \u003d false;\n    hasPendingAttributeValue \u003d false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS \u003d null;\n}",
  "Jsoup-50": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String contentData;\n    Document document \u003d null;\n    // look for BOM - overrides any other header or input\n    if (null !\u003d charsetName) {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        contentData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    } else {\n        // determine from meta. safe parse as UTF-8\n        // look for \u003cmeta http-equiv\u003d\"Content-Type\" content\u003d\"text/html;charset\u003dgb2312\"\u003e or HTML5 \u003cmeta charset\u003d\"gb2312\"\u003e\n        contentData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        document \u003d parser.parseInput(contentData, baseUri);\n        Element metaData \u003d document.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (null !\u003d metaData) {\n            // if not found, will keep utf-8 as best attempt\n            String detectedCharset \u003d null;\n            if (metaData.hasAttr(\"http-equiv\")) {\n                detectedCharset \u003d getCharsetFromContentType(metaData.attr(\"content\"));\n            }\n            if (null \u003d\u003d detectedCharset \u0026\u0026 metaData.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(metaData.attr(\"charset\"))) {\n                        detectedCharset \u003d metaData.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    detectedCharset \u003d null;\n                }\n            }\n            if (null !\u003d detectedCharset \u0026\u0026 0 !\u003d detectedCharset.length() \u0026\u0026 !detectedCharset.equals(defaultCharset)) {\n                // need to re-decode\n                detectedCharset \u003d detectedCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                charsetName \u003d detectedCharset;\n                byteData.rewind();\n                contentData \u003d Charset.forName(detectedCharset).decode(byteData).toString();\n                document \u003d null;\n            }\n        }\n    }\n    if (0 \u003c contentData.length() \u0026\u0026 UNICODE_BOM \u003d\u003d contentData.charAt(0)) {\n        byteData.rewind();\n        contentData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        contentData \u003d contentData.substring(1);\n        charsetName \u003d defaultCharset;\n        document \u003d null;\n    }\n    if (null \u003d\u003d document) {\n        document \u003d parser.parseInput(contentData, baseUri);\n        document.outputSettings().charset(charsetName);\n    }\n    return document;\n}",
  "Jsoup-51": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char character \u003d input[pos];\n    return (\u0027A\u0027 \u003c\u003d character \u0026\u0026 \u0027Z\u0027 \u003e\u003d character) || (\u0027a\u0027 \u003c\u003d character \u0026\u0026 \u0027z\u0027 \u003e\u003d character);\n}",
  "Jsoup-54": "private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n    for (Attribute property : source.attributes()) {\n        // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n        String attributeKey \u003d property.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n        el.setAttribute(attributeKey, property.getValue());\n    }\n}",
  "Jsoup-53": "public String chompBalanced(char open, char close) {\n    int beginning \u003d -1;\n    int finalPosition \u003d -1;\n    int level \u003d 0;\n    char previous \u003d 0;\n    do {\n        if (isEmpty())\n            break;\n        Character c \u003d consume();\n        if (0 \u003d\u003d previous || ESC !\u003d previous) {\n            if (!c.equals(open)) {\n                if (c.equals(close))\n                    level -\u003d 1;\n            } else {\n                level +\u003d 1;\n                if (-1 \u003d\u003d beginning)\n                    beginning \u003d pos;\n            }\n        }\n        if (0 \u003c level \u0026\u0026 0 !\u003d previous)\n            // don\u0027t include the outer match pair in the return\n            finalPosition \u003d pos;\n        previous \u003d c;\n    } while (0 \u003c level);\n    return (0 \u003c\u003d finalPosition) ? queue.substring(beginning, finalPosition) : \"\";\n}",
  "Jsoup-55": "void read(Tokeniser t, CharacterReader r) {\n    char character \u003d r.consume();\n    switch(character) {\n        case \u0027\u003e\u0027:\n            t.tagPending.selfClosing \u003d true;\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.error(this);\n            t.transition(BeforeAttributeName);\n    }\n}",
  "Jsoup-57": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (null \u003d\u003d attributes)\n        return;\n    Iterator\u003cString\u003e iterator \u003d attributes.keySet().iterator();\n    while (iterator.hasNext()) {\n        String attributeKey \u003d iterator.next();\n        if (attributeKey.equalsIgnoreCase(key))\n            attributes.remove(attributeKey);\n    }\n}",
  "Closure-91": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (Token.FUNCTION \u003d\u003d n.getType()) {\n        // Don\u0027t traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo functionJsDoc \u003d getFunctionJsDocInfo(n);\n        if (null !\u003d functionJsDoc \u0026\u0026 (functionJsDoc.isConstructor() || functionJsDoc.isInterface() || functionJsDoc.hasThisType() || functionJsDoc.isOverride())) {\n            return false;\n        }\n        // Don\u0027t traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a \u003d function() { }; // or\n        // function a() {} // or\n        // a.x \u003d function() {}; // or\n        // var a \u003d {x: function() {}};\n        int parentType \u003d parent.getType();\n        if (!(// object literal keys\n        Token.BLOCK \u003d\u003d parentType || Token.SCRIPT \u003d\u003d parentType || Token.NAME \u003d\u003d parentType || Token.ASSIGN \u003d\u003d parentType || Token.STRING \u003d\u003d parentType || Token.NUMBER \u003d\u003d parentType)) {\n            return false;\n        }\n        // Don\u0027t traverse functions that are getting lent to a prototype.\n    }\n    if (null !\u003d parent \u0026\u0026 Token.ASSIGN \u003d\u003d parent.getType()) {\n        Node leftHandSide \u003d parent.getFirstChild();\n        Node rhsValue \u003d leftHandSide.getNext();\n        if (leftHandSide !\u003d n) {\n            // Only traverse the right side if it\u0027s not an assignment to a prototype\n            // property or subproperty.\n            if (NodeUtil.isGet(leftHandSide)) {\n                if (Token.GETPROP \u003d\u003d leftHandSide.getType() \u0026\u0026 leftHandSide.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs \u003d leftHandSide.getFirstChild();\n                if (Token.GETPROP \u003d\u003d llhs.getType() \u0026\u0026 llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        } else {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a \u003d this).property \u003d c;),\n            // assignLhsChild should not be overridden.\n            if (null \u003d\u003d assignLhsChild) {\n                assignLhsChild \u003d leftHandSide;\n            }\n        }\n    }\n    return true;\n}",
  "Closure-92": "void replace() {\n    if (null \u003d\u003d firstNode) {\n        // Don\u0027t touch the base case (\u0027goog\u0027).\n        replacementNode \u003d candidateDefinition;\n        return;\n    }\n    // Handle the case where there is a duplicate definition for an explicitly\n    // provided symbol.\n    if (null \u003d\u003d candidateDefinition || null \u003d\u003d explicitNode) {\n        // Handle the case where there\u0027s not a duplicate definition.\n        replacementNode \u003d createDeclarationNode();\n        if (minimumModule !\u003d firstModule) {\n            // In this case, the name was implicitly provided by two independent\n            // modules. We need to move this code up to a common module.\n            int dotIndex \u003d namespace.indexOf(\u0027.\u0027);\n            if (-1 !\u003d dotIndex) {\n                // Add it after the parent namespace.\n                ProvidedName parentIdentifier \u003d providedNames.get(namespace.substring(0, dotIndex));\n                Preconditions.checkNotNull(parentIdentifier);\n                Preconditions.checkNotNull(parentIdentifier.replacementNode);\n                parentIdentifier.replacementNode.getParent().addChildAfter(replacementNode, parentIdentifier.replacementNode);\n            } else {\n                // Any old place is fine.\n                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n            }\n        } else {\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        }\n        if (null !\u003d explicitNode) {\n            explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n    } else {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n        // Does this need a VAR keyword?\n        replacementNode \u003d candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assignmentNode \u003d candidateDefinition.getFirstChild();\n            Node identifierNode \u003d assignmentNode.getFirstChild();\n            if (Token.NAME \u003d\u003d identifierNode.getType()) {\n                // Need to convert this assign to a var declaration.\n                Node assignedValueNode \u003d identifierNode.getNext();\n                assignmentNode.removeChild(identifierNode);\n                assignmentNode.removeChild(assignedValueNode);\n                identifierNode.addChildToFront(assignedValueNode);\n                Node tempVarNode \u003d new Node(Token.VAR, identifierNode);\n                tempVarNode.copyInformationFrom(candidateDefinition);\n                candidateDefinition.getParent().replaceChild(candidateDefinition, tempVarNode);\n                identifierNode.setJSDocInfo(assignmentNode.getJSDocInfo());\n                compiler.reportCodeChange();\n                replacementNode \u003d tempVarNode;\n            }\n        }\n    }\n}",
  "Compress-32": "private void applyPaxHeadersToCurrentEntry(Map\u003cString, String\u003e headers) {\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n     * mtime\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid,uname\n     * SCHILY.devminor, SCHILY.devmajor: don\u0027t have setters/getters for those\n     */\n    for (Entry\u003cString, String\u003e entry : headers.entrySet()) {\n        String headerKey \u003d entry.getKey();\n        String value \u003d entry.getValue();\n        if (!\"path\".equals(headerKey)) {\n            if (!\"linkpath\".equals(headerKey)) {\n                if (!\"gid\".equals(headerKey)) {\n                    if (!\"gname\".equals(headerKey)) {\n                        if (!\"uid\".equals(headerKey)) {\n                            if (!\"uname\".equals(headerKey)) {\n                                if (!\"size\".equals(headerKey)) {\n                                    if (!\"mtime\".equals(headerKey)) {\n                                        if (!\"SCHILY.devminor\".equals(headerKey)) {\n                                            if (\"SCHILY.devmajor\".equals(headerKey)) {\n                                                currEntry.setDevMajor(Integer.parseInt(value));\n                                            }\n                                        } else {\n                                            currEntry.setDevMinor(Integer.parseInt(value));\n                                        }\n                                    } else {\n                                        currEntry.setModTime((long) (Double.parseDouble(value) * 1000));\n                                    }\n                                } else {\n                                    currEntry.setSize(Long.parseLong(value));\n                                }\n                            } else {\n                                currEntry.setUserName(value);\n                            }\n                        } else {\n                            currEntry.setUserId(Integer.parseInt(value));\n                        }\n                    } else {\n                        currEntry.setGroupName(value);\n                    }\n                } else {\n                    currEntry.setGroupId(Integer.parseInt(value));\n                }\n            } else {\n                currEntry.setLinkName(value);\n            }\n        } else {\n            currEntry.setName(value);\n        }\n    }\n}",
  "Compress-31": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long value \u003d 0;\n    int finish \u003d offset + length;\n    int begin \u003d offset;\n    if (2 \u003e length) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (0 \u003d\u003d buffer[begin]) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (finish \u003e begin) {\n        if (\u0027 \u0027 !\u003d buffer[begin]) {\n            break;\n        } else {\n            begin +\u003d 1;\n        }\n    }\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte endByte \u003d buffer[finish - 1];\n    while (finish \u003e begin \u0026\u0026 (0 \u003d\u003d endByte || \u0027 \u0027 \u003d\u003d endByte)) {\n        finish -\u003d 1;\n        endByte \u003d buffer[finish - 1];\n    }\n    while (finish \u003e begin) {\n        final byte byteValue \u003d buffer[begin];\n        if (0 \u003d\u003d byteValue) {\n            break;\n        }\n        // CheckStyle:MagicNumber OFF\n        if (\u00270\u0027 \u003e byteValue || \u00277\u0027 \u003c byteValue) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, begin, byteValue));\n        }\n        // convert from ASCII\n        value \u003d (value \u003c\u003c 3) + (byteValue - \u00270\u0027);\n        // CheckStyle:MagicNumber ON\n        begin +\u003d 1;\n    }\n    return value;\n}",
  "Compress-30": "public int read(final byte[] dest, final int offs, final int len) throws IOException {\n    if (0 \u003e offs) {\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") \u003c 0.\");\n    }\n    if (0 \u003e len) {\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") \u003c 0.\");\n    }\n    if (dest.length \u003c offs + len) {\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") \u003e dest.length(\" + dest.length + \").\");\n    }\n    if (null \u003d\u003d this.in) {\n        throw new IOException(\"stream closed\");\n    }\n    final int endIndex \u003d offs + len;\n    int destinationOffset \u003d offs;\n    int byteValue;\n    while (endIndex \u003e destinationOffset \u0026\u0026 (0 \u003c\u003d (byteValue \u003d read0()))) {\n        dest[destinationOffset++] \u003d (byte) byteValue;\n        count(1);\n    }\n    int bytesRead \u003d (offs \u003d\u003d destinationOffset) ? -1 : (destinationOffset - offs);\n    return bytesRead;\n}",
  "Closure-95": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || null !\u003d type);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean isDeclaredInGlobalThis \u003d false;\n    if (Token.NAME !\u003d n.getType()) {\n        Preconditions.checkArgument(Token.GETPROP \u003d\u003d n.getType() \u0026\u0026 (Token.ASSIGN \u003d\u003d parent.getType() || Token.EXPR_RESULT \u003d\u003d parent.getType()));\n    } else {\n        Preconditions.checkArgument(Token.FUNCTION \u003d\u003d parent.getType() || Token.VAR \u003d\u003d parent.getType() || Token.LP \u003d\u003d parent.getType() || Token.CATCH \u003d\u003d parent.getType());\n        isDeclaredInGlobalThis \u003d scope.isGlobal() \u0026\u0026 (Token.VAR \u003d\u003d parent.getType() || Token.FUNCTION \u003d\u003d parent.getType());\n    }\n    String varName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!varName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeForDeclaration \u003d scope;\n    // don\u0027t try to declare in the global scope if there\u0027s\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (!scopeForDeclaration.isDeclared(varName, false)) {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput source \u003d compiler.getInput(sourceName);\n        scopeForDeclaration.declare(varName, n, type, source, inferred);\n        if (isDeclaredInGlobalThis) {\n            ObjectType globalObject \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExternal \u003d source.isExtern();\n            if (!inferred) {\n                globalObject.defineDeclaredProperty(varName, type, isExternal);\n            } else {\n                globalObject.defineInferredProperty(varName, null \u003d\u003d type ? getNativeType(JSTypeNative.NO_TYPE) : type, isExternal);\n            }\n        }\n        // If we\u0027re in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeForDeclaration.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n            FunctionType functionType \u003d (FunctionType) type;\n            if (functionType.isConstructor() || functionType.isInterface()) {\n                FunctionType baseClassConstructor \u003d functionType.getSuperClassConstructor();\n                scopeForDeclaration.declare(varName + \".prototype\", n, functionType.getPrototype(), compiler.getInput(sourceName), /* declared iff there\u0027s an explicit supertype */\n                null \u003d\u003d baseClassConstructor || baseClassConstructor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    } else {\n        Var previousVar \u003d scopeForDeclaration.getVar(varName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, previousVar, varName, type);\n    }\n}",
  "Compress-37": "Map\u003cString, String\u003e parsePaxHeaders(final InputStream i) throws IOException {\n    final Map\u003cString, String\u003e metadata \u003d new HashMap\u003cString, String\u003e(globalPaxHeaders);\n    // Format is \"length keyword\u003dvalue\\n\";\n    while (true) {\n        // get length\n        int character;\n        int lengthValue \u003d 0;\n        int read \u003d 0;\n        while (-1 !\u003d (character \u003d i.read())) {\n            read +\u003d 1;\n            if (\u0027 \u0027 \u003d\u003d character) {\n                // Get keyword\n                final ByteArrayOutputStream keywordBuffer \u003d new ByteArrayOutputStream();\n                while (-1 !\u003d (character \u003d i.read())) {\n                    read +\u003d 1;\n                    if (\u0027\u003d\u0027 \u003d\u003d character) {\n                        // end of keyword\n                        final String entryKey \u003d keywordBuffer.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int remainingLength \u003d lengthValue - read;\n                        if (1 !\u003d remainingLength) {\n                            final byte[] remainingBytes \u003d new byte[remainingLength];\n                            final int bytesRead \u003d IOUtils.readFully(i, remainingBytes);\n                            if (remainingLength !\u003d bytesRead) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + remainingLength + \" bytes, read \" + bytesRead);\n                            }\n                            // Drop trailing NL\n                            final String content \u003d new String(remainingBytes, 0, remainingLength - 1, CharsetNames.UTF_8);\n                            metadata.put(entryKey, content);\n                        } else {\n                            // only NL\n                            metadata.remove(entryKey);\n                        }\n                        break;\n                    }\n                    keywordBuffer.write((byte) character);\n                }\n                // Processed single header\n                break;\n            }\n            lengthValue *\u003d 10;\n            lengthValue +\u003d character - \u00270\u0027;\n        }\n        if (-1 \u003d\u003d character) {\n            // EOF\n            break;\n        }\n    }\n    return metadata;\n}",
  "Closure-96": "private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator\u003cNode\u003e params \u003d call.children().iterator();\n    // skip the function name\n    params.next();\n    Iterator\u003cNode\u003e args \u003d functionType.getParameters().iterator();\n    int index \u003d 0;\n    Node parameter \u003d null;\n    Node paramValue \u003d null;\n    while (params.hasNext() \u0026\u0026 args.hasNext()) {\n        // If there are no parameters left in the list, then the while loop\n        // above implies that this must be a var_args function.\n        parameter \u003d args.next();\n        paramValue \u003d params.next();\n        index +\u003d 1;\n        validator.expectArgumentMatchesParameter(t, paramValue, getJSType(paramValue), getJSType(parameter), call, index);\n    }\n    int argCount \u003d call.getChildCount() - 1;\n    int minimumArguments \u003d functionType.getMinArguments();\n    int maxArguments \u003d functionType.getMaxArguments();\n    if (argCount \u003c minimumArguments || argCount \u003e maxArguments) {\n        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(argCount), String.valueOf(minimumArguments), Integer.MAX_VALUE !\u003d maxArguments ? \" and no more than \" + maxArguments + \" argument(s)\" : \"\");\n    }\n}",
  "Compress-36": "private InputStream getCurrentStream() throws IOException {\n    if (deferredBlockStreams.isEmpty()) {\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n    }\n    while (1 \u003c deferredBlockStreams.size()) {\n        // In solid compression mode we need to decompress all leading folder\u0027\n        // streams to get access to an entry. We defer this until really needed\n        // so that entire blocks can be skipped without wasting time for decompression.\n        final InputStream inputStream \u003d deferredBlockStreams.remove(0);\n        IOUtils.skip(inputStream, Long.MAX_VALUE);\n        inputStream.close();\n    }\n    return deferredBlockStreams.get(0);\n}",
  "Compress-35": "public static boolean verifyCheckSum(byte[] header) {\n    long calculatedSum \u003d 0;\n    long totalUnsignedSum \u003d 0;\n    long totalSum \u003d 0;\n    int count \u003d 0;\n    int index \u003d 0;\n    while (header.length \u003e index) {\n        byte b \u003d header[index];\n        if (index \u003e\u003d CHKSUM_OFFSET \u0026\u0026 CHKSUM_OFFSET + CHKSUMLEN \u003e index) {\n            if (b \u003c \u00270\u0027 || \u00277\u0027 \u003c b || 6 \u003c\u003d count++) {\n                if (0 \u003c count) {\n                    count \u003d 6;\n                }\n            } else {\n                calculatedSum \u003d calculatedSum * 8 + b - \u00270\u0027;\n            }\n            b \u003d \u0027 \u0027;\n        }\n        totalUnsignedSum +\u003d 0xff \u0026 b;\n        totalSum +\u003d b;\n        index +\u003d 1;\n    }\n    return totalUnsignedSum \u003d\u003d calculatedSum || totalSum \u003d\u003d calculatedSum;\n}",
  "Closure-94": "static boolean isValidDefineValue(Node val, Set\u003cString\u003e defines) {\n    switch(val.getType()) {\n        case Token.STRING:\n        case Token.NUMBER:\n        case Token.TRUE:\n        case Token.FALSE:\n            return true;\n        // Binary operators are only valid if both children are valid.\n        case Token.BITAND:\n        case Token.BITNOT:\n        case Token.BITOR:\n        case Token.BITXOR:\n        // Uniary operators are valid if the child is valid.\n        case Token.NOT:\n        case Token.NEG:\n            return isValidDefineValue(val.getFirstChild(), defines);\n        // Names are valid if and only if they are defines themselves.\n        case Token.NAME:\n        case Token.GETPROP:\n            if (val.isQualifiedName()) {\n                return defines.contains(val.getQualifiedName());\n            }\n    }\n    return false;\n}",
  "Compress-34": "public ZipShort getCentralDirectoryLength() {\n    return getLocalFileDataLength();\n}",
  "Closure-99": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (Token.FUNCTION \u003d\u003d n.getType()) {\n        // Don\u0027t traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo docInfo \u003d getFunctionJsDocInfo(n);\n        if (null !\u003d docInfo \u0026\u0026 (docInfo.isConstructor() || docInfo.hasThisType() || docInfo.isOverride())) {\n            return false;\n        }\n        // Don\u0027t traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a \u003d function() { }; // or\n        // function a() {} // or\n        // a.x \u003d function() {};\n        int parentType \u003d parent.getType();\n        if (!(Token.BLOCK \u003d\u003d parentType || Token.SCRIPT \u003d\u003d parentType || Token.NAME \u003d\u003d parentType || Token.ASSIGN \u003d\u003d parentType)) {\n            return false;\n        }\n    }\n    if (null !\u003d parent \u0026\u0026 Token.ASSIGN \u003d\u003d parent.getType()) {\n        Node leftHandSide \u003d parent.getFirstChild();\n        Node rightHandSide \u003d leftHandSide.getNext();\n        if (leftHandSide !\u003d n) {\n            // Only traverse the right side if it\u0027s not an assignment to a prototype\n            // property or subproperty.\n            if (Token.GETPROP \u003d\u003d leftHandSide.getType() \u0026\u0026 leftHandSide.getLastChild().getString().equals(\"prototype\")) {\n                return false;\n            }\n            if (null !\u003d leftHandSide.getQualifiedName() \u0026\u0026 leftHandSide.getQualifiedName().contains(\".prototype.\")) {\n                return false;\n            }\n        } else {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a \u003d this).property \u003d c;),\n            // assignLhsChild should not be overridden.\n            if (null \u003d\u003d assignLhsChild) {\n                assignLhsChild \u003d leftHandSide;\n            }\n        }\n    }\n    return true;\n}",
  "Closure-97": "private Node tryFoldShift(Node n, Node left, Node right) {\n    if (Token.NUMBER \u003d\u003d left.getType() \u0026\u0026 Token.NUMBER \u003d\u003d right.getType()) {\n        double output;\n        double leftValue \u003d left.getDouble();\n        double rShiftValue \u003d right.getDouble();\n        // check ranges.  We do not do anything that would clip the double to\n        // a 32-bit range, since the user likely does not intend that.\n        if (!(Integer.MIN_VALUE \u003c\u003d leftValue \u0026\u0026 Integer.MAX_VALUE \u003e\u003d leftValue)) {\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n            return n;\n        }\n        // only the lower 5 bits are used when shifting, so don\u0027t do anything\n        // if the shift amount is outside [0,32)\n        if (!(0 \u003c\u003d rShiftValue \u0026\u0026 32 \u003e rShiftValue)) {\n            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n            return n;\n        }\n        // Convert the numbers to ints\n        int leftValueInt \u003d (int) leftValue;\n        if (leftValue !\u003d leftValueInt) {\n            error(FRACTIONAL_BITWISE_OPERAND, left);\n            return n;\n        }\n        int shiftAmountInt \u003d (int) rShiftValue;\n        if (rShiftValue !\u003d shiftAmountInt) {\n            error(FRACTIONAL_BITWISE_OPERAND, right);\n            return n;\n        }\n        switch(n.getType()) {\n            case Token.LSH:\n                output \u003d leftValueInt \u003c\u003c shiftAmountInt;\n                break;\n            case Token.RSH:\n                output \u003d leftValueInt \u003e\u003e shiftAmountInt;\n                break;\n            case Token.URSH:\n                // JavaScript handles zero shifts on signed numbers differently than\n                // Java as an Java int can not represent the unsigned 32-bit number\n                // where JavaScript can so use a long here.\n                output \u003d leftValueInt \u003e\u003e\u003e shiftAmountInt;\n                break;\n            default:\n                throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n        }\n        Node newValue \u003d Node.newNumber(output);\n        n.getParent().replaceChild(n, newValue);\n        reportCodeChange();\n        return newValue;\n    }\n    return n;\n}",
  "Compress-39": "public static String sanitize(String s) {\n    final char[] characters \u003d s.toCharArray();\n    final int length \u003d characters.length;\n    final StringBuilder stringBuilder \u003d new StringBuilder();\n    int index \u003d 0;\n    while (length \u003e index) {\n        final char ch \u003d characters[index];\n        if (!Character.isISOControl(ch)) {\n            Character.UnicodeBlock unicodeBlock \u003d Character.UnicodeBlock.of(ch);\n            if (null !\u003d unicodeBlock \u0026\u0026 Character.UnicodeBlock.SPECIALS !\u003d unicodeBlock) {\n                stringBuilder.append(ch);\n                continue;\n            }\n        }\n        stringBuilder.append(\u0027?\u0027);\n        index +\u003d 1;\n    }\n    return stringBuilder.toString();\n}",
  "Compress-38": "public boolean isDirectory() {\n    if (null !\u003d file) {\n        return file.isDirectory();\n    }\n    if (LF_DIR \u003d\u003d linkFlag) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
  "Jsoup-61": "public boolean hasClass(String className) {\n    final String classValue \u003d attributes.get(\"class\");\n    final int classLength \u003d classValue.length();\n    final int desiredLen \u003d className.length();\n    if (0 \u003d\u003d classLength || desiredLen \u003e classLength) {\n        return false;\n    }\n    // if both lengths are equal, only need compare the className with the attribute\n    if (desiredLen \u003d\u003d classLength) {\n        return className.equalsIgnoreCase(classValue);\n    }\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean insideClassName \u003d false;\n    int beginIndex \u003d 0;\n    int index \u003d 0;\n    while (classLength \u003e index) {\n        if (!Character.isWhitespace(classValue.charAt(index))) {\n            if (!insideClassName) {\n                // we\u0027re in a class name : keep the start of the substring\n                insideClassName \u003d true;\n                beginIndex \u003d index;\n            }\n        } else {\n            if (insideClassName) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (desiredLen \u003d\u003d index - beginIndex \u0026\u0026 classValue.regionMatches(true, beginIndex, className, 0, desiredLen)) {\n                    return true;\n                }\n                insideClassName \u003d false;\n            }\n        }\n        index +\u003d 1;\n    }\n    // check the last entry\n    if (insideClassName \u0026\u0026 desiredLen \u003d\u003d classLength - beginIndex) {\n        return classValue.regionMatches(true, beginIndex, className, 0, desiredLen);\n    }\n    return false;\n}",
  "Jsoup-62": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n    String tagName \u003d t.asEndTag().normalName();\n    ArrayList\u003cElement\u003e elementStack \u003d tb.getStack();\n    int index \u003d elementStack.size() - 1;\n    while (0 \u003c\u003d index) {\n        Element element \u003d elementStack.get(index);\n        if (!element.nodeName().equals(tagName)) {\n            if (tb.isSpecial(element)) {\n                tb.error(this);\n                return false;\n            }\n        } else {\n            tb.generateImpliedEndTags(tagName);\n            if (!tagName.equals(tb.currentElement().nodeName()))\n                tb.error(this);\n            tb.popStackToClose(tagName);\n            break;\n        }\n        index -\u003d 1;\n    }\n    return true;\n}",
  "Jsoup-64": "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n    tb.insert(startTag);\n    tb.tokeniser.transition(TokeniserState.Rawtext);\n    tb.markInsertionMode();\n    tb.transition(Text);\n}",
  "Jsoup-68": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n    // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n    int bottom \u003d stack.size() - 1;\n    if (MaxScopeSearchDepth \u003c bottom) {\n        bottom \u003d MaxScopeSearchDepth;\n    }\n    final int limit \u003d MaxScopeSearchDepth \u003c bottom ? bottom - MaxScopeSearchDepth : 0;\n    int index \u003d bottom;\n    while (limit \u003c\u003d index) {\n        final String elementName \u003d stack.get(index).nodeName();\n        if (inSorted(elementName, targetNames))\n            return true;\n        if (inSorted(elementName, baseTypes))\n            return false;\n        if (null !\u003d extraTypes \u0026\u0026 inSorted(elementName, extraTypes))\n            return false;\n        index -\u003d 1;\n    }\n    //Validate.fail(\"Should not be reachable\"); // would end up false because hitting \u0027html\u0027 at root (basetypes)\n    return false;\n}",
  "Compress-7": "public static String parseName(byte[] buffer, final int offset, final int length) {\n    StringBuffer stringBuffer \u003d new StringBuffer(length);\n    int finish \u003d offset + length;\n    int index \u003d offset;\n    while (finish \u003e index) {\n        if (0 \u003d\u003d buffer[index]) {\n            break;\n        }\n        stringBuffer.append((char) buffer[index]);\n        ++index;\n    }\n    return stringBuffer.toString();\n}",
  "Compress-8": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long value \u003d 0;\n    boolean isPadding \u003d true;\n    int limit \u003d offset + length;\n    int begin \u003d offset;\n    int index \u003d begin;\n    while (limit \u003e index) {\n        final byte currentByte \u003d buffer[index];\n        if (0 \u003d\u003d currentByte) {\n            break;\n        }\n        // Skip leading spaces\n        if ((byte) \u0027 \u0027 \u003d\u003d currentByte || \u00270\u0027 \u003d\u003d currentByte) {\n            if (isPadding) {\n                continue;\n            }\n            if ((byte) \u0027 \u0027 \u003d\u003d currentByte) {\n                break;\n            }\n        }\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n        isPadding \u003d false;\n        // CheckStyle:MagicNumber OFF\n        if (\u00270\u0027 \u003e currentByte || \u00277\u0027 \u003c currentByte) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, begin, currentByte));\n        }\n        // convert from ASCII\n        value \u003d (value \u003c\u003c 3) + (currentByte - \u00270\u0027);\n        // CheckStyle:MagicNumber ON\n        index +\u003d 1;\n    }\n    return value;\n}",
  "Compress-9": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if (currSize \u003c (currBytes + numToWrite)) {\n        throw new IOException(\"request to write \u0027\" + numToWrite + \"\u0027 bytes exceeds size in header of \u0027\" + currSize + \"\u0027 bytes for entry \u0027\" + currName + \"\u0027\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (0 \u003c assemLen) {\n        if (recordBuf.length \u003e (assemLen + numToWrite)) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            wOffset +\u003d numToWrite;\n            assemLen +\u003d numToWrite;\n            numToWrite \u003d 0;\n        } else {\n            int bufferLength \u003d recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, bufferLength);\n            buffer.writeRecord(recordBuf);\n            currBytes +\u003d recordBuf.length;\n            wOffset +\u003d bufferLength;\n            numToWrite -\u003d bufferLength;\n            assemLen \u003d 0;\n        }\n    }\n    //\n    // When we get here we have EITHER:\n    // o An empty \"assemble\" buffer.\n    // o No bytes to write (numToWrite \u003d\u003d 0)\n    //\n    while (0 \u003c numToWrite) {\n        if (recordBuf.length \u003e numToWrite) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen +\u003d numToWrite;\n            break;\n        }\n        buffer.writeRecord(wBuf, wOffset);\n        int bytesToWrite \u003d recordBuf.length;\n        currBytes +\u003d bytesToWrite;\n        numToWrite -\u003d bytesToWrite;\n        wOffset +\u003d bytesToWrite;\n    }\n    count(numToWrite);\n}",
  "Compress-40": "public long readBits(final int count) throws IOException {\n    if (0 \u003e count || MAXIMUM_CACHE_SIZE \u003c count) {\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n    }\n    while (count \u003e bitsCachedSize) {\n        final long subsequentByte \u003d in.read();\n        if (0 \u003e subsequentByte) {\n            return subsequentByte;\n        }\n        if (ByteOrder.LITTLE_ENDIAN !\u003d byteOrder) {\n            bitsCached \u003c\u003c\u003d 8;\n            bitsCached |\u003d subsequentByte;\n        } else {\n            bitsCached |\u003d (subsequentByte \u003c\u003c bitsCachedSize);\n        }\n        bitsCachedSize +\u003d 8;\n    }\n    // bitsCachedSize \u003e\u003d 57 and left-shifting it 8 bits would cause an overflow\n    final long outputBits;\n    if (ByteOrder.LITTLE_ENDIAN !\u003d byteOrder) {\n        outputBits \u003d (bitsCached \u003e\u003e (bitsCachedSize - count)) \u0026 MASKS[count];\n    } else {\n        outputBits \u003d (bitsCached \u0026 MASKS[count]);\n        bitsCached \u003e\u003e\u003e\u003d count;\n    }\n    bitsCachedSize -\u003d count;\n    return outputBits;\n}",
  "Math-106": "public Fraction parse(String source, ParsePosition pos) {\n    // try to parse improper fraction\n    Fraction fractionResult \u003d super.parse(source, pos);\n    if (null !\u003d fractionResult) {\n        return fractionResult;\n    }\n    int startingIndex \u003d pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse whole\n    Number integerPart \u003d getWholeFormat().parse(source, pos);\n    if (null \u003d\u003d integerPart) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(startingIndex);\n        return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse numerator\n    Number numerator \u003d getNumeratorFormat().parse(source, pos);\n    if (null \u003d\u003d numerator) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(startingIndex);\n        return null;\n    }\n    // minus signs should be leading, invalid expression\n    // parse \u0027/\u0027\n    int delimiterIndex \u003d pos.getIndex();\n    char delimiter \u003d parseNextCharacter(source, pos);\n    switch(delimiter) {\n        case 0:\n            // no \u0027/\u0027\n            // return num as a fraction\n            return new Fraction(numerator.intValue(), 1);\n        case \u0027/\u0027:\n            // found \u0027/\u0027, continue parsing denominator\n            break;\n        default:\n            // invalid \u0027/\u0027\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(startingIndex);\n            pos.setErrorIndex(delimiterIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse denominator\n    Number denominator \u003d getDenominatorFormat().parse(source, pos);\n    if (null \u003d\u003d denominator) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(startingIndex);\n        return null;\n    }\n    // minus signs must be leading, invalid\n    int wholeNumber \u003d integerPart.intValue();\n    int n \u003d numerator.intValue();\n    int d \u003d denominator.intValue();\n    return new Fraction(((Math.abs(wholeNumber) * d) + n) * MathUtils.sign(wholeNumber), d);\n}",
  "Compress-5": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || null \u003d\u003d current) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (buffer.length \u003e\u003d start \u0026\u0026 0 \u003c\u003d length \u0026\u0026 0 \u003c\u003d start \u0026\u0026 length \u003c\u003d buffer.length - start) {\n        if (ZipArchiveOutputStream.STORED \u003d\u003d current.getMethod()) {\n            int compressedSize \u003d (int) current.getSize();\n            if (compressedSize \u003c\u003d readBytesOfEntry) {\n                return -1;\n            }\n            if (lengthOfLastRead \u003c\u003d offsetInBuffer) {\n                offsetInBuffer \u003d 0;\n                if (-1 \u003d\u003d (lengthOfLastRead \u003d in.read(buf))) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream +\u003d lengthOfLastRead;\n            }\n            int bytesToRead \u003d lengthOfLastRead \u003c length ? lengthOfLastRead - offsetInBuffer : length;\n            if (bytesToRead \u003e (compressedSize - readBytesOfEntry)) {\n                bytesToRead \u003d compressedSize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, bytesToRead);\n            offsetInBuffer +\u003d bytesToRead;\n            readBytesOfEntry +\u003d bytesToRead;\n            crc.update(buffer, start, bytesToRead);\n            return bytesToRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (0 \u003c lengthOfLastRead) {\n                bytesReadFromStream +\u003d lengthOfLastRead;\n            }\n        }\n        int fetch \u003d 0;\n        try {\n            fetch \u003d inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (0 \u003d\u003d fetch \u0026\u0026 inf.finished()) {\n            return -1;\n        }\n        crc.update(buffer, start, fetch);\n        return fetch;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
  "Math-105": "public double getSumSquaredErrors() {\n    return sumYY - sumXY * sumXY / sumXX;\n}",
  "Compress-44": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n    this.checksum \u003d checksum;\n    this.in \u003d in;\n}",
  "Compress-1": "public void close() throws IOException {\n    if (!this.closed) {\n        super.close();\n        this.closed \u003d true;\n    }\n}",
  "Compress-41": "public ZipArchiveEntry getNextZipEntry() throws IOException {\n    boolean isFirstEntry \u003d true;\n    if (closed || hitCentralDirectory) {\n        return null;\n    }\n    if (null !\u003d current) {\n        closeEntry();\n        isFirstEntry \u003d false;\n    }\n    try {\n        if (!isFirstEntry) {\n            readFully(LFH_BUF);\n        } else {\n            // split archives have a special signature before the\n            // first local file header - look for it and fail with\n            // the appropriate error message if this is a split\n            // archive.\n            readFirstLocalFileHeader(LFH_BUF);\n        }\n    } catch (final EOFException e) {\n        return null;\n    }\n    final ZipLong headerSignature \u003d new ZipLong(LFH_BUF);\n    if (headerSignature.equals(ZipLong.CFH_SIG) || headerSignature.equals(ZipLong.AED_SIG)) {\n        hitCentralDirectory \u003d true;\n        skipRemainderOfArchive();\n    }\n    if (!headerSignature.equals(ZipLong.LFH_SIG)) {\n        return null;\n    }\n    int offset \u003d WORD;\n    current \u003d new CurrentEntry();\n    final int versionCreatedBy \u003d ZipShort.getValue(LFH_BUF, offset);\n    offset +\u003d SHORT;\n    current.entry.setPlatform((versionCreatedBy \u003e\u003e ZipFile.BYTE_SHIFT) \u0026 ZipFile.NIBLET_MASK);\n    final GeneralPurposeBit generalPurposeBit \u003d GeneralPurposeBit.parse(LFH_BUF, offset);\n    final boolean hasUTF8Flag \u003d generalPurposeBit.usesUTF8ForNames();\n    final ZipEncoding zipEntryEncoding \u003d hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    current.hasDataDescriptor \u003d generalPurposeBit.usesDataDescriptor();\n    current.entry.setGeneralPurposeBit(generalPurposeBit);\n    offset +\u003d SHORT;\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, offset));\n    offset +\u003d SHORT;\n    final long timestamp \u003d ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, offset));\n    current.entry.setTime(timestamp);\n    offset +\u003d WORD;\n    ZipLong length \u003d null, compressedSize \u003d null;\n    if (current.hasDataDescriptor) {\n        offset +\u003d 3 * WORD;\n    } else {\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, offset));\n        offset +\u003d WORD;\n        compressedSize \u003d new ZipLong(LFH_BUF, offset);\n        offset +\u003d WORD;\n        length \u003d new ZipLong(LFH_BUF, offset);\n        offset +\u003d WORD;\n    }\n    final int fileNameLength \u003d ZipShort.getValue(LFH_BUF, offset);\n    offset +\u003d SHORT;\n    final int additionalLength \u003d ZipShort.getValue(LFH_BUF, offset);\n    offset +\u003d SHORT;\n    final byte[] fileName \u003d new byte[fileNameLength];\n    readFully(fileName);\n    current.entry.setName(zipEntryEncoding.decode(fileName), fileName);\n    final byte[] extraData \u003d new byte[additionalLength];\n    readFully(extraData);\n    current.entry.setExtra(extraData);\n    if (!hasUTF8Flag \u0026\u0026 useUnicodeExtraFields) {\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n    }\n    processZip64Extra(length, compressedSize);\n    if (ArchiveEntry.SIZE_UNKNOWN !\u003d current.entry.getCompressedSize()) {\n        if (ZipMethod.UNSHRINKING.getCode() !\u003d current.entry.getMethod()) {\n            if (ZipMethod.IMPLODING.getCode() !\u003d current.entry.getMethod()) {\n                if (ZipMethod.BZIP2.getCode() \u003d\u003d current.entry.getMethod()) {\n                    current.in \u003d new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n                }\n            } else {\n                current.in \u003d new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        } else {\n            current.in \u003d new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        }\n    }\n    entriesRead +\u003d 1;\n    return current.entry;\n}",
  "Compress-46": "private static ZipLong unixTimeToZipLong(long l) {\n    final long LONG_UPPER_LIMIT \u003d 0x100000000L;\n    if (LONG_UPPER_LIMIT \u003c\u003d l) {\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n    }\n    return new ZipLong(l);\n}",
  "Compress-45": "public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long maxValueAsOctalChar \u003d TarConstants.UIDLEN \u003d\u003d length ? TarConstants.MAXID : TarConstants.MAXSIZE;\n    final boolean isNegative \u003d 0 \u003e value;\n    if (!isNegative \u0026\u0026 maxValueAsOctalChar \u003e\u003d value) {\n        // OK to store as octal chars\n        return formatLongOctalBytes(value, buf, offset, length);\n    }\n    if (9 \u003e length) {\n        formatLongBinary(value, buf, offset, length, isNegative);\n    }\n    formatBigIntegerBinary(value, buf, offset, length, isNegative);\n    buf[offset] \u003d (byte) (isNegative ? 0xff : 0x80);\n    return offset + length;\n}",
  "Jsoup-70": "static boolean preserveWhitespace(Node node) {\n    // looks only at this element and five levels up, to prevent recursion \u0026 needless stack searches\n    if (null !\u003d node \u0026\u0026 node instanceof Element) {\n        Element element \u003d (Element) node;\n        if (element.tag.preserveWhitespace())\n            return true;\n        else\n            return null !\u003d element.parent() \u0026\u0026 element.parent().tag.preserveWhitespace();\n    }\n    return false;\n}",
  "Jsoup-72": "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n    // limit (no cache):\n    if (maxStringCacheLen \u003c count)\n        return new String(charBuf, start, count);\n    // calculate hash:\n    int checksum \u003d 0;\n    int position \u003d start;\n    int j \u003d 0;\n    while (count \u003e j) {\n        checksum \u003d 31 * checksum + charBuf[position++];\n        j +\u003d 1;\n    }\n    // get from cache\n    final int index \u003d checksum \u0026 stringCache.length - 1;\n    String stored \u003d stringCache[index];\n    if (null !\u003d stored) {\n        // hashcode hit, check equality\n        if (!rangeEquals(charBuf, start, count, stored)) {\n            // hashcode conflict\n            stored \u003d new String(charBuf, start, count);\n            // update the cache, as recently used strings are more likely to show up again\n            stringCache[index] \u003d stored;\n        } else {\n            // hit\n            return stored;\n        }\n    } else {\n        // miss, add\n        stored \u003d new String(charBuf, start, count);\n        stringCache[index] \u003d stored;\n    }\n    return stored;\n}",
  "Math-103": "public double cumulativeProbability(double x) throws MathException {\n    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n}",
  "Math-102": "public double chiSquare(double[] expected, long[] observed) throws IllegalArgumentException {\n    if ((2 \u003e expected.length) || (observed.length !\u003d expected.length)) {\n        throw new IllegalArgumentException(\"observed, expected array lengths incorrect\");\n    }\n    if (!isPositive(expected) || !isNonNegative(observed)) {\n        throw new IllegalArgumentException(\"observed counts must be non-negative and expected counts must be postive\");\n    }\n    double chiSquareSum \u003d 0.0d;\n    double difference \u003d 0.0d;\n    int index \u003d 0;\n    while (observed.length \u003e index) {\n        difference \u003d ((double) observed[index] - expected[index]);\n        chiSquareSum +\u003d difference * difference / expected[index];\n        index +\u003d 1;\n    }\n    return chiSquareSum;\n}",
  "Jsoup-76": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch(t.type) {\n        case Character:\n            {\n                Token.Character characterToken \u003d t.asCharacter();\n                if (!characterToken.getData().equals(nullString)) {\n                    if (!tb.framesetOk() || !isWhitespace(characterToken)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(characterToken);\n                        tb.framesetOk(false);\n                    } else {\n                        // don\u0027t check if whitespace if frames already closed\n                        tb.reconstructFormattingElements();\n                        tb.insert(characterToken);\n                    }\n                } else {\n                    // todo confirm that check\n                    tb.error(this);\n                    return false;\n                }\n                break;\n            }\n        case Comment:\n            {\n                tb.insert(t.asComment());\n                break;\n            }\n        case Doctype:\n            {\n                tb.error(this);\n                return false;\n            }\n        case StartTag:\n            Token.StartTag beginTag \u003d t.asStartTag();\n            // todo - refactor to a switch statement\n            String tagName \u003d beginTag.normalName();\n            if (!tagName.equals(\"a\")) {\n                if (!StringUtil.inSorted(tagName, Constants.InBodyStartEmptyFormatters)) {\n                    if (!StringUtil.inSorted(tagName, Constants.InBodyStartPClosers)) {\n                        if (!tagName.equals(\"span\")) {\n                            if (!tagName.equals(\"li\")) {\n                                if (!tagName.equals(\"html\")) {\n                                    if (!StringUtil.inSorted(tagName, Constants.InBodyStartToHead)) {\n                                        if (!tagName.equals(\"body\")) {\n                                            if (!tagName.equals(\"frameset\")) {\n                                                if (!StringUtil.inSorted(tagName, Constants.Headings)) {\n                                                    if (!StringUtil.inSorted(tagName, Constants.InBodyStartPreListing)) {\n                                                        if (!tagName.equals(\"form\")) {\n                                                            if (!StringUtil.inSorted(tagName, Constants.DdDt)) {\n                                                                if (!tagName.equals(\"plaintext\")) {\n                                                                    if (!tagName.equals(\"button\")) {\n                                                                        if (!StringUtil.inSorted(tagName, Constants.Formatters)) {\n                                                                            if (!tagName.equals(\"nobr\")) {\n                                                                                if (!StringUtil.inSorted(tagName, Constants.InBodyStartApplets)) {\n                                                                                    if (!tagName.equals(\"table\")) {\n                                                                                        if (!tagName.equals(\"input\")) {\n                                                                                            if (!StringUtil.inSorted(tagName, Constants.InBodyStartMedia)) {\n                                                                                                if (!tagName.equals(\"hr\")) {\n                                                                                                    if (!tagName.equals(\"image\")) {\n                                                                                                        if (!tagName.equals(\"isindex\")) {\n                                                                                                            if (!tagName.equals(\"textarea\")) {\n                                                                                                                if (!tagName.equals(\"xmp\")) {\n                                                                                                                    if (!tagName.equals(\"iframe\")) {\n                                                                                                                        if (!tagName.equals(\"noembed\")) {\n                                                                                                                            if (!tagName.equals(\"select\")) {\n                                                                                                                                if (!StringUtil.inSorted(tagName, Constants.InBodyStartOptions)) {\n                                                                                                                                    if (!StringUtil.inSorted(tagName, Constants.InBodyStartRuby)) {\n                                                                                                                                        if (!tagName.equals(\"math\")) {\n                                                                                                                                            if (!tagName.equals(\"svg\")) {\n                                                                                                                                                if (!StringUtil.inSorted(tagName, Constants.InBodyStartDrop)) {\n                                                                                                                                                    tb.reconstructFormattingElements();\n                                                                                                                                                    tb.insert(beginTag);\n                                                                                                                                                } else {\n                                                                                                                                                    tb.error(this);\n                                                                                                                                                    return false;\n                                                                                                                                                }\n                                                                                                                                            } else {\n                                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                                                                                                                                                tb.insert(beginTag);\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                                            // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                                                                                                                                            tb.insert(beginTag);\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        if (tb.inScope(\"ruby\")) {\n                                                                                                                                            tb.generateImpliedEndTags();\n                                                                                                                                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                                                                                                                                tb.error(this);\n                                                                                                                                                // i.e. close up to but not include name\n                                                                                                                                                tb.popStackToBefore(\"ruby\");\n                                                                                                                                            }\n                                                                                                                                            tb.insert(beginTag);\n                                                                                                                                        }\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    if (tb.currentElement().nodeName().equals(\"option\"))\n                                                                                                                                        tb.processEndTag(\"option\");\n                                                                                                                                    tb.reconstructFormattingElements();\n                                                                                                                                    tb.insert(beginTag);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                tb.insert(beginTag);\n                                                                                                                                tb.framesetOk(false);\n                                                                                                                                HtmlTreeBuilderState context \u003d tb.state();\n                                                                                                                                if (context.equals(InTable) || context.equals(InCaption) || context.equals(InTableBody) || context.equals(InRow) || context.equals(InCell))\n                                                                                                                                    tb.transition(InSelectInTable);\n                                                                                                                                else\n                                                                                                                                    tb.transition(InSelect);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            // also handle noscript if script enabled\n                                                                                                                            handleRawtext(beginTag, tb);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        tb.framesetOk(false);\n                                                                                                                        handleRawtext(beginTag, tb);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    if (tb.inButtonScope(\"p\")) {\n                                                                                                                        tb.processEndTag(\"p\");\n                                                                                                                    }\n                                                                                                                    tb.reconstructFormattingElements();\n                                                                                                                    tb.framesetOk(false);\n                                                                                                                    handleRawtext(beginTag, tb);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                tb.insert(beginTag);\n                                                                                                                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                                                                                                                tb.tokeniser.transition(TokeniserState.Rcdata);\n                                                                                                                tb.markInsertionMode();\n                                                                                                                tb.framesetOk(false);\n                                                                                                                tb.transition(Text);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            // how much do we care about the early 90s?\n                                                                                                            tb.error(this);\n                                                                                                            if (null !\u003d tb.getFormElement())\n                                                                                                                return false;\n                                                                                                            tb.processStartTag(\"form\");\n                                                                                                            if (beginTag.attributes.hasKey(\"action\")) {\n                                                                                                                Element formElement \u003d tb.getFormElement();\n                                                                                                                formElement.attr(\"action\", beginTag.attributes.get(\"action\"));\n                                                                                                            }\n                                                                                                            tb.processStartTag(\"hr\");\n                                                                                                            tb.processStartTag(\"label\");\n                                                                                                            // hope you like english.\n                                                                                                            String message \u003d beginTag.attributes.hasKey(\"prompt\") ? beginTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \";\n                                                                                                            tb.process(new Token.Character().data(message));\n                                                                                                            // input\n                                                                                                            Attributes inputAttributes \u003d new Attributes();\n                                                                                                            for (Attribute attr : beginTag.attributes) {\n                                                                                                                if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                                                                                                    inputAttributes.put(attr);\n                                                                                                            }\n                                                                                                            inputAttributes.put(\"name\", \"isindex\");\n                                                                                                            tb.processStartTag(\"input\", inputAttributes);\n                                                                                                            tb.processEndTag(\"label\");\n                                                                                                            tb.processStartTag(\"hr\");\n                                                                                                            tb.processEndTag(\"form\");\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        if (null \u003d\u003d tb.getFromStack(\"svg\"))\n                                                                                                            // change \u003cimage\u003e to \u003cimg\u003e, unless in svg\n                                                                                                            return tb.process(beginTag.name(\"img\"));\n                                                                                                        else\n                                                                                                            tb.insert(beginTag);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    if (tb.inButtonScope(\"p\")) {\n                                                                                                        tb.processEndTag(\"p\");\n                                                                                                    }\n                                                                                                    tb.insertEmpty(beginTag);\n                                                                                                    tb.framesetOk(false);\n                                                                                                }\n                                                                                            } else {\n                                                                                                tb.insertEmpty(beginTag);\n                                                                                            }\n                                                                                        } else {\n                                                                                            tb.reconstructFormattingElements();\n                                                                                            Element element \u003d tb.insertEmpty(beginTag);\n                                                                                            if (!element.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                                                                                                tb.framesetOk(false);\n                                                                                        }\n                                                                                    } else {\n                                                                                        if (Document.QuirksMode.quirks !\u003d tb.getDocument().quirksMode() \u0026\u0026 tb.inButtonScope(\"p\")) {\n                                                                                            tb.processEndTag(\"p\");\n                                                                                        }\n                                                                                        tb.insert(beginTag);\n                                                                                        tb.framesetOk(false);\n                                                                                        tb.transition(InTable);\n                                                                                    }\n                                                                                } else {\n                                                                                    tb.reconstructFormattingElements();\n                                                                                    tb.insert(beginTag);\n                                                                                    tb.insertMarkerToFormattingElements();\n                                                                                    tb.framesetOk(false);\n                                                                                }\n                                                                            } else {\n                                                                                tb.reconstructFormattingElements();\n                                                                                if (tb.inScope(\"nobr\")) {\n                                                                                    tb.error(this);\n                                                                                    tb.processEndTag(\"nobr\");\n                                                                                    tb.reconstructFormattingElements();\n                                                                                }\n                                                                                Element element \u003d tb.insert(beginTag);\n                                                                                tb.pushActiveFormattingElements(element);\n                                                                            }\n                                                                        } else {\n                                                                            tb.reconstructFormattingElements();\n                                                                            Element element \u003d tb.insert(beginTag);\n                                                                            tb.pushActiveFormattingElements(element);\n                                                                        }\n                                                                    } else {\n                                                                        if (!tb.inButtonScope(\"button\")) {\n                                                                            tb.reconstructFormattingElements();\n                                                                            tb.insert(beginTag);\n                                                                            tb.framesetOk(false);\n                                                                        } else {\n                                                                            // close and reprocess\n                                                                            tb.error(this);\n                                                                            tb.processEndTag(\"button\");\n                                                                            tb.process(beginTag);\n                                                                        }\n                                                                    }\n                                                                } else {\n                                                                    if (tb.inButtonScope(\"p\")) {\n                                                                        tb.processEndTag(\"p\");\n                                                                    }\n                                                                    tb.insert(beginTag);\n                                                                    // once in, never gets out\n                                                                    tb.tokeniser.transition(TokeniserState.PLAINTEXT);\n                                                                }\n                                                            } else {\n                                                                tb.framesetOk(false);\n                                                                ArrayList\u003cElement\u003e elements \u003d tb.getStack();\n                                                                int index \u003d elements.size() - 1;\n                                                                while (0 \u003c index) {\n                                                                    Element element \u003d elements.get(index);\n                                                                    if (StringUtil.inSorted(element.nodeName(), Constants.DdDt)) {\n                                                                        tb.processEndTag(element.nodeName());\n                                                                        break;\n                                                                    }\n                                                                    if (tb.isSpecial(element) \u0026\u0026 !StringUtil.inSorted(element.nodeName(), Constants.InBodyStartLiBreakers))\n                                                                        break;\n                                                                    index -\u003d 1;\n                                                                }\n                                                                if (tb.inButtonScope(\"p\")) {\n                                                                    tb.processEndTag(\"p\");\n                                                                }\n                                                                tb.insert(beginTag);\n                                                            }\n                                                        } else {\n                                                            if (null !\u003d tb.getFormElement()) {\n                                                                tb.error(this);\n                                                                return false;\n                                                            }\n                                                            if (tb.inButtonScope(\"p\")) {\n                                                                tb.processEndTag(\"p\");\n                                                            }\n                                                            tb.insertForm(beginTag, true);\n                                                        }\n                                                    } else {\n                                                        if (tb.inButtonScope(\"p\")) {\n                                                            tb.processEndTag(\"p\");\n                                                        }\n                                                        tb.insert(beginTag);\n                                                        tb.framesetOk(false);\n                                                    }\n                                                } else {\n                                                    if (tb.inButtonScope(\"p\")) {\n                                                        tb.processEndTag(\"p\");\n                                                    }\n                                                    if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                                                        tb.error(this);\n                                                        tb.pop();\n                                                    }\n                                                    tb.insert(beginTag);\n                                                }\n                                            } else {\n                                                tb.error(this);\n                                                ArrayList\u003cElement\u003e elements \u003d tb.getStack();\n                                                if (1 !\u003d elements.size() \u0026\u0026 !((2 \u003c elements.size() \u0026\u0026 !elements.get(1).nodeName().equals(\"body\")))) {\n                                                    if (tb.framesetOk()) {\n                                                        Element second \u003d elements.get(1);\n                                                        if (null !\u003d second.parent())\n                                                            second.remove();\n                                                        // pop up to html element\n                                                        while (1 \u003c elements.size()) elements.remove(elements.size() - 1);\n                                                        tb.insert(beginTag);\n                                                        tb.transition(InFrameset);\n                                                    } else {\n                                                        // ignore frameset\n                                                        return false;\n                                                    }\n                                                } else {\n                                                    // only in fragment case\n                                                    // ignore\n                                                    return false;\n                                                }\n                                            }\n                                        } else {\n                                            tb.error(this);\n                                            ArrayList\u003cElement\u003e elements \u003d tb.getStack();\n                                            if (1 !\u003d elements.size() \u0026\u0026 !((2 \u003c elements.size() \u0026\u0026 !elements.get(1).nodeName().equals(\"body\")))) {\n                                                tb.framesetOk(false);\n                                                Element section \u003d elements.get(1);\n                                                for (Attribute property : beginTag.getAttributes()) {\n                                                    if (!section.hasAttr(property.getKey()))\n                                                        section.attributes().put(property);\n                                                }\n                                            } else {\n                                                // only in fragment case\n                                                // ignore\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        return tb.process(t, InHead);\n                                    }\n                                } else {\n                                    tb.error(this);\n                                    // merge attributes onto real html\n                                    Element documentRoot \u003d tb.getStack().get(0);\n                                    for (Attribute property : beginTag.getAttributes()) {\n                                        if (!documentRoot.hasAttr(property.getKey()))\n                                            documentRoot.attributes().put(property);\n                                    }\n                                }\n                            } else {\n                                tb.framesetOk(false);\n                                ArrayList\u003cElement\u003e elements \u003d tb.getStack();\n                                int index \u003d elements.size() - 1;\n                                while (0 \u003c index) {\n                                    Element element \u003d elements.get(index);\n                                    if (element.nodeName().equals(\"li\")) {\n                                        tb.processEndTag(\"li\");\n                                        break;\n                                    }\n                                    if (tb.isSpecial(element) \u0026\u0026 !StringUtil.inSorted(element.nodeName(), Constants.InBodyStartLiBreakers))\n                                        break;\n                                    index -\u003d 1;\n                                }\n                                if (tb.inButtonScope(\"p\")) {\n                                    tb.processEndTag(\"p\");\n                                }\n                                tb.insert(beginTag);\n                            }\n                        } else {\n                            // same as final else, but short circuits lots of checks\n                            tb.reconstructFormattingElements();\n                            tb.insert(beginTag);\n                        }\n                    } else {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(beginTag);\n                    }\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insertEmpty(beginTag);\n                    tb.framesetOk(false);\n                }\n            } else {\n                if (null !\u003d tb.getActiveFormattingElement(\"a\")) {\n                    tb.error(this);\n                    tb.processEndTag(\"a\");\n                    // still on stack?\n                    Element lastActiveAnchor \u003d tb.getFromStack(\"a\");\n                    if (null !\u003d lastActiveAnchor) {\n                        tb.removeFromActiveFormattingElements(lastActiveAnchor);\n                        tb.removeFromStack(lastActiveAnchor);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element anchor \u003d tb.insert(beginTag);\n                tb.pushActiveFormattingElements(anchor);\n            }\n            break;\n        case EndTag:\n            Token.EndTag closingTag \u003d t.asEndTag();\n            tagName \u003d closingTag.normalName();\n            if (!StringUtil.inSorted(tagName, Constants.InBodyEndAdoptionFormatters)) {\n                if (!StringUtil.inSorted(tagName, Constants.InBodyEndClosers)) {\n                    if (!tagName.equals(\"span\")) {\n                        if (!tagName.equals(\"li\")) {\n                            if (!tagName.equals(\"body\")) {\n                                if (!tagName.equals(\"html\")) {\n                                    if (!tagName.equals(\"form\")) {\n                                        if (!tagName.equals(\"p\")) {\n                                            if (!StringUtil.inSorted(tagName, Constants.DdDt)) {\n                                                if (!StringUtil.inSorted(tagName, Constants.Headings)) {\n                                                    if (!tagName.equals(\"sarcasm\")) {\n                                                        if (!StringUtil.inSorted(tagName, Constants.InBodyStartApplets)) {\n                                                            if (!tagName.equals(\"br\")) {\n                                                                return anyOtherEndTag(t, tb);\n                                                            } else {\n                                                                tb.error(this);\n                                                                tb.processStartTag(\"br\");\n                                                                return false;\n                                                            }\n                                                        } else {\n                                                            if (!tb.inScope(\"name\")) {\n                                                                if (!tb.inScope(tagName)) {\n                                                                    tb.error(this);\n                                                                    return false;\n                                                                }\n                                                                tb.generateImpliedEndTags();\n                                                                if (!tb.currentElement().nodeName().equals(tagName))\n                                                                    tb.error(this);\n                                                                tb.popStackToClose(tagName);\n                                                                tb.clearFormattingElementsToLastMarker();\n                                                            }\n                                                        }\n                                                    } else {\n                                                        // *sigh*\n                                                        return anyOtherEndTag(t, tb);\n                                                    }\n                                                } else {\n                                                    if (tb.inScope(Constants.Headings)) {\n                                                        tb.generateImpliedEndTags(tagName);\n                                                        if (!tb.currentElement().nodeName().equals(tagName))\n                                                            tb.error(this);\n                                                        tb.popStackToClose(Constants.Headings);\n                                                    } else {\n                                                        tb.error(this);\n                                                        return false;\n                                                    }\n                                                }\n                                            } else {\n                                                if (tb.inScope(tagName)) {\n                                                    tb.generateImpliedEndTags(tagName);\n                                                    if (!tb.currentElement().nodeName().equals(tagName))\n                                                        tb.error(this);\n                                                    tb.popStackToClose(tagName);\n                                                } else {\n                                                    tb.error(this);\n                                                    return false;\n                                                }\n                                            }\n                                        } else {\n                                            if (tb.inButtonScope(tagName)) {\n                                                tb.generateImpliedEndTags(tagName);\n                                                if (!tb.currentElement().nodeName().equals(tagName))\n                                                    tb.error(this);\n                                                tb.popStackToClose(tagName);\n                                            } else {\n                                                tb.error(this);\n                                                // if no p to close, creates an empty \u003cp\u003e\u003c/p\u003e\n                                                tb.processStartTag(tagName);\n                                                return tb.process(closingTag);\n                                            }\n                                        }\n                                    } else {\n                                        Element activeForm \u003d tb.getFormElement();\n                                        tb.setFormElement(null);\n                                        if (null !\u003d activeForm \u0026\u0026 tb.inScope(tagName)) {\n                                            tb.generateImpliedEndTags();\n                                            if (!tb.currentElement().nodeName().equals(tagName))\n                                                tb.error(this);\n                                            // remove currentForm from stack. will shift anything under up.\n                                            tb.removeFromStack(activeForm);\n                                        } else {\n                                            tb.error(this);\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    boolean wasProcessed \u003d tb.processEndTag(\"body\");\n                                    if (wasProcessed)\n                                        return tb.process(closingTag);\n                                }\n                            } else {\n                                if (tb.inScope(\"body\")) {\n                                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                                    tb.transition(AfterBody);\n                                } else {\n                                    tb.error(this);\n                                    return false;\n                                }\n                            }\n                        } else {\n                            if (tb.inListItemScope(tagName)) {\n                                tb.generateImpliedEndTags(tagName);\n                                if (!tb.currentElement().nodeName().equals(tagName))\n                                    tb.error(this);\n                                tb.popStackToClose(tagName);\n                            } else {\n                                tb.error(this);\n                                return false;\n                            }\n                        }\n                    } else {\n                        // same as final fall through, but saves short circuit\n                        return anyOtherEndTag(t, tb);\n                    }\n                } else {\n                    if (tb.inScope(tagName)) {\n                        tb.generateImpliedEndTags();\n                        if (!tb.currentElement().nodeName().equals(tagName))\n                            tb.error(this);\n                        tb.popStackToClose(tagName);\n                    } else {\n                        // nothing to close\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            } else {\n                int index \u003d 0;\n                while (8 \u003e index) {\n                    Element formatElement \u003d tb.getActiveFormattingElement(tagName);\n                    if (null !\u003d formatElement) {\n                        if (tb.onStack(formatElement)) {\n                            if (tb.inScope(formatElement.nodeName())) {\n                                if (formatElement !\u003d tb.currentElement())\n                                    tb.error(this);\n                            } else {\n                                tb.error(this);\n                                return false;\n                            }\n                        } else {\n                            tb.error(this);\n                            tb.removeFromActiveFormattingElements(formatElement);\n                            return true;\n                        }\n                    } else\n                        return anyOtherEndTag(t, tb);\n                    Element farthestBlock \u003d null;\n                    Element ancestorElement \u003d null;\n                    boolean wasFormattingElement \u003d false;\n                    ArrayList\u003cElement\u003e elements \u003d tb.getStack();\n                    // the spec doesn\u0027t limit to \u003c 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int currentStackSize \u003d elements.size();\n                    int si \u003d 0;\n                    while (currentStackSize \u003e si \u0026\u0026 64 \u003e si) {\n                        Element element \u003d elements.get(si);\n                        if (formatElement !\u003d element) {\n                            if (wasFormattingElement \u0026\u0026 tb.isSpecial(element)) {\n                                farthestBlock \u003d element;\n                                break;\n                            }\n                        } else {\n                            ancestorElement \u003d elements.get(si - 1);\n                            wasFormattingElement \u003d true;\n                        }\n                        si +\u003d 1;\n                    }\n                    if (null \u003d\u003d farthestBlock) {\n                        tb.popStackToClose(formatElement.nodeName());\n                        tb.removeFromActiveFormattingElements(formatElement);\n                        return true;\n                    }\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node \u003d farthestBlock;\n                    Element previousNode \u003d farthestBlock;\n                    int token \u003d 0;\n                    while (3 \u003e token) {\n                        if (tb.onStack(node))\n                            node \u003d tb.aboveOnStack(node);\n                        if (tb.isInActiveFormattingElements(node)) {\n                            if (formatElement \u003d\u003d node)\n                                break;\n                        } else {\n                            // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue;\n                        }\n                        Element substitute \u003d new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                        // case will follow the original node (so honours ParseSettings)\n                        tb.replaceActiveFormattingElement(node, substitute);\n                        tb.replaceOnStack(node, substitute);\n                        node \u003d substitute;\n                        if (farthestBlock \u003d\u003d previousNode) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (null !\u003d previousNode.parent())\n                            previousNode.remove();\n                        node.appendChild(previousNode);\n                        previousNode \u003d node;\n                        token +\u003d 1;\n                    }\n                    if (!StringUtil.inSorted(ancestorElement.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (null !\u003d previousNode.parent())\n                            previousNode.remove();\n                        ancestorElement.appendChild(previousNode);\n                    } else {\n                        if (null !\u003d previousNode.parent())\n                            previousNode.remove();\n                        tb.insertInFosterParent(previousNode);\n                    }\n                    Element holder \u003d new Element(formatElement.tag(), tb.getBaseUri());\n                    holder.attributes().addAll(formatElement.attributes());\n                    Node[] descendantNodes \u003d farthestBlock.childNodes().toArray(new Node[farthestBlock.childNodeSize()]);\n                    for (Node childElement : descendantNodes) {\n                        // append will reparent. thus the clone to avoid concurrent mod.\n                        holder.appendChild(childElement);\n                    }\n                    farthestBlock.appendChild(holder);\n                    tb.removeFromActiveFormattingElements(formatElement);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatElement);\n                    tb.insertOnStackAfter(farthestBlock, holder);\n                    index +\u003d 1;\n                }\n            }\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
  "Math-101": "public Complex parse(String source, ParsePosition pos) {\n    int originalIndex \u003d pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number realPart \u003d parseNumber(source, getRealFormat(), pos);\n    if (null \u003d\u003d realPart) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(originalIndex);\n        return null;\n    }\n    // parse sign\n    int signIndex \u003d pos.getIndex();\n    char signChar \u003d parseNextCharacter(source, pos);\n    int polarity \u003d 0;\n    switch(signChar) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(realPart.doubleValue(), 0.0);\n        case \u0027-\u0027:\n            polarity \u003d -1;\n            break;\n        case \u0027+\u0027:\n            polarity \u003d 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(originalIndex);\n            pos.setErrorIndex(signIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number imaginaryPart \u003d parseNumber(source, getRealFormat(), pos);\n    if (null \u003d\u003d imaginaryPart) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(originalIndex);\n        return null;\n    }\n    // parse imaginary character\n    int imaginaryCharacterLength \u003d getImaginaryCharacter().length();\n    signIndex \u003d pos.getIndex();\n    int finalIndex \u003d signIndex + imaginaryCharacterLength;\n    if (0 !\u003d source.substring(signIndex, finalIndex).compareTo(getImaginaryCharacter())) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(originalIndex);\n        pos.setErrorIndex(signIndex);\n        return null;\n    }\n    pos.setIndex(finalIndex);\n    return new Complex(realPart.doubleValue(), imaginaryPart.doubleValue() * polarity);\n}",
  "Jsoup-75": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sizeValue \u003d size;\n    int index \u003d 0;\n    while (sizeValue \u003e index) {\n        // inlined from Attribute.html()\n        final String attributeName \u003d keys[index];\n        final String value \u003d vals[index];\n        accum.append(\u0027 \u0027).append(attributeName);\n        // collapse checked\u003dnull, checked\u003d\"\", checked\u003dchecked; write out others\n        if (!(Document.OutputSettings.Syntax.html \u003d\u003d out.syntax() \u0026\u0026 (null \u003d\u003d value || value.equals(attributeName) \u0026\u0026 Attribute.isBooleanAttribute(attributeName)))) {\n            accum.append(\"\u003d\\\"\");\n            Entities.escape(accum, null \u003d\u003d value ? EmptyString : value, out, true, false, false);\n            accum.append(\u0027\"\u0027);\n        }\n        index +\u003d 1;\n    }\n}",
  "Jsoup-77": "private void popStackToClose(Token.EndTag endTag) {\n    String elementName \u003d endTag.name();\n    Element foundElement \u003d null;\n    for (int index \u003d stack.size() - 1; 0 \u003c\u003d index; index--) {\n        Element current \u003d stack.get(index);\n        if (current.nodeName().equals(elementName)) {\n            foundElement \u003d current;\n            break;\n        }\n    }\n    if (null \u003d\u003d foundElement)\n        // not found, skip\n        return;\n    for (int index \u003d stack.size() - 1; 0 \u003c\u003d index; index--) {\n        Element current \u003d stack.get(index);\n        stack.remove(index);\n        if (foundElement \u003d\u003d current)\n            break;\n    }\n}",
  "Compress-11": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (null \u003d\u003d in) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] headerBytes \u003d new byte[12];\n    in.mark(headerBytes.length);\n    try {\n        int bytesRead \u003d in.read(headerBytes);\n        in.reset();\n        if (!ZipArchiveInputStream.matches(headerBytes, bytesRead)) {\n            if (!JarArchiveInputStream.matches(headerBytes, bytesRead)) {\n                if (!ArArchiveInputStream.matches(headerBytes, bytesRead)) {\n                    if (CpioArchiveInputStream.matches(headerBytes, bytesRead)) {\n                        return new CpioArchiveInputStream(in);\n                    }\n                } else {\n                    return new ArArchiveInputStream(in);\n                }\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else {\n            return new ZipArchiveInputStream(in);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] bufferForDumpSignature \u003d new byte[32];\n        in.mark(bufferForDumpSignature.length);\n        bytesRead \u003d in.read(bufferForDumpSignature);\n        in.reset();\n        if (DumpArchiveInputStream.matches(bufferForDumpSignature, bytesRead)) {\n            return new DumpArchiveInputStream(in);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarBlockHeader \u003d new byte[512];\n        in.mark(tarBlockHeader.length);\n        bytesRead \u003d in.read(tarBlockHeader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarBlockHeader, bytesRead)) {\n            return new TarArchiveInputStream(in);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        try {\n            TarArchiveInputStream tarInputStream \u003d new TarArchiveInputStream(new ByteArrayInputStream(tarBlockHeader));\n            tarInputStream.getNextEntry();\n            return new TarArchiveInputStream(in);\n        } catch (Exception e) {\n            // NOPMD\n            // can generate IllegalArgumentException as well as IOException\n            // autodetection, simply not a TAR\n            // ignored\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}",
  "Compress-10": "private void resolveLocalFileHeaderData(Map\u003cZipArchiveEntry, NameAndComment\u003e entriesWithoutUTF8Flag) throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry entry : entries.keySet()) {\n        OffsetEntry positionEntry \u003d entries.get(entry);\n        long position \u003d positionEntry.headerOffset;\n        archive.seek(position + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] buffer \u003d new byte[SHORT];\n        archive.readFully(buffer);\n        int fileNameLength \u003d ZipShort.getValue(buffer);\n        archive.readFully(buffer);\n        int additionalFieldLength \u003d ZipShort.getValue(buffer);\n        int lengthToSkip \u003d fileNameLength;\n        while (0 \u003c lengthToSkip) {\n            int advanced \u003d archive.skipBytes(lengthToSkip);\n            if (0 \u003e\u003d advanced) {\n                throw new RuntimeException(\"failed to skip file name in\" + \" local file header\");\n            }\n            lengthToSkip -\u003d advanced;\n        }\n        byte[] localExtraData \u003d new byte[additionalFieldLength];\n        archive.readFully(localExtraData);\n        entry.setExtra(localExtraData);\n        positionEntry.dataOffset \u003d position + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLength + additionalFieldLength;\n        if (entriesWithoutUTF8Flag.containsKey(entry)) {\n            String originalName \u003d entry.getName();\n            NameAndComment nameAndComment \u003d entriesWithoutUTF8Flag.get(entry);\n            ZipUtil.setNameAndCommentFromExtraFields(entry, nameAndComment.name, nameAndComment.comment);\n            if (!originalName.equals(entry.getName())) {\n                nameMap.remove(originalName);\n                nameMap.put(entry.getName(), entry);\n            }\n        }\n    }\n}",
  "Compress-15": "public boolean equals(Object obj) {\n    if (obj \u003d\u003d this) {\n        return true;\n    }\n    if (null \u003d\u003d obj || obj.getClass() !\u003d getClass()) {\n        return false;\n    }\n    ZipArchiveEntry zipEntry \u003d (ZipArchiveEntry) obj;\n    String entryName \u003d getName();\n    String otherEntryName \u003d zipEntry.getName();\n    if (null !\u003d entryName) {\n        if (!entryName.equals(otherEntryName)) {\n            return false;\n        }\n    } else {\n        if (null !\u003d otherEntryName) {\n            return false;\n        }\n    }\n    String myDescription \u003d getComment();\n    String alternateComment \u003d zipEntry.getComment();\n    if (null !\u003d myDescription) {\n        if (!myDescription.equals(alternateComment)) {\n            return false;\n        }\n    } else {\n        if (null !\u003d alternateComment) {\n            return false;\n        }\n    }\n    return zipEntry.getTime() \u003d\u003d getTime() \u0026\u0026 zipEntry.getInternalAttributes() \u003d\u003d getInternalAttributes() \u0026\u0026 zipEntry.getPlatform() \u003d\u003d getPlatform() \u0026\u0026 zipEntry.getExternalAttributes() \u003d\u003d getExternalAttributes() \u0026\u0026 zipEntry.getMethod() \u003d\u003d getMethod() \u0026\u0026 zipEntry.getSize() \u003d\u003d getSize() \u0026\u0026 zipEntry.getCrc() \u003d\u003d getCrc() \u0026\u0026 zipEntry.getCompressedSize() \u003d\u003d getCompressedSize() \u0026\u0026 Arrays.equals(getCentralDirectoryExtra(), zipEntry.getCentralDirectoryExtra()) \u0026\u0026 Arrays.equals(getLocalFileDataExtra(), zipEntry.getLocalFileDataExtra()) \u0026\u0026 gpb.equals(zipEntry.gpb);\n}",
  "Compress-14": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long value \u003d 0;\n    int limit \u003d offset + length;\n    int begin \u003d offset;\n    if (2 \u003e length) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    boolean isAllNUL \u003d true;\n    int index \u003d begin;\n    while (limit \u003e index) {\n        if (0 !\u003d buffer[index]) {\n            isAllNUL \u003d false;\n            break;\n        }\n        index +\u003d 1;\n    }\n    if (isAllNUL) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (limit \u003e begin) {\n        if (\u0027 \u0027 !\u003d buffer[begin]) {\n            break;\n        } else {\n            begin +\u003d 1;\n        }\n    }\n    // Must have trailing NUL or space\n    byte terminator;\n    terminator \u003d buffer[limit - 1];\n    if (0 !\u003d terminator \u0026\u0026 \u0027 \u0027 !\u003d terminator) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, limit - 1, terminator));\n    } else {\n        limit -\u003d 1;\n    }\n    // May have additional NUL or space\n    terminator \u003d buffer[limit - 1];\n    if (0 \u003d\u003d terminator || \u0027 \u0027 \u003d\u003d terminator) {\n        limit -\u003d 1;\n    }\n    while (limit \u003e begin) {\n        final byte byteValue \u003d buffer[begin];\n        // CheckStyle:MagicNumber OFF\n        if (\u00270\u0027 \u003e byteValue || \u00277\u0027 \u003c byteValue) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, begin, byteValue));\n        }\n        // convert from ASCII\n        value \u003d (value \u003c\u003c 3) + (byteValue - \u00270\u0027);\n        // CheckStyle:MagicNumber ON\n        begin +\u003d 1;\n    }\n    return value;\n}",
  "Compress-13": "protected void setName(String name) {\n    this.name \u003d name;\n}",
  "Compress-12": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (null !\u003d currEntry) {\n        long bytesToSkip \u003d entrySize - entryOffset;\n        while (0 \u003c bytesToSkip) {\n            long advanced \u003d skip(bytesToSkip);\n            if (0 \u003e\u003d advanced) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            bytesToSkip -\u003d advanced;\n        }\n        readBuf \u003d null;\n    }\n    byte[] recordBuffer \u003d getRecord();\n    if (hasHitEOF) {\n        currEntry \u003d null;\n        return null;\n    }\n    currEntry \u003d new TarArchiveEntry(recordBuffer);\n    entryOffset \u003d 0;\n    entrySize \u003d currEntry.getSize();\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer extendedName \u003d new StringBuffer();\n        byte[] dataBuffer \u003d new byte[SMALL_BUFFER_SIZE];\n        int length \u003d 0;\n        while (0 \u003c\u003d (length \u003d read(dataBuffer))) {\n            extendedName.append(new String(dataBuffer, 0, length));\n        }\n        getNextEntry();\n        if (null \u003d\u003d currEntry) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (0 \u003c extendedName.length() \u0026\u0026 0 \u003d\u003d extendedName.charAt(extendedName.length() - 1)) {\n            extendedName.deleteCharAt(extendedName.length() - 1);\n        }\n        currEntry.setName(extendedName.toString());\n    }\n    if (currEntry.isPaxHeader()) {\n        // Process Pax headers\n        paxHeaders();\n    }\n    if (currEntry.isGNUSparse()) {\n        // Process sparse files\n        readGNUSparse();\n    }\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize \u003d currEntry.getSize();\n    return currEntry;\n}",
  "Compress-19": "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n    if (null !\u003d rawCentralDirectoryData) {\n        int calculatedLength \u003d (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);\n        if (calculatedLength !\u003d rawCentralDirectoryData.length) {\n            throw new ZipException(\"central directory zip64 extended\" + \" information extra field\u0027s length\" + \" doesn\u0027t match central directory\" + \" data.  Expected length \" + calculatedLength + \" but is \" + rawCentralDirectoryData.length);\n        }\n        int index \u003d 0;\n        if (hasUncompressedSize) {\n            size \u003d new ZipEightByteInteger(rawCentralDirectoryData, index);\n            index +\u003d DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize \u003d new ZipEightByteInteger(rawCentralDirectoryData, index);\n            index +\u003d DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset \u003d new ZipEightByteInteger(rawCentralDirectoryData, index);\n            index +\u003d DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart \u003d new ZipLong(rawCentralDirectoryData, index);\n            index +\u003d WORD;\n        }\n    }\n}",
  "Compress-18": "void writePaxHeaders(String entryName, Map\u003cString, String\u003e headers) throws IOException {\n    String entryPath \u003d \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n    // TarEntry\u0027s constructor would think this is a directory\n    // and not allow any data to be written\n    if (TarConstants.NAMELEN \u003c\u003d entryPath.length()) {\n        entryPath \u003d entryPath.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry tarEntry \u003d new TarArchiveEntry(entryPath, TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n    StringWriter stringWriter \u003d new StringWriter();\n    for (Map.Entry\u003cString, String\u003e headerEntry : headers.entrySet()) {\n        String headerKey \u003d headerEntry.getKey();\n        String attribute \u003d headerEntry.getValue();\n        int length \u003d headerKey.length() + attribute.length() + 3 + /* blank, equals and newline */\n        2;\n        String entryLine \u003d length + \" \" + headerKey + \"\u003d\" + attribute + \"\\n\";\n        int computedLength \u003d entryLine.getBytes(CharsetNames.UTF_8).length;\n        while (computedLength !\u003d length) {\n            // Adjust for cases where length \u003c 10 or \u003e 100\n            // or where UTF-8 encoding isn\u0027t a single octet\n            // per character.\n            // Must be in loop as size may go from 99 to 100 in\n            // first pass so we\u0027d need a second.\n            length \u003d computedLength;\n            entryLine \u003d length + \" \" + headerKey + \"\u003d\" + attribute + \"\\n\";\n            computedLength \u003d entryLine.getBytes(CharsetNames.UTF_8).length;\n        }\n        stringWriter.write(entryLine);\n    }\n    byte[] data \u003d stringWriter.toString().getBytes(CharsetNames.UTF_8);\n    tarEntry.setSize(data.length);\n    putArchiveEntry(tarEntry);\n    write(data);\n    closeArchiveEntry();\n}",
  "Compress-17": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long total \u003d 0;\n    int end \u003d offset + length;\n    int initial \u003d offset;\n    if (2 \u003e length) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (0 \u003d\u003d buffer[initial]) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (end \u003e initial) {\n        if (\u0027 \u0027 !\u003d buffer[initial]) {\n            break;\n        } else {\n            initial +\u003d 1;\n        }\n    }\n    // Must have trailing NUL or space\n    byte terminator;\n    terminator \u003d buffer[end - 1];\n    if (0 !\u003d terminator \u0026\u0026 \u0027 \u0027 !\u003d terminator) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, terminator));\n    } else {\n        end -\u003d 1;\n    }\n    // May have additional NULs or spaces\n    terminator \u003d buffer[end - 1];\n    if (0 \u003d\u003d terminator || \u0027 \u0027 \u003d\u003d terminator) {\n        end -\u003d 1;\n    }\n    while (end \u003e initial) {\n        final byte byteValue \u003d buffer[initial];\n        // CheckStyle:MagicNumber OFF\n        if (\u00270\u0027 \u003e byteValue || \u00277\u0027 \u003c byteValue) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, initial, byteValue));\n        }\n        // convert from ASCII\n        total \u003d (total \u003c\u003c 3) + (byteValue - \u00270\u0027);\n        // CheckStyle:MagicNumber ON\n        initial +\u003d 1;\n    }\n    return total;\n}",
  "Compress-16": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (null \u003d\u003d in) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] headerBytes \u003d new byte[12];\n    in.mark(headerBytes.length);\n    try {\n        int signatureLength \u003d in.read(headerBytes);\n        in.reset();\n        if (!ZipArchiveInputStream.matches(headerBytes, signatureLength)) {\n            if (!JarArchiveInputStream.matches(headerBytes, signatureLength)) {\n                if (!ArArchiveInputStream.matches(headerBytes, signatureLength)) {\n                    if (CpioArchiveInputStream.matches(headerBytes, signatureLength)) {\n                        return new CpioArchiveInputStream(in);\n                    }\n                } else {\n                    return new ArArchiveInputStream(in);\n                }\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else {\n            return new ZipArchiveInputStream(in);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] bufferedSignature \u003d new byte[32];\n        in.mark(bufferedSignature.length);\n        signatureLength \u003d in.read(bufferedSignature);\n        in.reset();\n        if (DumpArchiveInputStream.matches(bufferedSignature, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarBuffer \u003d new byte[512];\n        in.mark(tarBuffer.length);\n        signatureLength \u003d in.read(tarBuffer);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarBuffer, signatureLength)) {\n            return new TarArchiveInputStream(in);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (512 \u003c\u003d signatureLength) {\n            try {\n                TarArchiveInputStream tarArchiveInputStream \u003d new TarArchiveInputStream(new ByteArrayInputStream(tarBuffer));\n                // COMPRESS-191 - verify the header checksum\n                tarArchiveInputStream.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}",
  "Jsoup-15": "boolean process(Token t, TreeBuilder tb) {\n    switch(t.type) {\n        case Character:\n            {\n                Token.Character characterToken \u003d t.asCharacter();\n                if (!characterToken.getData().equals(nullString)) {\n                    if (!isWhitespace(characterToken)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(characterToken);\n                        tb.framesetOk(false);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(characterToken);\n                    }\n                } else {\n                    // todo confirm that check\n                    tb.error(this);\n                    return false;\n                }\n                break;\n            }\n        case Comment:\n            {\n                tb.insert(t.asComment());\n                break;\n            }\n        case Doctype:\n            {\n                tb.error(this);\n                return false;\n            }\n        case StartTag:\n            Token.StartTag openingTag \u003d t.asStartTag();\n            String tagName \u003d openingTag.name();\n            if (!tagName.equals(\"html\")) {\n                if (!StringUtil.in(tagName, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                    if (!tagName.equals(\"body\")) {\n                        if (!tagName.equals(\"frameset\")) {\n                            if (!StringUtil.in(tagName, \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\")) {\n                                if (!StringUtil.in(tagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                                    if (!StringUtil.in(tagName, \"pre\", \"listing\")) {\n                                        if (!tagName.equals(\"form\")) {\n                                            if (!tagName.equals(\"li\")) {\n                                                if (!StringUtil.in(tagName, \"dd\", \"dt\")) {\n                                                    if (!tagName.equals(\"plaintext\")) {\n                                                        if (!tagName.equals(\"button\")) {\n                                                            if (!tagName.equals(\"a\")) {\n                                                                if (!StringUtil.in(tagName, \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                                                                    if (!tagName.equals(\"nobr\")) {\n                                                                        if (!StringUtil.in(tagName, \"applet\", \"marquee\", \"object\")) {\n                                                                            if (!tagName.equals(\"table\")) {\n                                                                                if (!StringUtil.in(tagName, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                                                                                    if (!tagName.equals(\"input\")) {\n                                                                                        if (!StringUtil.in(tagName, \"param\", \"source\", \"track\")) {\n                                                                                            if (!tagName.equals(\"hr\")) {\n                                                                                                if (!tagName.equals(\"image\")) {\n                                                                                                    if (!tagName.equals(\"isindex\")) {\n                                                                                                        if (!tagName.equals(\"textarea\")) {\n                                                                                                            if (!tagName.equals(\"xmp\")) {\n                                                                                                                if (!tagName.equals(\"iframe\")) {\n                                                                                                                    if (!tagName.equals(\"noembed\")) {\n                                                                                                                        if (!tagName.equals(\"select\")) {\n                                                                                                                            if (!StringUtil.in(\"optgroup\", \"option\")) {\n                                                                                                                                if (!StringUtil.in(\"rp\", \"rt\")) {\n                                                                                                                                    if (!tagName.equals(\"math\")) {\n                                                                                                                                        if (!tagName.equals(\"svg\")) {\n                                                                                                                                            if (!StringUtil.in(tagName, \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                                tb.insert(openingTag);\n                                                                                                                                            } else {\n                                                                                                                                                tb.error(this);\n                                                                                                                                                return false;\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                                            // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                                                                                                                                            tb.insert(openingTag);\n                                                                                                                                            tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        tb.reconstructFormattingElements();\n                                                                                                                                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                                                                                                                                        tb.insert(openingTag);\n                                                                                                                                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    if (tb.inScope(\"ruby\")) {\n                                                                                                                                        tb.generateImpliedEndTags();\n                                                                                                                                        if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                                                                                                                            tb.error(this);\n                                                                                                                                            // i.e. close up to but not include name\n                                                                                                                                            tb.popStackToBefore(\"ruby\");\n                                                                                                                                        }\n                                                                                                                                        tb.insert(openingTag);\n                                                                                                                                    }\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                if (tb.currentElement().nodeName().equals(\"option\"))\n                                                                                                                                    tb.process(new Token.EndTag(\"option\"));\n                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                tb.insert(openingTag);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                            tb.insert(openingTag);\n                                                                                                                            tb.framesetOk(false);\n                                                                                                                            TreeBuilderState condition \u003d tb.state();\n                                                                                                                            if (condition.equals(InTable) || condition.equals(InCaption) || condition.equals(InTableBody) || condition.equals(InRow) || condition.equals(InCell))\n                                                                                                                                tb.transition(InSelectInTable);\n                                                                                                                            else\n                                                                                                                                tb.transition(InSelect);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        // also handle noscript if script enabled\n                                                                                                                        handleRawtext(openingTag, tb);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    tb.framesetOk(false);\n                                                                                                                    handleRawtext(openingTag, tb);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                if (tb.inButtonScope(\"p\")) {\n                                                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                                                }\n                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                tb.framesetOk(false);\n                                                                                                                handleRawtext(openingTag, tb);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            tb.insert(openingTag);\n                                                                                                            // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                                                                                                            tb.tokeniser.transition(TokeniserState.Rcdata);\n                                                                                                            tb.markInsertionMode();\n                                                                                                            tb.framesetOk(false);\n                                                                                                            tb.transition(Text);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        // how much do we care about the early 90s?\n                                                                                                        tb.error(this);\n                                                                                                        if (null !\u003d tb.getFormElement())\n                                                                                                            return false;\n                                                                                                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                        tb.process(new Token.StartTag(\"form\"));\n                                                                                                        if (openingTag.attributes.hasKey(\"action\")) {\n                                                                                                            Element formElement \u003d tb.getFormElement();\n                                                                                                            formElement.attr(\"action\", openingTag.attributes.get(\"action\"));\n                                                                                                        }\n                                                                                                        tb.process(new Token.StartTag(\"hr\"));\n                                                                                                        tb.process(new Token.StartTag(\"label\"));\n                                                                                                        // hope you like english.\n                                                                                                        String message \u003d openingTag.attributes.hasKey(\"prompt\") ? openingTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \";\n                                                                                                        tb.process(new Token.Character(message));\n                                                                                                        // input\n                                                                                                        Attributes inputAttributes \u003d new Attributes();\n                                                                                                        for (Attribute attr : openingTag.attributes) {\n                                                                                                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                                                                                                inputAttributes.put(attr);\n                                                                                                        }\n                                                                                                        inputAttributes.put(\"name\", \"isindex\");\n                                                                                                        tb.process(new Token.StartTag(\"input\", inputAttributes));\n                                                                                                        tb.process(new Token.EndTag(\"label\"));\n                                                                                                        tb.process(new Token.StartTag(\"hr\"));\n                                                                                                        tb.process(new Token.EndTag(\"form\"));\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    // we\u0027re not supposed to ask.\n                                                                                                    openingTag.name(\"img\");\n                                                                                                    return tb.process(openingTag);\n                                                                                                }\n                                                                                            } else {\n                                                                                                if (tb.inButtonScope(\"p\")) {\n                                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                                }\n                                                                                                tb.insertEmpty(openingTag);\n                                                                                                tb.framesetOk(false);\n                                                                                            }\n                                                                                        } else {\n                                                                                            tb.insertEmpty(openingTag);\n                                                                                        }\n                                                                                    } else {\n                                                                                        tb.reconstructFormattingElements();\n                                                                                        Element el \u003d tb.insertEmpty(openingTag);\n                                                                                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                                                                                            tb.framesetOk(false);\n                                                                                    }\n                                                                                } else {\n                                                                                    tb.reconstructFormattingElements();\n                                                                                    tb.insertEmpty(openingTag);\n                                                                                    tb.framesetOk(false);\n                                                                                }\n                                                                            } else {\n                                                                                if (Document.QuirksMode.quirks !\u003d tb.getDocument().quirksMode() \u0026\u0026 tb.inButtonScope(\"p\")) {\n                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                }\n                                                                                tb.insert(openingTag);\n                                                                                tb.framesetOk(false);\n                                                                                tb.transition(InTable);\n                                                                            }\n                                                                        } else {\n                                                                            tb.reconstructFormattingElements();\n                                                                            tb.insert(openingTag);\n                                                                            tb.insertMarkerToFormattingElements();\n                                                                            tb.framesetOk(false);\n                                                                        }\n                                                                    } else {\n                                                                        tb.reconstructFormattingElements();\n                                                                        if (tb.inScope(\"nobr\")) {\n                                                                            tb.error(this);\n                                                                            tb.process(new Token.EndTag(\"nobr\"));\n                                                                            tb.reconstructFormattingElements();\n                                                                        }\n                                                                        Element el \u003d tb.insert(openingTag);\n                                                                        tb.pushActiveFormattingElements(el);\n                                                                    }\n                                                                } else {\n                                                                    tb.reconstructFormattingElements();\n                                                                    Element el \u003d tb.insert(openingTag);\n                                                                    tb.pushActiveFormattingElements(el);\n                                                                }\n                                                            } else {\n                                                                if (null !\u003d tb.getActiveFormattingElement(\"a\")) {\n                                                                    tb.error(this);\n                                                                    tb.process(new Token.EndTag(\"a\"));\n                                                                    // still on stack?\n                                                                    Element currentA \u003d tb.getFromStack(\"a\");\n                                                                    if (null !\u003d currentA) {\n                                                                        tb.removeFromActiveFormattingElements(currentA);\n                                                                        tb.removeFromStack(currentA);\n                                                                    }\n                                                                }\n                                                                tb.reconstructFormattingElements();\n                                                                Element linkElement \u003d tb.insert(openingTag);\n                                                                tb.pushActiveFormattingElements(linkElement);\n                                                            }\n                                                        } else {\n                                                            if (!tb.inButtonScope(\"button\")) {\n                                                                tb.reconstructFormattingElements();\n                                                                tb.insert(openingTag);\n                                                                tb.framesetOk(false);\n                                                            } else {\n                                                                // close and reprocess\n                                                                tb.error(this);\n                                                                tb.process(new Token.EndTag(\"button\"));\n                                                                tb.process(openingTag);\n                                                            }\n                                                        }\n                                                    } else {\n                                                        if (tb.inButtonScope(\"p\")) {\n                                                            tb.process(new Token.EndTag(\"p\"));\n                                                        }\n                                                        tb.insert(openingTag);\n                                                        // once in, never gets out\n                                                        tb.tokeniser.transition(TokeniserState.PLAINTEXT);\n                                                    }\n                                                } else {\n                                                    tb.framesetOk(false);\n                                                    LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                                                    int index \u003d list.size() - 1;\n                                                    while (0 \u003c index) {\n                                                        Element el \u003d list.get(index);\n                                                        if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                                            tb.process(new Token.EndTag(el.nodeName()));\n                                                            break;\n                                                        }\n                                                        if (tb.isSpecial(el) \u0026\u0026 !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                                            break;\n                                                        index -\u003d 1;\n                                                    }\n                                                    if (tb.inButtonScope(\"p\")) {\n                                                        tb.process(new Token.EndTag(\"p\"));\n                                                    }\n                                                    tb.insert(openingTag);\n                                                }\n                                            } else {\n                                                tb.framesetOk(false);\n                                                LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                                                int index \u003d list.size() - 1;\n                                                while (0 \u003c index) {\n                                                    Element el \u003d list.get(index);\n                                                    if (el.nodeName().equals(\"li\")) {\n                                                        tb.process(new Token.EndTag(\"li\"));\n                                                        break;\n                                                    }\n                                                    if (tb.isSpecial(el) \u0026\u0026 !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                                        break;\n                                                    index -\u003d 1;\n                                                }\n                                                if (tb.inButtonScope(\"p\")) {\n                                                    tb.process(new Token.EndTag(\"p\"));\n                                                }\n                                                tb.insert(openingTag);\n                                            }\n                                        } else {\n                                            if (null !\u003d tb.getFormElement()) {\n                                                tb.error(this);\n                                                return false;\n                                            }\n                                            if (tb.inButtonScope(\"p\")) {\n                                                tb.process(new Token.EndTag(\"p\"));\n                                            }\n                                            Element formElement \u003d tb.insert(openingTag);\n                                            tb.setFormElement(formElement);\n                                        }\n                                    } else {\n                                        if (tb.inButtonScope(\"p\")) {\n                                            tb.process(new Token.EndTag(\"p\"));\n                                        }\n                                        tb.insert(openingTag);\n                                        // todo: ignore LF if next token\n                                        tb.framesetOk(false);\n                                    }\n                                } else {\n                                    if (tb.inButtonScope(\"p\")) {\n                                        tb.process(new Token.EndTag(\"p\"));\n                                    }\n                                    if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                                        tb.error(this);\n                                        tb.pop();\n                                    }\n                                    tb.insert(openingTag);\n                                }\n                            } else {\n                                if (tb.inButtonScope(\"p\")) {\n                                    tb.process(new Token.EndTag(\"p\"));\n                                }\n                                tb.insert(openingTag);\n                            }\n                        } else {\n                            tb.error(this);\n                            LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                            if (1 !\u003d list.size() \u0026\u0026 !((2 \u003c list.size() \u0026\u0026 !list.get(1).nodeName().equals(\"body\")))) {\n                                if (tb.framesetOk()) {\n                                    Element second \u003d list.get(1);\n                                    if (null !\u003d second.parent())\n                                        second.remove();\n                                    // pop up to html element\n                                    while (1 \u003c list.size()) list.removeLast();\n                                    tb.insert(openingTag);\n                                    tb.transition(InFrameset);\n                                } else {\n                                    // ignore frameset\n                                    return false;\n                                }\n                            } else {\n                                // only in fragment case\n                                // ignore\n                                return false;\n                            }\n                        }\n                    } else {\n                        tb.error(this);\n                        LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                        if (1 !\u003d list.size() \u0026\u0026 !((2 \u003c list.size() \u0026\u0026 !list.get(1).nodeName().equals(\"body\")))) {\n                            tb.framesetOk(false);\n                            Element element \u003d list.get(1);\n                            for (Attribute property : openingTag.getAttributes()) {\n                                if (!element.hasAttr(property.getKey()))\n                                    element.attributes().put(property);\n                            }\n                        } else {\n                            // only in fragment case\n                            // ignore\n                            return false;\n                        }\n                    }\n                } else {\n                    return tb.process(t, InHead);\n                }\n            } else {\n                tb.error(this);\n                // merge attributes onto real html\n                Element rootHtml \u003d tb.getStack().getFirst();\n                for (Attribute property : openingTag.getAttributes()) {\n                    if (!rootHtml.hasAttr(property.getKey()))\n                        rootHtml.attributes().put(property);\n                }\n            }\n            break;\n        case EndTag:\n            Token.EndTag closingTag \u003d t.asEndTag();\n            tagName \u003d closingTag.name();\n            if (!tagName.equals(\"body\")) {\n                if (!tagName.equals(\"html\")) {\n                    if (!StringUtil.in(tagName, \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        if (!tagName.equals(\"form\")) {\n                            if (!tagName.equals(\"p\")) {\n                                if (!tagName.equals(\"li\")) {\n                                    if (!StringUtil.in(tagName, \"dd\", \"dt\")) {\n                                        if (!StringUtil.in(tagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                                            if (!tagName.equals(\"sarcasm\")) {\n                                                if (!StringUtil.in(tagName, \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                                                    if (!StringUtil.in(tagName, \"applet\", \"marquee\", \"object\")) {\n                                                        if (!tagName.equals(\"br\")) {\n                                                            return anyOtherEndTag(t, tb);\n                                                        } else {\n                                                            tb.error(this);\n                                                            tb.process(new Token.StartTag(\"br\"));\n                                                            return false;\n                                                        }\n                                                    } else {\n                                                        if (!tb.inScope(\"name\")) {\n                                                            if (!tb.inScope(tagName)) {\n                                                                tb.error(this);\n                                                                return false;\n                                                            }\n                                                            tb.generateImpliedEndTags();\n                                                            if (!tb.currentElement().nodeName().equals(tagName))\n                                                                tb.error(this);\n                                                            tb.popStackToClose(tagName);\n                                                            tb.clearFormattingElementsToLastMarker();\n                                                        }\n                                                    }\n                                                } else {\n                                                    // Adoption Agency Algorithm.\n                                                    OUTER: for (int index \u003d 0; 8 \u003e index; index++) {\n                                                        Element formatElement \u003d tb.getActiveFormattingElement(tagName);\n                                                        if (null !\u003d formatElement) {\n                                                            if (tb.onStack(formatElement)) {\n                                                                if (tb.inScope(formatElement.nodeName())) {\n                                                                    if (formatElement !\u003d tb.currentElement())\n                                                                        tb.error(this);\n                                                                } else {\n                                                                    tb.error(this);\n                                                                    return false;\n                                                                }\n                                                            } else {\n                                                                tb.error(this);\n                                                                tb.removeFromActiveFormattingElements(formatElement);\n                                                                return true;\n                                                            }\n                                                        } else\n                                                            return anyOtherEndTag(t, tb);\n                                                        Element mostDistantBlock \u003d null;\n                                                        Element nearestCommonAncestor \u003d null;\n                                                        boolean hasFormattingElement \u003d false;\n                                                        LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                                                        int startTagAlternative \u003d 0;\n                                                        while (list.size() \u003e startTagAlternative) {\n                                                            Element el \u003d list.get(startTagAlternative);\n                                                            if (formatElement !\u003d el) {\n                                                                if (hasFormattingElement \u0026\u0026 tb.isSpecial(el)) {\n                                                                    mostDistantBlock \u003d el;\n                                                                    break;\n                                                                }\n                                                            } else {\n                                                                nearestCommonAncestor \u003d list.get(startTagAlternative - 1);\n                                                                hasFormattingElement \u003d true;\n                                                            }\n                                                            startTagAlternative +\u003d 1;\n                                                        }\n                                                        if (null \u003d\u003d mostDistantBlock) {\n                                                            tb.popStackToClose(formatElement.nodeName());\n                                                            tb.removeFromActiveFormattingElements(formatElement);\n                                                            return true;\n                                                        }\n                                                        // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                                                        // does that mean: int pos of format el in list?\n                                                        Element node \u003d mostDistantBlock;\n                                                        Element finalNode \u003d mostDistantBlock;\n                                                        INNER: for (int j \u003d 0; 3 \u003e j; j++) {\n                                                            if (tb.onStack(node))\n                                                                node \u003d tb.aboveOnStack(node);\n                                                            if (tb.isInActiveFormattingElements(node)) {\n                                                                if (formatElement \u003d\u003d node)\n                                                                    break INNER;\n                                                            } else {\n                                                                // note no bookmark check\n                                                                tb.removeFromStack(node);\n                                                                continue INNER;\n                                                            }\n                                                            Element substitution \u003d new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                                            tb.replaceActiveFormattingElement(node, substitution);\n                                                            tb.replaceOnStack(node, substitution);\n                                                            node \u003d substitution;\n                                                            if (mostDistantBlock \u003d\u003d finalNode) {\n                                                                // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                                                // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                                            }\n                                                            if (null !\u003d finalNode.parent())\n                                                                finalNode.remove();\n                                                            node.appendChild(finalNode);\n                                                            finalNode \u003d node;\n                                                        }\n                                                        if (!StringUtil.in(nearestCommonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                                            if (null !\u003d finalNode.parent())\n                                                                finalNode.remove();\n                                                            nearestCommonAncestor.appendChild(finalNode);\n                                                        } else {\n                                                            if (null !\u003d finalNode.parent())\n                                                                finalNode.remove();\n                                                            tb.insertInFosterParent(finalNode);\n                                                        }\n                                                        Element container \u003d new Element(Tag.valueOf(tagName), tb.getBaseUri());\n                                                        Node[] children \u003d mostDistantBlock.childNodes().toArray(new Node[mostDistantBlock.childNodes().size()]);\n                                                        for (Node siblingNode : children) {\n                                                            // append will reparent. thus the clone to avvoid concurrent mod.\n                                                            container.appendChild(siblingNode);\n                                                        }\n                                                        mostDistantBlock.appendChild(container);\n                                                        tb.removeFromActiveFormattingElements(formatElement);\n                                                        // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                                                        tb.removeFromStack(formatElement);\n                                                        tb.insertOnStackAfter(mostDistantBlock, container);\n                                                    }\n                                                }\n                                            } else {\n                                                // *sigh*\n                                                return anyOtherEndTag(t, tb);\n                                            }\n                                        } else {\n                                            if (tb.inScope(new String[] { \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\" })) {\n                                                tb.generateImpliedEndTags(tagName);\n                                                if (!tb.currentElement().nodeName().equals(tagName))\n                                                    tb.error(this);\n                                                tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                                            } else {\n                                                tb.error(this);\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        if (tb.inScope(tagName)) {\n                                            tb.generateImpliedEndTags(tagName);\n                                            if (!tb.currentElement().nodeName().equals(tagName))\n                                                tb.error(this);\n                                            tb.popStackToClose(tagName);\n                                        } else {\n                                            tb.error(this);\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    if (tb.inListItemScope(tagName)) {\n                                        tb.generateImpliedEndTags(tagName);\n                                        if (!tb.currentElement().nodeName().equals(tagName))\n                                            tb.error(this);\n                                        tb.popStackToClose(tagName);\n                                    } else {\n                                        tb.error(this);\n                                        return false;\n                                    }\n                                }\n                            } else {\n                                if (tb.inButtonScope(tagName)) {\n                                    tb.generateImpliedEndTags(tagName);\n                                    if (!tb.currentElement().nodeName().equals(tagName))\n                                        tb.error(this);\n                                    tb.popStackToClose(tagName);\n                                } else {\n                                    tb.error(this);\n                                    // if no p to close, creates an empty \u003cp\u003e\u003c/p\u003e\n                                    tb.process(new Token.StartTag(tagName));\n                                    return tb.process(closingTag);\n                                }\n                            }\n                        } else {\n                            Element activeForm \u003d tb.getFormElement();\n                            tb.setFormElement(null);\n                            if (null !\u003d activeForm \u0026\u0026 tb.inScope(tagName)) {\n                                tb.generateImpliedEndTags();\n                                if (!tb.currentElement().nodeName().equals(tagName))\n                                    tb.error(this);\n                                // remove currentForm from stack. will shift anything under up.\n                                tb.removeFromStack(activeForm);\n                            } else {\n                                tb.error(this);\n                                return false;\n                            }\n                        }\n                    } else {\n                        // todo: refactor these lookups\n                        if (tb.inScope(tagName)) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(tagName))\n                                tb.error(this);\n                            tb.popStackToClose(tagName);\n                        } else {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        }\n                    }\n                } else {\n                    boolean isIgnored \u003d tb.process(new Token.EndTag(\"body\"));\n                    if (isIgnored)\n                        return tb.process(closingTag);\n                }\n            } else {\n                if (tb.inScope(\"body\")) {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            }\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
  "Jsoup-19": "private boolean testValidProtocol(Element el, Attribute attr, Set\u003cProtocol\u003e protocols) {\n    // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n    // rels without a baseuri get removed\n    String absoluteUrl \u003d el.absUrl(attr.getKey());\n    if (!preserveRelativeLinks)\n        attr.setValue(absoluteUrl);\n    for (Protocol scheme : protocols) {\n        String prot \u003d scheme.toString() + \":\";\n        if (absoluteUrl.toLowerCase().startsWith(prot)) {\n            return true;\n        }\n    }\n    return false;\n}",
  "Compress-21": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n    int buffer \u003d 0;\n    int offset \u003d 7;\n    int index \u003d 0;\n    while (length \u003e index) {\n        buffer |\u003d ((bits.get(index) ? 1 : 0) \u003c\u003c offset);\n        --offset;\n        if (0 \u003d\u003d offset) {\n            header.write(buffer);\n            offset \u003d 7;\n            buffer \u003d 0;\n        }\n        index +\u003d 1;\n    }\n    if (0 \u003c length \u0026\u0026 0 \u003c offset) {\n        header.write(buffer);\n    }\n}",
  "Compress-26": "public static long skip(InputStream input, long numToSkip) throws IOException {\n    long initialAmount \u003d numToSkip;\n    while (0 \u003c numToSkip) {\n        long discarded \u003d input.skip(numToSkip);\n        if (0 \u003d\u003d discarded) {\n            break;\n        }\n        numToSkip -\u003d discarded;\n    }\n    return initialAmount - numToSkip;\n}",
  "Compress-25": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding \u003d ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields \u003d useUnicodeExtraFields;\n    in \u003d new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor \u003d allowStoredEntriesWithDataDescriptor;\n    // haven\u0027t read anything so far\n}",
  "Compress-24": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long value \u003d 0;\n    int limit \u003d offset + length;\n    int begin \u003d offset;\n    if (2 \u003e length) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (0 \u003d\u003d buffer[begin]) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (limit \u003e begin) {\n        if (\u0027 \u0027 !\u003d buffer[begin]) {\n            break;\n        } else {\n            begin +\u003d 1;\n        }\n    }\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte terminator \u003d buffer[limit - 1];\n    if (0 !\u003d terminator \u0026\u0026 \u0027 \u0027 !\u003d terminator) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, limit - 1, terminator));\n    } else {\n        limit -\u003d 1;\n    }\n    terminator \u003d buffer[limit - 1];\n    while (limit - 1 \u003e begin \u0026\u0026 (0 \u003d\u003d terminator || \u0027 \u0027 \u003d\u003d terminator)) {\n        limit -\u003d 1;\n        terminator \u003d buffer[limit - 1];\n    }\n    while (limit \u003e begin) {\n        final byte currentByte \u003d buffer[begin];\n        // CheckStyle:MagicNumber OFF\n        if (\u00270\u0027 \u003e currentByte || \u00277\u0027 \u003c currentByte) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, begin, currentByte));\n        }\n        // convert from ASCII\n        value \u003d (value \u003c\u003c 3) + (currentByte - \u00270\u0027);\n        // CheckStyle:MagicNumber ON\n        begin +\u003d 1;\n    }\n    return value;\n}",
  "Compress-23": "InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n    byte propertiesByte \u003d coder.properties[0];\n    long dictionarySize \u003d coder.properties[1];\n    int index \u003d 1;\n    while (4 \u003e index) {\n        dictionarySize |\u003d (coder.properties[index + 1] \u003c\u003c (8 * index));\n        index +\u003d 1;\n    }\n    if (LZMAInputStream.DICT_SIZE_MAX \u003c dictionarySize) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propertiesByte, (int) dictionarySize);\n}",
  "Compress-28": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    int bytesRead \u003d 0;\n    if (hasHitEOF || entrySize \u003c\u003d entryOffset) {\n        return -1;\n    }\n    if (null \u003d\u003d currEntry) {\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n    numToRead \u003d Math.min(numToRead, available());\n    bytesRead \u003d is.read(buf, offset, numToRead);\n    count(bytesRead);\n    if (-1 !\u003d bytesRead) {\n        entryOffset +\u003d bytesRead;\n    } else {\n        hasHitEOF \u003d true;\n    }\n    return bytesRead;\n}",
  "Compress-27": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long outcome \u003d 0;\n    int finalPosition \u003d offset + length;\n    int beginning \u003d offset;\n    if (2 \u003e length) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (0 \u003d\u003d buffer[beginning]) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (finalPosition \u003e beginning) {\n        if (\u0027 \u0027 !\u003d buffer[beginning]) {\n            break;\n        } else {\n            beginning +\u003d 1;\n        }\n    }\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte suffix \u003d buffer[finalPosition - 1];\n    while (finalPosition \u003e beginning \u0026\u0026 (0 \u003d\u003d suffix || \u0027 \u0027 \u003d\u003d suffix)) {\n        finalPosition -\u003d 1;\n        suffix \u003d buffer[finalPosition - 1];\n    }\n    if (finalPosition \u003d\u003d beginning) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, beginning, suffix));\n    }\n    while (finalPosition \u003e beginning) {\n        final byte currentByte \u003d buffer[beginning];\n        // CheckStyle:MagicNumber OFF\n        if (\u00270\u0027 \u003e currentByte || \u00277\u0027 \u003c currentByte) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, beginning, currentByte));\n        }\n        // convert from ASCII\n        outcome \u003d (outcome \u003c\u003c 3) + (currentByte - \u00270\u0027);\n        // CheckStyle:MagicNumber ON\n        beginning +\u003d 1;\n    }\n    return outcome;\n}",
  "Jsoup-10": "public String absUrl(String attributeKey) {\n    Validate.notEmpty(attributeKey);\n    String relativeUrl \u003d attr(attributeKey);\n    if (hasAttr(attributeKey)) {\n        URL foundation;\n        try {\n            try {\n                foundation \u003d new URL(baseUri);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute may be abs on its own, so try that\n                URL absoluteUrl \u003d new URL(relativeUrl);\n                return absoluteUrl.toExternalForm();\n            }\n            // workaround: java resolves \u0027//path/file + ?foo\u0027 to \u0027//path/?foo\u0027, not \u0027//path/file?foo\u0027 as desired\n            URL absoluteUrl \u003d new URL(foundation, relativeUrl);\n            return absoluteUrl.toExternalForm();\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    } else {\n        // nothing to make absolute with\n        return \"\";\n    }\n}",
  "Jsoup-13": "public boolean hasAttr(String attributeKey) {\n    Validate.notNull(attributeKey);\n    return attributes.hasKey(attributeKey);\n}",
  "Jsoup-27": "static String getCharsetFromContentType(String contentType) {\n    if (null \u003d\u003d contentType)\n        return null;\n    Matcher matcher \u003d charsetPattern.matcher(contentType);\n    if (matcher.find()) {\n        String encoding \u003d matcher.group(1).trim();\n        encoding \u003d encoding.toUpperCase(Locale.ENGLISH);\n        return encoding;\n    }\n    return null;\n}",
  "Jsoup-26": "public Document clean(Document dirtyDocument) {\n    Validate.notNull(dirtyDocument);\n    Document sanitized \u003d Document.createShell(dirtyDocument.baseUri());\n    copySafeNodes(dirtyDocument.body(), sanitized.body());\n    return sanitized;\n}",
  "JacksonDatabind-110": "public static JsonDeserializer\u003c?\u003e findForCollection(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n    JavaUtilCollectionsConverter converter;\n    // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...\n    if (!type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n        if (!type.hasRawClass(CLASS_SINGLETON_LIST)) {\n            if (!type.hasRawClass(CLASS_SINGLETON_SET)) {\n                if (!type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n                    if (!type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n                        return null;\n                    } else {\n                        converter \u003d converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n                    }\n                } else {\n                    converter \u003d converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n                }\n            } else {\n                converter \u003d converter(TYPE_SINGLETON_SET, type, Set.class);\n                // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n            }\n        } else {\n            converter \u003d converter(TYPE_SINGLETON_LIST, type, List.class);\n        }\n    } else {\n        converter \u003d converter(TYPE_AS_LIST, type, List.class);\n    }\n    return new StdDelegatingDeserializer\u003cObject\u003e(converter);\n}",
  "JacksonDatabind-112": "public JsonDeserializer\u003c?\u003e createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer\u003cObject\u003e proxy \u003d null;\n    if (null !\u003d _valueInstantiator) {\n        // [databind#2324]: check both array-delegating and delegating\n        AnnotatedWithParams creatorDelegate \u003d _valueInstantiator.getDelegateCreator();\n        if (null !\u003d creatorDelegate) {\n            JavaType delegateClass \u003d _valueInstantiator.getDelegateType(ctxt.getConfig());\n            proxy \u003d findDeserializer(ctxt, delegateClass, property);\n        }\n    }\n    JsonDeserializer\u003c?\u003e contentDeserializer \u003d _valueDeserializer;\n    final JavaType contentType \u003d _containerType.getContentType();\n    if (null !\u003d contentDeserializer) {\n        // if directly assigned, probably not yet contextual, so:\n        contentDeserializer \u003d ctxt.handleSecondaryContextualization(contentDeserializer, property, contentType);\n    } else {\n        // [databind#125]: May have a content converter\n        contentDeserializer \u003d findConvertingContentDeserializer(ctxt, property, contentDeserializer);\n        if (null \u003d\u003d contentDeserializer) {\n            // And we may also need to get deserializer for String\n            contentDeserializer \u003d ctxt.findContextualValueDeserializer(contentType, property);\n        }\n    }\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean isSingleValueWrapped \u003d findFormatFeature(ctxt, property, Collection.class, JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    NullValueProvider nullValueProvider \u003d findContentNullProvider(ctxt, property, contentDeserializer);\n    if (isDefaultDeserializer(contentDeserializer)) {\n        contentDeserializer \u003d null;\n    }\n    return withResolved(proxy, contentDeserializer, nullValueProvider, isSingleValueWrapped);\n}",
  "JacksonDatabind-102": "public JsonSerializer\u003c?\u003e createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that\u0027d skip check\n    // for config overrides, in case of root value\n    if (null \u003d\u003d property) {\n        return this;\n    }\n    JsonFormat.Value template \u003d findFormatOverrides(serializers, property, handledType());\n    if (null \u003d\u003d template) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape formatShape \u003d template.getShape();\n    if (formatShape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (template.hasPattern()) {\n        final Locale locale \u003d template.hasLocale() ? template.getLocale() : serializers.getLocale();\n        SimpleDateFormat dateFormat \u003d new SimpleDateFormat(template.getPattern(), locale);\n        TimeZone timeZone \u003d template.hasTimeZone() ? template.getTimeZone() : serializers.getTimeZone();\n        dateFormat.setTimeZone(timeZone);\n        return withFormat(Boolean.FALSE, dateFormat);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLanguage \u003d template.hasLocale();\n    final boolean hasTimeZone \u003d template.hasTimeZone();\n    final boolean isStringFormat \u003d (JsonFormat.Shape.STRING \u003d\u003d formatShape);\n    if (!hasLanguage \u0026\u0026 !hasTimeZone \u0026\u0026 !isStringFormat) {\n        return this;\n    }\n    DateFormat dfFormatted \u003d serializers.getConfig().getDateFormat();\n    // Jackson\u0027s own `StdDateFormat` is quite easy to deal with...\n    if (dfFormatted instanceof StdDateFormat) {\n        StdDateFormat std \u003d (StdDateFormat) dfFormatted;\n        if (template.hasLocale()) {\n            std \u003d std.withLocale(template.getLocale());\n        }\n        if (template.hasTimeZone()) {\n            std \u003d std.withTimeZone(template.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there\u0027s no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can\u0027t config other types\n    if (!(dfFormatted instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", dfFormatted.getClass().getName()));\n    }\n    SimpleDateFormat dateFormat \u003d (SimpleDateFormat) dfFormatted;\n    if (!hasLanguage) {\n        dateFormat \u003d (SimpleDateFormat) dateFormat.clone();\n    } else {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        dateFormat \u003d new SimpleDateFormat(dateFormat.toPattern(), template.getLocale());\n    }\n    TimeZone updatedTz \u003d template.getTimeZone();\n    boolean isTimeZoneModified \u003d (null !\u003d updatedTz) \u0026\u0026 !updatedTz.equals(dateFormat.getTimeZone());\n    if (isTimeZoneModified) {\n        dateFormat.setTimeZone(updatedTz);\n    }\n    return withFormat(Boolean.FALSE, dateFormat);\n}",
  "JacksonDatabind-105": "public static JsonDeserializer\u003c?\u003e find(Class\u003c?\u003e rawType, String clsName) {\n    if (_classNames.contains(clsName)) {\n        JsonDeserializer\u003c?\u003e deserializer \u003d FromStringDeserializer.findDeserializer(rawType);\n        if (null !\u003d deserializer) {\n            return deserializer;\n        }\n        if (UUID.class \u003d\u003d rawType) {\n            return new UUIDDeserializer();\n        }\n        if (StackTraceElement.class \u003d\u003d rawType) {\n            return new StackTraceElementDeserializer();\n        }\n        if (AtomicBoolean.class \u003d\u003d rawType) {\n            // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n            return new AtomicBooleanDeserializer();\n        }\n        if (ByteBuffer.class \u003d\u003d rawType) {\n            return new ByteBufferDeserializer();\n        }\n    }\n    return null;\n}",
  "JacksonDatabind-107": "protected final JsonDeserializer\u003cObject\u003e _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer\u003cObject\u003e deserializer \u003d _deserializers.get(typeId);\n    if (null \u003d\u003d deserializer) {\n        /* As per [databind#305], need to provide contextual info. But for\n         * backwards compatibility, let\u0027s start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType kind \u003d _idResolver.typeFromId(ctxt, typeId);\n        if (null !\u003d kind) {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; cannot change \u0027type class\u0027 (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((null !\u003d _baseType) \u0026\u0026 kind.getClass() \u003d\u003d _baseType.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!kind.hasGenericTypes()) {\n                    kind \u003d ctxt.getTypeFactory().constructSpecializedType(_baseType, kind.getRawClass());\n                }\n            }\n            deserializer \u003d ctxt.findContextualValueDeserializer(kind, _property);\n        } else {\n            // use the default impl if no type id available:\n            deserializer \u003d _findDefaultImplDeserializer(ctxt);\n            if (null \u003d\u003d deserializer) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType resolved \u003d _handleUnknownTypeId(ctxt, typeId);\n                if (null \u003d\u003d resolved) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return null;\n                }\n                // ... would this actually work?\n                deserializer \u003d ctxt.findContextualValueDeserializer(resolved, _property);\n            }\n        }\n        _deserializers.put(typeId, deserializer);\n    }\n    return deserializer;\n}",
  "JacksonDatabind-108": "@SuppressWarnings(\"unchecked\")\n@Override\npublic \u003cT extends TreeNode\u003e T readTree(JsonParser p) throws IOException {\n    return (T) _bindAsTree(p);\n}",
  "JacksonCore-7": "public int writeValue() {\n    // Most likely, object:\n    if (TYPE_OBJECT \u003d\u003d _type) {\n        _gotName \u003d false;\n        ++_index;\n        return STATUS_OK_AFTER_COLON;\n    }\n    // Ok, array?\n    if (TYPE_ARRAY \u003d\u003d _type) {\n        int indexValue \u003d _index;\n        ++_index;\n        return (0 \u003e indexValue) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n    }\n    // Nope, root context\n    // No commas within root context, but need space\n    ++_index;\n    return (0 \u003d\u003d _index) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n}",
  "JacksonCore-8": "public char[] getTextBuffer() {\n    // Are we just using shared input buffer?\n    if (0 \u003c\u003d _inputStart)\n        return _inputBuffer;\n    if (null !\u003d _resultArray)\n        return _resultArray;\n    if (null !\u003d _resultString) {\n        return (_resultArray \u003d _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments)\n        return _currentSegment;\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}",
  "Jsoup-20": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String parsedData;\n    Document parsedDocument \u003d null;\n    if (null !\u003d charsetName) {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        parsedData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    } else {\n        // determine from meta. safe parse as UTF-8\n        // look for \u003cmeta http-equiv\u003d\"Content-Type\" content\u003d\"text/html;charset\u003dgb2312\"\u003e or HTML5 \u003cmeta charset\u003d\"gb2312\"\u003e\n        parsedData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        parsedDocument \u003d parser.parseInput(parsedData, baseUri);\n        Element header \u003d parsedDocument.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (null !\u003d header) {\n            // if not found, will keep utf-8 as best attempt\n            String detectedCharset \u003d header.hasAttr(\"http-equiv\") ? getCharsetFromContentType(header.attr(\"content\")) : header.attr(\"charset\");\n            if (null !\u003d detectedCharset \u0026\u0026 0 !\u003d detectedCharset.length() \u0026\u0026 !detectedCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName \u003d detectedCharset;\n                byteData.rewind();\n                parsedData \u003d Charset.forName(detectedCharset).decode(byteData).toString();\n                parsedDocument \u003d null;\n            }\n        }\n    }\n    if (null \u003d\u003d parsedDocument) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn\u0027t be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        parsedDocument \u003d parser.parseInput(parsedData, baseUri);\n        parsedDocument.outputSettings().charset(charsetName);\n    }\n    return parsedDocument;\n}",
  "JacksonCore-5": "private final static int _parseIndex(String str) {\n    final int length \u003d str.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (0 \u003d\u003d length || 10 \u003c length) {\n        return -1;\n    }\n    int index \u003d 0;\n    while (length \u003e index) {\n        char digit \u003d str.charAt(index++);\n        if (\u00279\u0027 \u003c digit || \u00270\u0027 \u003e digit) {\n            return -1;\n        }\n        ++index;\n    }\n    if (10 \u003d\u003d length) {\n        long number \u003d NumberInput.parseLong(str);\n        if (Integer.MAX_VALUE \u003c number) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
  "JacksonCore-6": "private final static int _parseIndex(String str) {\n    final int length \u003d str.length();\n    // [core#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (0 \u003d\u003d length || 10 \u003c length) {\n        return -1;\n    }\n    int index \u003d 0;\n    while (length \u003e index) {\n        char digit \u003d str.charAt(index);\n        if (\u00279\u0027 \u003c digit || \u00270\u0027 \u003e digit) {\n            return -1;\n        }\n        ++index;\n    }\n    if (10 \u003d\u003d length) {\n        long numericValue \u003d NumberInput.parseLong(str);\n        if (Integer.MAX_VALUE \u003c numericValue) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
  "JacksonCore-3": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {\n    super(ctxt, features);\n    _inputStream \u003d in;\n    _objectCodec \u003d codec;\n    _symbols \u003d sym;\n    _inputBuffer \u003d inputBuffer;\n    _inputPtr \u003d start;\n    _inputEnd \u003d end;\n    // If we have offset, need to omit that from byte offset, so:\n    _bufferRecyclable \u003d bufferRecyclable;\n}",
  "JacksonCore-4": "public char[] expandCurrentSegment() {\n    final char[] currentSegment \u003d _currentSegment;\n    // Let\u0027s grow by 50% by default\n    final int currentLength \u003d currentSegment.length;\n    // but above intended maximum, slow to increase by 25%\n    int expandedLength \u003d (MAX_SEGMENT_LEN \u003d\u003d currentLength) ? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, currentLength + (currentLength \u003e\u003e 1));\n    return (_currentSegment \u003d Arrays.copyOf(currentSegment, expandedLength));\n}",
  "Jsoup-24": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String identifier \u003d r.consumeLetterSequence();\n        t.tagPending.appendTagName(identifier.toLowerCase());\n        t.dataBuffer.append(identifier);\n        r.advance();\n        return;\n    }\n    if (!t.isAppropriateEndTagToken() || r.isEmpty()) {\n        anythingElse(t, r);\n    } else {\n        char character \u003d r.consume();\n        switch(character) {\n            case \u0027\\t\u0027:\n            case \u0027\\n\u0027:\n            case \u0027\\f\u0027:\n            case \u0027 \u0027:\n                t.transition(BeforeAttributeName);\n                break;\n            case \u0027/\u0027:\n                t.transition(SelfClosingStartTag);\n                break;\n            case \u0027\u003e\u0027:\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            default:\n                t.dataBuffer.append(character);\n                anythingElse(t, r);\n                break;\n        }\n    }\n}",
  "Jsoup-38": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch(t.type) {\n        case Character:\n            {\n                Token.Character c \u003d t.asCharacter();\n                if (!c.getData().equals(nullString)) {\n                    if (!isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    }\n                } else {\n                    // todo confirm that check\n                    tb.error(this);\n                    return false;\n                }\n                break;\n            }\n        case Comment:\n            {\n                tb.insert(t.asComment());\n                break;\n            }\n        case Doctype:\n            {\n                tb.error(this);\n                return false;\n            }\n        case StartTag:\n            Token.StartTag elementStartTag \u003d t.asStartTag();\n            String elementName \u003d elementStartTag.name();\n            if (!elementName.equals(\"html\")) {\n                if (!StringUtil.in(elementName, Constants.InBodyStartToHead)) {\n                    if (!elementName.equals(\"body\")) {\n                        if (!elementName.equals(\"frameset\")) {\n                            if (!StringUtil.in(elementName, Constants.InBodyStartPClosers)) {\n                                if (!StringUtil.in(elementName, Constants.Headings)) {\n                                    if (!StringUtil.in(elementName, Constants.InBodyStartPreListing)) {\n                                        if (!elementName.equals(\"form\")) {\n                                            if (!elementName.equals(\"li\")) {\n                                                if (!StringUtil.in(elementName, Constants.DdDt)) {\n                                                    if (!elementName.equals(\"plaintext\")) {\n                                                        if (!elementName.equals(\"button\")) {\n                                                            if (!elementName.equals(\"a\")) {\n                                                                if (!StringUtil.in(elementName, Constants.Formatters)) {\n                                                                    if (!elementName.equals(\"nobr\")) {\n                                                                        if (!StringUtil.in(elementName, Constants.InBodyStartApplets)) {\n                                                                            if (!elementName.equals(\"table\")) {\n                                                                                if (!StringUtil.in(elementName, Constants.InBodyStartEmptyFormatters)) {\n                                                                                    if (!elementName.equals(\"input\")) {\n                                                                                        if (!StringUtil.in(elementName, Constants.InBodyStartMedia)) {\n                                                                                            if (!elementName.equals(\"hr\")) {\n                                                                                                if (!elementName.equals(\"image\")) {\n                                                                                                    if (!elementName.equals(\"isindex\")) {\n                                                                                                        if (!elementName.equals(\"textarea\")) {\n                                                                                                            if (!elementName.equals(\"xmp\")) {\n                                                                                                                if (!elementName.equals(\"iframe\")) {\n                                                                                                                    if (!elementName.equals(\"noembed\")) {\n                                                                                                                        if (!elementName.equals(\"select\")) {\n                                                                                                                            if (!StringUtil.in(elementName, Constants.InBodyStartOptions)) {\n                                                                                                                                if (!StringUtil.in(elementName, Constants.InBodyStartRuby)) {\n                                                                                                                                    if (!elementName.equals(\"math\")) {\n                                                                                                                                        if (!elementName.equals(\"svg\")) {\n                                                                                                                                            if (!StringUtil.in(elementName, Constants.InBodyStartDrop)) {\n                                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                                tb.insert(elementStartTag);\n                                                                                                                                            } else {\n                                                                                                                                                tb.error(this);\n                                                                                                                                                return false;\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                                            // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                                                                                                                                            tb.insert(elementStartTag);\n                                                                                                                                            tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        tb.reconstructFormattingElements();\n                                                                                                                                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                                                                                                                                        tb.insert(elementStartTag);\n                                                                                                                                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    if (tb.inScope(\"ruby\")) {\n                                                                                                                                        tb.generateImpliedEndTags();\n                                                                                                                                        if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                                                                                                                            tb.error(this);\n                                                                                                                                            // i.e. close up to but not include name\n                                                                                                                                            tb.popStackToBefore(\"ruby\");\n                                                                                                                                        }\n                                                                                                                                        tb.insert(elementStartTag);\n                                                                                                                                    }\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                if (tb.currentElement().nodeName().equals(\"option\"))\n                                                                                                                                    tb.process(new Token.EndTag(\"option\"));\n                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                tb.insert(elementStartTag);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                            tb.insert(elementStartTag);\n                                                                                                                            tb.framesetOk(false);\n                                                                                                                            HtmlTreeBuilderState context \u003d tb.state();\n                                                                                                                            if (context.equals(InTable) || context.equals(InCaption) || context.equals(InTableBody) || context.equals(InRow) || context.equals(InCell))\n                                                                                                                                tb.transition(InSelectInTable);\n                                                                                                                            else\n                                                                                                                                tb.transition(InSelect);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        // also handle noscript if script enabled\n                                                                                                                        handleRawtext(elementStartTag, tb);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    tb.framesetOk(false);\n                                                                                                                    handleRawtext(elementStartTag, tb);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                if (tb.inButtonScope(\"p\")) {\n                                                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                                                }\n                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                tb.framesetOk(false);\n                                                                                                                handleRawtext(elementStartTag, tb);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            tb.insert(elementStartTag);\n                                                                                                            // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                                                                                                            tb.tokeniser.transition(TokeniserState.Rcdata);\n                                                                                                            tb.markInsertionMode();\n                                                                                                            tb.framesetOk(false);\n                                                                                                            tb.transition(Text);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        // how much do we care about the early 90s?\n                                                                                                        tb.error(this);\n                                                                                                        if (null !\u003d tb.getFormElement())\n                                                                                                            return false;\n                                                                                                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                        tb.process(new Token.StartTag(\"form\"));\n                                                                                                        if (elementStartTag.attributes.hasKey(\"action\")) {\n                                                                                                            Element structure \u003d tb.getFormElement();\n                                                                                                            structure.attr(\"action\", elementStartTag.attributes.get(\"action\"));\n                                                                                                        }\n                                                                                                        tb.process(new Token.StartTag(\"hr\"));\n                                                                                                        tb.process(new Token.StartTag(\"label\"));\n                                                                                                        // hope you like english.\n                                                                                                        String label \u003d elementStartTag.attributes.hasKey(\"prompt\") ? elementStartTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \";\n                                                                                                        tb.process(new Token.Character(label));\n                                                                                                        // input\n                                                                                                        Attributes inputAttribs \u003d new Attributes();\n                                                                                                        for (Attribute attr : elementStartTag.attributes) {\n                                                                                                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                                                                                                inputAttribs.put(attr);\n                                                                                                        }\n                                                                                                        inputAttribs.put(\"name\", \"isindex\");\n                                                                                                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                                                                                                        tb.process(new Token.EndTag(\"label\"));\n                                                                                                        tb.process(new Token.StartTag(\"hr\"));\n                                                                                                        tb.process(new Token.EndTag(\"form\"));\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    // change \u003cimage\u003e to \u003cimg\u003e, unless in svg\n                                                                                                    return tb.process(elementStartTag.name(\"img\"));\n                                                                                                }\n                                                                                            } else {\n                                                                                                if (tb.inButtonScope(\"p\")) {\n                                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                                }\n                                                                                                tb.insertEmpty(elementStartTag);\n                                                                                                tb.framesetOk(false);\n                                                                                            }\n                                                                                        } else {\n                                                                                            tb.insertEmpty(elementStartTag);\n                                                                                        }\n                                                                                    } else {\n                                                                                        tb.reconstructFormattingElements();\n                                                                                        Element el \u003d tb.insertEmpty(elementStartTag);\n                                                                                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                                                                                            tb.framesetOk(false);\n                                                                                    }\n                                                                                } else {\n                                                                                    tb.reconstructFormattingElements();\n                                                                                    tb.insertEmpty(elementStartTag);\n                                                                                    tb.framesetOk(false);\n                                                                                }\n                                                                            } else {\n                                                                                if (Document.QuirksMode.quirks !\u003d tb.getDocument().quirksMode() \u0026\u0026 tb.inButtonScope(\"p\")) {\n                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                }\n                                                                                tb.insert(elementStartTag);\n                                                                                tb.framesetOk(false);\n                                                                                tb.transition(InTable);\n                                                                            }\n                                                                        } else {\n                                                                            tb.reconstructFormattingElements();\n                                                                            tb.insert(elementStartTag);\n                                                                            tb.insertMarkerToFormattingElements();\n                                                                            tb.framesetOk(false);\n                                                                        }\n                                                                    } else {\n                                                                        tb.reconstructFormattingElements();\n                                                                        if (tb.inScope(\"nobr\")) {\n                                                                            tb.error(this);\n                                                                            tb.process(new Token.EndTag(\"nobr\"));\n                                                                            tb.reconstructFormattingElements();\n                                                                        }\n                                                                        Element el \u003d tb.insert(elementStartTag);\n                                                                        tb.pushActiveFormattingElements(el);\n                                                                    }\n                                                                } else {\n                                                                    tb.reconstructFormattingElements();\n                                                                    Element el \u003d tb.insert(elementStartTag);\n                                                                    tb.pushActiveFormattingElements(el);\n                                                                }\n                                                            } else {\n                                                                if (null !\u003d tb.getActiveFormattingElement(\"a\")) {\n                                                                    tb.error(this);\n                                                                    tb.process(new Token.EndTag(\"a\"));\n                                                                    // still on stack?\n                                                                    Element lastActiveAnchor \u003d tb.getFromStack(\"a\");\n                                                                    if (null !\u003d lastActiveAnchor) {\n                                                                        tb.removeFromActiveFormattingElements(lastActiveAnchor);\n                                                                        tb.removeFromStack(lastActiveAnchor);\n                                                                    }\n                                                                }\n                                                                tb.reconstructFormattingElements();\n                                                                Element link \u003d tb.insert(elementStartTag);\n                                                                tb.pushActiveFormattingElements(link);\n                                                            }\n                                                        } else {\n                                                            if (!tb.inButtonScope(\"button\")) {\n                                                                tb.reconstructFormattingElements();\n                                                                tb.insert(elementStartTag);\n                                                                tb.framesetOk(false);\n                                                            } else {\n                                                                // close and reprocess\n                                                                tb.error(this);\n                                                                tb.process(new Token.EndTag(\"button\"));\n                                                                tb.process(elementStartTag);\n                                                            }\n                                                        }\n                                                    } else {\n                                                        if (tb.inButtonScope(\"p\")) {\n                                                            tb.process(new Token.EndTag(\"p\"));\n                                                        }\n                                                        tb.insert(elementStartTag);\n                                                        // once in, never gets out\n                                                        tb.tokeniser.transition(TokeniserState.PLAINTEXT);\n                                                    }\n                                                } else {\n                                                    tb.framesetOk(false);\n                                                    LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                                                    int index \u003d list.size() - 1;\n                                                    while (0 \u003c index) {\n                                                        Element el \u003d list.get(index);\n                                                        if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                                                            tb.process(new Token.EndTag(el.nodeName()));\n                                                            break;\n                                                        }\n                                                        if (tb.isSpecial(el) \u0026\u0026 !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                                            break;\n                                                        index -\u003d 1;\n                                                    }\n                                                    if (tb.inButtonScope(\"p\")) {\n                                                        tb.process(new Token.EndTag(\"p\"));\n                                                    }\n                                                    tb.insert(elementStartTag);\n                                                }\n                                            } else {\n                                                tb.framesetOk(false);\n                                                LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                                                int index \u003d list.size() - 1;\n                                                while (0 \u003c index) {\n                                                    Element el \u003d list.get(index);\n                                                    if (el.nodeName().equals(\"li\")) {\n                                                        tb.process(new Token.EndTag(\"li\"));\n                                                        break;\n                                                    }\n                                                    if (tb.isSpecial(el) \u0026\u0026 !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                                        break;\n                                                    index -\u003d 1;\n                                                }\n                                                if (tb.inButtonScope(\"p\")) {\n                                                    tb.process(new Token.EndTag(\"p\"));\n                                                }\n                                                tb.insert(elementStartTag);\n                                            }\n                                        } else {\n                                            if (null !\u003d tb.getFormElement()) {\n                                                tb.error(this);\n                                                return false;\n                                            }\n                                            if (tb.inButtonScope(\"p\")) {\n                                                tb.process(new Token.EndTag(\"p\"));\n                                            }\n                                            tb.insertForm(elementStartTag, true);\n                                        }\n                                    } else {\n                                        if (tb.inButtonScope(\"p\")) {\n                                            tb.process(new Token.EndTag(\"p\"));\n                                        }\n                                        tb.insert(elementStartTag);\n                                        // todo: ignore LF if next token\n                                        tb.framesetOk(false);\n                                    }\n                                } else {\n                                    if (tb.inButtonScope(\"p\")) {\n                                        tb.process(new Token.EndTag(\"p\"));\n                                    }\n                                    if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                                        tb.error(this);\n                                        tb.pop();\n                                    }\n                                    tb.insert(elementStartTag);\n                                }\n                            } else {\n                                if (tb.inButtonScope(\"p\")) {\n                                    tb.process(new Token.EndTag(\"p\"));\n                                }\n                                tb.insert(elementStartTag);\n                            }\n                        } else {\n                            tb.error(this);\n                            LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                            if (1 !\u003d list.size() \u0026\u0026 !((2 \u003c list.size() \u0026\u0026 !list.get(1).nodeName().equals(\"body\")))) {\n                                if (tb.framesetOk()) {\n                                    Element topElement \u003d list.get(1);\n                                    if (null !\u003d topElement.parent())\n                                        topElement.remove();\n                                    // pop up to html element\n                                    while (1 \u003c list.size()) list.removeLast();\n                                    tb.insert(elementStartTag);\n                                    tb.transition(InFrameset);\n                                } else {\n                                    // ignore frameset\n                                    return false;\n                                }\n                            } else {\n                                // only in fragment case\n                                // ignore\n                                return false;\n                            }\n                        }\n                    } else {\n                        tb.error(this);\n                        LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                        if (1 !\u003d list.size() \u0026\u0026 !((2 \u003c list.size() \u0026\u0026 !list.get(1).nodeName().equals(\"body\")))) {\n                            tb.framesetOk(false);\n                            Element element \u003d list.get(1);\n                            for (Attribute property : elementStartTag.getAttributes()) {\n                                if (!element.hasAttr(property.getKey()))\n                                    element.attributes().put(property);\n                            }\n                        } else {\n                            // only in fragment case\n                            // ignore\n                            return false;\n                        }\n                    }\n                } else {\n                    return tb.process(t, InHead);\n                }\n            } else {\n                tb.error(this);\n                // merge attributes onto real html\n                Element rootElement \u003d tb.getStack().getFirst();\n                for (Attribute property : elementStartTag.getAttributes()) {\n                    if (!rootElement.hasAttr(property.getKey()))\n                        rootElement.attributes().put(property);\n                }\n            }\n            break;\n        case EndTag:\n            Token.EndTag closingTag \u003d t.asEndTag();\n            elementName \u003d closingTag.name();\n            if (!elementName.equals(\"body\")) {\n                if (!elementName.equals(\"html\")) {\n                    if (!StringUtil.in(elementName, Constants.InBodyEndClosers)) {\n                        if (!elementName.equals(\"form\")) {\n                            if (!elementName.equals(\"p\")) {\n                                if (!elementName.equals(\"li\")) {\n                                    if (!StringUtil.in(elementName, Constants.DdDt)) {\n                                        if (!StringUtil.in(elementName, Constants.Headings)) {\n                                            if (!elementName.equals(\"sarcasm\")) {\n                                                if (!StringUtil.in(elementName, Constants.InBodyEndAdoptionFormatters)) {\n                                                    if (!StringUtil.in(elementName, Constants.InBodyStartApplets)) {\n                                                        if (!elementName.equals(\"br\")) {\n                                                            return anyOtherEndTag(t, tb);\n                                                        } else {\n                                                            tb.error(this);\n                                                            tb.process(new Token.StartTag(\"br\"));\n                                                            return false;\n                                                        }\n                                                    } else {\n                                                        if (!tb.inScope(\"name\")) {\n                                                            if (!tb.inScope(elementName)) {\n                                                                tb.error(this);\n                                                                return false;\n                                                            }\n                                                            tb.generateImpliedEndTags();\n                                                            if (!tb.currentElement().nodeName().equals(elementName))\n                                                                tb.error(this);\n                                                            tb.popStackToClose(elementName);\n                                                            tb.clearFormattingElementsToLastMarker();\n                                                        }\n                                                    }\n                                                } else {\n                                                    // Adoption Agency Algorithm.\n                                                    OUTER: for (int index \u003d 0; 8 \u003e index; index++) {\n                                                        Element formatElement \u003d tb.getActiveFormattingElement(elementName);\n                                                        if (null !\u003d formatElement) {\n                                                            if (tb.onStack(formatElement)) {\n                                                                if (tb.inScope(formatElement.nodeName())) {\n                                                                    if (formatElement !\u003d tb.currentElement())\n                                                                        tb.error(this);\n                                                                } else {\n                                                                    tb.error(this);\n                                                                    return false;\n                                                                }\n                                                            } else {\n                                                                tb.error(this);\n                                                                tb.removeFromActiveFormattingElements(formatElement);\n                                                                return true;\n                                                            }\n                                                        } else\n                                                            return anyOtherEndTag(t, tb);\n                                                        Element lastBlock \u003d null;\n                                                        Element nearestAncestor \u003d null;\n                                                        boolean seenFormattingElement \u003d false;\n                                                        LinkedList\u003cElement\u003e list \u003d tb.getStack();\n                                                        // the spec doesn\u0027t limit to \u003c 64, but in degenerate cases (9000+ stack depth) this prevents\n                                                        // run-aways\n                                                        final int maxStackDepth \u003d list.size();\n                                                        int si \u003d 0;\n                                                        while (maxStackDepth \u003e si \u0026\u0026 64 \u003e si) {\n                                                            Element el \u003d list.get(si);\n                                                            if (formatElement !\u003d el) {\n                                                                if (seenFormattingElement \u0026\u0026 tb.isSpecial(el)) {\n                                                                    lastBlock \u003d el;\n                                                                    break;\n                                                                }\n                                                            } else {\n                                                                nearestAncestor \u003d list.get(si - 1);\n                                                                seenFormattingElement \u003d true;\n                                                            }\n                                                            si +\u003d 1;\n                                                        }\n                                                        if (null \u003d\u003d lastBlock) {\n                                                            tb.popStackToClose(formatElement.nodeName());\n                                                            tb.removeFromActiveFormattingElements(formatElement);\n                                                            return true;\n                                                        }\n                                                        // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                                                        // does that mean: int pos of format el in list?\n                                                        Element node \u003d lastBlock;\n                                                        Element previousNode \u003d lastBlock;\n                                                        INNER: for (int j \u003d 0; 3 \u003e j; j++) {\n                                                            if (tb.onStack(node))\n                                                                node \u003d tb.aboveOnStack(node);\n                                                            if (tb.isInActiveFormattingElements(node)) {\n                                                                if (formatElement \u003d\u003d node)\n                                                                    break INNER;\n                                                            } else {\n                                                                // note no bookmark check\n                                                                tb.removeFromStack(node);\n                                                                continue INNER;\n                                                            }\n                                                            Element substitute \u003d new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                                            tb.replaceActiveFormattingElement(node, substitute);\n                                                            tb.replaceOnStack(node, substitute);\n                                                            node \u003d substitute;\n                                                            if (lastBlock \u003d\u003d previousNode) {\n                                                                // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                                                // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                                            }\n                                                            if (null !\u003d previousNode.parent())\n                                                                previousNode.remove();\n                                                            node.appendChild(previousNode);\n                                                            previousNode \u003d node;\n                                                        }\n                                                        if (!StringUtil.in(nearestAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                                            if (null !\u003d previousNode.parent())\n                                                                previousNode.remove();\n                                                            nearestAncestor.appendChild(previousNode);\n                                                        } else {\n                                                            if (null !\u003d previousNode.parent())\n                                                                previousNode.remove();\n                                                            tb.insertInFosterParent(previousNode);\n                                                        }\n                                                        Element container \u003d new Element(formatElement.tag(), tb.getBaseUri());\n                                                        container.attributes().addAll(formatElement.attributes());\n                                                        Node[] children \u003d lastBlock.childNodes().toArray(new Node[lastBlock.childNodeSize()]);\n                                                        for (Node siblingNode : children) {\n                                                            // append will reparent. thus the clone to avoid concurrent mod.\n                                                            container.appendChild(siblingNode);\n                                                        }\n                                                        lastBlock.appendChild(container);\n                                                        tb.removeFromActiveFormattingElements(formatElement);\n                                                        // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                                                        tb.removeFromStack(formatElement);\n                                                        tb.insertOnStackAfter(lastBlock, container);\n                                                    }\n                                                }\n                                            } else {\n                                                // *sigh*\n                                                return anyOtherEndTag(t, tb);\n                                            }\n                                        } else {\n                                            if (tb.inScope(Constants.Headings)) {\n                                                tb.generateImpliedEndTags(elementName);\n                                                if (!tb.currentElement().nodeName().equals(elementName))\n                                                    tb.error(this);\n                                                tb.popStackToClose(Constants.Headings);\n                                            } else {\n                                                tb.error(this);\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        if (tb.inScope(elementName)) {\n                                            tb.generateImpliedEndTags(elementName);\n                                            if (!tb.currentElement().nodeName().equals(elementName))\n                                                tb.error(this);\n                                            tb.popStackToClose(elementName);\n                                        } else {\n                                            tb.error(this);\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    if (tb.inListItemScope(elementName)) {\n                                        tb.generateImpliedEndTags(elementName);\n                                        if (!tb.currentElement().nodeName().equals(elementName))\n                                            tb.error(this);\n                                        tb.popStackToClose(elementName);\n                                    } else {\n                                        tb.error(this);\n                                        return false;\n                                    }\n                                }\n                            } else {\n                                if (tb.inButtonScope(elementName)) {\n                                    tb.generateImpliedEndTags(elementName);\n                                    if (!tb.currentElement().nodeName().equals(elementName))\n                                        tb.error(this);\n                                    tb.popStackToClose(elementName);\n                                } else {\n                                    tb.error(this);\n                                    // if no p to close, creates an empty \u003cp\u003e\u003c/p\u003e\n                                    tb.process(new Token.StartTag(elementName));\n                                    return tb.process(closingTag);\n                                }\n                            }\n                        } else {\n                            Element activeForm \u003d tb.getFormElement();\n                            tb.setFormElement(null);\n                            if (null !\u003d activeForm \u0026\u0026 tb.inScope(elementName)) {\n                                tb.generateImpliedEndTags();\n                                if (!tb.currentElement().nodeName().equals(elementName))\n                                    tb.error(this);\n                                // remove currentForm from stack. will shift anything under up.\n                                tb.removeFromStack(activeForm);\n                            } else {\n                                tb.error(this);\n                                return false;\n                            }\n                        }\n                    } else {\n                        if (tb.inScope(elementName)) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(elementName))\n                                tb.error(this);\n                            tb.popStackToClose(elementName);\n                        } else {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        }\n                    }\n                } else {\n                    boolean isProcessed \u003d tb.process(new Token.EndTag(\"body\"));\n                    if (isProcessed)\n                        return tb.process(closingTag);\n                }\n            } else {\n                if (tb.inScope(\"body\")) {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            }\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
  "Jsoup-37": "public String html() {\n    StringBuilder builder \u003d new StringBuilder();\n    html(builder);\n    return builder.toString().trim();\n}",
  "Jsoup-39": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String contentData;\n    Document document \u003d null;\n    if (null !\u003d charsetName) {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        contentData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    } else {\n        // determine from meta. safe parse as UTF-8\n        // look for \u003cmeta http-equiv\u003d\"Content-Type\" content\u003d\"text/html;charset\u003dgb2312\"\u003e or HTML5 \u003cmeta charset\u003d\"gb2312\"\u003e\n        contentData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        document \u003d parser.parseInput(contentData, baseUri);\n        Element header \u003d document.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (null !\u003d header) {\n            // if not found, will keep utf-8 as best attempt\n            String detectedCharset;\n            if (!header.hasAttr(\"http-equiv\")) {\n                detectedCharset \u003d header.attr(\"charset\");\n            } else {\n                detectedCharset \u003d getCharsetFromContentType(header.attr(\"content\"));\n                if (null \u003d\u003d detectedCharset \u0026\u0026 header.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(header.attr(\"charset\"))) {\n                            detectedCharset \u003d header.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        detectedCharset \u003d null;\n                    }\n                }\n            }\n            if (null !\u003d detectedCharset \u0026\u0026 0 !\u003d detectedCharset.length() \u0026\u0026 !detectedCharset.equals(defaultCharset)) {\n                // need to re-decode\n                detectedCharset \u003d detectedCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                charsetName \u003d detectedCharset;\n                byteData.rewind();\n                contentData \u003d Charset.forName(detectedCharset).decode(byteData).toString();\n                document \u003d null;\n            }\n        }\n    }\n    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n    if (0 \u003c contentData.length() \u0026\u0026 65279 \u003d\u003d contentData.charAt(0)) {\n        byteData.rewind();\n        contentData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        contentData \u003d contentData.substring(1);\n        charsetName \u003d defaultCharset;\n    }\n    if (null \u003d\u003d document) {\n        document \u003d parser.parseInput(contentData, baseUri);\n        document.outputSettings().charset(charsetName);\n    }\n    return document;\n}",
  "JacksonDatabind-101": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException {\n    // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n    //    value itself is NOT passed via `CreatorProperty` (which isn\u0027t supported).\n    //    Ok however to pass via setter or field.\n    final PropertyBasedCreator builder \u003d _propertyBasedCreator;\n    PropertyValueBuffer buffer \u003d builder.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer bufferedTokens \u003d new TokenBuffer(p, ctxt);\n    bufferedTokens.writeStartObject();\n    JsonToken jsonToken \u003d p.getCurrentToken();\n    while (JsonToken.FIELD_NAME \u003d\u003d jsonToken) {\n        String propertyName \u003d p.getCurrentName();\n        // to point to value\n        p.nextToken();\n        // creator property?\n        SettableBeanProperty creatorProperty \u003d builder.findCreatorProperty(propertyName);\n        if (null !\u003d creatorProperty) {\n            // Last creator property to set?\n            if (buffer.assignParameter(creatorProperty, _deserializeWithErrorWrapping(p, ctxt, creatorProperty))) {\n                // to move to following FIELD_NAME/END_OBJECT\n                jsonToken \u003d p.nextToken();\n                Object instance;\n                try {\n                    instance \u003d builder.build(ctxt, buffer);\n                } catch (Exception e) {\n                    instance \u003d wrapInstantiationProblem(e, ctxt);\n                }\n                // [databind#631]: Assign current value, to be accessible by custom serializers\n                p.setCurrentValue(instance);\n                // if so, need to copy all remaining tokens into buffer\n                while (JsonToken.FIELD_NAME \u003d\u003d jsonToken) {\n                    // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                    p.nextToken();\n                    bufferedTokens.copyCurrentStructure(p);\n                    jsonToken \u003d p.nextToken();\n                }\n                // 28-Aug-2018, tatu: Let\u0027s add sanity check here, easier to catch off-by-some\n                //    problems if we maintain invariants\n                bufferedTokens.writeEndObject();\n                if (_beanType.getRawClass() !\u003d instance.getClass()) {\n                    // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                    //   it\u0027s too complicated, so bail out\n                    ctxt.reportInputMismatch(creatorProperty, \"Cannot create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, instance, bufferedTokens);\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propertyName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty attribute \u003d _beanProperties.find(propertyName);\n        if (null !\u003d attribute) {\n            buffer.bufferProperty(attribute, _deserializeWithErrorWrapping(p, ctxt, attribute));\n            continue;\n        }\n        // Things marked as ignorable should not be passed to any setter\n        if (null !\u003d _ignorableProps \u0026\u0026 _ignorableProps.contains(propertyName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propertyName);\n            continue;\n        }\n        // 29-Nov-2016, tatu: probably should try to avoid sending content\n        //    both to any setter AND buffer... but, for now, the only thing\n        //    we can do.\n        // how about any setter? We\u0027ll get copies but...\n        if (null !\u003d _anySetter) {\n            // Need to copy to a separate buffer first\n            TokenBuffer bufferCopy \u003d TokenBuffer.asCopyOfValue(p);\n            bufferedTokens.writeFieldName(propertyName);\n            bufferedTokens.append(bufferCopy);\n            try {\n                buffer.bufferAnyProperty(_anySetter, propertyName, _anySetter.deserialize(bufferCopy.asParserOnFirstToken(), ctxt));\n            } catch (Exception e) {\n                wrapAndThrow(e, _beanType.getRawClass(), propertyName, ctxt);\n            }\n            continue;\n        } else {\n            // but... others should be passed to unwrapped property deserializers\n            bufferedTokens.writeFieldName(propertyName);\n            bufferedTokens.copyCurrentStructure(p);\n        }\n        jsonToken \u003d p.nextToken();\n    }\n    // We hit END_OBJECT, so:\n    Object instance;\n    try {\n        instance \u003d builder.build(ctxt, buffer);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        // never gets here\n        return null;\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, instance, bufferedTokens);\n}",
  "JacksonDatabind-100": "public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n    // Multiple possibilities...\n    JsonNode jsonNode \u003d currentNode();\n    if (null !\u003d jsonNode) {\n        // [databind#2096]: although `binaryValue()` works for real binary node\n        // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n        byte[] data \u003d jsonNode.binaryValue();\n        if (null !\u003d data) {\n            return data;\n        }\n        if (jsonNode.isPojo()) {\n            Object obj \u003d ((POJONode) jsonNode).getPojo();\n            if (obj instanceof byte[]) {\n                return (byte[]) obj;\n            }\n        }\n    }\n    // otherwise return null to mark we have no binary content\n    return null;\n}",
  "Jsoup-32": "public Element clone() {\n    Element duplicate \u003d (Element) super.clone();\n    duplicate.classNames();\n    return duplicate;\n}",
  "Jsoup-34": "int nextIndexOf(CharSequence seq) {\n    // doesn\u0027t handle scanning for surrogates\n    char initialChar \u003d seq.charAt(0);\n    int indexOffset \u003d pos;\n    while (length \u003e indexOffset) {\n        // scan to first instance of startchar:\n        if (input[indexOffset] !\u003d initialChar)\n            while (length \u003e ++indexOffset \u0026\u0026 input[indexOffset] !\u003d initialChar) ;\n        int index \u003d indexOffset + 1;\n        int finalIndex \u003d index + seq.length() - 1;\n        if (length \u003e indexOffset) {\n            int j \u003d 1;\n            while (finalIndex \u003e index \u0026\u0026 input[index] \u003d\u003d seq.charAt(j)) {\n                ;\n                index +\u003d 1;\n                j +\u003d 1;\n            }\n            if (// found full sequence\n            finalIndex \u003d\u003d index)\n                return indexOffset - pos;\n        }\n        indexOffset +\u003d 1;\n    }\n    return -1;\n}",
  "Jsoup-33": "Element insert(Token.StartTag startTag) {\n    // handle empty unknown tags\n    // when the spec expects an empty tag, will directly hit insertEmpty, so won\u0027t generate this fake end tag.\n    if (startTag.isSelfClosing()) {\n        Element element \u003d insertEmpty(startTag);\n        stack.add(element);\n        // ensure we get out of whatever state we are in. emitted for yielded processing\n        tokeniser.emit(new Token.EndTag(element.tagName()));\n        return element;\n    }\n    Element element \u003d new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n    insert(element);\n    return element;\n}",
  "Jsoup-35": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch(t.type) {\n        case Character:\n            {\n                Token.Character characterToken \u003d t.asCharacter();\n                if (!characterToken.getData().equals(nullString)) {\n                    if (!isWhitespace(characterToken)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(characterToken);\n                        tb.framesetOk(false);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(characterToken);\n                    }\n                } else {\n                    // todo confirm that check\n                    tb.error(this);\n                    return false;\n                }\n                break;\n            }\n        case Comment:\n            {\n                tb.insert(t.asComment());\n                break;\n            }\n        case Doctype:\n            {\n                tb.error(this);\n                return false;\n            }\n        case StartTag:\n            Token.StartTag openingTag \u003d t.asStartTag();\n            String tagName \u003d openingTag.name();\n            if (!tagName.equals(\"html\")) {\n                if (!StringUtil.in(tagName, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    if (!tagName.equals(\"body\")) {\n                        if (!tagName.equals(\"frameset\")) {\n                            if (!StringUtil.in(tagName, \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\")) {\n                                if (!StringUtil.in(tagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                                    if (!StringUtil.in(tagName, \"pre\", \"listing\")) {\n                                        if (!tagName.equals(\"form\")) {\n                                            if (!tagName.equals(\"li\")) {\n                                                if (!StringUtil.in(tagName, \"dd\", \"dt\")) {\n                                                    if (!tagName.equals(\"plaintext\")) {\n                                                        if (!tagName.equals(\"button\")) {\n                                                            if (!tagName.equals(\"a\")) {\n                                                                if (!StringUtil.in(tagName, \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                                                                    if (!tagName.equals(\"nobr\")) {\n                                                                        if (!StringUtil.in(tagName, \"applet\", \"marquee\", \"object\")) {\n                                                                            if (!tagName.equals(\"table\")) {\n                                                                                if (!StringUtil.in(tagName, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                                                                                    if (!tagName.equals(\"input\")) {\n                                                                                        if (!StringUtil.in(tagName, \"param\", \"source\", \"track\")) {\n                                                                                            if (!tagName.equals(\"hr\")) {\n                                                                                                if (!tagName.equals(\"image\")) {\n                                                                                                    if (!tagName.equals(\"isindex\")) {\n                                                                                                        if (!tagName.equals(\"textarea\")) {\n                                                                                                            if (!tagName.equals(\"xmp\")) {\n                                                                                                                if (!tagName.equals(\"iframe\")) {\n                                                                                                                    if (!tagName.equals(\"noembed\")) {\n                                                                                                                        if (!tagName.equals(\"select\")) {\n                                                                                                                            if (!StringUtil.in(\"optgroup\", \"option\")) {\n                                                                                                                                if (!StringUtil.in(\"rp\", \"rt\")) {\n                                                                                                                                    if (!tagName.equals(\"math\")) {\n                                                                                                                                        if (!tagName.equals(\"svg\")) {\n                                                                                                                                            if (!StringUtil.in(tagName, \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                                tb.insert(openingTag);\n                                                                                                                                            } else {\n                                                                                                                                                tb.error(this);\n                                                                                                                                                return false;\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                                            // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                                                                                                                                            tb.insert(openingTag);\n                                                                                                                                            tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        tb.reconstructFormattingElements();\n                                                                                                                                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                                                                                                                                        tb.insert(openingTag);\n                                                                                                                                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    if (tb.inScope(\"ruby\")) {\n                                                                                                                                        tb.generateImpliedEndTags();\n                                                                                                                                        if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                                                                                                                            tb.error(this);\n                                                                                                                                            // i.e. close up to but not include name\n                                                                                                                                            tb.popStackToBefore(\"ruby\");\n                                                                                                                                        }\n                                                                                                                                        tb.insert(openingTag);\n                                                                                                                                    }\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                if (tb.currentElement().nodeName().equals(\"option\"))\n                                                                                                                                    tb.process(new Token.EndTag(\"option\"));\n                                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                                tb.insert(openingTag);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            tb.reconstructFormattingElements();\n                                                                                                                            tb.insert(openingTag);\n                                                                                                                            tb.framesetOk(false);\n                                                                                                                            HtmlTreeBuilderState context \u003d tb.state();\n                                                                                                                            if (context.equals(InTable) || context.equals(InCaption) || context.equals(InTableBody) || context.equals(InRow) || context.equals(InCell))\n                                                                                                                                tb.transition(InSelectInTable);\n                                                                                                                            else\n                                                                                                                                tb.transition(InSelect);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        // also handle noscript if script enabled\n                                                                                                                        handleRawtext(openingTag, tb);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    tb.framesetOk(false);\n                                                                                                                    handleRawtext(openingTag, tb);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                if (tb.inButtonScope(\"p\")) {\n                                                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                                                }\n                                                                                                                tb.reconstructFormattingElements();\n                                                                                                                tb.framesetOk(false);\n                                                                                                                handleRawtext(openingTag, tb);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            tb.insert(openingTag);\n                                                                                                            // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                                                                                                            tb.tokeniser.transition(TokeniserState.Rcdata);\n                                                                                                            tb.markInsertionMode();\n                                                                                                            tb.framesetOk(false);\n                                                                                                            tb.transition(Text);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        // how much do we care about the early 90s?\n                                                                                                        tb.error(this);\n                                                                                                        if (null !\u003d tb.getFormElement())\n                                                                                                            return false;\n                                                                                                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                                                                                                        tb.process(new Token.StartTag(\"form\"));\n                                                                                                        if (openingTag.attributes.hasKey(\"action\")) {\n                                                                                                            Element formElement \u003d tb.getFormElement();\n                                                                                                            formElement.attr(\"action\", openingTag.attributes.get(\"action\"));\n                                                                                                        }\n                                                                                                        tb.process(new Token.StartTag(\"hr\"));\n                                                                                                        tb.process(new Token.StartTag(\"label\"));\n                                                                                                        // hope you like english.\n                                                                                                        String message \u003d openingTag.attributes.hasKey(\"prompt\") ? openingTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \";\n                                                                                                        tb.process(new Token.Character(message));\n                                                                                                        // input\n                                                                                                        Attributes inputAttributes \u003d new Attributes();\n                                                                                                        for (Attribute attr : openingTag.attributes) {\n                                                                                                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                                                                                                inputAttributes.put(attr);\n                                                                                                        }\n                                                                                                        inputAttributes.put(\"name\", \"isindex\");\n                                                                                                        tb.process(new Token.StartTag(\"input\", inputAttributes));\n                                                                                                        tb.process(new Token.EndTag(\"label\"));\n                                                                                                        tb.process(new Token.StartTag(\"hr\"));\n                                                                                                        tb.process(new Token.EndTag(\"form\"));\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    // we\u0027re not supposed to ask.\n                                                                                                    openingTag.name(\"img\");\n                                                                                                    return tb.process(openingTag);\n                                                                                                }\n                                                                                            } else {\n                                                                                                if (tb.inButtonScope(\"p\")) {\n                                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                                }\n                                                                                                tb.insertEmpty(openingTag);\n                                                                                                tb.framesetOk(false);\n                                                                                            }\n                                                                                        } else {\n                                                                                            tb.insertEmpty(openingTag);\n                                                                                        }\n                                                                                    } else {\n                                                                                        tb.reconstructFormattingElements();\n                                                                                        Element currentElement \u003d tb.insertEmpty(openingTag);\n                                                                                        if (!currentElement.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                                                                                            tb.framesetOk(false);\n                                                                                    }\n                                                                                } else {\n                                                                                    tb.reconstructFormattingElements();\n                                                                                    tb.insertEmpty(openingTag);\n                                                                                    tb.framesetOk(false);\n                                                                                }\n                                                                            } else {\n                                                                                if (Document.QuirksMode.quirks !\u003d tb.getDocument().quirksMode() \u0026\u0026 tb.inButtonScope(\"p\")) {\n                                                                                    tb.process(new Token.EndTag(\"p\"));\n                                                                                }\n                                                                                tb.insert(openingTag);\n                                                                                tb.framesetOk(false);\n                                                                                tb.transition(InTable);\n                                                                            }\n                                                                        } else {\n                                                                            tb.reconstructFormattingElements();\n                                                                            tb.insert(openingTag);\n                                                                            tb.insertMarkerToFormattingElements();\n                                                                            tb.framesetOk(false);\n                                                                        }\n                                                                    } else {\n                                                                        tb.reconstructFormattingElements();\n                                                                        if (tb.inScope(\"nobr\")) {\n                                                                            tb.error(this);\n                                                                            tb.process(new Token.EndTag(\"nobr\"));\n                                                                            tb.reconstructFormattingElements();\n                                                                        }\n                                                                        Element currentElement \u003d tb.insert(openingTag);\n                                                                        tb.pushActiveFormattingElements(currentElement);\n                                                                    }\n                                                                } else {\n                                                                    tb.reconstructFormattingElements();\n                                                                    Element currentElement \u003d tb.insert(openingTag);\n                                                                    tb.pushActiveFormattingElements(currentElement);\n                                                                }\n                                                            } else {\n                                                                if (null !\u003d tb.getActiveFormattingElement(\"a\")) {\n                                                                    tb.error(this);\n                                                                    tb.process(new Token.EndTag(\"a\"));\n                                                                    // still on stack?\n                                                                    Element activeAnchor \u003d tb.getFromStack(\"a\");\n                                                                    if (null !\u003d activeAnchor) {\n                                                                        tb.removeFromActiveFormattingElements(activeAnchor);\n                                                                        tb.removeFromStack(activeAnchor);\n                                                                    }\n                                                                }\n                                                                tb.reconstructFormattingElements();\n                                                                Element link \u003d tb.insert(openingTag);\n                                                                tb.pushActiveFormattingElements(link);\n                                                            }\n                                                        } else {\n                                                            if (!tb.inButtonScope(\"button\")) {\n                                                                tb.reconstructFormattingElements();\n                                                                tb.insert(openingTag);\n                                                                tb.framesetOk(false);\n                                                            } else {\n                                                                // close and reprocess\n                                                                tb.error(this);\n                                                                tb.process(new Token.EndTag(\"button\"));\n                                                                tb.process(openingTag);\n                                                            }\n                                                        }\n                                                    } else {\n                                                        if (tb.inButtonScope(\"p\")) {\n                                                            tb.process(new Token.EndTag(\"p\"));\n                                                        }\n                                                        tb.insert(openingTag);\n                                                        // once in, never gets out\n                                                        tb.tokeniser.transition(TokeniserState.PLAINTEXT);\n                                                    }\n                                                } else {\n                                                    tb.framesetOk(false);\n                                                    LinkedList\u003cElement\u003e elementsStack \u003d tb.getStack();\n                                                    int index \u003d elementsStack.size() - 1;\n                                                    while (0 \u003c index) {\n                                                        Element currentElement \u003d elementsStack.get(index);\n                                                        if (StringUtil.in(currentElement.nodeName(), \"dd\", \"dt\")) {\n                                                            tb.process(new Token.EndTag(currentElement.nodeName()));\n                                                            break;\n                                                        }\n                                                        if (tb.isSpecial(currentElement) \u0026\u0026 !StringUtil.in(currentElement.nodeName(), \"address\", \"div\", \"p\"))\n                                                            break;\n                                                        index -\u003d 1;\n                                                    }\n                                                    if (tb.inButtonScope(\"p\")) {\n                                                        tb.process(new Token.EndTag(\"p\"));\n                                                    }\n                                                    tb.insert(openingTag);\n                                                }\n                                            } else {\n                                                tb.framesetOk(false);\n                                                LinkedList\u003cElement\u003e elementsStack \u003d tb.getStack();\n                                                int index \u003d elementsStack.size() - 1;\n                                                while (0 \u003c index) {\n                                                    Element currentElement \u003d elementsStack.get(index);\n                                                    if (currentElement.nodeName().equals(\"li\")) {\n                                                        tb.process(new Token.EndTag(\"li\"));\n                                                        break;\n                                                    }\n                                                    if (tb.isSpecial(currentElement) \u0026\u0026 !StringUtil.in(currentElement.nodeName(), \"address\", \"div\", \"p\"))\n                                                        break;\n                                                    index -\u003d 1;\n                                                }\n                                                if (tb.inButtonScope(\"p\")) {\n                                                    tb.process(new Token.EndTag(\"p\"));\n                                                }\n                                                tb.insert(openingTag);\n                                            }\n                                        } else {\n                                            if (null !\u003d tb.getFormElement()) {\n                                                tb.error(this);\n                                                return false;\n                                            }\n                                            if (tb.inButtonScope(\"p\")) {\n                                                tb.process(new Token.EndTag(\"p\"));\n                                            }\n                                            tb.insertForm(openingTag, true);\n                                        }\n                                    } else {\n                                        if (tb.inButtonScope(\"p\")) {\n                                            tb.process(new Token.EndTag(\"p\"));\n                                        }\n                                        tb.insert(openingTag);\n                                        // todo: ignore LF if next token\n                                        tb.framesetOk(false);\n                                    }\n                                } else {\n                                    if (tb.inButtonScope(\"p\")) {\n                                        tb.process(new Token.EndTag(\"p\"));\n                                    }\n                                    if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                                        tb.error(this);\n                                        tb.pop();\n                                    }\n                                    tb.insert(openingTag);\n                                }\n                            } else {\n                                if (tb.inButtonScope(\"p\")) {\n                                    tb.process(new Token.EndTag(\"p\"));\n                                }\n                                tb.insert(openingTag);\n                            }\n                        } else {\n                            tb.error(this);\n                            LinkedList\u003cElement\u003e elementsStack \u003d tb.getStack();\n                            if (1 !\u003d elementsStack.size() \u0026\u0026 !((2 \u003c elementsStack.size() \u0026\u0026 !elementsStack.get(1).nodeName().equals(\"body\")))) {\n                                if (tb.framesetOk()) {\n                                    Element element \u003d elementsStack.get(1);\n                                    if (null !\u003d element.parent())\n                                        element.remove();\n                                    // pop up to html element\n                                    while (1 \u003c elementsStack.size()) elementsStack.removeLast();\n                                    tb.insert(openingTag);\n                                    tb.transition(InFrameset);\n                                } else {\n                                    // ignore frameset\n                                    return false;\n                                }\n                            } else {\n                                // only in fragment case\n                                // ignore\n                                return false;\n                            }\n                        }\n                    } else {\n                        tb.error(this);\n                        LinkedList\u003cElement\u003e elementsStack \u003d tb.getStack();\n                        if (1 !\u003d elementsStack.size() \u0026\u0026 !((2 \u003c elementsStack.size() \u0026\u0026 !elementsStack.get(1).nodeName().equals(\"body\")))) {\n                            tb.framesetOk(false);\n                            Element mainContent \u003d elementsStack.get(1);\n                            for (Attribute property : openingTag.getAttributes()) {\n                                if (!mainContent.hasAttr(property.getKey()))\n                                    mainContent.attributes().put(property);\n                            }\n                        } else {\n                            // only in fragment case\n                            // ignore\n                            return false;\n                        }\n                    }\n                } else {\n                    return tb.process(t, InHead);\n                }\n            } else {\n                tb.error(this);\n                // merge attributes onto real html\n                Element rootElement \u003d tb.getStack().getFirst();\n                for (Attribute property : openingTag.getAttributes()) {\n                    if (!rootElement.hasAttr(property.getKey()))\n                        rootElement.attributes().put(property);\n                }\n            }\n            break;\n        case EndTag:\n            Token.EndTag closingTag \u003d t.asEndTag();\n            tagName \u003d closingTag.name();\n            if (!tagName.equals(\"body\")) {\n                if (!tagName.equals(\"html\")) {\n                    if (!StringUtil.in(tagName, \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        if (!tagName.equals(\"form\")) {\n                            if (!tagName.equals(\"p\")) {\n                                if (!tagName.equals(\"li\")) {\n                                    if (!StringUtil.in(tagName, \"dd\", \"dt\")) {\n                                        if (!StringUtil.in(tagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                                            if (!tagName.equals(\"sarcasm\")) {\n                                                if (!StringUtil.in(tagName, \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                                                    if (!StringUtil.in(tagName, \"applet\", \"marquee\", \"object\")) {\n                                                        if (!tagName.equals(\"br\")) {\n                                                            return anyOtherEndTag(t, tb);\n                                                        } else {\n                                                            tb.error(this);\n                                                            tb.process(new Token.StartTag(\"br\"));\n                                                            return false;\n                                                        }\n                                                    } else {\n                                                        if (!tb.inScope(\"name\")) {\n                                                            if (!tb.inScope(tagName)) {\n                                                                tb.error(this);\n                                                                return false;\n                                                            }\n                                                            tb.generateImpliedEndTags();\n                                                            if (!tb.currentElement().nodeName().equals(tagName))\n                                                                tb.error(this);\n                                                            tb.popStackToClose(tagName);\n                                                            tb.clearFormattingElementsToLastMarker();\n                                                        }\n                                                    }\n                                                } else {\n                                                    // Adoption Agency Algorithm.\n                                                    OUTER: for (int index \u003d 0; 8 \u003e index; index++) {\n                                                        Element formatElement \u003d tb.getActiveFormattingElement(tagName);\n                                                        if (null !\u003d formatElement) {\n                                                            if (tb.onStack(formatElement)) {\n                                                                if (tb.inScope(formatElement.nodeName())) {\n                                                                    if (formatElement !\u003d tb.currentElement())\n                                                                        tb.error(this);\n                                                                } else {\n                                                                    tb.error(this);\n                                                                    return false;\n                                                                }\n                                                            } else {\n                                                                tb.error(this);\n                                                                tb.removeFromActiveFormattingElements(formatElement);\n                                                                return true;\n                                                            }\n                                                        } else\n                                                            return anyOtherEndTag(t, tb);\n                                                        Element farthestBlock \u003d null;\n                                                        Element closestAncestor \u003d null;\n                                                        boolean seenFormattingElement \u003d false;\n                                                        LinkedList\u003cElement\u003e elementsStack \u003d tb.getStack();\n                                                        int si \u003d 0;\n                                                        while (elementsStack.size() \u003e si \u0026\u0026 64 \u003e si) {\n                                                            Element currentElement \u003d elementsStack.get(si);\n                                                            if (formatElement !\u003d currentElement) {\n                                                                if (seenFormattingElement \u0026\u0026 tb.isSpecial(currentElement)) {\n                                                                    farthestBlock \u003d currentElement;\n                                                                    break;\n                                                                }\n                                                            } else {\n                                                                closestAncestor \u003d elementsStack.get(si - 1);\n                                                                seenFormattingElement \u003d true;\n                                                            }\n                                                            si +\u003d 1;\n                                                        }\n                                                        // the spec doesn\u0027t limit to \u003c 64, but in degenerate cases (9000+ stack depth) this prevents\n                                                        if (null \u003d\u003d farthestBlock) {\n                                                            tb.popStackToClose(formatElement.nodeName());\n                                                            tb.removeFromActiveFormattingElements(formatElement);\n                                                            return true;\n                                                        }\n                                                        // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                                                        // does that mean: int pos of format el in list?\n                                                        Element node \u003d farthestBlock;\n                                                        Element previousNode \u003d farthestBlock;\n                                                        INNER: for (int j \u003d 0; 3 \u003e j; j++) {\n                                                            if (tb.onStack(node))\n                                                                node \u003d tb.aboveOnStack(node);\n                                                            if (tb.isInActiveFormattingElements(node)) {\n                                                                if (formatElement \u003d\u003d node)\n                                                                    break INNER;\n                                                            } else {\n                                                                // note no bookmark check\n                                                                tb.removeFromStack(node);\n                                                                continue INNER;\n                                                            }\n                                                            Element substitute \u003d new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                                            tb.replaceActiveFormattingElement(node, substitute);\n                                                            tb.replaceOnStack(node, substitute);\n                                                            node \u003d substitute;\n                                                            if (farthestBlock \u003d\u003d previousNode) {\n                                                                // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                                                // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                                            }\n                                                            if (null !\u003d previousNode.parent())\n                                                                previousNode.remove();\n                                                            node.appendChild(previousNode);\n                                                            previousNode \u003d node;\n                                                        }\n                                                        if (!StringUtil.in(closestAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                                            if (null !\u003d previousNode.parent())\n                                                                previousNode.remove();\n                                                            closestAncestor.appendChild(previousNode);\n                                                        } else {\n                                                            if (null !\u003d previousNode.parent())\n                                                                previousNode.remove();\n                                                            tb.insertInFosterParent(previousNode);\n                                                        }\n                                                        Element container \u003d new Element(formatElement.tag(), tb.getBaseUri());\n                                                        Node[] descendantNodes \u003d farthestBlock.childNodes().toArray(new Node[farthestBlock.childNodeSize()]);\n                                                        for (Node subNode : descendantNodes) {\n                                                            // append will reparent. thus the clone to avoid concurrent mod.\n                                                            container.appendChild(subNode);\n                                                        }\n                                                        farthestBlock.appendChild(container);\n                                                        tb.removeFromActiveFormattingElements(formatElement);\n                                                        // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                                                        tb.removeFromStack(formatElement);\n                                                        tb.insertOnStackAfter(farthestBlock, container);\n                                                    }\n                                                }\n                                            } else {\n                                                // *sigh*\n                                                return anyOtherEndTag(t, tb);\n                                            }\n                                        } else {\n                                            if (tb.inScope(new String[] { \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\" })) {\n                                                tb.generateImpliedEndTags(tagName);\n                                                if (!tb.currentElement().nodeName().equals(tagName))\n                                                    tb.error(this);\n                                                tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                                            } else {\n                                                tb.error(this);\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        if (tb.inScope(tagName)) {\n                                            tb.generateImpliedEndTags(tagName);\n                                            if (!tb.currentElement().nodeName().equals(tagName))\n                                                tb.error(this);\n                                            tb.popStackToClose(tagName);\n                                        } else {\n                                            tb.error(this);\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    if (tb.inListItemScope(tagName)) {\n                                        tb.generateImpliedEndTags(tagName);\n                                        if (!tb.currentElement().nodeName().equals(tagName))\n                                            tb.error(this);\n                                        tb.popStackToClose(tagName);\n                                    } else {\n                                        tb.error(this);\n                                        return false;\n                                    }\n                                }\n                            } else {\n                                if (tb.inButtonScope(tagName)) {\n                                    tb.generateImpliedEndTags(tagName);\n                                    if (!tb.currentElement().nodeName().equals(tagName))\n                                        tb.error(this);\n                                    tb.popStackToClose(tagName);\n                                } else {\n                                    tb.error(this);\n                                    // if no p to close, creates an empty \u003cp\u003e\u003c/p\u003e\n                                    tb.process(new Token.StartTag(tagName));\n                                    return tb.process(closingTag);\n                                }\n                            }\n                        } else {\n                            Element activeForm \u003d tb.getFormElement();\n                            tb.setFormElement(null);\n                            if (null !\u003d activeForm \u0026\u0026 tb.inScope(tagName)) {\n                                tb.generateImpliedEndTags();\n                                if (!tb.currentElement().nodeName().equals(tagName))\n                                    tb.error(this);\n                                // remove currentForm from stack. will shift anything under up.\n                                tb.removeFromStack(activeForm);\n                            } else {\n                                tb.error(this);\n                                return false;\n                            }\n                        }\n                    } else {\n                        // todo: refactor these lookups\n                        if (tb.inScope(tagName)) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(tagName))\n                                tb.error(this);\n                            tb.popStackToClose(tagName);\n                        } else {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        }\n                    }\n                } else {\n                    boolean isNotIgnored \u003d tb.process(new Token.EndTag(\"body\"));\n                    if (isNotIgnored)\n                        return tb.process(closingTag);\n                }\n            } else {\n                if (tb.inScope(\"body\")) {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            }\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
  "Mockito-2": "public Timer(long durationMillis) {\n    this.durationMillis \u003d durationMillis;\n}",
  "Mockito-1": "public void captureArgumentsFrom(Invocation invocation) {\n    if (!invocation.getMethod().isVarArgs()) {\n        int index \u003d 0;\n        while (matchers.size() \u003e index) {\n            Matcher matcher \u003d matchers.get(index);\n            if (matcher instanceof CapturesArguments) {\n                ((CapturesArguments) matcher).captureFrom(invocation.getArgumentAt(index, Object.class));\n            }\n            index +\u003d 1;\n        }\n    } else {\n        int lastVarargIndex \u003d invocation.getRawArguments().length - 1;\n        throw new UnsupportedOperationException();\n    }\n    for (int index \u003d 0; matchers.size() \u003e index; index++) {\n        Matcher matcher \u003d matchers.get(index);\n        if (matcher instanceof CapturesArguments \u0026\u0026 index \u003c invocation.getRawArguments().length) {\n            //TODO SF - this whole lot can be moved captureFrom implementation\n            if (!isVariableArgument(invocation, index) || !isVarargMatcher(matcher)) {\n                ((CapturesArguments) matcher).captureFrom(invocation.getRawArguments()[index]);\n            } else {\n                Object argsArray \u003d invocation.getRawArguments()[index];\n                int elementIndex \u003d 0;\n                while (Array.getLength(argsArray) \u003e elementIndex) {\n                    ((CapturesArguments) matcher).captureFrom(Array.get(argsArray, elementIndex));\n                    elementIndex +\u003d 1;\n                }\n                //since we\u0027ve captured all varargs already, it does not make sense to process other matchers.\n                return;\n            }\n        }\n    }\n}",
  "Gson-15": "public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n}",
  "Gson-16": "private static Type resolve(Type context, Class\u003c?\u003e contextRawType, Type toResolve, Collection\u003cTypeVariable\u003e visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n        if (!(toResolve instanceof TypeVariable)) {\n            if (!(toResolve instanceof Class) || !((Class\u003c?\u003e) toResolve).isArray()) {\n                if (!(toResolve instanceof GenericArrayType)) {\n                    if (!(toResolve instanceof ParameterizedType)) {\n                        if (!(toResolve instanceof WildcardType)) {\n                            return toResolve;\n                        } else {\n                            WildcardType base \u003d (WildcardType) toResolve;\n                            Type[] lowerBounds \u003d base.getLowerBounds();\n                            Type[] originalTypeUpperBound \u003d base.getUpperBounds();\n                            if (1 !\u003d lowerBounds.length) {\n                                if (1 \u003d\u003d originalTypeUpperBound.length) {\n                                    Type boundType \u003d resolve(context, contextRawType, originalTypeUpperBound[0], visitedTypeVariables);\n                                    if (originalTypeUpperBound[0] !\u003d boundType) {\n                                        return subtypeOf(boundType);\n                                    }\n                                }\n                            } else {\n                                Type lowerBoundType \u003d resolve(context, contextRawType, lowerBounds[0], visitedTypeVariables);\n                                if (lowerBounds[0] !\u003d lowerBoundType) {\n                                    return supertypeOf(lowerBoundType);\n                                }\n                            }\n                            return base;\n                        }\n                    } else {\n                        ParameterizedType base \u003d (ParameterizedType) toResolve;\n                        Type parentType \u003d base.getOwnerType();\n                        Type newTypeOwner \u003d resolve(context, contextRawType, parentType, visitedTypeVariables);\n                        boolean modified \u003d parentType !\u003d newTypeOwner;\n                        Type[] typeArguments \u003d base.getActualTypeArguments();\n                        int index \u003d 0, count \u003d typeArguments.length;\n                        while (count \u003e index) {\n                            Type resolvedArgumentType \u003d resolve(context, contextRawType, typeArguments[index], visitedTypeVariables);\n                            if (typeArguments[index] !\u003d resolvedArgumentType) {\n                                if (!modified) {\n                                    typeArguments \u003d typeArguments.clone();\n                                    modified \u003d true;\n                                }\n                                typeArguments[index] \u003d resolvedArgumentType;\n                            }\n                            index +\u003d 1;\n                        }\n                        return modified ? newParameterizedTypeWithOwner(newTypeOwner, base.getRawType(), typeArguments) : base;\n                    }\n                } else {\n                    GenericArrayType base \u003d (GenericArrayType) toResolve;\n                    Type elementType \u003d base.getGenericComponentType();\n                    Type resolvedComponentType \u003d resolve(context, contextRawType, elementType, visitedTypeVariables);\n                    return resolvedComponentType \u003d\u003d elementType ? base : arrayOf(resolvedComponentType);\n                }\n            } else {\n                Class\u003c?\u003e base \u003d (Class\u003c?\u003e) toResolve;\n                Type elementType \u003d base.getComponentType();\n                Type resolvedComponentType \u003d resolve(context, contextRawType, elementType, visitedTypeVariables);\n                return resolvedComponentType \u003d\u003d elementType ? base : arrayOf(resolvedComponentType);\n            }\n        } else {\n            TypeVariable\u003c?\u003e typeParam \u003d (TypeVariable\u003c?\u003e) toResolve;\n            // cannot reduce due to infinite recursion\n            toResolve \u003d resolveTypeVariable(context, contextRawType, typeParam);\n            if (typeParam \u003d\u003d toResolve) {\n                return toResolve;\n            }\n        }\n    }\n}",
  "Gson-13": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\n    char[] array \u003d this.buffer;\n    int index \u003d pos;\n    int length \u003d limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long numberValue \u003d 0;\n    boolean isNegative \u003d false;\n    boolean canFitInLong \u003d true;\n    int previousCharacter \u003d NUMBER_CHAR_NONE;\n    int i \u003d 0;\n    charactersOfNumber: for (; true; i++) {\n        if (length \u003d\u003d index + i) {\n            if (array.length \u003d\u003d i) {\n                // Though this looks like a well-formed number, it\u0027s too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            index \u003d pos;\n            length \u003d limit;\n        }\n        char character \u003d array[index + i];\n        switch(character) {\n            case \u0027-\u0027:\n                if (NUMBER_CHAR_NONE !\u003d previousCharacter) {\n                    if (NUMBER_CHAR_EXP_E \u003d\u003d previousCharacter) {\n                        previousCharacter \u003d NUMBER_CHAR_EXP_SIGN;\n                        continue;\n                    }\n                } else {\n                    isNegative \u003d true;\n                    previousCharacter \u003d NUMBER_CHAR_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case \u0027+\u0027:\n                if (NUMBER_CHAR_EXP_E \u003d\u003d previousCharacter) {\n                    previousCharacter \u003d NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case \u0027e\u0027:\n            case \u0027E\u0027:\n                if (NUMBER_CHAR_DIGIT \u003d\u003d previousCharacter || NUMBER_CHAR_FRACTION_DIGIT \u003d\u003d previousCharacter) {\n                    previousCharacter \u003d NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case \u0027.\u0027:\n                if (NUMBER_CHAR_DIGIT \u003d\u003d previousCharacter) {\n                    previousCharacter \u003d NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (\u00270\u0027 \u003e character || \u00279\u0027 \u003c character) {\n                    if (!isLiteral(character)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (NUMBER_CHAR_SIGN !\u003d previousCharacter \u0026\u0026 NUMBER_CHAR_NONE !\u003d previousCharacter) {\n                    if (NUMBER_CHAR_DIGIT !\u003d previousCharacter) {\n                        if (NUMBER_CHAR_DECIMAL !\u003d previousCharacter) {\n                            if (NUMBER_CHAR_EXP_E \u003d\u003d previousCharacter || NUMBER_CHAR_EXP_SIGN \u003d\u003d previousCharacter) {\n                                previousCharacter \u003d NUMBER_CHAR_EXP_DIGIT;\n                            }\n                        } else {\n                            previousCharacter \u003d NUMBER_CHAR_FRACTION_DIGIT;\n                        }\n                    } else {\n                        if (0 \u003d\u003d numberValue) {\n                            // Leading \u00270\u0027 prefix is not allowed (since it could be octal).\n                            return PEEKED_NONE;\n                        }\n                        long updatedValue \u003d numberValue * 10 - (character - \u00270\u0027);\n                        canFitInLong \u0026\u003d MIN_INCOMPLETE_INTEGER \u003c numberValue || (MIN_INCOMPLETE_INTEGER \u003d\u003d numberValue \u0026\u0026 numberValue \u003e updatedValue);\n                        numberValue \u003d updatedValue;\n                    }\n                } else {\n                    numberValue \u003d -(character - \u00270\u0027);\n                    previousCharacter \u003d NUMBER_CHAR_DIGIT;\n                }\n        }\n    }\n    // We\u0027ve read a complete number. Decide if it\u0027s a PEEKED_LONG or a PEEKED_NUMBER.\n    if (NUMBER_CHAR_DIGIT !\u003d previousCharacter || !canFitInLong || !((Long.MIN_VALUE !\u003d numberValue || isNegative))) {\n        if (NUMBER_CHAR_DIGIT !\u003d previousCharacter \u0026\u0026 NUMBER_CHAR_FRACTION_DIGIT !\u003d previousCharacter \u0026\u0026 NUMBER_CHAR_EXP_DIGIT !\u003d previousCharacter) {\n            return PEEKED_NONE;\n        } else {\n            peekedNumberLength \u003d i;\n            return peeked \u003d PEEKED_NUMBER;\n        }\n    } else {\n        peekedLong \u003d isNegative ? numberValue : -numberValue;\n        pos +\u003d i;\n        return peeked \u003d PEEKED_LONG;\n    }\n}",
  "Gson-11": "public Number read(JsonReader in) throws IOException {\n    JsonToken token \u003d in.peek();\n    switch(token) {\n        case NULL:\n            in.nextNull();\n            return null;\n        case NUMBER:\n            return new LazilyParsedNumber(in.nextString());\n        default:\n            throw new JsonSyntaxException(\"Expecting number, got: \" + token);\n    }\n}",
  "Gson-12": "@Override\npublic void skipValue() throws IOException {\n    if (JsonToken.NAME !\u003d peek()) {\n        popStack();\n        pathNames[stackSize - 1] \u003d \"null\";\n    } else {\n        nextName();\n        pathNames[stackSize - 2] \u003d \"null\";\n    }\n    pathIndices[stackSize - 1] +\u003d 1;\n}",
  "Gson-17": "public Date read(JsonReader in) throws IOException {\n    if (JsonToken.STRING !\u003d in.peek()) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date timestamp \u003d deserializeToDate(in.nextString());\n    if (Date.class !\u003d dateType) {\n        if (Timestamp.class !\u003d dateType) {\n            if (java.sql.Date.class !\u003d dateType) {\n                // This must never happen: dateType is guarded in the primary constructor\n                throw new AssertionError();\n            } else {\n                return new java.sql.Date(timestamp.getTime());\n            }\n        } else {\n            return new Timestamp(timestamp.getTime());\n        }\n    } else {\n        return timestamp;\n    }\n}",
  "Gson-18": "static Type getSupertype(Type context, Class\u003c?\u003e contextRawType, Class\u003c?\u003e supertype) {\n    // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}",
  "Mockito-8": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType genericType \u003d (ParameterizedType) classType;\n    TypeVariable[] typeVars \u003d ((Class\u003c?\u003e) genericType.getRawType()).getTypeParameters();\n    Type[] typeArguments \u003d genericType.getActualTypeArguments();\n    int index \u003d 0;\n    while (typeArguments.length \u003e index) {\n        TypeVariable typeVariable \u003d typeVars[index];\n        Type actualTypeArgument \u003d typeArguments[index];\n        if (!(actualTypeArgument instanceof WildcardType)) {\n            contextualActualTypeParameters.put(typeVariable, actualTypeArgument);\n        } else {\n            contextualActualTypeParameters.put(typeVariable, boundsOf((WildcardType) actualTypeArgument));\n        }\n        // logger.log(\"For \u0027\" + parameterizedType + \"\u0027 found type variable : { \u0027\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 : \u0027\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"\u0027 }\");\n        index +\u003d 1;\n    }\n}",
  "JacksonXml-5": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n    //    root name lookup as that may link back to diff version, configuration\n    _rootNameLookup \u003d src._rootNameLookup;\n}",
  "Mockito-7": "private void readTypeVariables() {\n    for (Type kind : typeVariable.getBounds()) {\n        registerTypeVariablesOn(kind);\n    }\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n}",
  "Mockito-9": "public Object answer(InvocationOnMock invocation) throws Throwable {\n    return invocation.callRealMethod();\n}",
  "JacksonXml-2": "private final int _next() throws XMLStreamException {\n    switch(_currentState) {\n        case XML_ATTRIBUTE_VALUE:\n            ++_nextAttributeIndex;\n        // fall through\n        case // attributes to return?\n        XML_START_ELEMENT:\n            if (_attributeCount \u003e _nextAttributeIndex) {\n                _localName \u003d _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n                _namespaceURI \u003d _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n                _textValue \u003d _xmlReader.getAttributeValue(_nextAttributeIndex);\n                return (_currentState \u003d XML_ATTRIBUTE_NAME);\n            }\n            // otherwise need to find START/END_ELEMENT or text\n            String content \u003d _collectUntilTag();\n            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n            if (XMLStreamReader.START_ELEMENT \u003d\u003d _xmlReader.getEventType()) {\n                return _initStartElement();\n            }\n            // For END_ELEMENT we will return text, if any\n            if (null !\u003d content) {\n                _textValue \u003d content;\n                return (_currentState \u003d XML_TEXT);\n            }\n            return _handleEndElement();\n        case XML_ATTRIBUTE_NAME:\n            // if we just returned name, will need to just send value next\n            return (_currentState \u003d XML_ATTRIBUTE_VALUE);\n        case XML_TEXT:\n            // mixed text with other elements\n            // text followed by END_ELEMENT\n            return _handleEndElement();\n        case XML_END:\n            return XML_END;\n    }\n    // Ok: must be END_ELEMENT; see what tag we get (or end)\n    switch(_skipUntilTag()) {\n        case XMLStreamConstants.END_DOCUMENT:\n            return (_currentState \u003d XML_END);\n        case XMLStreamConstants.END_ELEMENT:\n            return _handleEndElement();\n    }\n    // START_ELEMENT...\n    return _initStartElement();\n}",
  "JacksonXml-1": "public JsonToken nextToken() throws IOException {\n    _binaryValue \u003d null;\n    if (null !\u003d _nextToken) {\n        JsonToken t \u003d _nextToken;\n        _currToken \u003d t;\n        _nextToken \u003d null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext \u003d _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext \u003d _parsingContext.getParent();\n                _namesToWrap \u003d _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int jsonElement \u003d _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (XmlTokenStream.XML_START_ELEMENT \u003d\u003d jsonElement) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken \u003d JsonToken.FIELD_NAME;\n            _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken \u003d JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won\u0027t be\n            // reported anyway, and we need to process following event.\n            jsonElement \u003d _xmlTokens.next();\n            _mayBeLeaf \u003d true;\n            continue;\n        }\n        String elementName \u003d _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(elementName);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (null !\u003d _namesToWrap \u0026\u0026 _namesToWrap.contains(elementName)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf \u003d true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what\u0027s the best way to find next token?\n        return (_currToken \u003d JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(jsonElement) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf \u003d false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken \u003d JsonToken.VALUE_NULL);\n            }\n            _currToken \u003d _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext \u003d _parsingContext.getParent();\n            _namesToWrap \u003d _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf \u003d false;\n                _nextToken \u003d JsonToken.FIELD_NAME;\n                _currText \u003d _xmlTokens.getText();\n                _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken \u003d JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken \u003d JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText \u003d _xmlTokens.getText();\n            return (_currToken \u003d JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText \u003d _xmlTokens.getText();\n            if (!_mayBeLeaf) {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() \u0026\u0026 (JsonToken.FIELD_NAME !\u003d _currToken) \u0026\u0026 _isEmpty(_currText)) {\n                    _currToken \u003d JsonToken.END_OBJECT;\n                    _parsingContext \u003d _parsingContext.getParent();\n                    _namesToWrap \u003d _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            } else {\n                _mayBeLeaf \u003d false;\n                /* One more refinement (pronunced like \"hack\") is that if\n             * we had an empty String (or all white space), and we are\n             * deserializing an array, we better hide the empty text.\n             */\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken \u003d JsonToken.END_ARRAY;\n                        _parsingContext \u003d _parsingContext.getParent();\n                        _namesToWrap \u003d _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken \u003d JsonToken.VALUE_STRING);\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken \u003d JsonToken.VALUE_STRING;\n            return (_currToken \u003d JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken \u003d null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}",
  "Mockito-3": "public void captureArgumentsFrom(Invocation invocation) {\n    if (!invocation.getMethod().isVarArgs()) {\n        int index \u003d 0;\n        while (matchers.size() \u003e index) {\n            Matcher matcher \u003d matchers.get(index);\n            if (matcher instanceof CapturesArguments) {\n                ((CapturesArguments) matcher).captureFrom(invocation.getArgumentAt(index, Object.class));\n            }\n            index +\u003d 1;\n        }\n    } else {\n        int lastVarargIndex \u003d invocation.getRawArguments().length - 1;\n        for (int index \u003d 0; lastVarargIndex \u003e index; index++) {\n            Matcher matcher \u003d matchers.get(index);\n            if (matcher instanceof CapturesArguments) {\n                ((CapturesArguments) matcher).captureFrom(invocation.getArgumentAt(index, Object.class));\n            }\n        }\n        for (int index \u003d lastVarargIndex; matchers.size() \u003e index; index++) {\n            Matcher matcher \u003d matchers.get(index);\n            if (matcher instanceof CapturesArguments) {\n                ((CapturesArguments) matcher).captureFrom(invocation.getRawArguments()[index - lastVarargIndex]);\n            }\n        }\n    }\n}",
  "JacksonXml-4": "protected void _serializeXmlNull(JsonGenerator jgen) throws IOException {\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n    //    configured root name...\n    if (jgen instanceof ToXmlGenerator) {\n        _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n    }\n    super.serializeValue(jgen, null);\n}",
  "JacksonXml-3": "public String nextTextValue() throws IOException {\n    _binaryValue \u003d null;\n    if (null !\u003d _nextToken) {\n        JsonToken tokenType \u003d _nextToken;\n        _currToken \u003d tokenType;\n        _nextToken \u003d null;\n        // expected case; yes, got a String\n        if (JsonToken.VALUE_STRING \u003d\u003d tokenType) {\n            return _currText;\n        }\n        _updateState(tokenType);\n        return null;\n    }\n    int nextElement \u003d _xmlTokens.next();\n    // mostly copied from \u0027nextToken()\u0027\n    while (XmlTokenStream.XML_START_ELEMENT \u003d\u003d nextElement) {\n        if (_mayBeLeaf) {\n            _nextToken \u003d JsonToken.FIELD_NAME;\n            _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\n            _currToken \u003d JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            nextElement \u003d _xmlTokens.next();\n            _mayBeLeaf \u003d true;\n            continue;\n        }\n        String elementName \u003d _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(elementName);\n        if (null !\u003d _namesToWrap \u0026\u0026 _namesToWrap.contains(elementName)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf \u003d true;\n        _currToken \u003d JsonToken.FIELD_NAME;\n        return null;\n    }\n    // Ok; beyond start element, what do we get?\n    switch(nextElement) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf \u003d false;\n                _currToken \u003d JsonToken.VALUE_STRING;\n                return (_currText \u003d \"\");\n            }\n            _currToken \u003d _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext \u003d _parsingContext.getParent();\n            _namesToWrap \u003d _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (!_mayBeLeaf) {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken \u003d JsonToken.FIELD_NAME;\n            } else {\n                _mayBeLeaf \u003d false;\n                _nextToken \u003d JsonToken.FIELD_NAME;\n                _currText \u003d _xmlTokens.getText();\n                _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\n                _currToken \u003d JsonToken.START_OBJECT;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText \u003d _xmlTokens.getText();\n            _currToken \u003d JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText \u003d _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf \u003d false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken \u003d JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken \u003d JsonToken.VALUE_STRING;\n            _currToken \u003d JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken \u003d null;\n    }\n    return null;\n}",
  "Mockito-5": "public void verify(VerificationData data) {\n    AssertionError verificationError \u003d null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (!returnOnSuccess) {\n                verificationError \u003d null;\n            } else {\n                return;\n            }\n        } catch (MockitoAssertionError e) {\n            verificationError \u003d handleVerifyException(e);\n        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n            verificationError \u003d handleVerifyException(e);\n        }\n    }\n    if (null !\u003d verificationError) {\n        throw verificationError;\n    }\n}",
  "Cli-3": "public static Number createNumber(String str) {\n    try {\n        return NumberUtils.createNumber(str);\n    } catch (NumberFormatException nfe) {\n        System.err.println(nfe.getMessage());\n    }\n    return null;\n}",
  "Cli-4": "private void checkRequiredOptions() throws MissingOptionException {\n    // if there are required options that have not been\n    // processsed\n    if (0 \u003c requiredOptions.size()) {\n        Iterator iterator \u003d requiredOptions.iterator();\n        StringBuffer builder \u003d new StringBuffer();\n        // loop through the required options\n        while (iterator.hasNext()) {\n            builder.append(iterator.next());\n        }\n        throw new MissingOptionException(builder.toString());\n    }\n}",
  "Cli-2": "protected void burstToken(String token, boolean stopAtNonOption) {\n    int lengthOfToken \u003d token.length();\n    int index \u003d 1;\n    while (lengthOfToken \u003e index) {\n        String optionChar \u003d String.valueOf(token.charAt(index));\n        boolean isOptionPresent \u003d options.hasOption(optionChar);\n        if (!isOptionPresent) {\n            if (!stopAtNonOption) {\n                tokens.add(\"-\" + optionChar);\n            } else {\n                process(token.substring(index));\n            }\n        } else {\n            tokens.add(\"-\" + optionChar);\n            currentOption \u003d options.getOption(optionChar);\n            if (currentOption.hasArg() \u0026\u0026 ((index + 1) !\u003d token.length())) {\n                tokens.add(token.substring(index + 1));\n                break;\n            }\n        }\n        index +\u003d 1;\n    }\n}",
  "Cli-8": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int wrapPosition \u003d findWrapPos(text, width, 0);\n    if (-1 \u003d\u003d wrapPosition) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, wrapPosition))).append(defaultNewLine);\n    // all following lines must be padded with nextLineTabStop space\n    // characters\n    final String indentation \u003d createPadding(nextLineTabStop);\n    while (true) {\n        text \u003d indentation + text.substring(wrapPosition).trim();\n        wrapPosition \u003d findWrapPos(text, width, nextLineTabStop);\n        if (-1 \u003d\u003d wrapPosition) {\n            sb.append(text);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, wrapPosition))).append(defaultNewLine);\n    }\n}",
  "Cli-5": "static String stripLeadingHyphens(String str) {\n    if (!str.startsWith(\"--\")) {\n        if (str.startsWith(\"-\")) {\n            return str.substring(1, str.length());\n        }\n    } else {\n        return str.substring(2, str.length());\n    }\n    return str;\n}",
  "Cli-9": "protected void checkRequiredOptions() throws MissingOptionException {\n    // if there are required options that have not been\n    // processsed\n    if (0 \u003c getRequiredOptions().size()) {\n        Iterator iterator \u003d getRequiredOptions().iterator();\n        StringBuffer messageBuffer \u003d new StringBuffer(\"Missing required option\");\n        messageBuffer.append(1 \u003d\u003d getRequiredOptions().size() ? \"\" : \"s\");\n        messageBuffer.append(\": \");\n        // loop through the required options\n        while (iterator.hasNext()) {\n            messageBuffer.append(iterator.next());\n        }\n        throw new MissingOptionException(messageBuffer.toString());\n    }\n}",
  "Gson-5": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception error \u003d null;\n    try {\n        int currentIndex \u003d pos.getIndex();\n        // extract year\n        int calendarYear \u003d parseInt(date, currentIndex, currentIndex +\u003d 4);\n        if (checkOffset(date, currentIndex, \u0027-\u0027)) {\n            currentIndex +\u003d 1;\n        }\n        // extract month\n        int season \u003d parseInt(date, currentIndex, currentIndex +\u003d 2);\n        if (checkOffset(date, currentIndex, \u0027-\u0027)) {\n            currentIndex +\u003d 1;\n        }\n        // extract day\n        int datum \u003d parseInt(date, currentIndex, currentIndex +\u003d 2);\n        // default time value\n        int hourOfDay \u003d 0;\n        int mins \u003d 0;\n        int ticks \u003d 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int timeInMilliseconds \u003d 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasTime \u003d checkOffset(date, currentIndex, \u0027T\u0027);\n        if (!hasTime \u0026\u0026 (currentIndex \u003e\u003d date.length())) {\n            Calendar dateTimeRepresentation \u003d new GregorianCalendar(calendarYear, season - 1, datum);\n            pos.setIndex(currentIndex);\n            return dateTimeRepresentation.getTime();\n        }\n        if (hasTime) {\n            // extract hours, minutes, seconds and milliseconds\n            hourOfDay \u003d parseInt(date, currentIndex +\u003d 1, currentIndex +\u003d 2);\n            if (checkOffset(date, currentIndex, \u0027:\u0027)) {\n                currentIndex +\u003d 1;\n            }\n            mins \u003d parseInt(date, currentIndex, currentIndex +\u003d 2);\n            if (checkOffset(date, currentIndex, \u0027:\u0027)) {\n                currentIndex +\u003d 1;\n            }\n            // second and milliseconds can be optional\n            if (currentIndex \u003c date.length()) {\n                char timeIndicator \u003d date.charAt(currentIndex);\n                if (\u0027Z\u0027 !\u003d timeIndicator \u0026\u0026 \u0027+\u0027 !\u003d timeIndicator \u0026\u0026 \u0027-\u0027 !\u003d timeIndicator) {\n                    ticks \u003d parseInt(date, currentIndex, currentIndex +\u003d 2);\n                    // truncate up to 3 leap seconds\n                    if (59 \u003c ticks \u0026\u0026 63 \u003e ticks)\n                        ticks \u003d 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, currentIndex, \u0027.\u0027)) {\n                        currentIndex +\u003d 1;\n                        // assume at least one digit\n                        int endIndex \u003d indexOfNonDigit(date, currentIndex + 1);\n                        // parse up to 3 digits\n                        int parseEndIndex \u003d Math.min(endIndex, currentIndex + 3);\n                        int digits \u003d parseInt(date, currentIndex, parseEndIndex);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndIndex - currentIndex) {\n                            case 2:\n                                timeInMilliseconds \u003d digits * 10;\n                                break;\n                            case 1:\n                                timeInMilliseconds \u003d digits * 100;\n                                break;\n                            default:\n                                timeInMilliseconds \u003d digits;\n                        }\n                        currentIndex \u003d endIndex;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (currentIndex \u003e\u003d date.length()) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timeZone \u003d null;\n        char timezoneSymbol \u003d date.charAt(currentIndex);\n        if (\u0027Z\u0027 !\u003d timezoneSymbol) {\n            if (\u0027+\u0027 !\u003d timezoneSymbol \u0026\u0026 \u0027-\u0027 !\u003d timezoneSymbol) {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneSymbol + \"\u0027\");\n            } else {\n                String timezoneOffsetString \u003d date.substring(currentIndex);\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                currentIndex +\u003d timezoneOffsetString.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (!\"+0000\".equals(timezoneOffsetString) \u0026\u0026 !\"+00:00\".equals(timezoneOffsetString)) {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that\u0027s the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneOffsetId \u003d \"GMT\" + timezoneOffsetString;\n                    String timezoneOffsetId \u003d \"UTC\" + timezoneOffsetString;\n                    timeZone \u003d TimeZone.getTimeZone(timezoneOffsetId);\n                    String act \u003d timeZone.getID();\n                    if (!act.equals(timezoneOffsetId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don\u0027t sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add \u0027loose\u0027 comparison instead.\n                     */\n                        String sanitized \u003d act.replace(\":\", \"\");\n                        if (!sanitized.equals(timezoneOffsetId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneOffsetId + \" given, resolves to \" + timeZone.getID());\n                        }\n                    }\n                } else {\n                    timeZone \u003d TIMEZONE_UTC;\n                }\n            }\n        } else {\n            timeZone \u003d TIMEZONE_UTC;\n            currentIndex +\u003d 1;\n        }\n        Calendar dateTimeRepresentation \u003d new GregorianCalendar(timeZone);\n        dateTimeRepresentation.setLenient(false);\n        dateTimeRepresentation.set(Calendar.YEAR, calendarYear);\n        dateTimeRepresentation.set(Calendar.MONTH, season - 1);\n        dateTimeRepresentation.set(Calendar.DAY_OF_MONTH, datum);\n        dateTimeRepresentation.set(Calendar.HOUR_OF_DAY, hourOfDay);\n        dateTimeRepresentation.set(Calendar.MINUTE, mins);\n        dateTimeRepresentation.set(Calendar.SECOND, ticks);\n        dateTimeRepresentation.set(Calendar.MILLISECOND, timeInMilliseconds);\n        pos.setIndex(currentIndex);\n        return dateTimeRepresentation.getTime();\n        // If we get a ParseException it\u0027ll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        error \u003d e;\n    } catch (NumberFormatException e) {\n        error \u003d e;\n    } catch (IllegalArgumentException e) {\n        error \u003d e;\n    }\n    String stringRepresentation \u003d (null \u003d\u003d date) ? null : (\u0027\"\u0027 + date + \"\u0027\");\n    String errorMessage \u003d error.getMessage();\n    if (null \u003d\u003d errorMessage || errorMessage.isEmpty()) {\n        errorMessage \u003d \"(\" + error.getClass().getName() + \")\";\n    }\n    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + stringRepresentation + \"]: \" + errorMessage, pos.getIndex());\n    ex.initCause(error);\n    throw ex;\n}",
  "Gson-6": "static TypeAdapter\u003c?\u003e getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson, TypeToken\u003c?\u003e fieldType, JsonAdapter annotation) {\n    Class\u003c?\u003e adapterClass \u003d annotation.value();\n    TypeAdapter\u003c?\u003e adapter;\n    if (!TypeAdapter.class.isAssignableFrom(adapterClass)) {\n        if (!TypeAdapterFactory.class.isAssignableFrom(adapterClass)) {\n            throw new IllegalArgumentException(\"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n        } else {\n            Class\u003cTypeAdapterFactory\u003e adapterFactory \u003d (Class\u003cTypeAdapterFactory\u003e) adapterClass;\n            adapter \u003d constructorConstructor.get(TypeToken.get(adapterFactory)).construct().create(gson, fieldType);\n        }\n    } else {\n        Class\u003cTypeAdapter\u003c?\u003e\u003e typeAdapterClass \u003d (Class\u003cTypeAdapter\u003c?\u003e\u003e) adapterClass;\n        adapter \u003d constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    }\n    adapter \u003d adapter.nullSafe();\n    return adapter;\n}",
  "JacksonDatabind-91": "private boolean _hasCustomHandlers(JavaType t) {\n    if (t.isContainerType()) {\n        // First: value types may have both value and type handlers\n        JavaType contentType \u003d t.getContentType();\n        if (null !\u003d contentType) {\n            return (null !\u003d contentType.getValueHandler()) || (null !\u003d contentType.getTypeHandler());\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n        }\n    }\n    return false;\n}",
  "JacksonDatabind-93": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n    // There are certain nasty classes that could cause problems, mostly\n    // via default typing -- catch them here.\n    final Class\u003c?\u003e clazz \u003d type.getRawClass();\n    String qualified \u003d clazz.getName();\n    main_check: do {\n        if (_cfgIllegalClassNames.contains(qualified)) {\n            break;\n        }\n        // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n        //    for some Spring framework types\n        // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n        if (qualified.startsWith(PREFIX_STRING)) {\n            Class\u003c?\u003e subclass \u003d clazz;\n            while (Object.class !\u003d subclass) {\n                String className \u003d subclass.getSimpleName();\n                // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                if (// ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                \"AbstractPointcutAdvisor\".equals(className) || \"AbstractApplicationContext\".equals(className)) {\n                    break main_check;\n                }\n                subclass \u003d subclass.getSuperclass();\n            }\n        }\n        return;\n    } while (false);\n    throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", qualified));\n}",
  "JacksonDatabind-94": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n    // There are certain nasty classes that could cause problems, mostly\n    // via default typing -- catch them here.\n    final Class\u003c?\u003e clazz \u003d type.getRawClass();\n    String qualifiedName \u003d clazz.getName();\n    main_check: do {\n        if (_cfgIllegalClassNames.contains(qualifiedName)) {\n            break;\n        }\n        // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n        //    for some Spring framework types\n        // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n        if (!clazz.isInterface()) {\n            if (qualifiedName.startsWith(PREFIX_SPRING)) {\n                Class\u003c?\u003e currentClass \u003d clazz;\n                while ((null !\u003d currentClass) \u0026\u0026 (Object.class !\u003d currentClass)) {\n                    String className \u003d currentClass.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (// ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                    \"AbstractPointcutAdvisor\".equals(className) || \"AbstractApplicationContext\".equals(className)) {\n                        break main_check;\n                    }\n                    // [databind#1737]; more 3rd party\n                    // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                    // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                    // [databind#1931]; more 3rd party\n                    // com.mchange.v2.c3p0.ComboPooledDataSource\n                    // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource\n                    currentClass \u003d currentClass.getSuperclass();\n                }\n            }\n        } else {\n            ;\n        }\n        return;\n    } while (false);\n    throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", qualifiedName));\n}",
  "JacksonDatabind-96": "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException {\n    // Looks like there\u0027s bit of magic regarding 1-parameter creators; others simpler:\n    if (candidate.paramCount() !\u003d 1) {\n        // Ok: for delegates, we want one and exactly one parameter without\n        // injection AND without name\n        int singleParamWithoutInjection \u003d candidate.findOnlyParamWithoutInjection();\n        if (0 \u003c\u003d singleParamWithoutInjection) {\n            // getting close; but most not have name\n            if (null \u003d\u003d candidate.paramName(singleParamWithoutInjection)) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter argument \u003d candidate.parameter(0);\n    JacksonInject.Value injectionId \u003d candidate.injection(0);\n    PropertyName parameterName \u003d candidate.explicitParamName(0);\n    BeanPropertyDefinition propertyDefinition \u003d candidate.propertyDef(0);\n    // If there\u0027s injection or explicit name, should be properties-based\n    boolean useParameters \u003d (null !\u003d parameterName) || (null !\u003d injectionId);\n    if (!useParameters \u0026\u0026 (null !\u003d propertyDefinition)) {\n        // One more thing: if implicit name matches property with a getter\n        // or field, we\u0027ll consider it property-based as well\n        // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n        //    not implicit name, but name with possible strategy-based-rename\n        parameterName \u003d candidate.findImplicitParamName(0);\n        parameterName \u003d candidate.findImplicitParamName(0);\n        useParameters \u003d (null !\u003d parameterName) \u0026\u0026 propertyDefinition.couldSerialize();\n    }\n    if (useParameters) {\n        SettableBeanProperty[] fields \u003d new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, parameterName, 0, argument, injectionId) };\n        creators.addPropertyCreator(candidate.creator(), true, fields);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n    // one more thing: sever link to creator property, to avoid possible later\n    // problems with \"unresolved\" constructor property\n    if (null !\u003d propertyDefinition) {\n        ((POJOPropertyBuilder) propertyDefinition).removeConstructors();\n    }\n}",
  "JacksonDatabind-97": "public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException {\n    if (null !\u003d _value) {\n        if (!(_value instanceof JsonSerializable)) {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            gen.writeObject(_value);\n        } else {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        }\n    } else {\n        ctxt.defaultSerializeNull(gen);\n    }\n}",
  "JacksonDatabind-98": "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException {\n    // first things first: deserialize all data buffered:\n    final int size \u003d _properties.length;\n    Object[] data \u003d new Object[size];\n    for (int index \u003d 0; size \u003e index; ++index) {\n        String externalTypeId \u003d _typeIds[index];\n        final ExtTypedProperty extTypedProperty \u003d _properties[index];\n        if (null !\u003d externalTypeId) {\n            if (null \u003d\u003d _tokens[index]) {\n                SettableBeanProperty property \u003d extTypedProperty.getProperty();\n                ctxt.reportInputMismatch(_beanType, \"Missing property \u0027%s\u0027 for external type id \u0027%s\u0027\", property.getName(), _properties[index].getTypePropertyName());\n            }\n        } else {\n            // let\u0027s allow missing both type and property (may already have been set, too)\n            if (null \u003d\u003d _tokens[index]) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of \u0027defaultImpl\u0027\n            if (extTypedProperty.hasDefaultType()) {\n                externalTypeId \u003d extTypedProperty.getDefaultTypeId();\n            } else {\n                ctxt.reportInputMismatch(_beanType, \"Missing external type id property \u0027%s\u0027\", extTypedProperty.getTypePropertyName());\n            }\n        }\n        data[index] \u003d _deserialize(p, ctxt, index, externalTypeId);\n        final SettableBeanProperty property \u003d extTypedProperty.getProperty();\n        // also: if it\u0027s creator prop, fill in\n        if (0 \u003c\u003d property.getCreatorIndex()) {\n            buffer.assignParameter(property, data[index]);\n            // [databind#999] And maybe there\u0027s creator property for type id too?\n            SettableBeanProperty typeProperty \u003d extTypedProperty.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((null !\u003d typeProperty) \u0026\u0026 (0 \u003c\u003d typeProperty.getCreatorIndex())) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProperty, externalTypeId);\n            }\n        }\n    }\n    Object object \u003d creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int index \u003d 0; size \u003e index; ++index) {\n        SettableBeanProperty property \u003d _properties[index].getProperty();\n        if (0 \u003e property.getCreatorIndex()) {\n            property.set(object, data[index]);\n        }\n    }\n    return object;\n}",
  "JacksonDatabind-99": "protected String buildCanonicalName() {\n    StringBuilder stringBuilder \u003d new StringBuilder();\n    stringBuilder.append(_class.getName());\n    stringBuilder.append(\u0027\u003c\u0027);\n    stringBuilder.append(_referencedType.toCanonical());\n    return stringBuilder.toString();\n}",
  "JacksonDatabind-82": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isInstantiable \u003d !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] constructorProps \u003d isInstantiable ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasConstructorProperties \u003d (null !\u003d constructorProps);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignoredProperties \u003d ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set\u003cString\u003e excluded;\n    if (null \u003d\u003d ignoredProperties) {\n        excluded \u003d Collections.emptySet();\n    } else {\n        boolean ignoreUnknownProperties \u003d ignoredProperties.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreUnknownProperties);\n        // Or explicit/implicit definitions?\n        excluded \u003d ignoredProperties.getIgnored();\n        for (String propertyName : excluded) {\n            builder.addIgnorable(propertyName);\n        }\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethodAnnotated \u003d beanDesc.findAnySetter();\n    AnnotatedMember anySetterAttribute \u003d null;\n    if (null \u003d\u003d anySetterMethodAnnotated) {\n        anySetterAttribute \u003d beanDesc.findAnySetterField();\n        if (null !\u003d anySetterAttribute) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterAttribute));\n        }\n    } else {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethodAnnotated));\n    }\n    // NOTE: we do NOT add @JsonIgnore\u0027d properties into blocked ones if there\u0027s any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (null \u003d\u003d anySetterMethodAnnotated \u0026\u0026 null \u003d\u003d anySetterAttribute) {\n        Collection\u003cString\u003e ignored2 \u003d beanDesc.getIgnoredPropertyNames();\n        if (null !\u003d ignored2) {\n            for (String propertyName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to \u0027ignored\u0027:\n                builder.addIgnorable(propertyName);\n            }\n        }\n    }\n    final boolean useGettersAsMutators \u003d ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) \u0026\u0026 ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let\u0027s then filter out property definitions\n    List\u003cBeanPropertyDefinition\u003e propertyDefinitions \u003d filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), excluded);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier modifier : _factoryConfig.deserializerModifiers()) {\n            propertyDefinitions \u003d modifier.updateProperties(ctxt.getConfig(), beanDesc, propertyDefinitions);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition beanPropertyDefinition : propertyDefinitions) {\n        SettableBeanProperty beanProperty \u003d null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (!beanPropertyDefinition.hasSetter()) {\n            if (!beanPropertyDefinition.hasField()) {\n                if (useGettersAsMutators \u0026\u0026 beanPropertyDefinition.hasGetter()) {\n                    /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n                    AnnotatedMethod accessor \u003d beanPropertyDefinition.getGetter();\n                    // should only consider Collections and Maps, for now?\n                    Class\u003c?\u003e rawTypeOfProperty \u003d accessor.getRawType();\n                    if (Collection.class.isAssignableFrom(rawTypeOfProperty) || Map.class.isAssignableFrom(rawTypeOfProperty)) {\n                        beanProperty \u003d constructSetterlessProperty(ctxt, beanDesc, beanPropertyDefinition);\n                    }\n                }\n            } else {\n                JavaType dataType \u003d beanPropertyDefinition.getField().getType();\n                beanProperty \u003d constructSettableProperty(ctxt, beanDesc, beanPropertyDefinition, dataType);\n            }\n        } else {\n            JavaType dataType \u003d beanPropertyDefinition.getSetter().getParameterType(0);\n            beanProperty \u003d constructSettableProperty(ctxt, beanDesc, beanPropertyDefinition, dataType);\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasConstructorProperties \u0026\u0026 beanPropertyDefinition.hasConstructorParameter()) {\n            /* If property is passed via constructor parameter, we must\n             * handle things in special way. Not sure what is the most optimal way...\n             * for now, let\u0027s just call a (new) method in builder, which does nothing.\n             */\n            // but let\u0027s call a method just to allow custom builders to be aware...\n            final String name \u003d beanPropertyDefinition.getName();\n            CreatorProperty creatorProperty \u003d null;\n            if (null !\u003d constructorProps) {\n                for (SettableBeanProperty cp : constructorProps) {\n                    if (name.equals(cp.getName()) \u0026\u0026 (cp instanceof CreatorProperty)) {\n                        creatorProperty \u003d (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (null \u003d\u003d creatorProperty) {\n                List\u003cString\u003e creatorPropertyNames \u003d new ArrayList\u003c\u003e();\n                for (SettableBeanProperty cp : constructorProps) {\n                    creatorPropertyNames.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, beanPropertyDefinition, \"Could not find creator property with name \u0027%s\u0027 (known Creator properties: %s)\", name, creatorPropertyNames);\n                continue;\n            }\n            if (null !\u003d beanProperty) {\n                creatorProperty.setFallbackSetter(beanProperty);\n            }\n            beanProperty \u003d creatorProperty;\n            builder.addCreatorProperty(creatorProperty);\n            continue;\n        }\n        if (null !\u003d beanProperty) {\n            Class\u003c?\u003e[] visibility \u003d beanPropertyDefinition.findViews();\n            if (null \u003d\u003d visibility) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    visibility \u003d NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            beanProperty.setViews(visibility);\n            builder.addProperty(beanProperty);\n        }\n    }\n}",
  "JacksonDatabind-83": "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String content \u003d p.getValueAsString();\n    if (null !\u003d content) {\n        // has String representation\n        if (0 \u003d\u003d content.length() || 0 \u003d\u003d (content \u003d content.trim()).length()) {\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception exception \u003d null;\n        try {\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            if (null !\u003d _deserialize(content, ctxt)) {\n                return _deserialize(content, ctxt);\n            }\n        } catch (IllegalArgumentException iae) {\n            exception \u003d iae;\n        } catch (MalformedURLException me) {\n            exception \u003d me;\n        }\n        String errorMessage \u003d \"not a valid textual representation\";\n        if (null !\u003d exception) {\n            String m2 \u003d exception.getMessage();\n            if (null !\u003d m2) {\n                errorMessage \u003d errorMessage + \", problem: \" + m2;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException e \u003d ctxt.weirdStringException(content, _valueClass, errorMessage);\n        if (null !\u003d exception) {\n            e.initCause(exception);\n        }\n        throw e;\n        // nothing to do here, yet? We\u0027ll fail anyway\n    }\n    JsonToken jsonToken \u003d p.getCurrentToken();\n    // [databind#381]\n    if (JsonToken.START_ARRAY \u003d\u003d jsonToken) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (JsonToken.VALUE_EMBEDDED_OBJECT \u003d\u003d jsonToken) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object embeddedObject \u003d p.getEmbeddedObject();\n        if (null \u003d\u003d embeddedObject) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(embeddedObject.getClass())) {\n            return (T) embeddedObject;\n        }\n        return _deserializeEmbedded(embeddedObject, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}",
  "JacksonDatabind-85": "public JsonSerializer\u003c?\u003e createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    if (null \u003d\u003d property) {\n        return this;\n    }\n    JsonFormat.Value style \u003d findFormatOverrides(serializers, property, handledType());\n    if (null \u003d\u003d style) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape form \u003d style.getShape();\n    if (form.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if ((JsonFormat.Shape.STRING \u003d\u003d form) || style.hasPattern() || style.hasLocale() || style.hasTimeZone()) {\n        TimeZone timeZone \u003d style.getTimeZone();\n        final String dateFormatPattern \u003d style.hasPattern() ? style.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n        final Locale locale \u003d style.hasLocale() ? style.getLocale() : serializers.getLocale();\n        SimpleDateFormat dateFormat \u003d new SimpleDateFormat(dateFormatPattern, locale);\n        if (null \u003d\u003d timeZone) {\n            timeZone \u003d serializers.getTimeZone();\n        }\n        dateFormat.setTimeZone(timeZone);\n        return withFormat(Boolean.FALSE, dateFormat);\n    }\n    // Otherwise, need one of these changes:\n    // Jackson\u0027s own `StdDateFormat` is quite easy to deal with...\n    // 08-Jun-2017, tatu: Unfortunately there\u0027s no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can\u0027t config other types\n    //            serializers.reportBadDefinition(handledType(), String.format(\n    // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n    return this;\n}",
  "JacksonDatabind-88": "protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException {\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let\u0027s first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory typeFactory \u003d ctxt.getTypeFactory();\n    if (0 \u003c id.indexOf(\u0027\u003c\u0027)) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType typeInstance \u003d typeFactory.constructFromCanonical(id);\n        // Probably cleaner to have a method in `TypeFactory` but can\u0027t add in patch\n        return typeInstance;\n    }\n    Class\u003c?\u003e clazz;\n    try {\n        clazz \u003d typeFactory.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext deserializationContext \u003d (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return deserializationContext.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id \u0027\" + id + \"\u0027 (for id type \u0027Id.class\u0027): \" + e.getMessage(), e);\n    }\n    return typeFactory.constructSpecializedType(_baseType, clazz);\n}",
  "Jsoup-80": "void insert(Token.Comment commentToken) {\n    Comment note \u003d new Comment(commentToken.getData());\n    Node add \u003d note;\n    if (commentToken.bogus) {\n        // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n        String content \u003d note.getData();\n        if (1 \u003c content.length() \u0026\u0026 (content.startsWith(\"!\") || content.startsWith(\"?\"))) {\n            Document xmlDocument \u003d Jsoup.parse(\"\u003c\" + content.substring(1, content.length() - 1) + \"\u003e\", baseUri, Parser.xmlParser());\n            Element element \u003d xmlDocument.child(0);\n            add \u003d new XmlDeclaration(settings.normalizeTag(element.tagName()), content.startsWith(\"!\"));\n            add.attributes().addAll(element.attributes());\n        }\n    }\n    insertNode(add);\n}",
  "Jsoup-82": "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (// empty body\n    null \u003d\u003d input)\n        return new Document(baseUri);\n    input \u003d ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document parsedDocument \u003d null;\n    boolean isCompletelyRead \u003d false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is \u003c buffer size, so can\u0027t be invalid.\n    ByteBuffer initialBytes \u003d readToByteBuffer(input, firstReadBufferSize - 1);\n    isCompletelyRead \u003d -1 \u003d\u003d input.read();\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomEncoding \u003d detectCharsetFromBom(initialBytes);\n    if (null !\u003d bomEncoding)\n        charsetName \u003d bomEncoding.charset;\n    if (null !\u003d charsetName) {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    } else {\n        // determine from meta. safe first parse as UTF-8\n        String fileContent \u003d Charset.forName(defaultCharset).decode(initialBytes).toString();\n        parsedDocument \u003d parser.parseInput(fileContent, baseUri);\n        // look for \u003cmeta http-equiv\u003d\"Content-Type\" content\u003d\"text/html;charset\u003dgb2312\"\u003e or HTML5 \u003cmeta charset\u003d\"gb2312\"\u003e\n        Elements metaTags \u003d parsedDocument.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String detectedCharset \u003d null;\n        for (Element header : metaTags) {\n            if (header.hasAttr(\"http-equiv\"))\n                detectedCharset \u003d getCharsetFromContentType(header.attr(\"content\"));\n            if (null \u003d\u003d detectedCharset \u0026\u0026 header.hasAttr(\"charset\"))\n                detectedCharset \u003d header.attr(\"charset\");\n            if (null !\u003d detectedCharset)\n                break;\n        }\n        // look for \u003c?xml encoding\u003d\u0027ISO-8859-1\u0027?\u003e\n        if (null \u003d\u003d detectedCharset \u0026\u0026 0 \u003c parsedDocument.childNodeSize()) {\n            Node first \u003d parsedDocument.childNode(0);\n            XmlDeclaration xmlDeclaration \u003d null;\n            if (!(first instanceof XmlDeclaration)) {\n                if (first instanceof Comment) {\n                    Comment nodeComment \u003d (Comment) first;\n                    if (nodeComment.isXmlDeclaration())\n                        xmlDeclaration \u003d nodeComment.asXmlDeclaration();\n                }\n            } else\n                xmlDeclaration \u003d (XmlDeclaration) first;\n            if (null !\u003d xmlDeclaration) {\n                if (xmlDeclaration.name().equalsIgnoreCase(\"xml\"))\n                    detectedCharset \u003d xmlDeclaration.attr(\"encoding\");\n            }\n        }\n        detectedCharset \u003d validateCharset(detectedCharset);\n        if (null \u003d\u003d detectedCharset || detectedCharset.equalsIgnoreCase(defaultCharset)) {\n            if (!isCompletelyRead) {\n                parsedDocument \u003d null;\n            }\n        } else {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            detectedCharset \u003d detectedCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n            charsetName \u003d detectedCharset;\n            parsedDocument \u003d null;\n        }\n    }\n    if (null \u003d\u003d parsedDocument) {\n        if (null \u003d\u003d charsetName)\n            charsetName \u003d defaultCharset;\n        BufferedReader bufferedReader \u003d new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        null !\u003d bomEncoding \u0026\u0026 bomEncoding.offset)\n            bufferedReader.skip(1);\n        try {\n            parsedDocument \u003d parser.parseInput(bufferedReader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset encoding \u003d Charset.forName(charsetName);\n        parsedDocument.outputSettings().charset(encoding);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return parsedDocument;\n}",
  "JacksonDatabind-9": "public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n    String text;\n    if (!(value instanceof Date)) {\n        text \u003d value.toString();\n    } else {\n        provider.defaultSerializeDateKey((Date) value, jgen);\n        return;\n    }\n    jgen.writeFieldName(text);\n}",
  "Jsoup-85": "public Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    this.key \u003d key.trim();\n    // trimming could potentially make empty, so validate here\n    Validate.notEmpty(key);\n    this.val \u003d val;\n    this.parent \u003d parent;\n}",
  "Jsoup-84": "public void head(org.jsoup.nodes.Node source, int depth) {\n    // inherit from above on the stack\n    namespacesStack.push(new HashMap\u003c\u003e(namespacesStack.peek()));\n    if (!(source instanceof org.jsoup.nodes.Element)) {\n        if (!(source instanceof org.jsoup.nodes.TextNode)) {\n            if (!(source instanceof org.jsoup.nodes.Comment)) {\n                if (!(source instanceof org.jsoup.nodes.DataNode)) {\n                    // unhandled\n                } else {\n                    org.jsoup.nodes.DataNode sourceNode \u003d (org.jsoup.nodes.DataNode) source;\n                    Text node \u003d doc.createTextNode(sourceNode.getWholeData());\n                    dest.appendChild(node);\n                }\n            } else {\n                org.jsoup.nodes.Comment sourceNodeComment \u003d (org.jsoup.nodes.Comment) source;\n                Comment note \u003d doc.createComment(sourceNodeComment.getData());\n                dest.appendChild(note);\n            }\n        } else {\n            org.jsoup.nodes.TextNode textNode \u003d (org.jsoup.nodes.TextNode) source;\n            Text content \u003d doc.createTextNode(textNode.getWholeText());\n            dest.appendChild(content);\n        }\n    } else {\n        org.jsoup.nodes.Element elementSource \u003d (org.jsoup.nodes.Element) source;\n        String namespacePrefix \u003d updateNamespaces(elementSource);\n        String uri \u003d namespacesStack.peek().get(namespacePrefix);\n        String elementName \u003d elementSource.tagName();\n        Element element \u003d doc.createElementNS(uri, elementName);\n        copyAttributes(elementSource, element);\n        if (null !\u003d dest) {\n            dest.appendChild(element);\n        } else {\n            // sets up the root\n            doc.appendChild(element);\n        }\n        // descend\n        dest \u003d element;\n    }\n}",
  "JacksonDatabind-7": "public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n    copyCurrentStructure(jp);\n    /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n     *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n     *    to assume one did exist.\n     */\n    return this;\n}",
  "JacksonDatabind-8": "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n    final int bitmask \u003d (1 \u003c\u003c typeIndex);\n    _hasNonDefaultCreator \u003d true;\n    AnnotatedWithParams previousOne \u003d _creators[typeIndex];\n    // already had an explicitly marked one?\n    if (null !\u003d previousOne) {\n        if (0 !\u003d (_explicitCreators \u0026 bitmask)) {\n            // already had explicitly annotated, leave as-is\n            // but skip, if new one not annotated\n            if (!explicit) {\n                return;\n            }\n            // both explicit: verify\n            // otherwise only verify if neither explicitly annotated.\n        }\n        // one more thing: ok to override in sub-class\n        if (newOne.getClass() \u003d\u003d previousOne.getClass()) {\n            // [databind#667]: avoid one particular class of bogus problems\n            throw new IllegalArgumentException(\"Conflicting \" + TYPE_DESCS[typeIndex] + \" creators: already had explicitly marked \" + previousOne + \", encountered \" + newOne);\n            // otherwise, which one to choose?\n            // new type more generic, use old\n            // new type more specific, use it\n        }\n    }\n    if (explicit) {\n        _explicitCreators |\u003d bitmask;\n    }\n    _creators[typeIndex] \u003d _fixAccess(newOne);\n}",
  "Jsoup-86": "public XmlDeclaration asXmlDeclaration() {\n    String xmlData \u003d getData();\n    Document xmlDocument \u003d Jsoup.parse(\"\u003c\" + xmlData.substring(1, xmlData.length() - 1) + \"\u003e\", baseUri(), Parser.xmlParser());\n    XmlDeclaration xmlDeclaration \u003d null;\n    if (0 \u003c xmlDocument.childNodeSize()) {\n        Element element \u003d xmlDocument.child(0);\n        xmlDeclaration \u003d new XmlDeclaration(NodeUtils.parser(xmlDocument).settings().normalizeTag(element.tagName()), xmlData.startsWith(\"!\"));\n        xmlDeclaration.attributes().addAll(element.attributes());\n    }\n    return xmlDeclaration;\n}",
  "JacksonDatabind-5": "protected void _addMethodMixIns(Class\u003c?\u003e targetClass, AnnotatedMethodMap methods, Class\u003c?\u003e mixInCls, AnnotatedMethodMap mixIns) {\n    List\u003cClass\u003c?\u003e\u003e ancestors \u003d new ArrayList\u003cClass\u003c?\u003e\u003e();\n    ancestors.add(mixInCls);\n    ClassUtil.findSuperTypes(mixInCls, targetClass, ancestors);\n    for (Class\u003c?\u003e blendInCls : ancestors) {\n        for (Method method : blendInCls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(method)) {\n                continue;\n            }\n            AnnotatedMethod annotatedMethod \u003d methods.find(method);\n            /* Do we already have a method to augment (from sub-class\n             * that will mask this mixIn)? If so, add if visible\n             * without masking (no such annotation)\n             */\n            if (null \u003d\u003d annotatedMethod) {\n                // Well, or, as per [Issue#515], multi-level merge within mixins...\n                mixIns.add(_constructMethod(method));\n            } else {\n                _addMixUnders(method, annotatedMethod);\n                /* Otherwise will have precedence, but must wait\n                 * until we find the real method (mixIn methods are\n                 * just placeholder, can\u0027t be called)\n                 */\n            }\n        }\n    }\n}",
  "Jsoup-89": "public String setValue(String val) {\n    String previousVal \u003d parent.get(this.key);\n    if (null !\u003d parent) {\n        int index \u003d parent.indexOfKey(this.key);\n        if (Attributes.NotFound !\u003d index)\n            parent.vals[index] \u003d val;\n    }\n    this.val \u003d val;\n    return Attributes.checkNotNull(previousVal);\n}",
  "JacksonDatabind-6": "protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    /* 21-May-2009, tatu: DateFormat has very strict handling of\n     * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n     */\n    /* First: do we have \"zulu\" format (\u0027Z\u0027 \u003d\u003d \"GMT\")? If yes, that\u0027s\n     * quite simple because we already set date format timezone to be\n     * GMT, and hence can just strip out \u0027Z\u0027 altogether\n     */\n    int length \u003d dateStr.length();\n    char lastChar \u003d dateStr.charAt(length - 1);\n    DateFormat dateFormat;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (10 \u003c length || !Character.isDigit(lastChar)) {\n        if (\u0027Z\u0027 !\u003d lastChar) {\n            // Let\u0027s see if we have timezone indicator or not...\n            if (!hasTimeZone(dateStr)) {\n                // If not, plain date. Easiest to just patch \u0027Z\u0027 in the end?\n                StringBuilder stringBuilder \u003d new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLength \u003d length - dateStr.lastIndexOf(\u0027T\u0027) - 1;\n                if (8 \u003e\u003d timeLength) {\n                    stringBuilder.append(\".000\");\n                }\n                stringBuilder.append(\u0027Z\u0027);\n                dateStr \u003d stringBuilder.toString();\n                dateFormat \u003d _formatISO8601_z;\n                if (null \u003d\u003d dateFormat) {\n                    dateFormat \u003d _formatISO8601_z \u003d _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n                }\n            } else {\n                lastChar \u003d dateStr.charAt(length - 3);\n                if (\u0027:\u0027 !\u003d lastChar) {\n                    if (\u0027+\u0027 \u003d\u003d lastChar || \u0027-\u0027 \u003d\u003d lastChar) {\n                        // missing minutes\n                        // let\u0027s just append \u002700\u0027\n                        dateStr +\u003d \"00\";\n                    }\n                } else {\n                    // remove optional colon\n                    // remove colon\n                    StringBuilder stringBuilder \u003d new StringBuilder(dateStr);\n                    stringBuilder.delete(length - 3, length - 2);\n                    dateStr \u003d stringBuilder.toString();\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                length \u003d dateStr.length();\n                // remove \u0027T\u0027, \u0027+\u0027/\u0027-\u0027 and 4-digit timezone-offset\n                lastChar \u003d dateStr.charAt(length - 9);\n                if (Character.isDigit(lastChar)) {\n                    StringBuilder stringBuilder \u003d new StringBuilder(dateStr);\n                    stringBuilder.insert(length - 5, \".000\");\n                    dateStr \u003d stringBuilder.toString();\n                }\n                dateFormat \u003d _formatISO8601;\n                if (null \u003d\u003d _formatISO8601) {\n                    dateFormat \u003d _formatISO8601 \u003d _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            }\n        } else {\n            dateFormat \u003d _formatISO8601_z;\n            if (null \u003d\u003d dateFormat) {\n                dateFormat \u003d _formatISO8601_z \u003d _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (\u0027:\u0027 \u003d\u003d dateStr.charAt(length - 4)) {\n                StringBuilder stringBuilder \u003d new StringBuilder(dateStr);\n                stringBuilder.insert(length - 1, \".000\");\n                dateStr \u003d stringBuilder.toString();\n            }\n        }\n    } else {\n        dateFormat \u003d _formatPlain;\n        if (null \u003d\u003d dateFormat) {\n            dateFormat \u003d _formatPlain \u003d _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    }\n    return dateFormat.parse(dateStr, pos);\n}",
  "Jsoup-88": "public String getValue() {\n    return val;\n}",
  "JacksonDatabind-1": "public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception {\n    Object data \u003d get(bean);\n    if (null \u003d\u003d data) {\n        // nulls need specialized handling\n        if (null \u003d\u003d _nullSerializer) {\n            // can NOT suppress entries in tabular output\n            jgen.writeNull();\n        } else {\n            _nullSerializer.serialize(null, jgen, prov);\n        }\n    }\n    // otherwise find serializer to use\n    JsonSerializer\u003cObject\u003e serializer \u003d _serializer;\n    if (null \u003d\u003d serializer) {\n        Class\u003c?\u003e clazz \u003d data.getClass();\n        PropertySerializerMap serializerMap \u003d _dynamicSerializers;\n        serializer \u003d serializerMap.serializerFor(clazz);\n        if (null \u003d\u003d serializer) {\n            serializer \u003d _findAndAddDynamic(serializerMap, clazz, prov);\n        }\n    }\n    // and then see if we must suppress certain values (default, empty)\n    if (null !\u003d _suppressableValue) {\n        if (_suppressableValue !\u003d MARKER_FOR_EMPTY) {\n            if (_suppressableValue.equals(data)) {\n                // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        } else {\n            if (serializer.isEmpty(data)) {\n                // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n    }\n    // For non-nulls: simple check for direct cycles\n    if (bean \u003d\u003d data) {\n        _handleSelfReference(bean, serializer);\n    }\n    if (null !\u003d _typeSerializer) {\n        serializer.serializeWithType(data, jgen, prov, _typeSerializer);\n    } else {\n        serializer.serialize(data, jgen, prov);\n    }\n}",
  "JacksonDatabind-70": "public void remove(SettableBeanProperty propToRm) {\n    ArrayList\u003cSettableBeanProperty\u003e properties \u003d new ArrayList\u003cSettableBeanProperty\u003e(_size);\n    String propertyName \u003d getPropertyName(propToRm);\n    boolean located \u003d false;\n    int index \u003d 1, limit \u003d _hashArea.length;\n    while (limit \u003e index) {\n        SettableBeanProperty property \u003d (SettableBeanProperty) _hashArea[index];\n        if (null \u003d\u003d property) {\n            continue;\n        }\n        if (!located) {\n            // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n            //   as only former is lower-case in case-insensitive case\n            located \u003d propertyName.equals(property.getName());\n            if (located) {\n                // need to leave a hole here\n                _propsInOrder[_findFromOrdered(property)] \u003d null;\n                continue;\n            }\n        }\n        properties.add(property);\n        index +\u003d 2;\n    }\n    if (!located) {\n        throw new NoSuchElementException(\"No entry \u0027\" + propToRm.getName() + \"\u0027 found, can\u0027t remove\");\n    }\n    init(properties);\n}",
  "JacksonDatabind-71": "public static StdKeyDeserializer forType(Class\u003c?\u003e raw) {\n    int type;\n    // first common types:\n    if (String.class !\u003d raw \u0026\u0026 Object.class !\u003d raw) {\n        if (UUID.class !\u003d raw) {\n            if (Integer.class !\u003d raw) {\n                if (Long.class !\u003d raw) {\n                    if (Date.class !\u003d raw) {\n                        if (Calendar.class !\u003d raw) {\n                            if (Boolean.class !\u003d raw) {\n                                if (Byte.class !\u003d raw) {\n                                    if (Character.class !\u003d raw) {\n                                        if (Short.class !\u003d raw) {\n                                            if (Float.class !\u003d raw) {\n                                                if (Double.class !\u003d raw) {\n                                                    if (URI.class !\u003d raw) {\n                                                        if (URL.class !\u003d raw) {\n                                                            if (Class.class !\u003d raw) {\n                                                                if (Locale.class !\u003d raw) {\n                                                                    if (Currency.class !\u003d raw) {\n                                                                        return null;\n                                                                    } else {\n                                                                        FromStringDeserializer\u003c?\u003e deserializer \u003d FromStringDeserializer.findDeserializer(Currency.class);\n                                                                        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deserializer);\n                                                                    }\n                                                                } else {\n                                                                    FromStringDeserializer\u003c?\u003e deserializer \u003d FromStringDeserializer.findDeserializer(Locale.class);\n                                                                    return new StdKeyDeserializer(TYPE_LOCALE, raw, deserializer);\n                                                                }\n                                                            } else {\n                                                                type \u003d TYPE_CLASS;\n                                                            }\n                                                        } else {\n                                                            type \u003d TYPE_URL;\n                                                        }\n                                                    } else {\n                                                        type \u003d TYPE_URI;\n                                                    }\n                                                } else {\n                                                    type \u003d TYPE_DOUBLE;\n                                                }\n                                            } else {\n                                                type \u003d TYPE_FLOAT;\n                                            }\n                                        } else {\n                                            type \u003d TYPE_SHORT;\n                                        }\n                                    } else {\n                                        type \u003d TYPE_CHAR;\n                                    }\n                                } else {\n                                    type \u003d TYPE_BYTE;\n                                }\n                            } else {\n                                type \u003d TYPE_BOOLEAN;\n                            }\n                        } else {\n                            type \u003d TYPE_CALENDAR;\n                            // then less common ones...\n                        }\n                    } else {\n                        type \u003d TYPE_DATE;\n                    }\n                } else {\n                    type \u003d TYPE_LONG;\n                }\n            } else {\n                type \u003d TYPE_INT;\n            }\n        } else {\n            type \u003d TYPE_UUID;\n        }\n    } else {\n        return StringKD.forType(raw);\n    }\n    return new StdKeyDeserializer(type, raw);\n}",
  "JacksonDatabind-74": "protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException {\n    // As per [JACKSON-614], may have default implementation to use\n    JsonDeserializer\u003cObject\u003e defaultDeserializer \u003d _findDefaultImplDeserializer(ctxt);\n    if (null !\u003d defaultDeserializer) {\n        if (null !\u003d tb) {\n            tb.writeEndObject();\n            p \u003d tb.asParser(p);\n            // must move to point to the first token:\n            p.nextToken();\n        }\n        return defaultDeserializer.deserialize(p, ctxt);\n    }\n    // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n    Object value \u003d TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n    if (null !\u003d value) {\n        return value;\n    }\n    // or, something for which \"as-property\" won\u0027t work, changed into \"wrapper-array\" type:\n    if (JsonToken.START_ARRAY \u003d\u003d p.getCurrentToken()) {\n        return super.deserializeTypedFromAny(p, ctxt);\n    }\n    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, \"missing property \u0027\" + _typePropertyName + \"\u0027 that is to contain type id  (for class \" + baseTypeName() + \")\");\n    return null;\n}",
  "JacksonDatabind-76": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final PropertyBasedCreator builder \u003d _propertyBasedCreator;\n    PropertyValueBuffer propertyValueStorage \u003d builder.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens \u003d new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken currentToken \u003d p.getCurrentToken();\n    while (JsonToken.FIELD_NAME \u003d\u003d currentToken) {\n        String fieldName \u003d p.getCurrentName();\n        // to point to value\n        p.nextToken();\n        // creator property?\n        SettableBeanProperty constructorProperty \u003d builder.findCreatorProperty(fieldName);\n        if (null !\u003d constructorProperty) {\n            if (propertyValueStorage.assignParameter(constructorProperty, constructorProperty.deserialize(p, ctxt))) {\n                currentToken \u003d p.nextToken();\n                Object instance;\n                try {\n                    instance \u003d builder.build(ctxt, propertyValueStorage);\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), fieldName, ctxt);\n                    continue;\n                }\n                while (JsonToken.FIELD_NAME \u003d\u003d currentToken) {\n                    p.nextToken();\n                    tokens.copyCurrentStructure(p);\n                    currentToken \u003d p.nextToken();\n                }\n                tokens.writeEndObject();\n                if (_beanType.getRawClass() !\u003d instance.getClass()) {\n                    ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, instance, tokens);\n            }\n            continue;\n        }\n        // Object Id property?\n        if (propertyValueStorage.readIdProperty(fieldName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty field \u003d _beanProperties.find(fieldName);\n        if (null !\u003d field) {\n            propertyValueStorage.bufferProperty(field, field.deserialize(p, ctxt));\n            continue;\n        }\n        if (null !\u003d _ignorableProps \u0026\u0026 _ignorableProps.contains(fieldName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), fieldName);\n            continue;\n        }\n        tokens.writeFieldName(fieldName);\n        tokens.copyCurrentStructure(p);\n        // \"any property\"?\n        if (null !\u003d _anySetter) {\n            propertyValueStorage.bufferAnyProperty(_anySetter, fieldName, _anySetter.deserialize(p, ctxt));\n        }\n        currentToken \u003d p.nextToken();\n    }\n    // We hit END_OBJECT, so:\n    Object instance;\n    // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n    try {\n        instance \u003d builder.build(ctxt, propertyValueStorage);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, instance, tokens);\n}",
  "Jsoup-90": "private static boolean looksLikeUtf8(byte[] input) {\n    int index \u003d 0;\n    // BOM:\n    if (3 \u003c\u003d input.length \u0026\u0026 0xEF \u003d\u003d (input[0] \u0026 0xFF) \u0026\u0026 0xBB \u003d\u003d (input[1] \u0026 0xFF) \u0026 0xBF \u003d\u003d (input[2] \u0026 0xFF)) {\n        index \u003d 3;\n    }\n    int limit;\n    int maxLength \u003d input.length;\n    while (maxLength \u003e index) {\n        int byteValue \u003d input[index];\n        if (0 \u003d\u003d (byteValue \u0026 0x80)) {\n            // ASCII\n            continue;\n        }\n        // UTF-8 leading:\n        if (0xC0 !\u003d (byteValue \u0026 0xE0)) {\n            if (0xE0 !\u003d (byteValue \u0026 0xF0)) {\n                if (0xF0 !\u003d (byteValue \u0026 0xF8)) {\n                    return false;\n                } else {\n                    limit \u003d index + 3;\n                }\n            } else {\n                limit \u003d index + 2;\n            }\n        } else {\n            limit \u003d index + 1;\n        }\n        while (limit \u003e index) {\n            index +\u003d 1;\n            byteValue \u003d input[index];\n            if (0x80 !\u003d (byteValue \u0026 0xC0)) {\n                return false;\n            }\n        }\n        ++index;\n    }\n    return true;\n}",
  "JacksonDatabind-77": "@Override\npublic JsonDeserializer\u003cObject\u003e createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig settings \u003d ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer\u003cObject\u003e overrideDeserializer \u003d _findCustomBeanDeserializer(type, settings, beanDesc);\n    if (null !\u003d overrideDeserializer) {\n        return overrideDeserializer;\n    }\n    /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() \u0026\u0026 !type.isPrimitive()) {\n        // Let\u0027s make it possible to materialize abstract types.\n        JavaType actualType \u003d materializeAbstractType(ctxt, type, beanDesc);\n        if (null !\u003d actualType) {\n            /* important: introspect actual implementation (abstract class or\n                 * interface doesn\u0027t have constructors, for one)\n                 */\n            beanDesc \u003d settings.introspect(actualType);\n            return buildBeanDeserializer(ctxt, actualType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer\u003cObject\u003e deserializer \u003d (JsonDeserializer\u003cObject\u003e) findStdDeserializer(ctxt, type, beanDesc);\n    if (null !\u003d deserializer) {\n        return deserializer;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}",
  "JacksonDatabind-78": "@Override\npublic JsonDeserializer\u003cObject\u003e createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig settings \u003d ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer\u003cObject\u003e overrideDeserializer \u003d _findCustomBeanDeserializer(type, settings, beanDesc);\n    if (null !\u003d overrideDeserializer) {\n        return overrideDeserializer;\n    }\n    /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() \u0026\u0026 !type.isPrimitive() \u0026\u0026 !type.isEnumType()) {\n        // Let\u0027s make it possible to materialize abstract types.\n        JavaType actualType \u003d materializeAbstractType(ctxt, type, beanDesc);\n        if (null !\u003d actualType) {\n            /* important: introspect actual implementation (abstract class or\n                 * interface doesn\u0027t have constructors, for one)\n                 */\n            beanDesc \u003d settings.introspect(actualType);\n            return buildBeanDeserializer(ctxt, actualType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer\u003cObject\u003e deserializer \u003d (JsonDeserializer\u003cObject\u003e) findStdDeserializer(ctxt, type, beanDesc);\n    if (null !\u003d deserializer) {\n        return deserializer;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}",
  "Jsoup-93": "public List\u003cConnection.KeyVal\u003e formData() {\n    ArrayList\u003cConnection.KeyVal\u003e formValues \u003d new ArrayList\u003c\u003e();\n    // iterate the form control elements and accumulate their values\n    for (Element element : elements) {\n        // contents are form listable, superset of submitable\n        if (!element.tag().isFormSubmittable())\n            continue;\n        // skip disabled form inputs\n        if (element.hasAttr(\"disabled\"))\n            continue;\n        String fieldName \u003d element.attr(\"name\");\n        if (0 \u003d\u003d fieldName.length())\n            continue;\n        String inputType \u003d element.attr(\"type\");\n        if (!\"select\".equals(element.normalName())) {\n            if (!\"checkbox\".equalsIgnoreCase(inputType) \u0026\u0026 !\"radio\".equalsIgnoreCase(inputType)) {\n                formValues.add(HttpConnection.KeyVal.create(fieldName, element.val()));\n            } else {\n                // only add checkbox or radio if they have the checked attribute\n                if (element.hasAttr(\"checked\")) {\n                    final String value \u003d 0 \u003c element.val().length() ? element.val() : \"on\";\n                    formValues.add(HttpConnection.KeyVal.create(fieldName, value));\n                }\n            }\n        } else {\n            Elements choices \u003d element.select(\"option[selected]\");\n            boolean isSet \u003d false;\n            for (Element elementOption : choices) {\n                formValues.add(HttpConnection.KeyVal.create(fieldName, elementOption.val()));\n                isSet \u003d true;\n            }\n            if (!isSet) {\n                Element elementOption \u003d element.select(\"option\").first();\n                if (null !\u003d elementOption)\n                    formValues.add(HttpConnection.KeyVal.create(fieldName, elementOption.val()));\n            }\n        }\n    }\n    return formValues;\n}",
  "Time-27": "private static PeriodFormatter toFormatter(List\u003cObject\u003e elementPairs, boolean notPrinter, boolean notParser) {\n    if (notPrinter \u0026\u0026 notParser) {\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    int count \u003d elementPairs.size();\n    if (2 \u003c\u003d count \u0026\u0026 elementPairs.get(0) instanceof Separator) {\n        Separator delimiter \u003d (Separator) elementPairs.get(0);\n        PeriodFormatter formatter \u003d toFormatter(elementPairs.subList(2, count), notPrinter, notParser);\n        delimiter \u003d delimiter.finish(formatter.getPrinter(), formatter.getParser());\n        return new PeriodFormatter(delimiter, delimiter);\n    }\n    Object[] composite \u003d createComposite(elementPairs);\n    if (!notPrinter) {\n        if (!notParser) {\n            return new PeriodFormatter((PeriodPrinter) composite[0], (PeriodParser) composite[1]);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) composite[0], null);\n        }\n    } else {\n        return new PeriodFormatter(null, (PeriodParser) composite[1]);\n    }\n}",
  "Time-24": "public long computeMillis(boolean resetFields, String text) {\n    SavedField[] recordedFields \u003d iSavedFields;\n    int size \u003d iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields \u003d recordedFields \u003d (SavedField[]) iSavedFields.clone();\n        iSavedFieldsShared \u003d false;\n    }\n    sort(recordedFields, size);\n    if (0 \u003c size) {\n        // alter base year for parsing if first field is month or day\n        DurationField durationMonths \u003d DurationFieldType.months().getField(iChrono);\n        DurationField durationDays \u003d DurationFieldType.days().getField(iChrono);\n        DurationField initial \u003d recordedFields[0].iField.getDurationField();\n        if (0 \u003c\u003d compareReverse(initial, durationMonths) \u0026\u0026 0 \u003e\u003d compareReverse(initial, durationDays)) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n    long timeInMillis \u003d iMillis;\n    try {\n        int index \u003d 0;\n        while (size \u003e index) {\n            timeInMillis \u003d recordedFields[index].set(timeInMillis, resetFields);\n            index +\u003d 1;\n        }\n    } catch (IllegalFieldValueException e) {\n        if (null !\u003d text) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + \u0027\"\u0027);\n        }\n        throw e;\n    }\n    if (null !\u003d iZone) {\n        int delta \u003d iZone.getOffsetFromLocal(timeInMillis);\n        timeInMillis -\u003d delta;\n        if (iZone.getOffset(timeInMillis) !\u003d delta) {\n            String errorMessage \u003d \"Illegal instant due to time zone offset transition (\" + iZone + \u0027)\u0027;\n            if (null !\u003d text) {\n                errorMessage \u003d \"Cannot parse \\\"\" + text + \"\\\": \" + errorMessage;\n            }\n            throw new IllegalArgumentException(errorMessage);\n        }\n    } else {\n        timeInMillis -\u003d iOffset;\n    }\n    return timeInMillis;\n}",
  "Time-25": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetEstimated \u003d getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantRevised \u003d instantLocal - offsetEstimated;\n    final int offsetRecalculated \u003d getOffset(instantRevised);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetRecalculated !\u003d offsetEstimated) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if (0 \u003e (offsetEstimated - offsetRecalculated)) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextTransitionLocal \u003d nextTransition(instantRevised);\n            long nextTransitionAdjusted \u003d nextTransition(instantLocal - offsetRecalculated);\n            if (nextTransitionAdjusted !\u003d nextTransitionLocal) {\n                return offsetEstimated;\n            }\n        }\n    }\n    return offsetRecalculated;\n}",
  "Time-22": "protected BasePeriod(long duration) {\n    this(duration, null, null);\n    // bug [3264409]\n}",
  "Time-23": "private static synchronized String getConvertedId(String id) {\n    Map\u003cString, String\u003e conversionMap \u003d cZoneIdConversion;\n    if (null \u003d\u003d conversionMap) {\n        // Backwards compatibility with TimeZone.\n        conversionMap \u003d new HashMap\u003cString, String\u003e();\n        conversionMap.put(\"GMT\", \"UTC\");\n        conversionMap.put(\"MIT\", \"Pacific/Apia\");\n        // JDK 1.1 compatible\n        conversionMap.put(\"HST\", \"Pacific/Honolulu\");\n        conversionMap.put(\"AST\", \"America/Anchorage\");\n        conversionMap.put(\"PST\", \"America/Los_Angeles\");\n        // JDK 1.1 compatible\n        conversionMap.put(\"MST\", \"America/Denver\");\n        conversionMap.put(\"PNT\", \"America/Phoenix\");\n        conversionMap.put(\"CST\", \"America/Chicago\");\n        // JDK 1.1 compatible\n        conversionMap.put(\"EST\", \"America/New_York\");\n        conversionMap.put(\"IET\", \"America/Indianapolis\");\n        conversionMap.put(\"PRT\", \"America/Puerto_Rico\");\n        conversionMap.put(\"CNT\", \"America/St_Johns\");\n        conversionMap.put(\"AGT\", \"America/Buenos_Aires\");\n        conversionMap.put(\"BET\", \"America/Sao_Paulo\");\n        conversionMap.put(\"WET\", \"Europe/London\");\n        conversionMap.put(\"ECT\", \"Europe/Paris\");\n        conversionMap.put(\"ART\", \"Africa/Cairo\");\n        conversionMap.put(\"CAT\", \"Africa/Harare\");\n        conversionMap.put(\"EET\", \"Europe/Bucharest\");\n        conversionMap.put(\"EAT\", \"Africa/Addis_Ababa\");\n        conversionMap.put(\"MET\", \"Asia/Tehran\");\n        conversionMap.put(\"NET\", \"Asia/Yerevan\");\n        conversionMap.put(\"PLT\", \"Asia/Karachi\");\n        conversionMap.put(\"IST\", \"Asia/Calcutta\");\n        conversionMap.put(\"BST\", \"Asia/Dhaka\");\n        conversionMap.put(\"VST\", \"Asia/Saigon\");\n        conversionMap.put(\"CTT\", \"Asia/Shanghai\");\n        conversionMap.put(\"JST\", \"Asia/Tokyo\");\n        conversionMap.put(\"ACT\", \"Australia/Darwin\");\n        conversionMap.put(\"AET\", \"Australia/Sydney\");\n        conversionMap.put(\"SST\", \"Pacific/Guadalcanal\");\n        conversionMap.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion \u003d conversionMap;\n    }\n    return conversionMap.get(id);\n}",
  "JacksonDatabind-60": "@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException {\n    // Regardless of other parts, first need to find value to serialize:\n    Object data \u003d null;\n    try {\n        data \u003d _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (null \u003d\u003d data) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer\u003cObject\u003e serializer \u003d _valueSerializer;\n        if (null !\u003d serializer) {\n            /* 09-Dec-2010, tatu: To work around natural type\u0027s refusal to add type info, we do\n                 *    this (note: type is for the wrapper type, not enclosed value!)\n                 */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                serializer.serialize(data, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        } else {\n            // no serializer yet? Need to fetch\n            //                ser \u003d provider.findTypedValueSerializer(value.getClass(), true, _property);\n            serializer \u003d provider.findValueSerializer(data.getClass(), _property);\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegat type).\n        serializer.serializeWithType(data, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable exceptionThrown \u003d e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (exceptionThrown instanceof InvocationTargetException \u0026\u0026 null !\u003d exceptionThrown.getCause()) {\n            exceptionThrown \u003d exceptionThrown.getCause();\n        }\n        // Errors shouldn\u0027t be wrapped (and often can\u0027t, as well)\n        if (exceptionThrown instanceof Error) {\n            throw (Error) exceptionThrown;\n        }\n        // let\u0027s try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(exceptionThrown, bean, _accessorMethod.getName() + \"()\");\n    }\n}",
  "JacksonDatabind-62": "public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer\u003cObject\u003e delegateDeserializer \u003d null;\n    if (null !\u003d _valueInstantiator) {\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateClass \u003d _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (null \u003d\u003d delegateClass) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \" + _collectionType + \": value instantiator (\" + _valueInstantiator.getClass().getName() + \") returned true for \u0027canCreateUsingDelegate()\u0027, but null for \u0027getDelegateType()\u0027\");\n            }\n            delegateDeserializer \u003d findDeserializer(ctxt, delegateClass, property);\n        }\n    }\n    // [databind#1043]: allow per-property allow-wrapping of single overrides:\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean acceptSingleValueAsArray \u003d findFormatFeature(ctxt, property, Collection.class, JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    // also, often value deserializer is resolved here:\n    JsonDeserializer\u003c?\u003e contentDeserializer \u003d _valueDeserializer;\n    // May have a content converter\n    contentDeserializer \u003d findConvertingContentDeserializer(ctxt, property, contentDeserializer);\n    final JavaType contentType \u003d _collectionType.getContentType();\n    if (null !\u003d contentDeserializer) {\n        // if directly assigned, probably not yet contextual, so:\n        contentDeserializer \u003d ctxt.handleSecondaryContextualization(contentDeserializer, property, contentType);\n    } else {\n        contentDeserializer \u003d ctxt.findContextualValueDeserializer(contentType, property);\n    }\n    // and finally, type deserializer needs context as well\n    TypeDeserializer valueTypeDeserializer \u003d _valueTypeDeserializer;\n    if (null !\u003d valueTypeDeserializer) {\n        valueTypeDeserializer \u003d valueTypeDeserializer.forProperty(property);\n    }\n    return withResolved(delegateDeserializer, contentDeserializer, valueTypeDeserializer, acceptSingleValueAsArray);\n}",
  "JacksonDatabind-63": "public String getDescription() {\n    if (null \u003d\u003d _desc) {\n        StringBuilder stringBuilder \u003d new StringBuilder();\n        if (null !\u003d _from) {\n            Class\u003c?\u003e cls \u003d (_from instanceof Class\u003c?\u003e) ? (Class\u003c?\u003e) _from : _from.getClass();\n            // Hmmh. Although Class.getName() is mostly ok, it does look\n            // butt-ugly for arrays.\n            // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n            //   as it drops enclosing class. So let\u0027s try bit different approach\n            String packageName \u003d ClassUtil.getPackageName(cls);\n            if (null !\u003d packageName) {\n                stringBuilder.append(packageName);\n                stringBuilder.append(\u0027.\u0027);\n            }\n            stringBuilder.append(cls.getSimpleName());\n        } else {\n            // can this ever occur?\n            stringBuilder.append(\"UNKNOWN\");\n        }\n        stringBuilder.append(\u0027[\u0027);\n        if (null \u003d\u003d _fieldName) {\n            if (0 \u003e _index) {\n                stringBuilder.append(\u0027?\u0027);\n            } else {\n                stringBuilder.append(_index);\n            }\n        } else {\n            stringBuilder.append(\u0027\"\u0027);\n            stringBuilder.append(_fieldName);\n            stringBuilder.append(\u0027\"\u0027);\n        }\n        stringBuilder.append(\u0027]\u0027);\n        _desc \u003d stringBuilder.toString();\n    }\n    return _desc;\n}",
  "JacksonDatabind-64": "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer\u003c?\u003e ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType typeToSerialize;\n    try {\n        typeToSerialize \u003d findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n    // Container types can have separate type serializers for content (value / element) type\n    if (null !\u003d contentTypeSer) {\n        /* 04-Feb-2010, tatu: Let\u0027s force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (null \u003d\u003d typeToSerialize) {\n            typeToSerialize \u003d TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            typeToSerialize \u003d declaredType;\n        }\n        JavaType contentType \u003d typeToSerialize.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (null \u003d\u003d contentType) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef, \"serialization type \" + typeToSerialize + \" has no content\");\n        }\n        typeToSerialize \u003d typeToSerialize.withContentTypeHandler(contentTypeSer);\n        contentType \u003d typeToSerialize.getContentType();\n    }\n    Object defaultValueToSuppress \u003d null;\n    boolean omitNulls \u003d false;\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType resolvedType \u003d (null \u003d\u003d typeToSerialize) ? declaredType : typeToSerialize;\n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclusionValue \u003d _config.getDefaultPropertyInclusion(resolvedType.getRawClass(), _defaultInclusion);\n    // property annotation override\n    inclusionValue \u003d inclusionValue.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion \u003d inclusionValue.getValueInclusion();\n    if (JsonInclude.Include.USE_DEFAULTS \u003d\u003d inclusion) {\n        // should not occur but...\n        inclusion \u003d JsonInclude.Include.ALWAYS;\n    }\n    switch(inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (!_useRealPropertyDefaults) {\n                defaultValueToSuppress \u003d getDefaultValue(resolvedType);\n                omitNulls \u003d true;\n            } else {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                defaultValueToSuppress \u003d getPropertyDefaultValue(propDef.getName(), am, resolvedType);\n            }\n            if (null !\u003d defaultValueToSuppress) {\n                if (defaultValueToSuppress.getClass().isArray()) {\n                    defaultValueToSuppress \u003d ArrayBuilders.getArrayComparator(defaultValueToSuppress);\n                }\n            } else {\n                omitNulls \u003d true;\n            }\n            break;\n        case // new with 2.6, to support Guava/JDK8 Optionals\n        NON_ABSENT:\n            // always suppress nulls\n            omitNulls \u003d true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (resolvedType.isReferenceType()) {\n                defaultValueToSuppress \u003d BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            omitNulls \u003d true;\n            // but possibly also \u0027empty\u0027 values:\n            defaultValueToSuppress \u003d BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            omitNulls \u003d true;\n        // fall through\n        // default\n        case ALWAYS:\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (resolvedType.isContainerType() \u0026\u0026 !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                defaultValueToSuppress \u003d BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n    }\n    BeanPropertyWriter beanPropertyWriter \u003d new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, typeToSerialize, omitNulls, defaultValueToSuppress);\n    // How about custom null serializer?\n    Object nullSerializerDefinition \u003d _annotationIntrospector.findNullSerializer(am);\n    if (null !\u003d nullSerializerDefinition) {\n        beanPropertyWriter.assignNullSerializer(prov.serializerInstance(am, nullSerializerDefinition));\n    }\n    // And then, handling of unwrapping\n    NameTransformer nameTransformer \u003d _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (null !\u003d nameTransformer) {\n        beanPropertyWriter \u003d beanPropertyWriter.unwrappingWriter(nameTransformer);\n    }\n    return beanPropertyWriter;\n}",
  "JacksonDatabind-66": "@SuppressWarnings(\"resource\")\n@Override\npublic final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (null \u003d\u003d key) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        // Ugh... should not have to give parser which may or may not be correct one...\n        Object outcome \u003d _delegate.deserialize(ctxt.getParser(), ctxt);\n        if (null !\u003d outcome) {\n            return outcome;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n    }\n}",
  "JacksonDatabind-67": "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n    final DeserializationConfig config \u003d ctxt.getConfig();\n    KeyDeserializer keyDeserializer \u003d null;\n    if (_factoryConfig.hasKeyDeserializers()) {\n        BeanDescription classDescription \u003d config.introspectClassAnnotations(type.getRawClass());\n        for (KeyDeserializers d : _factoryConfig.keyDeserializers()) {\n            keyDeserializer \u003d d.findKeyDeserializer(type, config, classDescription);\n            if (null !\u003d keyDeserializer) {\n                break;\n            }\n        }\n    }\n    // the only non-standard thing is this:\n    if (null \u003d\u003d keyDeserializer) {\n        if (type.isEnumType()) {\n            return _createEnumKeyDeserializer(ctxt, type);\n        }\n        keyDeserializer \u003d StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n    }\n    // and then post-processing\n    if (null !\u003d keyDeserializer) {\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier modifier : _factoryConfig.deserializerModifiers()) {\n                keyDeserializer \u003d modifier.modifyKeyDeserializer(config, type, keyDeserializer);\n            }\n        }\n    }\n    return keyDeserializer;\n}",
  "Time-17": "public long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long previousInstant \u003d convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long adjustedInstant \u003d convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (adjustedInstant \u003d\u003d previousInstant) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long localTime \u003d convertUTCToLocal(instant);\n    return convertLocalToUTC(localTime, false, earlierOrLater ? adjustedInstant : previousInstant);\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}",
  "Time-18": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\n    Chronology reference;\n    if (null !\u003d (reference \u003d getBase())) {\n        return reference.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n    // Assume date is Gregorian.\n    long timestamp;\n    timestamp \u003d iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    if (iCutoverMillis \u003e timestamp) {\n        // Maybe it\u0027s Julian.\n        timestamp \u003d iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (iCutoverMillis \u003c\u003d timestamp) {\n            // Okay, it\u0027s in the illegal cutover gap.\n            throw new IllegalArgumentException(\"Specified date does not exist\");\n        }\n    }\n    return timestamp;\n}",
  "Time-15": "public static long safeMultiply(long val1, int val2) {\n    switch(val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n    }\n    long result \u003d val1 * val2;\n    if (val1 !\u003d result / val2) {\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return result;\n}",
  "Time-16": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser dateTimeParser \u003d requireParser();\n    if (null \u003d\u003d instant) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long epochMillis \u003d instant.getMillis();\n    Chronology calendar \u003d instant.getChronology();\n    long instantTimestamp \u003d epochMillis + calendar.getZone().getOffset(epochMillis);\n    calendar \u003d selectChronology(calendar);\n    DateTimeParserBucket context \u003d new DateTimeParserBucket(instantTimestamp, calendar, iLocale, iPivotYear, iDefaultYear);\n    int parsedPosition \u003d dateTimeParser.parseInto(context, text, position);\n    instant.setMillis(context.computeMillis(false, text));\n    if (!iOffsetParsed || null \u003d\u003d context.getOffsetInteger()) {\n        if (null !\u003d context.getZone()) {\n            calendar \u003d calendar.withZone(context.getZone());\n        }\n    } else {\n        int offsetValue \u003d context.getOffsetInteger();\n        DateTimeZone parsedTimeZone \u003d DateTimeZone.forOffsetMillis(offsetValue);\n        calendar \u003d calendar.withZone(parsedTimeZone);\n    }\n    instant.setChronology(calendar);\n    if (null !\u003d iZone) {\n        instant.setZone(iZone);\n    }\n    return parsedPosition;\n}",
  "Time-14": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can\u0027t handle\n    // 2004-02-29 + 48 months -\u003e 2008-02-29 type dates\n    if (0 \u003d\u003d valueToAdd) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (!DateTimeUtils.isContiguous(partial)) {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    } else {\n        long timestamp \u003d 0L;\n        int index \u003d 0, length \u003d partial.size();\n        while (length \u003e index) {\n            timestamp \u003d partial.getFieldType(index).getField(iChronology).set(timestamp, values[index]);\n            index +\u003d 1;\n        }\n        timestamp \u003d add(timestamp, valueToAdd);\n        return iChronology.get(partial, timestamp);\n    }\n}",
  "Csv-5": "public void println() throws IOException {\n    final String lineSeparator \u003d format.getRecordSeparator();\n    out.append(lineSeparator);\n    newRecord \u003d true;\n}",
  "Csv-6": "\u003cM extends Map\u003cString, String\u003e\u003e M putIn(final M map) {\n    for (final Entry\u003cString, Integer\u003e pair : mapping.entrySet()) {\n        final int index \u003d pair.getValue().intValue();\n        map.put(pair.getKey(), values[index]);\n    }\n    return map;\n}",
  "Csv-3": "int readEscape() throws IOException {\n    // the escape char has just been read (normally a backslash)\n    final int escapeChar \u003d in.read();\n    switch(escapeChar) {\n        case \u0027r\u0027:\n            return CR;\n        case \u0027n\u0027:\n            return LF;\n        case \u0027t\u0027:\n            return TAB;\n        case \u0027b\u0027:\n            return BACKSPACE;\n        case \u0027f\u0027:\n            return FF;\n        case CR:\n        case LF:\n        // TODO is this correct?\n        case FF:\n        // TODO is this correct? Do tabs need to be escaped?\n        case TAB:\n        case // TODO is this correct?\n        BACKSPACE:\n            return escapeChar;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            return escapeChar;\n    }\n}",
  "Csv-4": "public Map\u003cString, Integer\u003e getHeaderMap() {\n    return new LinkedHashMap\u003cString, Integer\u003e(this.headerMap);\n}",
  "Csv-1": "public int read() throws IOException {\n    int charRead \u003d super.read();\n    if (\u0027\\n\u0027 \u003d\u003d charRead) {\n        lineCounter +\u003d 1;\n    }\n    lastChar \u003d charRead;\n    return lastChar;\n}",
  "Csv-2": "public String get(final String name) {\n    if (null \u003d\u003d mapping) {\n        throw new IllegalStateException(\"No header mapping was specified, the record values can\u0027t be accessed by name\");\n    }\n    final Integer position \u003d mapping.get(name);\n    return null !\u003d position ? values[position.intValue()] : null;\n}",
  "Time-19": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int estimatedOffset \u003d getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantCorrected \u003d instantLocal - estimatedOffset;\n    final int offsetCorrected \u003d getOffset(instantCorrected);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetCorrected \u003d\u003d estimatedOffset) {\n        if (0 \u003c estimatedOffset) {\n            long lastTransition \u003d previousTransition(instantCorrected);\n            if (instantCorrected \u003e lastTransition) {\n                int offsetPrevious \u003d getOffset(lastTransition);\n                int change \u003d offsetPrevious - estimatedOffset;\n                if (change \u003e\u003d instantCorrected - lastTransition) {\n                    return offsetPrevious;\n                }\n            }\n        }\n    } else {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if (0 \u003e (estimatedOffset - offsetCorrected)) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long upcomingLocal \u003d nextTransition(instantCorrected);\n            long nextTransitionAdjusted \u003d nextTransition(instantLocal - offsetCorrected);\n            if (nextTransitionAdjusted !\u003d upcomingLocal) {\n                return estimatedOffset;\n            }\n        }\n    }\n    return offsetCorrected;\n}",
  "JacksonDatabind-50": "@Override\n@SuppressWarnings(\"resource\")\nprotected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt) throws IOException {\n    final PropertyBasedCreator builder \u003d _propertyBasedCreator;\n    PropertyValueBuffer holder \u003d builder.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer extraProperties \u003d null;\n    JsonToken token \u003d p.getCurrentToken();\n    while (JsonToken.FIELD_NAME \u003d\u003d token) {\n        String propertyName \u003d p.getCurrentName();\n        // to point to value\n        p.nextToken();\n        // creator property?\n        SettableBeanProperty constructorProperty \u003d builder.findCreatorProperty(propertyName);\n        if (null !\u003d constructorProperty) {\n            // Last creator property to set?\n            if (holder.assignParameter(constructorProperty, _deserializeWithErrorWrapping(p, ctxt, constructorProperty))) {\n                // to move to following FIELD_NAME/END_OBJECT\n                p.nextToken();\n                Object instance;\n                try {\n                    instance \u003d builder.build(ctxt, holder);\n                } catch (Exception e) {\n                    instance \u003d wrapInstantiationProblem(e, ctxt);\n                }\n                if (null \u003d\u003d instance) {\n                    return ctxt.handleInstantiationProblem(handledType(), null, _creatorReturnedNullException());\n                }\n                // [databind#631]: Assign current value, to be accessible by custom serializers\n                p.setCurrentValue(instance);\n                //  polymorphic?\n                if (_beanType.getRawClass() !\u003d instance.getClass()) {\n                    return handlePolymorphic(p, ctxt, instance, extraProperties);\n                }\n                if (null !\u003d extraProperties) {\n                    // nope, just extra unknown stuff...\n                    instance \u003d handleUnknownProperties(ctxt, instance, extraProperties);\n                }\n                // or just clean?\n                return deserialize(p, ctxt, instance);\n            }\n            continue;\n        }\n        // Object Id property?\n        if (holder.readIdProperty(propertyName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty property \u003d _beanProperties.find(propertyName);\n        if (null !\u003d property) {\n            holder.bufferProperty(property, _deserializeWithErrorWrapping(p, ctxt, property));\n            // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n            //    handling of forward references here. Not exactly sure why existing\n            //    facilities did not cover, but this does appear to solve the problem\n            continue;\n        }\n        // Things marked as ignorable should not be passed to any setter\n        if (null !\u003d _ignorableProps \u0026\u0026 _ignorableProps.contains(propertyName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propertyName);\n            continue;\n        }\n        // \"any property\"?\n        if (null !\u003d _anySetter) {\n            try {\n                holder.bufferAnyProperty(_anySetter, propertyName, _anySetter.deserialize(p, ctxt));\n            } catch (Exception e) {\n                wrapAndThrow(e, _beanType.getRawClass(), propertyName, ctxt);\n            }\n            continue;\n        }\n        // Ok then, let\u0027s collect the whole field; name and value\n        if (null \u003d\u003d extraProperties) {\n            extraProperties \u003d new TokenBuffer(p, ctxt);\n        }\n        extraProperties.writeFieldName(propertyName);\n        extraProperties.copyCurrentStructure(p);\n        token \u003d p.nextToken();\n    }\n    // We hit END_OBJECT, so:\n    Object instance;\n    try {\n        instance \u003d builder.build(ctxt, holder);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        // never gets here\n        instance \u003d null;\n    }\n    if (null !\u003d extraProperties) {\n        // polymorphic?\n        if (_beanType.getRawClass() !\u003d instance.getClass()) {\n            return handlePolymorphic(null, ctxt, instance, extraProperties);\n        }\n        // no, just some extra unknown properties\n        return handleUnknownProperties(ctxt, instance, extraProperties);\n    }\n    return instance;\n}",
  "JacksonDatabind-51": "protected final JsonDeserializer\u003cObject\u003e _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer\u003cObject\u003e deserializer \u003d _deserializers.get(typeId);\n    if (null \u003d\u003d deserializer) {\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let\u0027s start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType kind \u003d _idResolver.typeFromId(ctxt, typeId);\n        if (null !\u003d kind) {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change \u0027type class\u0027 (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((null !\u003d _baseType) \u0026\u0026 kind.getClass() \u003d\u003d _baseType.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                kind \u003d ctxt.getTypeFactory().constructSpecializedType(_baseType, kind.getRawClass());\n            }\n            deserializer \u003d ctxt.findContextualValueDeserializer(kind, _property);\n        } else {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deserializer \u003d _findDefaultImplDeserializer(ctxt);\n            if (null \u003d\u003d deserializer) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType genuine \u003d _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (null \u003d\u003d genuine) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deserializer \u003d ctxt.findContextualValueDeserializer(genuine, _property);\n            }\n        }\n        _deserializers.put(typeId, deserializer);\n    }\n    return deserializer;\n}",
  "JacksonDatabind-54": "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer\u003c?\u003e ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType dataSerializationType \u003d findSerializationType(am, defaultUseStaticTyping, declaredType);\n    // Container types can have separate type serializers for content (value / element) type\n    if (null !\u003d contentTypeSer) {\n        /* 04-Feb-2010, tatu: Let\u0027s force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (null \u003d\u003d dataSerializationType) {\n            dataSerializationType \u003d TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            dataSerializationType \u003d declaredType;\n        }\n        JavaType contentType \u003d dataSerializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (null \u003d\u003d contentType) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property \u0027\" + propDef.getName() + \"\u0027 (of type \" + _beanDesc.getType() + \"); serialization type \" + dataSerializationType + \" has no content\");\n        }\n        dataSerializationType \u003d dataSerializationType.withContentTypeHandler(contentTypeSer);\n        contentType \u003d dataSerializationType.getContentType();\n    }\n    Object defaultValueToSuppress \u003d null;\n    boolean omitNulls \u003d false;\n    JsonInclude.Value inclusionConfig \u003d _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusionValue \u003d inclusionConfig.getValueInclusion();\n    if (JsonInclude.Include.USE_DEFAULTS \u003d\u003d inclusionValue) {\n        // should not occur but...\n        inclusionValue \u003d JsonInclude.Include.ALWAYS;\n    }\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType inferredType \u003d (null \u003d\u003d dataSerializationType) ? declaredType : dataSerializationType;\n    switch(inclusionValue) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (JsonInclude.Include.NON_DEFAULT !\u003d _defaultInclusion.getValueInclusion()) {\n                defaultValueToSuppress \u003d getDefaultValue(inferredType);\n            } else {\n                defaultValueToSuppress \u003d getPropertyDefaultValue(propDef.getName(), am, inferredType);\n            }\n            if (null !\u003d defaultValueToSuppress) {\n                if (defaultValueToSuppress.getClass().isArray()) {\n                    defaultValueToSuppress \u003d ArrayBuilders.getArrayComparator(defaultValueToSuppress);\n                }\n            } else {\n                omitNulls \u003d true;\n            }\n            break;\n        case // new with 2.6, to support Guava/JDK8 Optionals\n        NON_ABSENT:\n            // always suppress nulls\n            omitNulls \u003d true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (declaredType.isReferenceType()) {\n                defaultValueToSuppress \u003d BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            omitNulls \u003d true;\n            // but possibly also \u0027empty\u0027 values:\n            defaultValueToSuppress \u003d BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            omitNulls \u003d true;\n        // fall through\n        // default\n        case ALWAYS:\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (declaredType.isContainerType() \u0026\u0026 !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                defaultValueToSuppress \u003d BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n    }\n    BeanPropertyWriter propertyWriter \u003d new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, dataSerializationType, omitNulls, defaultValueToSuppress);\n    // How about custom null serializer?\n    Object nullSerializerDef \u003d _annotationIntrospector.findNullSerializer(am);\n    if (null !\u003d nullSerializerDef) {\n        propertyWriter.assignNullSerializer(prov.serializerInstance(am, nullSerializerDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer nameTransformer \u003d _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (null !\u003d nameTransformer) {\n        propertyWriter \u003d propertyWriter.unwrappingWriter(nameTransformer);\n    }\n    return propertyWriter;\n}",
  "JacksonDatabind-55": "@SuppressWarnings(\"unchecked\")\npublic static JsonSerializer\u003cObject\u003e getFallbackKeySerializer(SerializationConfig config, Class\u003c?\u003e rawKeyType) {\n    if (null !\u003d rawKeyType) {\n        // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure\n        //   if that is a bug or feature. Regardless, it seems to require dynamic handling\n        //   (compared to getting actual fully typed Enum).\n        //  Note that this might even work from the earlier point, but let\u0027s play it safe for now\n        // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because\n        //    then there is no static type\n        if (Enum.class \u003d\u003d rawKeyType) {\n            return new Dynamic();\n        }\n        if (rawKeyType.isEnum()) {\n            return new Default(Default.TYPE_ENUM, rawKeyType);\n        }\n    }\n    return DEFAULT_KEY_SERIALIZER;\n}",
  "Csv-9": "\u003cM extends Map\u003cString, String\u003e\u003e M putIn(final M map) {\n    for (final Entry\u003cString, Integer\u003e element : mapping.entrySet()) {\n        final int index \u003d element.getValue().intValue();\n        if (values.length \u003e index) {\n            map.put(element.getKey(), values[index]);\n        }\n    }\n    return map;\n}",
  "JacksonDatabind-56": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int index \u003d value.indexOf(\u0027_\u0027);\n                if (0 \u003e index) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String initial \u003d value.substring(0, index);\n                value \u003d value.substring(index + 1);\n                index \u003d value.indexOf(\u0027_\u0027);\n                if (0 \u003e index) {\n                    // two pieces\n                    return new Locale(initial, value);\n                }\n                String nextPart \u003d value.substring(0, index);\n                return new Locale(initial, nextPart, value.substring(index + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (!value.startsWith(\"[\")) {\n                int index \u003d value.indexOf(\u0027:\u0027);\n                if (0 \u003c\u003d index \u0026\u0026 0 \u003e value.indexOf(\u0027:\u0027, index + 1)) {\n                    // host:port\n                    int socketPort \u003d Integer.parseInt(value.substring(index + 1));\n                    return new InetSocketAddress(value.substring(0, index), socketPort);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            } else {\n                // bracketed IPv6 (with port number)\n                int lastIndex \u003d value.lastIndexOf(\u0027]\u0027);\n                if (-1 \u003d\u003d lastIndex) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int portSeparatorIndex \u003d value.indexOf(\u0027:\u0027, lastIndex);\n                int socketPort \u003d -1 \u003c portSeparatorIndex ? Integer.parseInt(value.substring(portSeparatorIndex + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, lastIndex + 1), socketPort);\n            }\n    }\n    throw new IllegalArgumentException();\n}",
  "JacksonDatabind-57": "public \u003cT\u003e MappingIterator\u003cT\u003e readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException {\n    if (null !\u003d _dataFormatReaders) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n}",
  "JacksonDatabind-58": "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, JavaType propType0) throws JsonMappingException {\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember accessor \u003d propDef.getNonConstructorMutator();\n    if (ctxt.canOverrideAccessModifiers()) {\n        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        // !!! NOTE: should be handled better for 2.8 and later\n        accessor.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n    }\n    // note: this works since we know there\u0027s exactly one argument for methods\n    BeanProperty.Std attribute \u003d new BeanProperty.Std(propDef.getFullName(), propType0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), accessor, propDef.getMetadata());\n    JavaType dataType \u003d resolveType(ctxt, beanDesc, propType0, accessor);\n    // did type change?\n    if (propType0 !\u003d dataType) {\n        attribute \u003d attribute.withType(dataType);\n    }\n    // First: does the Method specify the deserializer to use? If so, let\u0027s use it.\n    JsonDeserializer\u003cObject\u003e propertyDeserializer \u003d findDeserializerFromAnnotation(ctxt, accessor);\n    dataType \u003d modifyTypeByAnnotation(ctxt, accessor, dataType);\n    TypeDeserializer typeDeserializer \u003d dataType.getTypeHandler();\n    SettableBeanProperty prop;\n    if (!(accessor instanceof AnnotatedMethod)) {\n        prop \u003d new FieldProperty(propDef, dataType, typeDeserializer, beanDesc.getClassAnnotations(), (AnnotatedField) accessor);\n    } else {\n        prop \u003d new MethodProperty(propDef, dataType, typeDeserializer, beanDesc.getClassAnnotations(), (AnnotatedMethod) accessor);\n    }\n    if (null !\u003d propertyDeserializer) {\n        prop \u003d prop.withValueDeserializer(propertyDeserializer);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty reference \u003d propDef.findReferenceType();\n    if (null !\u003d reference \u0026\u0026 reference.isManagedReference()) {\n        prop.setManagedReferenceName(reference.getName());\n    }\n    ObjectIdInfo objectIdentityInfo \u003d propDef.findObjectIdInfo();\n    if (null !\u003d objectIdentityInfo) {\n        prop.setObjectIdInfo(objectIdentityInfo);\n    }\n    return prop;\n}",
  "Csv-7": "private Map\u003cString, Integer\u003e initializeHeader() throws IOException {\n    Map\u003cString, Integer\u003e headerIndexMap \u003d null;\n    final String[] headerFormat \u003d this.format.getHeader();\n    if (null !\u003d headerFormat) {\n        headerIndexMap \u003d new LinkedHashMap\u003cString, Integer\u003e();\n        String[] columns \u003d null;\n        if (0 !\u003d headerFormat.length) {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            columns \u003d headerFormat;\n        } else {\n            // read the header from the first line of the file\n            final CSVRecord nextCSVRecord \u003d this.nextRecord();\n            if (null !\u003d nextCSVRecord) {\n                columns \u003d nextCSVRecord.values();\n            }\n        }\n        // build the name to index mappings\n        if (null !\u003d columns) {\n            int index \u003d 0;\n            while (columns.length \u003e index) {\n                headerIndexMap.put(columns[index], Integer.valueOf(index));\n                index +\u003d 1;\n            }\n        }\n    }\n    return headerIndexMap;\n}",
  "Time-20": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n    String substringText \u003d text.substring(position);\n    for (String identifier : ALL_IDS) {\n        if (substringText.startsWith(identifier)) {\n            bucket.setZone(DateTimeZone.forID(identifier));\n            return position + identifier.length();\n        }\n    }\n    return ~position;\n}",
  "JacksonDatabind-42": "protected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (STD_URI \u003d\u003d _kind) {\n        return URI.create(\"\");\n    }\n    // As per [databind#1123], Locale too\n    return super._deserializeFromEmptyString();\n}",
  "Math-48": "protected final double doSolve() {\n    // Get initial solution\n    double initialGuess \u003d getMin();\n    double maxBound \u003d getMax();\n    double fInitial \u003d computeObjectiveValue(initialGuess);\n    double fMax \u003d computeObjectiveValue(maxBound);\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (0.0 \u003d\u003d fInitial) {\n        return initialGuess;\n    }\n    if (0.0 \u003d\u003d fMax) {\n        return maxBound;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(initialGuess, maxBound);\n    // Get accuracies.\n    final double functionValueTolerance \u003d getFunctionValueAccuracy();\n    final double absoluteTolerance \u003d getAbsoluteAccuracy();\n    final double relativeTolerance \u003d getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean reversed \u003d false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double approximation \u003d maxBound - ((fMax * (maxBound - initialGuess)) / (fMax - fInitial));\n        final double fValue \u003d computeObjectiveValue(approximation);\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (0.0 \u003d\u003d fValue) {\n            return approximation;\n        }\n        // Update the bounds with the new approximation.\n        if (0 \u003c\u003d fMax * fValue) {\n            switch(method) {\n                case ILLINOIS:\n                    fInitial *\u003d 0.5;\n                    break;\n                case PEGASUS:\n                    fInitial *\u003d fMax / (fMax + fValue);\n                    break;\n                case REGULA_FALSI:\n                    // Detect early that algorithm is stuck, instead of waiting\n                    // for the maximum number of iterations to be exceeded.\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        } else {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            initialGuess \u003d maxBound;\n            fInitial \u003d fMax;\n            reversed \u003d !reversed;\n        }\n        // Update from [x0, x1] to [x0, x].\n        maxBound \u003d approximation;\n        fMax \u003d fValue;\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can\u0027t get closer to\n        // the root than we already are.\n        if (functionValueTolerance \u003e\u003d FastMath.abs(fMax)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return maxBound;\n                case LEFT_SIDE:\n                    if (reversed) {\n                        return maxBound;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!reversed) {\n                        return maxBound;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (0 \u003e\u003d fMax) {\n                        return maxBound;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (0 \u003c\u003d fMax) {\n                        return maxBound;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.max(relativeTolerance * FastMath.abs(maxBound), absoluteTolerance) \u003e FastMath.abs(maxBound - initialGuess)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return maxBound;\n                case LEFT_SIDE:\n                    return reversed ? maxBound : initialGuess;\n                case RIGHT_SIDE:\n                    return reversed ? initialGuess : maxBound;\n                case BELOW_SIDE:\n                    return (0 \u003e\u003d fMax) ? maxBound : initialGuess;\n                case ABOVE_SIDE:\n                    return (0 \u003c\u003d fMax) ? maxBound : initialGuess;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
  "JacksonDatabind-43": "@Override\npublic Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {\n    Object identifier \u003d _valueDeserializer.deserialize(p, ctxt);\n    /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n    // note: no null checks (unlike usually); deserializer should fail if one found\n    if (null \u003d\u003d identifier) {\n        return null;\n    }\n    ReadableObjectId objectIdRef \u003d ctxt.findObjectId(identifier, _objectIdReader.generator, _objectIdReader.resolver);\n    objectIdRef.bindItem(instance);\n    // also: may need to set a property value as well\n    SettableBeanProperty identifierProperty \u003d _objectIdReader.idProperty;\n    if (null !\u003d identifierProperty) {\n        return identifierProperty.setAndReturn(instance, identifier);\n    }\n    return instance;\n}",
  "JacksonDatabind-44": "protected JavaType _narrow(Class\u003c?\u003e subclass) {\n    if (subclass \u003d\u003d _class) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n    /*\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n                */\n    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}",
  "JacksonDatabind-45": "public JsonSerializer\u003c?\u003e createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    if (null !\u003d property) {\n        JsonFormat.Value annotationFormat \u003d serializers.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n        if (null !\u003d annotationFormat) {\n            // Simple case first: serialize as numeric timestamp?\n            JsonFormat.Shape mode \u003d annotationFormat.getShape();\n            if (mode.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (JsonFormat.Shape.STRING \u003d\u003d annotationFormat.getShape()) {\n                TimeZone timeZone \u003d annotationFormat.getTimeZone();\n                final String dateFormatPattern \u003d annotationFormat.hasPattern() ? annotationFormat.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale locale \u003d annotationFormat.hasLocale() ? annotationFormat.getLocale() : serializers.getLocale();\n                SimpleDateFormat dateFormatter \u003d new SimpleDateFormat(dateFormatPattern, locale);\n                if (null \u003d\u003d timeZone) {\n                    timeZone \u003d serializers.getTimeZone();\n                }\n                dateFormatter.setTimeZone(timeZone);\n                return withFormat(Boolean.FALSE, dateFormatter);\n            }\n        }\n    }\n    return this;\n}",
  "JacksonDatabind-46": "public StringBuilder getGenericSignature(StringBuilder sb) {\n    _classSignature(_class, sb, false);\n    sb.append(\u0027\u003c\u0027);\n    sb \u003d _referencedType.getGenericSignature(sb);\n    sb.append(\u0027;\u0027);\n    return sb;\n}",
  "JacksonDatabind-47": "public JavaType refineSerializationType(final MapperConfig\u003c?\u003e config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType currentType \u003d baseType;\n    final TypeFactory typeFactory \u003d config.getTypeFactory();\n    // 10-Oct-2015, tatu: For 2.7, we\u0027ll need to delegate back to\n    //    now-deprecated secondary methods; this because while\n    //    direct sub-class not yet retrofitted may only override\n    //    those methods. With 2.8 or later we may consider removal\n    //    of these methods\n    // Ok: start by refining the main type itself; common to all types\n    Class\u003c?\u003e serializerClass \u003d findSerializationType(a);\n    if (null !\u003d serializerClass) {\n        if (!currentType.hasRawClass(serializerClass)) {\n            try {\n                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                //   may be needed here too in future?\n                currentType \u003d typeFactory.constructGeneralizedType(currentType, serializerClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from \u0027%s\u0027: %s\", currentType, serializerClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        } else {\n            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n            //    static typing this way\n            currentType \u003d currentType.withStaticTyping();\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (currentType.isMapLikeType()) {\n        JavaType elementType \u003d currentType.getKeyType();\n        Class\u003c?\u003e keyTypeClass \u003d findSerializationKeyType(a, elementType);\n        if (null !\u003d keyTypeClass) {\n            if (!elementType.hasRawClass(keyTypeClass)) {\n                Class\u003c?\u003e currentRaw \u003d elementType.getRawClass();\n                try {\n                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                    //   specialize (narrow) type sometimes, even if more commonly opposite\n                    //   is needed.\n                    if (!keyTypeClass.isAssignableFrom(currentRaw)) {\n                        if (!currentRaw.isAssignableFrom(keyTypeClass)) {\n                            throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", elementType, keyTypeClass.getName()));\n                        } else {\n                            // specialization, ok as well\n                            elementType \u003d typeFactory.constructSpecializedType(elementType, keyTypeClass);\n                        }\n                    } else {\n                        // common case\n                        elementType \u003d typeFactory.constructGeneralizedType(elementType, keyTypeClass);\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from \u0027%s\u0027: %s\", currentType, keyTypeClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            } else {\n                elementType \u003d elementType.withStaticTyping();\n            }\n            currentType \u003d ((MapLikeType) currentType).withKeyType(elementType);\n        }\n    }\n    JavaType valueType \u003d currentType.getContentType();\n    if (null !\u003d valueType) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        Class\u003c?\u003e valueClass \u003d findSerializationContentType(a, valueType);\n        if (null !\u003d valueClass) {\n            if (!valueType.hasRawClass(valueClass)) {\n                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n                //   specialize (narrow) type sometimes, even if more commonly opposite\n                //   is needed.\n                Class\u003c?\u003e currentRaw \u003d valueType.getRawClass();\n                try {\n                    if (!valueClass.isAssignableFrom(currentRaw)) {\n                        if (!currentRaw.isAssignableFrom(valueClass)) {\n                            throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", valueType, valueClass.getName()));\n                        } else {\n                            // specialization, ok as well\n                            valueType \u003d typeFactory.constructSpecializedType(valueType, valueClass);\n                        }\n                    } else {\n                        // common case\n                        valueType \u003d typeFactory.constructGeneralizedType(valueType, valueClass);\n                    }\n                } catch (IllegalArgumentException iae) {\n                    // shouldn\u0027t really happen\n                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from \u0027%s\u0027: %s\", currentType, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            } else {\n                valueType \u003d valueType.withStaticTyping();\n            }\n            currentType \u003d currentType.withContentType(valueType);\n        }\n    }\n    return currentType;\n}",
  "JacksonDatabind-49": "public Object generateId(Object forPojo) {\n    // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n    //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n    //    need to use existing id if there is one:\n    id \u003d generator.generateId(forPojo);\n    return id;\n}",
  "JxPath-10": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].computeValue(context), args[1].computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n}",
  "Math-40": "protected double doSolve() {\n    // prepare arrays with the first points\n    final double[] pointsX \u003d new double[maximalOrder + 1];\n    final double[] f \u003d new double[maximalOrder + 1];\n    pointsX[0] \u003d getMin();\n    pointsX[1] \u003d getStartValue();\n    pointsX[2] \u003d getMax();\n    verifySequence(pointsX[0], pointsX[1], pointsX[2]);\n    // evaluate initial guess\n    f[1] \u003d computeObjectiveValue(pointsX[1]);\n    if (Precision.equals(f[1], 0.0, 1)) {\n        // return the initial guess if it is a perfect root.\n        return pointsX[1];\n    }\n    // evaluate first  endpoint\n    f[0] \u003d computeObjectiveValue(pointsX[0]);\n    if (Precision.equals(f[0], 0.0, 1)) {\n        // return the first endpoint if it is a perfect root.\n        return pointsX[0];\n    }\n    int numPoints;\n    int signSwitchIndex;\n    if (0 \u003c\u003d f[0] * f[1]) {\n        // evaluate second endpoint\n        f[2] \u003d computeObjectiveValue(pointsX[2]);\n        if (Precision.equals(f[2], 0.0, 1)) {\n            // return the second endpoint if it is a perfect root.\n            return pointsX[2];\n        }\n        if (0 \u003c\u003d f[1] * f[2]) {\n            throw new NoBracketingException(pointsX[0], pointsX[2], f[0], f[2]);\n        } else {\n            // use all computed point as a start sampling array for solving\n            numPoints \u003d 3;\n            signSwitchIndex \u003d 2;\n        }\n    } else {\n        // reduce interval if it brackets the root\n        numPoints \u003d 2;\n        signSwitchIndex \u003d 1;\n    }\n    // prepare a work array for inverse polynomial interpolation\n    final double[] interpolationPoints \u003d new double[pointsX.length];\n    // current tightest bracketing of the root\n    double lowerBound \u003d pointsX[signSwitchIndex - 1];\n    double valueAtSignChange \u003d f[signSwitchIndex - 1];\n    double absoluteValueYA \u003d FastMath.abs(valueAtSignChange);\n    int ageCounterA \u003d 0;\n    double xUpper \u003d pointsX[signSwitchIndex];\n    double valueB \u003d f[signSwitchIndex];\n    double absValueYB \u003d FastMath.abs(valueB);\n    int agingCounterB \u003d 0;\n    // search loop\n    while (true) {\n        // check convergence of bracketing interval\n        final double xTolerance \u003d getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(lowerBound), FastMath.abs(xUpper));\n        if ((xTolerance \u003e\u003d (xUpper - lowerBound)) || (getFunctionValueAccuracy() \u003e FastMath.max(absoluteValueYA, absValueYB))) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return absValueYB \u003e absoluteValueYA ? lowerBound : xUpper;\n                case LEFT_SIDE:\n                    return lowerBound;\n                case RIGHT_SIDE:\n                    return xUpper;\n                case BELOW_SIDE:\n                    return (0 \u003e\u003d valueAtSignChange) ? lowerBound : xUpper;\n                case ABOVE_SIDE:\n                    return (0 \u003e valueAtSignChange) ? xUpper : lowerBound;\n                default:\n                    // this should never happen\n                    throw new MathInternalError(null);\n            }\n        }\n        // target for the next evaluation point\n        double desiredY;\n        if (MAXIMAL_AGING \u003e ageCounterA) {\n            if (MAXIMAL_AGING \u003e agingCounterB) {\n                // bracketing is balanced, try to find the root itself\n                desiredY \u003d 0;\n            } else {\n                // we keep updating the low bracket, try to compensate this\n                desiredY \u003d -REDUCTION_FACTOR * valueAtSignChange;\n            }\n        } else {\n            // we keep updating the high bracket, try to compensate this\n            desiredY \u003d -REDUCTION_FACTOR * valueB;\n        }\n        // make a few attempts to guess a root,\n        double updatedX;\n        int initialValue \u003d 0;\n        int finishingPoint \u003d numPoints;\n        do {\n            // guess a value for current target, using inverse polynomial interpolation\n            System.arraycopy(pointsX, initialValue, interpolationPoints, initialValue, finishingPoint - initialValue);\n            updatedX \u003d guessX(desiredY, interpolationPoints, f, initialValue, finishingPoint);\n            if (!((lowerBound \u003c updatedX) \u0026\u0026 (xUpper \u003e updatedX))) {\n                // the guessed root is not strictly inside of the tightest bracketing interval\n                // the guessed root is either not strictly inside the interval or it\n                // is a NaN (which occurs when some sampling points share the same y)\n                // we try again with a lower interpolation order\n                if (finishingPoint - signSwitchIndex \u003e signSwitchIndex - initialValue) {\n                    // we have more points after sign change, drop the highest point\n                    --finishingPoint;\n                } else {\n                    // we have more points before the sign change, drop the lowest point\n                    ++initialValue;\n                }\n                // we need to do one more attempt\n                updatedX \u003d Double.NaN;\n            }\n        } while (Double.isNaN(updatedX) \u0026\u0026 (1 \u003c finishingPoint - initialValue));\n        if (Double.isNaN(updatedX)) {\n            // fall back to bisection\n            updatedX \u003d lowerBound + 0.5 * (xUpper - lowerBound);\n            initialValue \u003d signSwitchIndex - 1;\n            finishingPoint \u003d signSwitchIndex;\n        }\n        // evaluate the function at the guessed root\n        final double nextValueY \u003d computeObjectiveValue(updatedX);\n        if (Precision.equals(nextValueY, 0.0, 1)) {\n            // we have found an exact root, since it is not an approximation\n            // we don\u0027t need to bother about the allowed solutions setting\n            return updatedX;\n        }\n        if (!((2 \u003c numPoints)) || !((numPoints !\u003d finishingPoint - initialValue))) {\n            if (pointsX.length \u003d\u003d numPoints) {\n                // we have to drop one point in order to insert the new one\n                numPoints -\u003d 1;\n                // keep the tightest bracketing interval as centered as possible\n                if ((pointsX.length + 1) / 2 \u003c\u003d signSwitchIndex) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(pointsX, 1, pointsX, 0, numPoints);\n                    System.arraycopy(f, 1, f, 0, numPoints);\n                    --signSwitchIndex;\n                }\n            }\n        } else {\n            // we have been forced to ignore some points to keep bracketing,\n            // they are probably too far from the root, drop them from now on\n            numPoints \u003d finishingPoint - initialValue;\n            System.arraycopy(pointsX, initialValue, pointsX, 0, numPoints);\n            System.arraycopy(f, initialValue, f, 0, numPoints);\n            signSwitchIndex -\u003d initialValue;\n        }\n        // insert the last computed point\n        //(by construction, we know it lies inside the tightest bracketing interval)\n        System.arraycopy(pointsX, signSwitchIndex, pointsX, signSwitchIndex + 1, numPoints - signSwitchIndex);\n        pointsX[signSwitchIndex] \u003d updatedX;\n        System.arraycopy(f, signSwitchIndex, f, signSwitchIndex + 1, numPoints - signSwitchIndex);\n        f[signSwitchIndex] \u003d nextValueY;\n        ++numPoints;\n        // update the bracketing interval\n        if (0 \u003c nextValueY * valueAtSignChange) {\n            // the sign change occurs after the inserted point\n            lowerBound \u003d updatedX;\n            valueAtSignChange \u003d nextValueY;\n            absoluteValueYA \u003d FastMath.abs(valueAtSignChange);\n            ageCounterA \u003d 0;\n            ++agingCounterB;\n            // update the sign change index\n            signSwitchIndex +\u003d 1;\n        } else {\n            // the sign change occurs before the inserted point\n            xUpper \u003d updatedX;\n            valueB \u003d nextValueY;\n            absValueYB \u003d FastMath.abs(valueB);\n            ++ageCounterA;\n            agingCounterB \u003d 0;\n        }\n    }\n}",
  "Math-41": "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n    double variance \u003d Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (1 !\u003d length) {\n            if (1 \u003c length) {\n                double totalAccumulation \u003d 0.0;\n                double deviation \u003d 0.0;\n                double totalDeviation \u003d 0.0;\n                for (int index \u003d begin; begin + length \u003e index; index++) {\n                    deviation \u003d values[index] - mean;\n                    totalAccumulation +\u003d weights[index] * (deviation * deviation);\n                    totalDeviation +\u003d weights[index] * deviation;\n                }\n                double totalWeights \u003d 0;\n                for (int index \u003d 0; weights.length \u003e index; index++) {\n                    totalWeights +\u003d weights[index];\n                }\n                if (!isBiasCorrected) {\n                    variance \u003d (totalAccumulation - (totalDeviation * totalDeviation / totalWeights)) / totalWeights;\n                } else {\n                    variance \u003d (totalAccumulation - (totalDeviation * totalDeviation / totalWeights)) / (totalWeights - 1.0);\n                }\n            }\n        } else {\n            variance \u003d 0.0;\n        }\n    }\n    return variance;\n}",
  "JxPath-12": "public static boolean testNode(Node node, NodeTest test) {\n    if (null \u003d\u003d test) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (Node.ELEMENT_NODE !\u003d node.getNodeType()) {\n            return false;\n        }\n        NodeNameTest nodeNameCriteria \u003d (NodeNameTest) test;\n        QName nodeNameToTest \u003d nodeNameCriteria.getNodeName();\n        String namespaceIdentifier \u003d nodeNameCriteria.getNamespaceURI();\n        boolean isAny \u003d nodeNameCriteria.isWildcard();\n        String testNamespacePrefix \u003d nodeNameToTest.getPrefix();\n        if (isAny \u0026\u0026 null \u003d\u003d testNamespacePrefix) {\n            return true;\n        }\n        if (isAny || nodeNameToTest.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String namespaceURIOfNode \u003d DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceIdentifier, namespaceURIOfNode);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int elementType \u003d node.getNodeType();\n        switch(((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return Node.ELEMENT_NODE \u003d\u003d elementType || Node.DOCUMENT_NODE \u003d\u003d elementType;\n            case Compiler.NODE_TYPE_TEXT:\n                return Node.CDATA_SECTION_NODE \u003d\u003d elementType || Node.TEXT_NODE \u003d\u003d elementType;\n            case Compiler.NODE_TYPE_COMMENT:\n                return Node.COMMENT_NODE \u003d\u003d elementType;\n            case Compiler.NODE_TYPE_PI:\n                return Node.PROCESSING_INSTRUCTION_NODE \u003d\u003d elementType;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (Node.PROCESSING_INSTRUCTION_NODE \u003d\u003d node.getNodeType()) {\n            String testTarget \u003d ((ProcessingInstructionTest) test).getTarget();\n            String processingInstructionTarget \u003d ((ProcessingInstruction) node).getTarget();\n            return testTarget.equals(processingInstructionTarget);\n        }\n    }\n    return false;\n}",
  "Math-42": "protected RealPointValuePair getSolution() {\n    int negativeVariableColumnIndex \u003d columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n    Integer negativeVariableBasicRow \u003d 0 \u003c negativeVariableColumnIndex ? getBasicRow(negativeVariableColumnIndex) : null;\n    double leastPositive \u003d null \u003d\u003d negativeVariableBasicRow ? 0 : getEntry(negativeVariableBasicRow, getRhsOffset());\n    Set\u003cInteger\u003e activeBasicRows \u003d new HashSet\u003cInteger\u003e();\n    double[] parameters \u003d new double[getOriginalNumDecisionVariables()];\n    int index \u003d 0;\n    while (parameters.length \u003e index) {\n        int columnIndex \u003d columnLabels.indexOf(\"x\" + index);\n        if (0 \u003e columnIndex) {\n            parameters[index] \u003d 0;\n            continue;\n        }\n        Integer currentBasicRow \u003d getBasicRow(columnIndex);\n        // if the basic row is found to be the objective function row\n        // set the coefficient to 0 -\u003e this case handles unconstrained\n        // variables that are still part of the objective function\n        if (!activeBasicRows.contains(currentBasicRow)) {\n            activeBasicRows.add(currentBasicRow);\n            parameters[index] \u003d (null \u003d\u003d currentBasicRow ? 0 : getEntry(currentBasicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : leastPositive);\n        } else {\n            // if multiple variables can take a given value\n            // then we choose the first and set the rest equal to 0\n            parameters[index] \u003d 0 - (restrictToNonNegative ? 0 : leastPositive);\n        }\n        index +\u003d 1;\n    }\n    return new RealPointValuePair(parameters, f.getValue(parameters));\n}",
  "Math-43": "public void addValue(double value) {\n    sumImpl.increment(value);\n    sumsqImpl.increment(value);\n    minImpl.increment(value);\n    maxImpl.increment(value);\n    sumLogImpl.increment(value);\n    secondMoment.increment(value);\n    // If mean, variance or geomean have been overridden,\n    // need to increment these\n    if (!(meanImpl instanceof Mean)) {\n        meanImpl.increment(value);\n    }\n    if (!(varianceImpl instanceof Variance)) {\n        varianceImpl.increment(value);\n    }\n    if (!(geoMeanImpl instanceof GeometricMean)) {\n        geoMeanImpl.increment(value);\n    }\n    n +\u003d 1;\n}",
  "Math-44": "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n    double lastT \u003d interpolator.getGlobalPreviousTime();\n    final double currentTime \u003d interpolator.getGlobalCurrentTime();\n    resetOccurred \u003d false;\n    // initialize the events states if needed\n    if (!statesInitialized) {\n        for (EventState eventState : eventsStates) {\n            eventState.reinitializeBegin(interpolator);\n        }\n        statesInitialized \u003d true;\n    }\n    // search for next events that may occur during the step\n    final int directionSign \u003d interpolator.isForward() ? +1 : -1;\n    SortedSet\u003cEventState\u003e triggeredEvents \u003d new TreeSet\u003cEventState\u003e(new Comparator\u003cEventState\u003e() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(EventState es0, EventState es1) {\n            return directionSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n    for (final EventState eventState : eventsStates) {\n        if (eventState.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            triggeredEvents.add(eventState);\n        }\n    }\n    while (!triggeredEvents.isEmpty()) {\n        // handle the chronologically first event\n        final Iterator\u003cEventState\u003e eventIterator \u003d triggeredEvents.iterator();\n        final EventState nextEvent \u003d eventIterator.next();\n        eventIterator.remove();\n        // restrict the interpolator to the first part of the step, up to the event\n        final double eventTime \u003d nextEvent.getEventTime();\n        interpolator.setSoftPreviousTime(lastT);\n        interpolator.setSoftCurrentTime(eventTime);\n        // trigger the event\n        interpolator.setInterpolatedTime(eventTime);\n        final double[] eventY \u003d interpolator.getInterpolatedState();\n        nextEvent.stepAccepted(eventTime, eventY);\n        isLastStep \u003d nextEvent.stop();\n        // handle the first part of the step, up to the event\n        for (final StepHandler processor : stepHandlers) {\n            processor.handleStep(interpolator, isLastStep);\n        }\n        if (isLastStep) {\n            // the event asked to stop integration\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            return eventTime;\n        }\n        if (nextEvent.reset(eventTime, eventY)) {\n            // some event handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventTime, y, yDot);\n            resetOccurred \u003d true;\n            return eventTime;\n        }\n        // prepare handling of the remaining part of the step\n        lastT \u003d eventTime;\n        interpolator.setSoftPreviousTime(eventTime);\n        interpolator.setSoftCurrentTime(currentTime);\n        // check if the same event occurs again in the remaining part of the step\n        if (nextEvent.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            triggeredEvents.add(nextEvent);\n        }\n    }\n    interpolator.setInterpolatedTime(currentTime);\n    final double[] currentY \u003d interpolator.getInterpolatedState();\n    for (final EventState eventState : eventsStates) {\n        eventState.stepAccepted(currentTime, currentY);\n        isLastStep \u003d isLastStep || eventState.stop();\n    }\n    isLastStep \u003d isLastStep || Precision.equals(currentTime, tEnd, 1);\n    // handle the remaining part of the step, after all events if any\n    for (StepHandler processor : stepHandlers) {\n        processor.handleStep(interpolator, isLastStep);\n    }\n    return currentTime;\n}",
  "Cli-40": "public static \u003cT\u003e T createValue(final String str, final Class\u003cT\u003e clazz) throws ParseException {\n    if (clazz !\u003d PatternOptionBuilder.STRING_VALUE) {\n        if (clazz !\u003d PatternOptionBuilder.OBJECT_VALUE) {\n            if (clazz !\u003d PatternOptionBuilder.NUMBER_VALUE) {\n                if (clazz !\u003d PatternOptionBuilder.DATE_VALUE) {\n                    if (clazz !\u003d PatternOptionBuilder.CLASS_VALUE) {\n                        if (clazz !\u003d PatternOptionBuilder.FILE_VALUE) {\n                            if (clazz !\u003d PatternOptionBuilder.EXISTING_FILE_VALUE) {\n                                if (clazz !\u003d PatternOptionBuilder.FILES_VALUE) {\n                                    if (clazz !\u003d PatternOptionBuilder.URL_VALUE) {\n                                        return null;\n                                    } else {\n                                        return (T) createURL(str);\n                                    }\n                                } else {\n                                    return (T) createFiles(str);\n                                }\n                            } else {\n                                return (T) openFile(str);\n                            }\n                        } else {\n                            return (T) createFile(str);\n                        }\n                    } else {\n                        return (T) createClass(str);\n                    }\n                } else {\n                    return (T) createDate(str);\n                }\n            } else {\n                return (T) createNumber(str);\n            }\n        } else {\n            return (T) createObject(str);\n        }\n    } else {\n        return (T) str;\n    }\n}",
  "Math-45": "public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n    super(rowDimension, columnDimension);\n    this.rows \u003d rowDimension;\n    this.columns \u003d columnDimension;\n    this.entries \u003d new OpenIntToDoubleHashMap(0.0);\n}",
  "JxPath-15": "public boolean setPosition(int position) {\n    if (!prepared) {\n        prepared \u003d true;\n        BasicNodeSet nodeCollection \u003d (BasicNodeSet) getNodeSet();\n        ArrayList nodePointers \u003d new ArrayList();\n        int index \u003d 0;\n        while (contexts.length \u003e index) {\n            EvalContext evaluationContext \u003d (EvalContext) contexts[index];\n            while (evaluationContext.nextSet()) {\n                while (evaluationContext.nextNode()) {\n                    NodePointer nodePointer \u003d evaluationContext.getCurrentNodePointer();\n                    if (!nodePointers.contains(nodePointer)) {\n                        nodeCollection.add(nodePointer);\n                        nodePointers.add(nodePointer);\n                    }\n                }\n            }\n            index +\u003d 1;\n        }\n    }\n    return super.setPosition(position);\n}",
  "Math-7": "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n    double lastT \u003d interpolator.getGlobalPreviousTime();\n    final double latestT \u003d interpolator.getGlobalCurrentTime();\n    // initialize the events states if needed\n    if (!statesInitialized) {\n        for (EventState eventState : eventsStates) {\n            eventState.reinitializeBegin(interpolator);\n        }\n        statesInitialized \u003d true;\n    }\n    // search for next events that may occur during the step\n    final int directionSign \u003d interpolator.isForward() ? +1 : -1;\n    SortedSet\u003cEventState\u003e triggeredEvents \u003d new TreeSet\u003cEventState\u003e(new Comparator\u003cEventState\u003e() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(EventState es0, EventState es1) {\n            return directionSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n    for (final EventState eventState : eventsStates) {\n        if (eventState.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            triggeredEvents.add(eventState);\n        }\n    }\n    while (!triggeredEvents.isEmpty()) {\n        // handle the chronologically first event\n        final Iterator\u003cEventState\u003e eventIterator \u003d triggeredEvents.iterator();\n        final EventState nextEvent \u003d eventIterator.next();\n        eventIterator.remove();\n        // restrict the interpolator to the first part of the step, up to the event\n        final double eventTime \u003d nextEvent.getEventTime();\n        interpolator.setSoftPreviousTime(lastT);\n        interpolator.setSoftCurrentTime(eventTime);\n        // get state at event time\n        interpolator.setInterpolatedTime(eventTime);\n        final double[] eventY \u003d interpolator.getInterpolatedState().clone();\n        // advance all event states to current time\n        nextEvent.stepAccepted(eventTime, eventY);\n        isLastStep \u003d nextEvent.stop();\n        // handle the first part of the step, up to the event\n        for (final StepHandler processor : stepHandlers) {\n            processor.handleStep(interpolator, isLastStep);\n        }\n        if (isLastStep) {\n            // the event asked to stop integration\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            for (final EventState remainingEvents : triggeredEvents) {\n                remainingEvents.stepAccepted(eventTime, eventY);\n            }\n            return eventTime;\n        }\n        boolean requiresReset \u003d nextEvent.reset(eventTime, eventY);\n        if (requiresReset) {\n            // some event handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventTime, y, yDot);\n            resetOccurred \u003d true;\n            for (final EventState remainingEvents : triggeredEvents) {\n                remainingEvents.stepAccepted(eventTime, eventY);\n            }\n            return eventTime;\n        }\n        // prepare handling of the remaining part of the step\n        lastT \u003d eventTime;\n        interpolator.setSoftPreviousTime(eventTime);\n        interpolator.setSoftCurrentTime(latestT);\n        // check if the same event occurs again in the remaining part of the step\n        if (nextEvent.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            triggeredEvents.add(nextEvent);\n        }\n    }\n    // last part of the step, after the last event\n    interpolator.setInterpolatedTime(latestT);\n    final double[] currentY \u003d interpolator.getInterpolatedState();\n    for (final EventState eventState : eventsStates) {\n        eventState.stepAccepted(latestT, currentY);\n        isLastStep \u003d isLastStep || eventState.stop();\n    }\n    isLastStep \u003d isLastStep || Precision.equals(latestT, tEnd, 1);\n    // handle the remaining part of the step, after all events if any\n    for (StepHandler processor : stepHandlers) {\n        processor.handleStep(interpolator, isLastStep);\n    }\n    return latestT;\n}",
  "Math-8": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n    if (0 \u003e\u003d sampleSize) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\n    }\n    final T[] result \u003d (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n    int index \u003d 0;\n    while (sampleSize \u003e index) {\n        result[index] \u003d sample();\n        index +\u003d 1;\n    }\n    return result;\n}",
  "Lang-11": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (0 !\u003d count) {\n        if (0 \u003e count) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n    } else {\n        return \"\";\n    }\n    if (null !\u003d chars \u0026\u0026 0 \u003d\u003d chars.length) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (0 \u003d\u003d start \u0026\u0026 0 \u003d\u003d end) {\n        if (null \u003d\u003d chars) {\n            if (letters || numbers) {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            } else {\n                end \u003d Integer.MAX_VALUE;\n            }\n        } else {\n            end \u003d chars.length;\n        }\n    }\n    char[] array \u003d new char[count];\n    int range \u003d end - start;\n    while (0 !\u003d count--) {\n        char character;\n        if (null !\u003d chars) {\n            character \u003d chars[random.nextInt(range) + start];\n        } else {\n            character \u003d (char) (random.nextInt(range) + start);\n        }\n        if (!letters || !Character.isLetter(character) \u0026\u0026 !numbers || !Character.isDigit(character) \u0026\u0026 letters || numbers) {\n            count +\u003d 1;\n        } else {\n            if (56320 \u003e character || 57343 \u003c character) {\n                if (55296 \u003e character || 56191 \u003c character) {\n                    if (56192 \u003e character || 56319 \u003c character) {\n                        array[count] \u003d character;\n                    } else {\n                        // private high surrogate, no effing clue, so skip it\n                        count +\u003d 1;\n                    }\n                } else {\n                    if (0 !\u003d count) {\n                        // high surrogate, insert low surrogate before putting it in\n                        array[count] \u003d (char) (56320 + random.nextInt(128));\n                        count -\u003d 1;\n                        array[count] \u003d character;\n                    } else {\n                        count +\u003d 1;\n                    }\n                }\n            } else {\n                if (0 !\u003d count) {\n                    // low surrogate, insert high surrogate after putting it in\n                    array[count] \u003d character;\n                    count -\u003d 1;\n                    array[count] \u003d (char) (55296 + random.nextInt(128));\n                } else {\n                    count +\u003d 1;\n                }\n            }\n        }\n    }\n    return new String(array);\n}",
  "Math-5": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (0.0 \u003d\u003d real \u0026\u0026 0.0 \u003d\u003d imaginary) {\n        return NaN;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(imaginary) \u003c\u003d FastMath.abs(real)) {\n        double ratio \u003d imaginary / real;\n        double factor \u003d 1. / (imaginary * ratio + real);\n        return createComplex(factor, -factor * ratio);\n    } else {\n        double ratio \u003d real / imaginary;\n        double factor \u003d 1. / (real * ratio + imaginary);\n        return createComplex(factor * ratio, -factor);\n    }\n}",
  "Lang-10": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean isPreviousCharWhitespace \u003d false;\n    int index \u003d 0;\n    while (value.length() \u003e index) {\n        char character \u003d value.charAt(index);\n        if (Character.isWhitespace(character)) {\n            if (!isPreviousCharWhitespace) {\n                isPreviousCharWhitespace \u003d true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        isPreviousCharWhitespace \u003d false;\n        switch(character) {\n            case \u0027\\\u0027\u0027:\n                if (unquote) {\n                    if (value.length() \u003d\u003d ++index) {\n                        return regex;\n                    }\n                    character \u003d value.charAt(index);\n                }\n                break;\n            case \u0027?\u0027:\n            case \u0027[\u0027:\n            case \u0027]\u0027:\n            case \u0027(\u0027:\n            case \u0027)\u0027:\n            case \u0027{\u0027:\n            case \u0027}\u0027:\n            case \u0027\\\\\u0027:\n            case \u0027|\u0027:\n            case \u0027*\u0027:\n            case \u0027+\u0027:\n            case \u0027^\u0027:\n            case \u0027$\u0027:\n            case \u0027.\u0027:\n                regex.append(\u0027\\\\\u0027);\n        }\n        regex.append(character);\n        ++index;\n    }\n    return regex;\n}",
  "Cli-39": "public static Object createValue(final String str, final Class\u003c?\u003e clazz) throws ParseException {\n    if (clazz !\u003d PatternOptionBuilder.STRING_VALUE) {\n        if (clazz !\u003d PatternOptionBuilder.OBJECT_VALUE) {\n            if (clazz !\u003d PatternOptionBuilder.NUMBER_VALUE) {\n                if (clazz !\u003d PatternOptionBuilder.DATE_VALUE) {\n                    if (clazz !\u003d PatternOptionBuilder.CLASS_VALUE) {\n                        if (clazz !\u003d PatternOptionBuilder.FILE_VALUE) {\n                            if (clazz !\u003d PatternOptionBuilder.EXISTING_FILE_VALUE) {\n                                if (clazz !\u003d PatternOptionBuilder.FILES_VALUE) {\n                                    if (clazz !\u003d PatternOptionBuilder.URL_VALUE) {\n                                        return null;\n                                    } else {\n                                        return createURL(str);\n                                    }\n                                } else {\n                                    return createFiles(str);\n                                }\n                            } else {\n                                return createFile(str);\n                            }\n                        } else {\n                            return createFile(str);\n                        }\n                    } else {\n                        return createClass(str);\n                    }\n                } else {\n                    return createDate(str);\n                }\n            } else {\n                return createNumber(str);\n            }\n        } else {\n            return createObject(str);\n        }\n    } else {\n        return str;\n    }\n}",
  "Cli-38": "private boolean isShortOption(String token) {\n    // short options (-S, -SV, -S\u003dV, -SV1\u003dV2, -S1S2)\n    if (!token.startsWith(\"-\") || 1 \u003d\u003d token.length()) {\n        return false;\n    }\n    // remove leading \"-\" and \"\u003dvalue\"\n    int index \u003d token.indexOf(\"\u003d\");\n    String optionName \u003d -1 \u003d\u003d index ? token.substring(1) : token.substring(1, index);\n    return options.hasShortOption(optionName);\n    // check for several concatenated short options\n}",
  "Cli-37": "private boolean isShortOption(String token) {\n    // short options (-S, -SV, -S\u003dV, -SV1\u003dV2, -S1S2)\n    return token.startsWith(\"-\") \u0026\u0026 2 \u003c\u003d token.length() \u0026\u0026 options.hasShortOption(token.substring(1, 2));\n    // remove leading \"-\" and \"\u003dvalue\"\n}",
  "Math-9": "public Line revert() {\n    final Line restored \u003d new Line(zero, zero.subtract(direction));\n    return restored;\n}",
  "Math-60": "public double cumulativeProbability(double x) throws MathException {\n    final double difference \u003d x - mean;\n    try {\n        return 0.5 * (1.0 + Erf.erf((difference) / (standardDeviation * FastMath.sqrt(2.0))));\n    } catch (MaxIterationsExceededException ex) {\n        if ((mean - 20 * standardDeviation) \u003c\u003d x) {\n            if ((mean + 20 * standardDeviation) \u003e\u003d x) {\n                throw ex;\n            } else {\n                return 1;\n            }\n        } else {\n            // JDK 1.5 blows at 38\n            return 0;\n        }\n    }\n}",
  "Math-58": "public double[] fit() {\n    final double[] initialEstimation \u003d (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(), initialEstimation);\n}",
  "Math-59": "public static float max(final float a, final float b) {\n    return (b \u003e\u003d a) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}",
  "JacksonDatabind-33": "public PropertyName findNameForSerialization(Annotated a) {\n    String propertyName \u003d null;\n    JsonGetter jsonGetter \u003d _findAnnotation(a, JsonGetter.class);\n    if (null \u003d\u003d jsonGetter) {\n        JsonProperty jsonProperty \u003d _findAnnotation(a, JsonProperty.class);\n        if (null \u003d\u003d jsonProperty) {\n            if (!_hasAnnotation(a, JsonSerialize.class) \u0026\u0026 !_hasAnnotation(a, JsonView.class) \u0026\u0026 !_hasAnnotation(a, JsonRawValue.class)) {\n                return null;\n            } else {\n                propertyName \u003d \"\";\n            }\n        } else {\n            propertyName \u003d jsonProperty.value();\n            /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n             *   it\u0027s actually bit tricky to do it more efficiently (meta-annotations\n             *   add more lookups; AnnotationMap costs etc)\n             */\n        }\n    } else {\n        propertyName \u003d jsonGetter.value();\n    }\n    return PropertyName.construct(propertyName);\n}",
  "JacksonDatabind-34": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    if (!_isInt) {\n        Class\u003c?\u003e handledClass \u003d handledType();\n        if (BigDecimal.class !\u003d handledClass) {\n            // otherwise bit unclear what to call... but let\u0027s try:\n            /*JsonNumberFormatVisitor v2 \u003d*/\n            visitor.expectNumberFormat(typeHint);\n        } else {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        }\n    } else {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    }\n}",
  "JacksonDatabind-35": "private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    // 02-Aug-2013, tatu: May need to use native type ids\n    if (p.canReadTypeId()) {\n        Object subtypeId \u003d p.getTypeId();\n        if (null !\u003d subtypeId) {\n            return _deserializeWithNativeTypeId(p, ctxt, subtypeId);\n        }\n    }\n    // first, sanity checks\n    if (JsonToken.START_OBJECT !\u003d p.getCurrentToken()) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \" + baseTypeName());\n    }\n    // should always get field name, but just in case...\n    if (JsonToken.FIELD_NAME !\u003d p.nextToken()) {\n        throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, \"need JSON String that contains type id (for subtype of \" + baseTypeName() + \")\");\n    }\n    final String subtypeId \u003d p.getText();\n    JsonDeserializer\u003cObject\u003e deserializer \u003d _findDeserializer(ctxt, subtypeId);\n    p.nextToken();\n    // Minor complication: we may need to merge type id in?\n    if (_typeIdVisible \u0026\u0026 JsonToken.START_OBJECT \u003d\u003d p.getCurrentToken()) {\n        // but what if there\u0027s nowhere to add it in? Error? Or skip? For now, skip.\n        TokenBuffer tokenBuffer \u003d new TokenBuffer(null, false);\n        // recreate START_OBJECT\n        tokenBuffer.writeStartObject();\n        tokenBuffer.writeFieldName(_typePropertyName);\n        tokenBuffer.writeString(subtypeId);\n        p \u003d JsonParserSequence.createFlattened(tokenBuffer.asParser(p), p);\n        p.nextToken();\n    }\n    Object result \u003d deserializer.deserialize(p, ctxt);\n    // And then need the closing END_OBJECT\n    if (JsonToken.END_OBJECT !\u003d p.nextToken()) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT after type information and deserialized value\");\n    }\n    return result;\n}",
  "JacksonDatabind-36": "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (loc.equals(DEFAULT_LOCALE)) {\n        df \u003d (DateFormat) df.clone();\n        if (null !\u003d tz) {\n            df.setTimeZone(tz);\n        }\n    } else {\n        df \u003d new SimpleDateFormat(format, loc);\n        df.setTimeZone((null \u003d\u003d tz) ? DEFAULT_TIMEZONE : tz);\n    }\n    return df;\n}",
  "JacksonDatabind-37": "protected JavaType _narrow(Class\u003c?\u003e subclass) {\n    if (subclass \u003d\u003d _class) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values, so no.\n    /*\n    if (!_class.isAssignableFrom(subclass)) {\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n    }\n    */\n    // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n}",
  "Cli-35": "public List\u003cString\u003e getMatchingOptions(String opt) {\n    opt \u003d Util.stripLeadingHyphens(opt);\n    List\u003cString\u003e matchingOptions \u003d new ArrayList\u003cString\u003e();\n    // for a perfect match return the single option only\n    for (String fullOption : longOpts.keySet()) {\n        if (fullOption.startsWith(opt)) {\n            matchingOptions.add(fullOption);\n        }\n    }\n    return matchingOptions;\n}",
  "Math-50": "protected final double doSolve() {\n    // Get initial solution\n    double initialEstimate \u003d getMin();\n    double xUpperBound \u003d getMax();\n    double fStart \u003d computeObjectiveValue(initialEstimate);\n    double fHigh \u003d computeObjectiveValue(xUpperBound);\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (0.0 \u003d\u003d fStart) {\n        return initialEstimate;\n    }\n    if (0.0 \u003d\u003d fHigh) {\n        return xUpperBound;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(initialEstimate, xUpperBound);\n    // Get accuracies.\n    final double functionValueTolerance \u003d getFunctionValueAccuracy();\n    final double absAccuracy \u003d getAbsoluteAccuracy();\n    final double relTolerance \u003d getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean reversed \u003d false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double approximation \u003d xUpperBound - ((fHigh * (xUpperBound - initialEstimate)) / (fHigh - fStart));\n        final double functionValue \u003d computeObjectiveValue(approximation);\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (0.0 \u003d\u003d functionValue) {\n            return approximation;\n        }\n        // Update the bounds with the new approximation.\n        if (0 \u003c\u003d fHigh * functionValue) {\n            switch(method) {\n                case ILLINOIS:\n                    fStart *\u003d 0.5;\n                    break;\n                case PEGASUS:\n                    fStart *\u003d fHigh / (fHigh + functionValue);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (xUpperBound \u003d\u003d approximation) {\n                        initialEstimate \u003d 0.5 * (initialEstimate + xUpperBound - FastMath.max(relTolerance * FastMath.abs(xUpperBound), absAccuracy));\n                        fStart \u003d computeObjectiveValue(initialEstimate);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        } else {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            initialEstimate \u003d xUpperBound;\n            fStart \u003d fHigh;\n            reversed \u003d !reversed;\n        }\n        // Update from [x0, x1] to [x0, x].\n        xUpperBound \u003d approximation;\n        fHigh \u003d functionValue;\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can\u0027t get closer to\n        // the root than we already are.\n        if (functionValueTolerance \u003e\u003d FastMath.abs(fHigh)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return xUpperBound;\n                case LEFT_SIDE:\n                    if (reversed) {\n                        return xUpperBound;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!reversed) {\n                        return xUpperBound;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (0 \u003e\u003d fHigh) {\n                        return xUpperBound;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (0 \u003c\u003d fHigh) {\n                        return xUpperBound;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.max(relTolerance * FastMath.abs(xUpperBound), absAccuracy) \u003e FastMath.abs(xUpperBound - initialEstimate)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return xUpperBound;\n                case LEFT_SIDE:\n                    return reversed ? xUpperBound : initialEstimate;\n                case RIGHT_SIDE:\n                    return reversed ? initialEstimate : xUpperBound;\n                case BELOW_SIDE:\n                    return (0 \u003e\u003d fHigh) ? xUpperBound : initialEstimate;\n                case ABOVE_SIDE:\n                    return (0 \u003c\u003d fHigh) ? xUpperBound : initialEstimate;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
  "JacksonDatabind-39": "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n    //    special unfortunately\n    p.skipChildren();\n    return null;\n}",
  "Math-51": "protected final double doSolve() {\n    // Get initial solution\n    double initialGuess \u003d getMin();\n    double xUpperBound \u003d getMax();\n    double initialObjectiveValue \u003d computeObjectiveValue(initialGuess);\n    double fUpper \u003d computeObjectiveValue(xUpperBound);\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (0.0 \u003d\u003d initialObjectiveValue) {\n        return initialGuess;\n    }\n    if (0.0 \u003d\u003d fUpper) {\n        return xUpperBound;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(initialGuess, xUpperBound);\n    // Get accuracies.\n    final double functionValueTolerance \u003d getFunctionValueAccuracy();\n    final double absoluteTolerance \u003d getAbsoluteAccuracy();\n    final double relativeTolerance \u003d getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean reversed \u003d false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double approximation \u003d xUpperBound - ((fUpper * (xUpperBound - initialGuess)) / (fUpper - initialObjectiveValue));\n        final double fValue \u003d computeObjectiveValue(approximation);\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (0.0 \u003d\u003d fValue) {\n            return approximation;\n        }\n        // Update the bounds with the new approximation.\n        if (0 \u003c\u003d fUpper * fValue) {\n            switch(method) {\n                case ILLINOIS:\n                    initialObjectiveValue *\u003d 0.5;\n                    break;\n                case PEGASUS:\n                    initialObjectiveValue *\u003d fUpper / (fUpper + fValue);\n                    break;\n                // Update formula cannot make any progress: Update the\n                // search interval.\n                default:\n            }\n        } else {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            initialGuess \u003d xUpperBound;\n            initialObjectiveValue \u003d fUpper;\n            reversed \u003d !reversed;\n        }\n        // Update from [x0, x1] to [x0, x].\n        xUpperBound \u003d approximation;\n        fUpper \u003d fValue;\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can\u0027t get closer to\n        // the root than we already are.\n        if (functionValueTolerance \u003e\u003d FastMath.abs(fUpper)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return xUpperBound;\n                case LEFT_SIDE:\n                    if (reversed) {\n                        return xUpperBound;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!reversed) {\n                        return xUpperBound;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (0 \u003e\u003d fUpper) {\n                        return xUpperBound;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (0 \u003c\u003d fUpper) {\n                        return xUpperBound;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.max(relativeTolerance * FastMath.abs(xUpperBound), absoluteTolerance) \u003e FastMath.abs(xUpperBound - initialGuess)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return xUpperBound;\n                case LEFT_SIDE:\n                    return reversed ? xUpperBound : initialGuess;\n                case RIGHT_SIDE:\n                    return reversed ? initialGuess : xUpperBound;\n                case BELOW_SIDE:\n                    return (0 \u003e\u003d fUpper) ? xUpperBound : initialGuess;\n                case ABOVE_SIDE:\n                    return (0 \u003c\u003d fUpper) ? xUpperBound : initialGuess;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
  "Math-52": "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n    // norms computation\n    double u1NormSq \u003d u1.getNormSq();\n    double u2NormSq \u003d u2.getNormSq();\n    double v1NormSquared \u003d v1.getNormSq();\n    double v2NormSquared \u003d v2.getNormSq();\n    if ((0 \u003d\u003d u1NormSq) || (0 \u003d\u003d u2NormSq) || (0 \u003d\u003d v1NormSquared) || (0 \u003d\u003d v2NormSquared)) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n    // normalize v1 in order to have (v1\u0027|v1\u0027) \u003d (u1|u1)\n    v1 \u003d new Vector3D(FastMath.sqrt(u1NormSq / v1NormSquared), v1);\n    // adjust v2 in order to have (u1|u2) \u003d (v1\u0027|v2\u0027) and (v2\u0027|v2\u0027) \u003d (u2|u2)\n    double dotProductU1U2 \u003d u1.dotProduct(u2);\n    double v1DotV2 \u003d v1.dotProduct(v2);\n    double coeffA \u003d dotProductU1U2 / u1NormSq;\n    double coefficientV \u003d v1DotV2 / u1NormSq;\n    double gamma \u003d FastMath.sqrt((u2NormSq - dotProductU1U2 * coeffA) / (v2NormSquared - v1DotV2 * coefficientV));\n    double delta \u003d coeffA - gamma * coefficientV;\n    v2 \u003d new Vector3D(delta, v1, gamma, v2);\n    // preliminary computation\n    Vector3D uBase \u003d u1;\n    Vector3D referenceVector \u003d v1;\n    Vector3D v1MinusU1 \u003d v1.subtract(u1);\n    Vector3D v2DiffU2 \u003d v2.subtract(u2);\n    Vector3D crossProductVector \u003d v1MinusU1.crossProduct(v2DiffU2);\n    Vector3D uCross \u003d u1.crossProduct(u2);\n    double dotProductResult \u003d crossProductVector.dotProduct(uCross);\n    if (0 \u003d\u003d dotProductResult) {\n        // the (q1, q2, q3) vector is close to the (u1, u2) plane\n        // we try other vectors\n        Vector3D vCross \u003d Vector3D.crossProduct(v1, v2);\n        Vector3D v3Differenceu3 \u003d vCross.subtract(uCross);\n        crossProductVector \u003d v1MinusU1.crossProduct(v3Differenceu3);\n        Vector3D u2Adjusted \u003d u1.crossProduct(uCross);\n        dotProductResult \u003d crossProductVector.dotProduct(u2Adjusted);\n        if (0 \u003d\u003d dotProductResult) {\n            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n            crossProductVector \u003d v2DiffU2.crossProduct(v3Differenceu3);\n            ;\n            dotProductResult \u003d crossProductVector.dotProduct(u2.crossProduct(uCross));\n            ;\n            if (0 \u003d\u003d dotProductResult) {\n                // the (q1, q2, q3) vector is aligned with everything\n                // this is really the identity rotation\n                q0 \u003d 1.0;\n                q1 \u003d 0.0;\n                q2 \u003d 0.0;\n                q3 \u003d 0.0;\n                return;\n            }\n            // we will have to use u2 and v2 to compute the scalar part\n            uBase \u003d u2;\n            referenceVector \u003d v2;\n        }\n    }\n    // compute the vectorial part\n    dotProductResult \u003d FastMath.sqrt(dotProductResult);\n    double inverseFactor \u003d 1.0 / (dotProductResult + dotProductResult);\n    q1 \u003d inverseFactor * crossProductVector.getX();\n    q2 \u003d inverseFactor * crossProductVector.getY();\n    q3 \u003d inverseFactor * crossProductVector.getZ();\n    // compute the scalar part\n    crossProductVector \u003d new Vector3D(uBase.getY() * q3 - uBase.getZ() * q2, uBase.getZ() * q1 - uBase.getX() * q3, uBase.getX() * q2 - uBase.getY() * q1);\n    q0 \u003d referenceVector.dotProduct(crossProductVector) / (2 * crossProductVector.getNormSq());\n}",
  "Cli-33": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n    StringBuffer buffer \u003d new StringBuffer(text.length());\n    renderWrappedText(buffer, width, nextLineTabStop, text);\n    pw.println(buffer.toString());\n}",
  "Cli-32": "protected int findWrapPos(String text, int width, int startPos) {\n    int wrapPos;\n    // the line ends before the max wrap pos or a new line char found\n    if (!((-1 !\u003d (wrapPos \u003d text.indexOf(\u0027\\n\u0027, startPos)) \u0026\u0026 width \u003e\u003d wrapPos)) \u0026\u0026 !((-1 !\u003d (wrapPos \u003d text.indexOf(\u0027\\t\u0027, startPos)) \u0026\u0026 width \u003e\u003d wrapPos))) {\n        if (text.length() \u003c\u003d startPos + width) {\n            return -1;\n        }\n    } else {\n        return wrapPos + 1;\n    }\n    // look for the last whitespace character before startPos+width\n    wrapPos \u003d startPos + width;\n    char character;\n    while ((startPos \u003c\u003d wrapPos) \u0026\u0026 (\u0027 \u0027 !\u003d (character \u003d text.charAt(wrapPos))) \u0026\u0026 (\u0027\\n\u0027 !\u003d character) \u0026\u0026 (\u0027\\r\u0027 !\u003d character)) {\n        --wrapPos;\n    }\n    // if we found it - just return\n    if (startPos \u003c wrapPos) {\n        return wrapPos;\n    }\n    // if we didn\u0027t find one, simply chop at startPos+width\n    wrapPos \u003d startPos + width;\n    while ((text.length() \u003e\u003d wrapPos) \u0026\u0026 (\u0027 \u0027 !\u003d (character \u003d text.charAt(wrapPos))) \u0026\u0026 (\u0027\\n\u0027 !\u003d character) \u0026\u0026 (\u0027\\r\u0027 !\u003d character)) {\n        ++wrapPos;\n    }\n    return text.length() \u003d\u003d wrapPos ? -1 : wrapPos;\n}",
  "Math-53": "public Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}",
  "Math-3": "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    final int size \u003d a.length;\n    if (b.length !\u003d size) {\n        throw new DimensionMismatchException(size, b.length);\n    }\n    // Revert to scalar multiplication.\n    final double[] productHigh \u003d new double[size];\n    double prodLowTotal \u003d 0;\n    for (int index \u003d 0; size \u003e index; index++) {\n        final double elementA \u003d a[index];\n        final double scaledA \u003d SPLIT_FACTOR * elementA;\n        final double aHigh \u003d scaledA - (scaledA - elementA);\n        final double aFraction \u003d elementA - aHigh;\n        final double biValue \u003d b[index];\n        final double coefB \u003d SPLIT_FACTOR * biValue;\n        final double bUpper \u003d coefB - (coefB - biValue);\n        final double bLowValue \u003d biValue - bUpper;\n        productHigh[index] \u003d elementA * biValue;\n        final double prodLowValue \u003d aFraction * bLowValue - (((productHigh[index] - aHigh * bUpper) - aFraction * bUpper) - aHigh * bLowValue);\n        prodLowTotal +\u003d prodLowValue;\n    }\n    final double prodHighCurrent \u003d productHigh[0];\n    double prodHighNextValue \u003d productHigh[1];\n    double sumHighPrevious \u003d prodHighCurrent + prodHighNextValue;\n    double sAdjusted \u003d sumHighPrevious - prodHighNextValue;\n    double prodLowAccumulation \u003d (prodHighNextValue - (sumHighPrevious - sAdjusted)) + (prodHighCurrent - sAdjusted);\n    final int lenMinusOneIndex \u003d size - 1;\n    for (int index \u003d 1; lenMinusOneIndex \u003e index; index++) {\n        prodHighNextValue \u003d productHigh[index + 1];\n        final double currentHighSum \u003d sumHighPrevious + prodHighNextValue;\n        sAdjusted \u003d currentHighSum - prodHighNextValue;\n        prodLowAccumulation +\u003d (prodHighNextValue - (currentHighSum - sAdjusted)) + (sumHighPrevious - sAdjusted);\n        sumHighPrevious \u003d currentHighSum;\n    }\n    double output \u003d sumHighPrevious + (prodLowTotal + prodLowAccumulation);\n    if (Double.isNaN(output)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        output \u003d 0;\n        int index \u003d 0;\n        while (size \u003e index) {\n            output +\u003d a[index] * b[index];\n            ++index;\n        }\n    }\n    return output;\n}",
  "Math-55": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    // rescale both vectors without losing precision,\n    // to ensure their norm are the same order of magnitude\n    // we reduce cancellation errors by preconditioning,\n    // we replace v1 by v3 \u003d v1 - rho v2 with rho chosen in order to compute\n    // v3 without loss of precision. See Kahan lecture\n    // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n    // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n    // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n    // compute cross product from v3 and v2 instead of v1 and v2\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}",
  "Math-56": "public int[] getCounts(int index) {\n    if (0 \u003e index || totalSize \u003c\u003d index) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] subindices \u003d new int[dimension];\n    int totalCount \u003d 0;\n    int counter \u003d 0;\n    while (last \u003e counter) {\n        int idx \u003d 0;\n        final int shift \u003d uniCounterOffset[counter];\n        while (index \u003e\u003d totalCount) {\n            totalCount +\u003d shift;\n            ++idx;\n        }\n        --idx;\n        totalCount -\u003d shift;\n        subindices[counter] \u003d idx;\n        counter +\u003d 1;\n    }\n    int idx \u003d 1;\n    while (index \u003e totalCount) {\n        totalCount +\u003d idx;\n        ++idx;\n    }\n    --idx;\n    subindices[last] \u003d idx;\n    return subindices;\n}",
  "Math-2": "public double getNumericalMean() {\n    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n}",
  "Math-57": "private static \u003cT extends Clusterable\u003cT\u003e\u003e List\u003cCluster\u003cT\u003e\u003e chooseInitialCenters(final Collection\u003cT\u003e points, final int k, final Random random) {\n    final List\u003cT\u003e dataPoints \u003d new ArrayList\u003cT\u003e(points);\n    final List\u003cCluster\u003cT\u003e\u003e clusterList \u003d new ArrayList\u003cCluster\u003cT\u003e\u003e();\n    // Choose one center uniformly at random from among the data points.\n    final T initialCenter \u003d dataPoints.remove(random.nextInt(dataPoints.size()));\n    clusterList.add(new Cluster\u003cT\u003e(initialCenter));\n    final double[] distanceSquaredSum \u003d new double[dataPoints.size()];\n    while (k \u003e clusterList.size()) {\n        // For each data point x, compute D(x), the distance between x and\n        // the nearest center that has already been chosen.\n        int total \u003d 0;\n        for (int index \u003d 0; dataPoints.size() \u003e index; index++) {\n            final T point \u003d dataPoints.get(index);\n            final Cluster\u003cT\u003e closest \u003d getNearestCluster(clusterList, point);\n            final double distanceSquared \u003d point.distanceFrom(closest.getCenter());\n            total +\u003d distanceSquared * distanceSquared;\n            distanceSquaredSum[index] \u003d total;\n        }\n        // Add one new data point as a center. Each point x is chosen with\n        // probability proportional to D(x)2\n        final double threshold \u003d random.nextDouble() * total;\n        for (int index \u003d 0; distanceSquaredSum.length \u003e index; index++) {\n            if (threshold \u003c\u003d distanceSquaredSum[index]) {\n                final T point \u003d dataPoints.remove(index);\n                clusterList.add(new Cluster\u003cT\u003e(point));\n                break;\n            }\n        }\n    }\n    return clusterList;\n}",
  "Lang-22": "private static int greatestCommonDivisor(int u, int v) {\n    // From Commons Math:\n    //if either operand is abs 1, return 1:\n    if (1 \u003e\u003d Math.abs(u) || 1 \u003e\u003d Math.abs(v)) {\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can\u0027t necessarily negate a negative number without\n    // overflow)\n    // make u negative\n    if (0 \u003c u) {\n        u \u003d -u;\n    }\n    // make v negative\n    if (0 \u003c v) {\n        v \u003d -v;\n    }\n    // B1. [Find power of 2]\n    int powerOfTwoCount \u003d 0;\n    while (0 \u003d\u003d (u \u0026 1) \u0026\u0026 0 \u003d\u003d (v \u0026 1) \u0026\u0026 31 \u003e powerOfTwoCount) {\n        // while u and v are both even...\n        // cast out twos.\n        u /\u003d 2;\n        // cast out twos.\n        v /\u003d 2;\n        // cast out twos.\n        powerOfTwoCount +\u003d 1;\n    }\n    if (31 \u003d\u003d powerOfTwoCount) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int diff \u003d (1 \u003d\u003d (u \u0026 1)) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u\u003c0 \u0026\u0026 v\u003c0; */\n        // B4/B3: cast out twos from t.\n        while (0 \u003d\u003d (diff \u0026 1)) {\n            // while t is even..\n            // cast out twos\n            diff /\u003d 2;\n        }\n        // B5 [reset max(u,v)]\n        if (0 \u003e\u003d diff) {\n            v \u003d diff;\n        } else {\n            u \u003d -diff;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        diff \u003d (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (0 !\u003d diff);\n    // gcd is u*2^k\n    return -u * (1 \u003c\u003c powerOfTwoCount);\n}",
  "Cli-29": "static String stripLeadingAndTrailingQuotes(String str) {\n    if (str.startsWith(\"\\\"\")) {\n        str \u003d str.substring(1, str.length());\n    }\n    int size \u003d str.length();\n    if (str.endsWith(\"\\\"\")) {\n        str \u003d str.substring(0, size - 1);\n    }\n    return str;\n}",
  "Lang-21": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (null \u003d\u003d cal1 || null \u003d\u003d cal2) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal2.get(Calendar.MILLISECOND) \u003d\u003d cal1.get(Calendar.MILLISECOND) \u0026\u0026 cal2.get(Calendar.SECOND) \u003d\u003d cal1.get(Calendar.SECOND) \u0026\u0026 cal2.get(Calendar.MINUTE) \u003d\u003d cal1.get(Calendar.MINUTE) \u0026\u0026 cal2.get(Calendar.HOUR) \u003d\u003d cal1.get(Calendar.HOUR) \u0026\u0026 cal2.get(Calendar.DAY_OF_YEAR) \u003d\u003d cal1.get(Calendar.DAY_OF_YEAR) \u0026\u0026 cal2.get(Calendar.YEAR) \u003d\u003d cal1.get(Calendar.YEAR) \u0026\u0026 cal2.get(Calendar.ERA) \u003d\u003d cal1.get(Calendar.ERA) \u0026\u0026 cal2.getClass() \u003d\u003d cal1.getClass());\n}",
  "Cli-28": "protected void processProperties(Properties properties) {\n    if (null \u003d\u003d properties) {\n        return;\n    }\n    Enumeration propertyNamesEnumeration \u003d properties.propertyNames();\n    while (propertyNamesEnumeration.hasMoreElements()) {\n        String propertyName \u003d propertyNamesEnumeration.nextElement().toString();\n        if (!cmd.hasOption(propertyName)) {\n            Option opt \u003d getOptions().getOption(propertyName);\n            // get the value from the properties instance\n            String propertyValue \u003d properties.getProperty(propertyName);\n            if (!opt.hasArg()) {\n                if (!(\"yes\".equalsIgnoreCase(propertyValue) || \"true\".equalsIgnoreCase(propertyValue) || \"1\".equalsIgnoreCase(propertyValue))) {\n                    // if the value is not yes, true or 1 then don\u0027t add the\n                    // option to the CommandLine\n                    break;\n                }\n            } else {\n                if (null \u003d\u003d opt.getValues() || 0 \u003d\u003d opt.getValues().length) {\n                    try {\n                        opt.addValueForProcessing(propertyValue);\n                    } catch (RuntimeException exp) {\n                        // if we cannot add the value don\u0027t worry about it\n                    }\n                }\n            }\n            cmd.addOption(opt);\n        }\n    }\n}",
  "Cli-27": "public void setSelected(Option option) throws AlreadySelectedException {\n    if (null \u003d\u003d option) {\n        // reset the option previously selected\n        selected \u003d null;\n        return;\n    }\n    // if no option has already been selected or the\n    // same option is being reselected then set the\n    // selected member variable\n    if (null !\u003d selected \u0026\u0026 !selected.equals(option.getOpt())) {\n        throw new AlreadySelectedException(this, option);\n    } else {\n        selected \u003d option.getOpt();\n    }\n}",
  "Cli-26": "public static Option create(String opt) throws IllegalArgumentException {\n    // create the option\n    Option optionInstance \u003d new Option(opt, description);\n    // set the option properties\n    optionInstance.setLongOpt(longopt);\n    optionInstance.setRequired(required);\n    optionInstance.setOptionalArg(optionalArg);\n    optionInstance.setArgs(numberOfArgs);\n    optionInstance.setType(type);\n    optionInstance.setValueSeparator(valuesep);\n    optionInstance.setArgName(argName);\n    // reset the OptionBuilder properties\n    OptionBuilder.reset();\n    // return the Option instance\n    return optionInstance;\n}",
  "Cli-25": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int wrapPosition \u003d findWrapPos(text, width, 0);\n    if (-1 \u003d\u003d wrapPosition) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, wrapPosition))).append(defaultNewLine);\n    if (width \u003c\u003d nextLineTabStop) {\n        // stops infinite loop happening\n        nextLineTabStop \u003d width - 1;\n    }\n    // all following lines must be padded with nextLineTabStop space\n    // characters\n    final String indentation \u003d createPadding(nextLineTabStop);\n    while (true) {\n        text \u003d indentation + text.substring(wrapPosition).trim();\n        wrapPosition \u003d findWrapPos(text, width, 0);\n        if (-1 \u003d\u003d wrapPosition) {\n            sb.append(text);\n            return sb;\n        }\n        if ((width \u003c text.length()) \u0026\u0026 (nextLineTabStop - 1 \u003d\u003d wrapPosition)) {\n            wrapPosition \u003d width;\n        }\n        sb.append(rtrim(text.substring(0, wrapPosition))).append(defaultNewLine);\n    }\n}",
  "Math-25": "private void guessAOmega() {\n    // initialize the sums for the linear model between the two integrals\n    double squaredXSum \u003d 0;\n    double sumF2Squared \u003d 0;\n    double sXY \u003d 0;\n    double sxPrimeIntegral \u003d 0;\n    double szIntegral \u003d 0;\n    double latestX \u003d observations[0].getX();\n    double currentValueY \u003d observations[0].getY();\n    double secondFunctionIntegral \u003d 0;\n    double fDerivativeSquaredIntegral \u003d 0;\n    final double initialX \u003d latestX;\n    for (int index \u003d 1; observations.length \u003e index; ++index) {\n        // one step forward\n        final double lastX \u003d latestX;\n        final double previousValueY \u003d currentValueY;\n        latestX \u003d observations[index].getX();\n        currentValueY \u003d observations[index].getY();\n        // update the integrals of f\u003csup\u003e2\u003c/sup\u003e and f\u0027\u003csup\u003e2\u003c/sup\u003e\n        // considering a linear model for f (and therefore constant f\u0027)\n        final double deltaX \u003d latestX - lastX;\n        final double deltaY \u003d currentValueY - previousValueY;\n        final double f2IncrementalIntegral \u003d deltaX * (previousValueY * previousValueY + previousValueY * currentValueY + currentValueY * currentValueY) / 3;\n        final double fDerivativeSquaredStepIntegral \u003d deltaY * deltaY / deltaX;\n        final double x \u003d latestX - initialX;\n        secondFunctionIntegral +\u003d f2IncrementalIntegral;\n        fDerivativeSquaredIntegral +\u003d fDerivativeSquaredStepIntegral;\n        squaredXSum +\u003d x * x;\n        sumF2Squared +\u003d secondFunctionIntegral * secondFunctionIntegral;\n        sXY +\u003d x * secondFunctionIntegral;\n        sxPrimeIntegral +\u003d x * fDerivativeSquaredIntegral;\n        szIntegral +\u003d secondFunctionIntegral * fDerivativeSquaredIntegral;\n    }\n    // compute the amplitude and pulsation coefficients\n    double coefficient1 \u003d sumF2Squared * sxPrimeIntegral - sXY * szIntegral;\n    double coefficientC2 \u003d sXY * sxPrimeIntegral - squaredXSum * szIntegral;\n    double cDeterminant \u003d squaredXSum * sumF2Squared - sXY * sXY;\n    if (!((0 \u003e coefficient1 / coefficientC2)) \u0026\u0026 !((0 \u003e coefficientC2 / cDeterminant))) {\n        // In some ill-conditioned cases (cf. MATH-844), the guesser\n        // procedure cannot produce sensible results.\n        a \u003d FastMath.sqrt(coefficient1 / coefficientC2);\n        omega \u003d FastMath.sqrt(coefficientC2 / cDeterminant);\n    } else {\n        final int last \u003d observations.length - 1;\n        // Range of the observations, assuming that the\n        // observations are sorted.\n        final double xInterval \u003d observations[last].getX() - observations[0].getX();\n        if (0 \u003d\u003d xInterval) {\n            throw new ZeroException();\n        }\n        omega \u003d 2 * Math.PI / xInterval;\n        double yMinimum \u003d Double.POSITIVE_INFINITY;\n        double yUpperBound \u003d Double.NEGATIVE_INFINITY;\n        int index \u003d 1;\n        while (observations.length \u003e index) {\n            final double observedY \u003d observations[index].getY();\n            if (yMinimum \u003e observedY) {\n                yMinimum \u003d observedY;\n            }\n            if (yUpperBound \u003c observedY) {\n                yUpperBound \u003d observedY;\n            }\n            ++index;\n        }\n        a \u003d 0.5 * (yUpperBound - yMinimum);\n    }\n}",
  "Math-26": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long maxValue \u003d Integer.MAX_VALUE;\n    double initialValue \u003d value;\n    long integerPart \u003d (long) FastMath.floor(initialValue);\n    if (maxValue \u003c integerPart) {\n        throw new FractionConversionException(value, integerPart, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (epsilon \u003e FastMath.abs(integerPart - value)) {\n        this.numerator \u003d (int) integerPart;\n        this.denominator \u003d 1;\n        return;\n    }\n    long previousNumerator \u003d 1;\n    long denominatorPrevious \u003d 0;\n    long prevNumerator \u003d integerPart;\n    long denominatorCurrent \u003d 1;\n    long p2 \u003d 0;\n    long denominator2 \u003d 1;\n    int iterationCount \u003d 0;\n    boolean terminate \u003d false;\n    do {\n        ++iterationCount;\n        double reciprocal \u003d 1.0 / (initialValue - integerPart);\n        long aNext \u003d (long) FastMath.floor(reciprocal);\n        p2 \u003d (aNext * prevNumerator) + previousNumerator;\n        denominator2 \u003d (aNext * denominatorCurrent) + denominatorPrevious;\n        if ((maxValue \u003c p2) || (maxValue \u003c denominator2)) {\n            throw new FractionConversionException(value, p2, denominator2);\n        }\n        double approximation \u003d (double) p2 / (double) denominator2;\n        if (maxIterations \u003c\u003d iterationCount || epsilon \u003e\u003d FastMath.abs(approximation - value) || maxDenominator \u003c\u003d denominator2) {\n            terminate \u003d true;\n        } else {\n            previousNumerator \u003d prevNumerator;\n            prevNumerator \u003d p2;\n            denominatorPrevious \u003d denominatorCurrent;\n            denominatorCurrent \u003d denominator2;\n            integerPart \u003d aNext;\n            initialValue \u003d reciprocal;\n        }\n    } while (!terminate);\n    if (maxIterations \u003c\u003d iterationCount) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (maxDenominator \u003c\u003d denominator2) {\n        this.numerator \u003d (int) prevNumerator;\n        this.denominator \u003d (int) denominatorCurrent;\n    } else {\n        this.numerator \u003d (int) p2;\n        this.denominator \u003d (int) denominator2;\n    }\n}",
  "JacksonDatabind-20": "public JsonNode setAll(Map\u003cString, ? extends JsonNode\u003e properties) {\n    for (Map.Entry\u003cString, ? extends JsonNode\u003e entry : properties.entrySet()) {\n        JsonNode value \u003d entry.getValue();\n        if (null \u003d\u003d value) {\n            value \u003d nullNode();\n        }\n        _children.put(entry.getKey(), value);\n    }\n    return this;\n}",
  "Math-27": "public double percentageValue() {\n    return multiply(100).doubleValue();\n}",
  "Math-28": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n    // create a list of all the rows that tie for the lowest score in the minimum ratio test\n    List\u003cInteger\u003e tieRowIndices \u003d new ArrayList\u003cInteger\u003e();\n    double minRatioValue \u003d Double.MAX_VALUE;\n    for (int rowIndex \u003d tableau.getNumObjectiveFunctions(); tableau.getHeight() \u003e rowIndex; rowIndex++) {\n        final double rightHandSide \u003d tableau.getEntry(rowIndex, tableau.getWidth() - 1);\n        final double value \u003d tableau.getEntry(rowIndex, col);\n        if (0 \u003c Precision.compareTo(value, 0d, maxUlps)) {\n            final double quotient \u003d rightHandSide / value;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int comparisonResult \u003d Double.compare(quotient, minRatioValue);\n            if (0 !\u003d comparisonResult) {\n                if (0 \u003e comparisonResult) {\n                    minRatioValue \u003d quotient;\n                    tieRowIndices \u003d new ArrayList\u003cInteger\u003e();\n                    tieRowIndices.add(rowIndex);\n                }\n            } else {\n                tieRowIndices.add(rowIndex);\n            }\n        }\n    }\n    if (0 !\u003d tieRowIndices.size()) {\n        if (1 \u003c tieRowIndices.size()) {\n            // there\u0027s a degeneracy as indicated by a tie in the minimum ratio test\n            // 1. check if there\u0027s an artificial variable that can be forced out of the basis\n            for (Integer index : tieRowIndices) {\n                int rowIndex \u003d 0;\n                while (tableau.getNumArtificialVariables() \u003e rowIndex) {\n                    int column \u003d rowIndex + tableau.getArtificialVariableOffset();\n                    final double value \u003d tableau.getEntry(index, column);\n                    if (Precision.equals(value, 1d, maxUlps) \u0026\u0026 index.equals(tableau.getBasicRow(column))) {\n                        return index;\n                    }\n                    rowIndex +\u003d 1;\n                }\n            }\n            // 2. apply Bland\u0027s rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n            Integer selectedRow \u003d null;\n            int minRowIndex \u003d tableau.getWidth();\n            for (Integer index : tieRowIndices) {\n                int rowIndex \u003d tableau.getNumObjectiveFunctions();\n                while (tableau.getWidth() - 1 \u003e rowIndex \u0026\u0026 index !\u003d selectedRow) {\n                    if (tableau.getBasicRow(rowIndex) \u003d\u003d index) {\n                        if (minRowIndex \u003e rowIndex) {\n                            minRowIndex \u003d rowIndex;\n                            selectedRow \u003d index;\n                        }\n                    }\n                    rowIndex +\u003d 1;\n                }\n            }\n            return selectedRow;\n        }\n    } else {\n        return null;\n    }\n    return tieRowIndices.get(0);\n}",
  "JacksonDatabind-24": "public BaseSettings withDateFormat(DateFormat df) {\n    if (df \u003d\u003d _dateFormat) {\n        return this;\n    }\n    TimeZone timeZone \u003d (null \u003d\u003d df) ? _timeZone : df.getTimeZone();\n    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, timeZone, _defaultBase64);\n}",
  "Cli-24": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int wrapPos \u003d findWrapPos(text, width, 0);\n    if (-1 \u003d\u003d wrapPos) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, wrapPos))).append(defaultNewLine);\n    if (width \u003c\u003d nextLineTabStop) {\n        // stops infinite loop happening\n        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\n    }\n    // all following lines must be padded with nextLineTabStop space\n    // characters\n    final String indentation \u003d createPadding(nextLineTabStop);\n    while (true) {\n        text \u003d indentation + text.substring(wrapPos).trim();\n        wrapPos \u003d findWrapPos(text, width, 0);\n        if (-1 \u003d\u003d wrapPos) {\n            sb.append(text);\n            return sb;\n        }\n        if ((width \u003c text.length()) \u0026\u0026 (nextLineTabStop - 1 \u003d\u003d wrapPos)) {\n            wrapPos \u003d width;\n        }\n        sb.append(rtrim(text.substring(0, wrapPos))).append(defaultNewLine);\n    }\n}",
  "JacksonDatabind-27": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt) throws IOException {\n    final ExternalTypeHandler handler \u003d _externalTypeIdHandler.start();\n    final PropertyBasedCreator builder \u003d _propertyBasedCreator;\n    PropertyValueBuffer propertyValueCollector \u003d builder.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokenStream \u003d new TokenBuffer(p);\n    tokenStream.writeStartObject();\n    JsonToken token \u003d p.getCurrentToken();\n    while (JsonToken.FIELD_NAME \u003d\u003d token) {\n        String fieldName \u003d p.getCurrentName();\n        // to point to value\n        p.nextToken();\n        // creator property?\n        SettableBeanProperty constructorProperty \u003d builder.findCreatorProperty(fieldName);\n        if (null !\u003d constructorProperty) {\n            // first: let\u0027s check to see if this might be part of value with external type id:\n            // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n            //   since it is not the bean\n            if (!handler.handlePropertyValue(p, ctxt, fieldName, propertyValueCollector)) {\n                // Last creator property to set?\n                if (propertyValueCollector.assignParameter(constructorProperty, _deserializeWithErrorWrapping(p, ctxt, constructorProperty))) {\n                    // to move to following FIELD_NAME/END_OBJECT\n                    token \u003d p.nextToken();\n                    Object instance;\n                    try {\n                        instance \u003d builder.build(ctxt, propertyValueCollector);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), fieldName, ctxt);\n                        // never gets here\n                        continue;\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (JsonToken.FIELD_NAME \u003d\u003d token) {\n                        // to skip name\n                        p.nextToken();\n                        tokenStream.copyCurrentStructure(p);\n                        token \u003d p.nextToken();\n                    }\n                    if (_beanType.getRawClass() !\u003d instance.getClass()) {\n                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                        //   it\u0027s too complicated, so bail out\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return handler.complete(p, ctxt, instance);\n                }\n            } else {\n                ;\n            }\n            continue;\n        }\n        // Object Id property?\n        if (propertyValueCollector.readIdProperty(fieldName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty property \u003d _beanProperties.find(fieldName);\n        if (null !\u003d property) {\n            propertyValueCollector.bufferProperty(property, property.deserialize(p, ctxt));\n            continue;\n        }\n        // external type id (or property that depends on it)?\n        if (handler.handlePropertyValue(p, ctxt, fieldName, null)) {\n            continue;\n        }\n        /* As per [JACKSON-313], things marked as ignorable should not be\n         * passed to any setter\n         */\n        if (null !\u003d _ignorableProps \u0026\u0026 _ignorableProps.contains(fieldName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), fieldName);\n            continue;\n        }\n        // \"any property\"?\n        if (null !\u003d _anySetter) {\n            propertyValueCollector.bufferAnyProperty(_anySetter, fieldName, _anySetter.deserialize(p, ctxt));\n        }\n        token \u003d p.nextToken();\n    }\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return handler.complete(p, ctxt, propertyValueCollector, builder);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        // never gets here\n        return null;\n    }\n}",
  "Lang-17": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (null \u003d\u003d out) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (null \u003d\u003d input) {\n        return;\n    }\n    int index \u003d 0;\n    int length \u003d Character.codePointCount(input, 0, input.length());\n    while (length \u003e index) {\n        int processed \u003d translate(input, index, out);\n        if (0 !\u003d processed) {\n            int codePointIndex \u003d 0;\n            while (processed \u003e codePointIndex) {\n                if (length - 2 \u003c\u003d index) {\n                    index +\u003d 1;\n                } else {\n                    index +\u003d Character.charCount(Character.codePointAt(input, index));\n                }\n                codePointIndex +\u003d 1;\n            }\n            // contract with translators is that they have to understand codepoints\n            index -\u003d 1;\n        } else {\n            char[] chars \u003d Character.toChars(Character.codePointAt(input, index));\n            out.write(chars);\n        }\n        index +\u003d 1;\n    }\n}",
  "Cli-23": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int wrapPos \u003d findWrapPos(text, width, 0);\n    if (-1 \u003d\u003d wrapPos) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, wrapPos))).append(defaultNewLine);\n    // all following lines must be padded with nextLineTabStop space\n    // characters\n    final String indentation \u003d createPadding(nextLineTabStop);\n    while (true) {\n        int previousWrapPos \u003d wrapPos;\n        text \u003d indentation + text.substring(wrapPos).trim();\n        wrapPos \u003d findWrapPos(text, width, 0);\n        if (-1 !\u003d wrapPos) {\n            if (previousWrapPos \u003d\u003d wrapPos) {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n            }\n        } else {\n            sb.append(text);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, wrapPos))).append(defaultNewLine);\n    }\n}",
  "JacksonDatabind-28": "public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    if (JsonToken.START_OBJECT \u003d\u003d p.getCurrentToken()) {\n        p.nextToken();\n        return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n    }\n    // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n    //    if caller has advanced to the first token of Object, but for empty Object\n    if (JsonToken.FIELD_NAME \u003d\u003d p.getCurrentToken()) {\n        return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n    }\n    throw ctxt.mappingException(ObjectNode.class);\n}",
  "Lang-16": "public static Number createNumber(String str) throws NumberFormatException {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char finalChar \u003d str.charAt(str.length() - 1);\n    String coefficient;\n    String fraction;\n    String exponent;\n    int decimalPosition \u003d str.indexOf(\u0027.\u0027);\n    int exponentPosition \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (-1 \u003e\u003d decimalPosition) {\n        if (-1 \u003e\u003d exponentPosition) {\n            coefficient \u003d str;\n        } else {\n            if (str.length() \u003c exponentPosition) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            coefficient \u003d str.substring(0, exponentPosition);\n        }\n        fraction \u003d null;\n    } else {\n        if (-1 \u003e\u003d exponentPosition) {\n            fraction \u003d str.substring(decimalPosition + 1);\n        } else {\n            if (decimalPosition \u003e exponentPosition || str.length() \u003c exponentPosition) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            fraction \u003d str.substring(decimalPosition + 1, exponentPosition);\n        }\n        coefficient \u003d str.substring(0, decimalPosition);\n    }\n    if (Character.isDigit(finalChar) || \u0027.\u0027 \u003d\u003d finalChar) {\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length());\n        }\n        if (null !\u003d fraction || null !\u003d exponent) {\n            //Must be a float,double,BigDec\n            boolean isZeroValue \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n            try {\n                Float floatValue \u003d createFloat(str);\n                if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isZeroValue))) {\n                    return floatValue;\n                }\n            } catch (NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n            }\n            try {\n                Double dbl \u003d createDouble(str);\n                if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.doubleValue() \u0026\u0026 !isZeroValue))) {\n                    return dbl;\n                }\n            } catch (NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n            }\n            return createBigDecimal(str);\n        } else {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n    } else {\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length() - 1);\n        }\n        //Requesting a specific type..\n        String numericValue \u003d str.substring(0, str.length() - 1);\n        boolean isZeroValue \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n        switch(finalChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (null \u003d\u003d fraction \u0026\u0026 null \u003d\u003d exponent \u0026\u0026 (\u0027-\u0027 \u003d\u003d numericValue.charAt(0) \u0026\u0026 isDigits(numericValue.substring(1)) || isDigits(numericValue))) {\n                    try {\n                        return createLong(numericValue);\n                    } catch (NumberFormatException nfe) {\n                        // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numericValue);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float floatValue \u003d NumberUtils.createFloat(numericValue);\n                    if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isZeroValue))) {\n                        //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return floatValue;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double dbl \u003d NumberUtils.createDouble(numericValue);\n                    if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.floatValue() \u0026\u0026 !isZeroValue))) {\n                        return dbl;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numericValue);\n                } catch (NumberFormatException e) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n}",
  "Lang-19": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    int seqEnd \u003d input.length();\n    // Uses -2 to ensure there is something after the \u0026#\n    if (\u0027\u0026\u0027 \u003d\u003d input.charAt(index) \u0026\u0026 seqEnd - 1 \u003e index \u0026\u0026 \u0027#\u0027 \u003d\u003d input.charAt(index + 1)) {\n        int begin \u003d index + 2;\n        boolean isHexadecimal \u003d false;\n        char initialChar \u003d input.charAt(begin);\n        if (\u0027x\u0027 \u003d\u003d initialChar || \u0027X\u0027 \u003d\u003d initialChar) {\n            begin +\u003d 1;\n            isHexadecimal \u003d true;\n            // Check there\u0027s more than just an x after the \u0026#\n        }\n        int finalIndex \u003d begin;\n        // Note that this supports character codes without a ; on the end\n        while (\u0027;\u0027 !\u003d input.charAt(finalIndex)) {\n            finalIndex +\u003d 1;\n        }\n        int numericValue;\n        try {\n            if (!isHexadecimal) {\n                numericValue \u003d Integer.parseInt(input.subSequence(begin, finalIndex).toString(), 10);\n            } else {\n                numericValue \u003d Integer.parseInt(input.subSequence(begin, finalIndex).toString(), 16);\n            }\n        } catch (NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(begin, finalIndex) + \"[\" + begin + \"][\" + finalIndex + \"]\");\n            return 0;\n        }\n        if (0xFFFF \u003e\u003d numericValue) {\n            out.write(numericValue);\n        } else {\n            char[] charsArray \u003d Character.toChars(numericValue);\n            out.write(charsArray[0]);\n            out.write(charsArray[1]);\n        }\n        return 2 + (finalIndex - begin) + (isHexadecimal ? 1 : 0) + 1;\n    }\n    return 0;\n}",
  "Lang-18": "protected List\u003cRule\u003e parsePattern() {\n    DateFormatSymbols dateFormatSymbols \u003d new DateFormatSymbols(mLocale);\n    List\u003cRule\u003e patterns \u003d new ArrayList\u003cRule\u003e();\n    String[] erasList \u003d dateFormatSymbols.getEras();\n    String[] monthsArray \u003d dateFormatSymbols.getMonths();\n    String[] abbreviatedMonths \u003d dateFormatSymbols.getShortMonths();\n    String[] weekdaysArray \u003d dateFormatSymbols.getWeekdays();\n    String[] abbreviatedWeekdays \u003d dateFormatSymbols.getShortWeekdays();\n    String[] ampmMarkers \u003d dateFormatSymbols.getAmPmStrings();\n    int size \u003d mPattern.length();\n    int[] positionRef \u003d new int[1];\n    int index \u003d 0;\n    while (size \u003e index) {\n        positionRef[0] \u003d index;\n        String substring \u003d parseToken(mPattern, positionRef);\n        index \u003d positionRef[0];\n        int tokenLength \u003d substring.length();\n        if (0 \u003d\u003d tokenLength) {\n            break;\n        }\n        Rule directive;\n        char character \u003d substring.charAt(0);\n        switch(character) {\n            case // era designator (text)\n            \u0027G\u0027:\n                directive \u003d new TextField(Calendar.ERA, erasList);\n                break;\n            case // year (number)\n            \u0027y\u0027:\n                if (4 \u003e tokenLength) {\n                    directive \u003d TwoDigitYearField.INSTANCE;\n                } else {\n                    directive \u003d selectNumberRule(Calendar.YEAR, tokenLength);\n                }\n                break;\n            case // month in year (text and number)\n            \u0027M\u0027:\n                if (4 \u003e tokenLength) {\n                    if (3 !\u003d tokenLength) {\n                        if (2 !\u003d tokenLength) {\n                            directive \u003d UnpaddedMonthField.INSTANCE;\n                        } else {\n                            directive \u003d TwoDigitMonthField.INSTANCE;\n                        }\n                    } else {\n                        directive \u003d new TextField(Calendar.MONTH, abbreviatedMonths);\n                    }\n                } else {\n                    directive \u003d new TextField(Calendar.MONTH, monthsArray);\n                }\n                break;\n            case // day in month (number)\n            \u0027d\u0027:\n                directive \u003d selectNumberRule(Calendar.DAY_OF_MONTH, tokenLength);\n                break;\n            case // hour in am/pm (number, 1..12)\n            \u0027h\u0027:\n                directive \u003d new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLength));\n                break;\n            case // hour in day (number, 0..23)\n            \u0027H\u0027:\n                directive \u003d selectNumberRule(Calendar.HOUR_OF_DAY, tokenLength);\n                break;\n            case // minute in hour (number)\n            \u0027m\u0027:\n                directive \u003d selectNumberRule(Calendar.MINUTE, tokenLength);\n                break;\n            case // second in minute (number)\n            \u0027s\u0027:\n                directive \u003d selectNumberRule(Calendar.SECOND, tokenLength);\n                break;\n            case // millisecond (number)\n            \u0027S\u0027:\n                directive \u003d selectNumberRule(Calendar.MILLISECOND, tokenLength);\n                break;\n            case // day in week (text)\n            \u0027E\u0027:\n                directive \u003d new TextField(Calendar.DAY_OF_WEEK, 4 \u003e tokenLength ? abbreviatedWeekdays : weekdaysArray);\n                break;\n            case // day in year (number)\n            \u0027D\u0027:\n                directive \u003d selectNumberRule(Calendar.DAY_OF_YEAR, tokenLength);\n                break;\n            case // day of week in month (number)\n            \u0027F\u0027:\n                directive \u003d selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLength);\n                break;\n            case // week in year (number)\n            \u0027w\u0027:\n                directive \u003d selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLength);\n                break;\n            case // week in month (number)\n            \u0027W\u0027:\n                directive \u003d selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLength);\n                break;\n            case // am/pm marker (text)\n            \u0027a\u0027:\n                directive \u003d new TextField(Calendar.AM_PM, ampmMarkers);\n                break;\n            case // hour in day (1..24)\n            \u0027k\u0027:\n                directive \u003d new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLength));\n                break;\n            case // hour in am/pm (0..11)\n            \u0027K\u0027:\n                directive \u003d selectNumberRule(Calendar.HOUR, tokenLength);\n                break;\n            case // time zone (text)\n            \u0027z\u0027:\n                if (4 \u003e tokenLength) {\n                    directive \u003d new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                } else {\n                    directive \u003d new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                }\n                break;\n            case // time zone (value)\n            \u0027Z\u0027:\n                if (1 !\u003d tokenLength) {\n                    directive \u003d TimeZoneNumberRule.INSTANCE_COLON;\n                } else {\n                    directive \u003d TimeZoneNumberRule.INSTANCE_NO_COLON;\n                }\n                break;\n            case // literal text\n            \u0027\\\u0027\u0027:\n                String extractedSub \u003d substring.substring(1);\n                if (1 !\u003d extractedSub.length()) {\n                    directive \u003d new StringLiteral(extractedSub);\n                } else {\n                    directive \u003d new CharacterLiteral(extractedSub.charAt(0));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + substring);\n        }\n        patterns.add(directive);\n        index +\u003d 1;\n    }\n    return patterns;\n}",
  "Math-20": "public double[] repairAndDecode(final double[] x) {\n    return decode(x);\n}",
  "Cli-20": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\n    init();\n    this.options \u003d options;\n    // an iterator for the command line tokens\n    Iterator iterator \u003d Arrays.asList(arguments).iterator();\n    // process each command line token\n    while (iterator.hasNext()) {\n        // get the next command line token\n        String argument \u003d (String) iterator.next();\n        // handle long option --foo or --foo\u003dbar\n        if (!argument.startsWith(\"--\")) {\n            // single hyphen\n            if (!\"-\".equals(argument)) {\n                if (!argument.startsWith(\"-\")) {\n                    if (!stopAtNonOption) {\n                        tokens.add(argument);\n                    } else {\n                        process(argument);\n                    }\n                } else {\n                    if (2 !\u003d argument.length()) {\n                        if (// requires bursting\n                        !options.hasOption(argument)) {\n                            burstToken(argument, stopAtNonOption);\n                        } else {\n                            tokens.add(argument);\n                        }\n                    } else {\n                        processOptionToken(argument, stopAtNonOption);\n                    }\n                }\n            } else {\n                tokens.add(argument);\n            }\n        } else {\n            if (-1 \u003d\u003d argument.indexOf(\u0027\u003d\u0027)) {\n                tokens.add(argument);\n            } else {\n                tokens.add(argument.substring(0, argument.indexOf(\u0027\u003d\u0027)));\n                tokens.add(argument.substring(argument.indexOf(\u0027\u003d\u0027) + 1, argument.length()));\n            }\n        }\n        gobble(iterator);\n    }\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}",
  "Math-21": "public RectangularCholeskyDecomposition(RealMatrix matrix, double small) throws NonPositiveDefiniteMatrixException {\n    final int dimension \u003d matrix.getRowDimension();\n    final double[][] dataMatrix \u003d matrix.getData();\n    final double[][] choleskyMatrix \u003d new double[dimension][dimension];\n    int[] pivot \u003d new int[dimension];\n    int[] position \u003d new int[dimension];\n    for (int indexVariable \u003d 0; dimension \u003e indexVariable; ++indexVariable) {\n        position[indexVariable] \u003d indexVariable;\n    }\n    int rankIndex \u003d 0;\n    boolean continueLoop \u003d true;\n    while (continueLoop) {\n        // find maximal diagonal element\n        pivot[rankIndex] \u003d rankIndex;\n        for (int indexVariable \u003d rankIndex + 1; dimension \u003e indexVariable; ++indexVariable) {\n            int ii \u003d position[indexVariable];\n            int isi \u003d position[pivot[indexVariable]];\n            if (dataMatrix[isi][isi] \u003c dataMatrix[ii][ii]) {\n                pivot[rankIndex] \u003d indexVariable;\n            }\n        }\n        // swap elements\n        if (rankIndex !\u003d pivot[rankIndex]) {\n            int tempIndex \u003d position[rankIndex];\n            position[rankIndex] \u003d position[pivot[rankIndex]];\n            position[pivot[rankIndex]] \u003d tempIndex;\n        }\n        // check diagonal element\n        int rowIndex \u003d position[rankIndex];\n        if (small \u003c\u003d dataMatrix[rowIndex][rowIndex]) {\n            // transform the matrix\n            final double rootSquare \u003d FastMath.sqrt(dataMatrix[rowIndex][rowIndex]);\n            choleskyMatrix[rankIndex][rankIndex] \u003d rootSquare;\n            final double reciprocal \u003d 1 / rootSquare;\n            int indexVariable \u003d rankIndex + 1;\n            while (dimension \u003e indexVariable) {\n                final int ii \u003d position[indexVariable];\n                final double tempValue \u003d reciprocal * dataMatrix[ii][rowIndex];\n                choleskyMatrix[indexVariable][rankIndex] \u003d tempValue;\n                dataMatrix[ii][ii] -\u003d tempValue * tempValue;\n                int col \u003d rankIndex + 1;\n                while (indexVariable \u003e col) {\n                    final int entryIndex \u003d position[col];\n                    final double f \u003d dataMatrix[ii][entryIndex] - tempValue * choleskyMatrix[col][rankIndex];\n                    dataMatrix[ii][entryIndex] \u003d f;\n                    dataMatrix[entryIndex][ii] \u003d f;\n                    ++col;\n                }\n                ++indexVariable;\n            }\n            // prepare next iteration\n            continueLoop \u003d dimension \u003e ++rankIndex;\n        } else {\n            if (0 \u003d\u003d rankIndex) {\n                throw new NonPositiveDefiniteMatrixException(dataMatrix[rowIndex][rowIndex], rowIndex, small);\n            }\n            int indexVariable \u003d rankIndex;\n            while (dimension \u003e indexVariable) {\n                if (-small \u003e dataMatrix[position[indexVariable]][position[indexVariable]]) {\n                    // there is at least one sufficiently negative diagonal element,\n                    // the symmetric positive semidefinite matrix is wrong\n                    throw new NonPositiveDefiniteMatrixException(dataMatrix[position[indexVariable]][position[indexVariable]], indexVariable, small);\n                }\n                ++indexVariable;\n            }\n            // all remaining diagonal elements are close to zero, we consider we have\n            // found the rank of the symmetric positive semidefinite matrix\n            ++rankIndex;\n            continueLoop \u003d false;\n        }\n    }\n    // build the root matrix\n    rank \u003d rankIndex;\n    root \u003d MatrixUtils.createRealMatrix(dimension, rankIndex);\n    for (int indexVariable \u003d 0; dimension \u003e indexVariable; ++indexVariable) {\n        int col \u003d 0;\n        while (rankIndex \u003e col) {\n            root.setEntry(position[indexVariable], col, choleskyMatrix[indexVariable][col]);\n            ++col;\n        }\n    }\n}",
  "Lang-12": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (0 !\u003d count) {\n        if (0 \u003e count) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n    } else {\n        return \"\";\n    }\n    if (0 \u003d\u003d start \u0026\u0026 0 \u003d\u003d end) {\n        if (letters || numbers) {\n            end \u003d \u0027z\u0027 + 1;\n            start \u003d \u0027 \u0027;\n        } else {\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] array \u003d new char[count];\n    int range \u003d end - start;\n    while (0 !\u003d count--) {\n        char character;\n        if (null !\u003d chars) {\n            character \u003d chars[random.nextInt(range) + start];\n        } else {\n            character \u003d (char) (random.nextInt(range) + start);\n        }\n        if (!letters || !Character.isLetter(character) \u0026\u0026 !numbers || !Character.isDigit(character) \u0026\u0026 letters || numbers) {\n            count +\u003d 1;\n        } else {\n            if (56320 \u003e character || 57343 \u003c character) {\n                if (55296 \u003e character || 56191 \u003c character) {\n                    if (56192 \u003e character || 56319 \u003c character) {\n                        array[count] \u003d character;\n                    } else {\n                        // private high surrogate, no effing clue, so skip it\n                        count +\u003d 1;\n                    }\n                } else {\n                    if (0 !\u003d count) {\n                        // high surrogate, insert low surrogate before putting it in\n                        array[count] \u003d (char) (56320 + random.nextInt(128));\n                        count -\u003d 1;\n                        array[count] \u003d character;\n                    } else {\n                        count +\u003d 1;\n                    }\n                }\n            } else {\n                if (0 !\u003d count) {\n                    // low surrogate, insert high surrogate after putting it in\n                    array[count] \u003d character;\n                    count -\u003d 1;\n                    array[count] \u003d (char) (55296 + random.nextInt(128));\n                } else {\n                    count +\u003d 1;\n                }\n            }\n        }\n    }\n    return new String(array);\n}",
  "Math-23": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinimization \u003d GoalType.MINIMIZE \u003d\u003d getGoalType();\n    final double lowerBound \u003d getMin();\n    final double median \u003d getStartValue();\n    final double highValue \u003d getMax();\n    // Optional additional convergence criteria.\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e convergenceTester \u003d getConvergenceChecker();\n    double a;\n    double highBoundary;\n    if (highValue \u003c\u003d lowerBound) {\n        a \u003d highValue;\n        highBoundary \u003d lowerBound;\n    } else {\n        a \u003d lowerBound;\n        highBoundary \u003d highValue;\n    }\n    double value \u003d median;\n    double v \u003d value;\n    double z \u003d value;\n    double stepSize \u003d 0;\n    double e \u003d 0;\n    double objectValue \u003d computeObjectiveValue(value);\n    if (!isMinimization) {\n        objectValue \u003d -objectValue;\n    }\n    double functionValue \u003d objectValue;\n    double fValueW \u003d objectValue;\n    UnivariatePointValuePair lastBestPoint \u003d null;\n    UnivariatePointValuePair latest \u003d new UnivariatePointValuePair(value, isMinimization ? objectValue : -objectValue);\n    // Best point encountered so far (which is the initial guess).\n    int iteration \u003d 0;\n    while (true) {\n        final double midpoint \u003d 0.5 * (a + highBoundary);\n        final double tolerance1 \u003d relativeThreshold * FastMath.abs(value) + absoluteThreshold;\n        final double toleranceFactor \u003d 2 * tolerance1;\n        // Default stopping criterion.\n        final boolean terminate \u003d toleranceFactor - 0.5 * (highBoundary - a) \u003e\u003d FastMath.abs(value - midpoint);\n        if (terminate) {\n            // Default termination (Brent\u0027s criterion).\n            return best(latest, lastBestPoint, isMinimization);\n        } else {\n            double p \u003d 0;\n            double tempValue \u003d 0;\n            double r \u003d 0;\n            double newEstimate \u003d 0;\n            if (tolerance1 \u003e\u003d FastMath.abs(e)) {\n                // Golden section step.\n                if (midpoint \u003c\u003d value) {\n                    e \u003d a - value;\n                } else {\n                    e \u003d highBoundary - value;\n                }\n                stepSize \u003d GOLDEN_SECTION * e;\n            } else {\n                // Fit parabola.\n                r \u003d (value - z) * (objectValue - functionValue);\n                tempValue \u003d (value - v) * (objectValue - fValueW);\n                p \u003d (value - v) * tempValue - (value - z) * r;\n                tempValue \u003d 2 * (tempValue - r);\n                if (0 \u003e\u003d tempValue) {\n                    tempValue \u003d -tempValue;\n                } else {\n                    p \u003d -p;\n                }\n                r \u003d e;\n                e \u003d stepSize;\n                if (tempValue * (a - value) \u003e\u003d p || tempValue * (highBoundary - value) \u003c\u003d p || FastMath.abs(0.5 * tempValue * r) \u003c\u003d FastMath.abs(p)) {\n                    // Golden section step.\n                    if (midpoint \u003c\u003d value) {\n                        e \u003d a - value;\n                    } else {\n                        e \u003d highBoundary - value;\n                    }\n                    stepSize \u003d GOLDEN_SECTION * e;\n                } else {\n                    // Parabolic interpolation step.\n                    stepSize \u003d p / tempValue;\n                    newEstimate \u003d value + stepSize;\n                    // f must not be evaluated too close to a or b.\n                    if (toleranceFactor \u003e newEstimate - a || toleranceFactor \u003e highBoundary - newEstimate) {\n                        if (midpoint \u003c value) {\n                            stepSize \u003d -tolerance1;\n                        } else {\n                            stepSize \u003d tolerance1;\n                        }\n                    }\n                }\n            }\n            // Update by at least \"tol1\".\n            if (tolerance1 \u003c\u003d FastMath.abs(stepSize)) {\n                newEstimate \u003d value + stepSize;\n            } else {\n                if (0 \u003e stepSize) {\n                    newEstimate \u003d value - tolerance1;\n                } else {\n                    newEstimate \u003d value + tolerance1;\n                }\n            }\n            double objectiveValueAtU \u003d computeObjectiveValue(newEstimate);\n            if (!isMinimization) {\n                objectiveValueAtU \u003d -objectiveValueAtU;\n            }\n            // User-defined convergence checker.\n            lastBestPoint \u003d latest;\n            latest \u003d new UnivariatePointValuePair(newEstimate, isMinimization ? objectiveValueAtU : -objectiveValueAtU);\n            if (null !\u003d convergenceTester) {\n                if (convergenceTester.converged(iteration, lastBestPoint, latest)) {\n                    return best(latest, lastBestPoint, isMinimization);\n                }\n            }\n            // Update a, b, v, w and x.\n            if (objectValue \u003c objectiveValueAtU) {\n                if (value \u003c\u003d newEstimate) {\n                    highBoundary \u003d newEstimate;\n                } else {\n                    a \u003d newEstimate;\n                }\n                if (fValueW \u003c objectiveValueAtU \u0026\u0026 !Precision.equals(z, value)) {\n                    if (functionValue \u003e\u003d objectiveValueAtU || Precision.equals(v, value) || Precision.equals(v, z)) {\n                        v \u003d newEstimate;\n                        functionValue \u003d objectiveValueAtU;\n                    }\n                } else {\n                    v \u003d z;\n                    functionValue \u003d fValueW;\n                    z \u003d newEstimate;\n                    fValueW \u003d objectiveValueAtU;\n                }\n            } else {\n                if (value \u003c\u003d newEstimate) {\n                    a \u003d value;\n                } else {\n                    highBoundary \u003d value;\n                }\n                v \u003d z;\n                functionValue \u003d fValueW;\n                z \u003d value;\n                fValueW \u003d objectValue;\n                value \u003d newEstimate;\n                objectValue \u003d objectiveValueAtU;\n            }\n        }\n        ++iteration;\n    }\n}",
  "Lang-14": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs2 \u003d\u003d cs1) {\n        return true;\n    }\n    if (null \u003d\u003d cs1 || null \u003d\u003d cs2) {\n        return false;\n    }\n    return cs1.equals(cs2);\n}",
  "Math-24": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinimization \u003d GoalType.MINIMIZE \u003d\u003d getGoalType();\n    final double lowBoundary \u003d getMin();\n    final double median \u003d getStartValue();\n    final double boundUpper \u003d getMax();\n    // Optional additional convergence criteria.\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e convergenceTester \u003d getConvergenceChecker();\n    double leftBound;\n    double upperBound;\n    if (boundUpper \u003c\u003d lowBoundary) {\n        leftBound \u003d boundUpper;\n        upperBound \u003d lowBoundary;\n    } else {\n        leftBound \u003d lowBoundary;\n        upperBound \u003d boundUpper;\n    }\n    double value \u003d median;\n    double val \u003d value;\n    double temp \u003d value;\n    double stepSize \u003d 0;\n    double e \u003d 0;\n    double objectiveValue \u003d computeObjectiveValue(value);\n    if (!isMinimization) {\n        objectiveValue \u003d -objectiveValue;\n    }\n    double functionValue \u003d objectiveValue;\n    double fValueW \u003d objectiveValue;\n    UnivariatePointValuePair last \u003d null;\n    UnivariatePointValuePair latest \u003d new UnivariatePointValuePair(value, isMinimization ? objectiveValue : -objectiveValue);\n    int iterationCount \u003d 0;\n    while (true) {\n        final double midpoint \u003d 0.5 * (leftBound + upperBound);\n        final double tolerance1 \u003d relativeThreshold * FastMath.abs(value) + absoluteThreshold;\n        final double toleranceMargin \u003d 2 * tolerance1;\n        // Default stopping criterion.\n        final boolean termination \u003d toleranceMargin - 0.5 * (upperBound - leftBound) \u003e\u003d FastMath.abs(value - midpoint);\n        if (termination) {\n            // Default termination (Brent\u0027s criterion).\n            return latest;\n        } else {\n            double p \u003d 0;\n            double denominator \u003d 0;\n            double tempValue \u003d 0;\n            double nextPoint \u003d 0;\n            if (tolerance1 \u003e\u003d FastMath.abs(e)) {\n                // Golden section step.\n                if (midpoint \u003c\u003d value) {\n                    e \u003d leftBound - value;\n                } else {\n                    e \u003d upperBound - value;\n                }\n                stepSize \u003d GOLDEN_SECTION * e;\n            } else {\n                // Fit parabola.\n                tempValue \u003d (value - temp) * (objectiveValue - functionValue);\n                denominator \u003d (value - val) * (objectiveValue - fValueW);\n                p \u003d (value - val) * denominator - (value - temp) * tempValue;\n                denominator \u003d 2 * (denominator - tempValue);\n                if (0 \u003e\u003d denominator) {\n                    denominator \u003d -denominator;\n                } else {\n                    p \u003d -p;\n                }\n                tempValue \u003d e;\n                e \u003d stepSize;\n                if (denominator * (leftBound - value) \u003e\u003d p || denominator * (upperBound - value) \u003c\u003d p || FastMath.abs(0.5 * denominator * tempValue) \u003c\u003d FastMath.abs(p)) {\n                    // Golden section step.\n                    if (midpoint \u003c\u003d value) {\n                        e \u003d leftBound - value;\n                    } else {\n                        e \u003d upperBound - value;\n                    }\n                    stepSize \u003d GOLDEN_SECTION * e;\n                } else {\n                    // Parabolic interpolation step.\n                    stepSize \u003d p / denominator;\n                    nextPoint \u003d value + stepSize;\n                    // f must not be evaluated too close to a or b.\n                    if (toleranceMargin \u003e nextPoint - leftBound || toleranceMargin \u003e upperBound - nextPoint) {\n                        if (midpoint \u003c value) {\n                            stepSize \u003d -tolerance1;\n                        } else {\n                            stepSize \u003d tolerance1;\n                        }\n                    }\n                }\n            }\n            // Update by at least \"tol1\".\n            if (tolerance1 \u003c\u003d FastMath.abs(stepSize)) {\n                nextPoint \u003d value + stepSize;\n            } else {\n                if (0 \u003e stepSize) {\n                    nextPoint \u003d value - tolerance1;\n                } else {\n                    nextPoint \u003d value + tolerance1;\n                }\n            }\n            double newValue \u003d computeObjectiveValue(nextPoint);\n            if (!isMinimization) {\n                newValue \u003d -newValue;\n            }\n            // User-defined convergence checker.\n            last \u003d latest;\n            latest \u003d new UnivariatePointValuePair(nextPoint, isMinimization ? newValue : -newValue);\n            if (null !\u003d convergenceTester) {\n                if (convergenceTester.converged(iterationCount, last, latest)) {\n                    return latest;\n                }\n            }\n            // Update a, b, v, w and x.\n            if (objectiveValue \u003c newValue) {\n                if (value \u003c\u003d nextPoint) {\n                    upperBound \u003d nextPoint;\n                } else {\n                    leftBound \u003d nextPoint;\n                }\n                if (fValueW \u003c newValue \u0026\u0026 !Precision.equals(temp, value)) {\n                    if (functionValue \u003e\u003d newValue || Precision.equals(val, value) || Precision.equals(val, temp)) {\n                        val \u003d nextPoint;\n                        functionValue \u003d newValue;\n                    }\n                } else {\n                    val \u003d temp;\n                    functionValue \u003d fValueW;\n                    temp \u003d nextPoint;\n                    fValueW \u003d newValue;\n                }\n            } else {\n                if (value \u003c\u003d nextPoint) {\n                    leftBound \u003d value;\n                } else {\n                    upperBound \u003d value;\n                }\n                val \u003d temp;\n                functionValue \u003d fValueW;\n                temp \u003d value;\n                fValueW \u003d objectiveValue;\n                value \u003d nextPoint;\n                objectiveValue \u003d newValue;\n            }\n        }\n        ++iterationCount;\n    }\n}",
  "Lang-31": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int characterSequenceLength \u003d cs.length();\n    int searchCharsLength \u003d searchChars.length;\n    int index \u003d 0;\n    while (characterSequenceLength \u003e index) {\n        char character \u003d cs.charAt(index);\n        int j \u003d 0;\n        while (searchCharsLength \u003e j) {\n            if (character \u003d\u003d searchChars[j]) {\n                // ch is a supplementary character\n                // ch is in the Basic Multilingual Plane\n                return true;\n            }\n            j +\u003d 1;\n        }\n        index +\u003d 1;\n    }\n    return false;\n}",
  "Cli-19": "private void processOptionToken(String token, boolean stopAtNonOption) {\n    if (!options.hasOption(token)) {\n        if (stopAtNonOption) {\n            eatTheRest \u003d true;\n            tokens.add(token);\n        }\n    } else {\n        currentOption \u003d options.getOption(token);\n        tokens.add(token);\n    }\n}",
  "Lang-33": "public static Class\u003c?\u003e[] toClass(Object[] array) {\n    if (null !\u003d array) {\n        if (0 \u003d\u003d array.length) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n    } else {\n        return null;\n    }\n    Class\u003c?\u003e[] typeArray \u003d new Class[array.length];\n    int index \u003d 0;\n    while (array.length \u003e index) {\n        typeArray[index] \u003d array[index].getClass();\n        index +\u003d 1;\n    }\n    return typeArray;\n}",
  "Cli-17": "protected void burstToken(String token, boolean stopAtNonOption) {\n    int index \u003d 1;\n    while (token.length() \u003e index) {\n        String character \u003d String.valueOf(token.charAt(index));\n        if (!options.hasOption(character)) {\n            if (!stopAtNonOption) {\n                tokens.add(token);\n                break;\n            } else {\n                process(token.substring(index));\n            }\n        } else {\n            tokens.add(\"-\" + character);\n            currentOption \u003d options.getOption(character);\n            if (currentOption.hasArg() \u0026\u0026 ((index + 1) !\u003d token.length())) {\n                tokens.add(token.substring(index + 1));\n                break;\n            }\n        }\n        index +\u003d 1;\n    }\n}",
  "Cli-15": "public List getValues(final Option option, List defaultValues) {\n    // initialize the return list\n    List optionsList \u003d (List) values.get(option);\n    // grab the correct default values\n    if ((null \u003d\u003d optionsList) || optionsList.isEmpty()) {\n        optionsList \u003d defaultValues;\n    }\n    // augment the list with the default values\n    if ((null \u003d\u003d optionsList) || optionsList.isEmpty()) {\n        optionsList \u003d (List) this.defaultValues.get(option);\n    }\n    // if there are more default values as specified, add them to\n    // the list.\n    // copy the list first\n    return null \u003d\u003d optionsList ? Collections.EMPTY_LIST : optionsList;\n}",
  "Cli-14": "public void validate(final WriteableCommandLine commandLine) throws OptionException {\n    // number of options found\n    int count \u003d 0;\n    // reference to first unexpected option\n    Option extraordinary \u003d null;\n    for (final Iterator iterator \u003d options.iterator(); iterator.hasNext(); ) {\n        final Option argument \u003d (Option) iterator.next();\n        // needs validation?\n        boolean checkValidity \u003d argument.isRequired() || argument instanceof Group;\n        if (checkValidity) {\n            argument.validate(commandLine);\n        }\n        // if the child option is present then validate it\n        if (commandLine.hasOption(argument)) {\n            if (maximum \u003c ++count) {\n                extraordinary \u003d argument;\n                break;\n            }\n            argument.validate(commandLine);\n        }\n    }\n    // too many options\n    if (null !\u003d extraordinary) {\n        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, extraordinary.getPreferredName());\n    }\n    // too few option\n    if (minimum \u003e count) {\n        throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n    }\n    // validate each anonymous argument\n    for (final Iterator iterator \u003d anonymous.iterator(); iterator.hasNext(); ) {\n        final Option argument \u003d (Option) iterator.next();\n        argument.validate(commandLine);\n    }\n}",
  "Math-38": "private void prelim(double[] lowerBound, double[] upperBound) {\n    // XXX\n    printMethod();\n    final int dimensionCount \u003d currentBest.getDimension();\n    final int numInterpolationPoints \u003d numberOfInterpolationPoints;\n    final int dimCount \u003d bMatrix.getRowDimension();\n    final double trustRegionRadiusSquared \u003d initialTrustRegionRadius * initialTrustRegionRadius;\n    final double inverseRhoSquared \u003d 1d / trustRegionRadiusSquared;\n    final int numPoints \u003d dimensionCount + 1;\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n    for (int index \u003d 0; dimensionCount \u003e index; index++) {\n        originShift.setEntry(index, currentBest.getEntry(index));\n        int k \u003d 0;\n        while (numInterpolationPoints \u003e k) {\n            interpolationPoints.setEntry(k, index, ZERO);\n            k +\u003d 1;\n        }\n        int i \u003d 0;\n        while (dimCount \u003e i) {\n            bMatrix.setEntry(i, index, ZERO);\n            i +\u003d 1;\n        }\n    }\n    for (int i \u003d 0, limit \u003d dimensionCount * numPoints / 2; limit \u003e i; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k \u003d 0; numInterpolationPoints \u003e k; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        int index \u003d 0, limit \u003d numInterpolationPoints - numPoints;\n        while (limit \u003e index) {\n            zMatrix.setEntry(k, index, ZERO);\n            index +\u003d 1;\n        }\n    }\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n    int indexOfInterpolationPoint \u003d 0;\n    int jpt \u003d 0;\n    double initialFunctionValue \u003d Double.NaN;\n    do {\n        final int functionEvaluations \u003d getEvaluations();\n        final int numFunctionEvaluations \u003d functionEvaluations - dimensionCount;\n        final int nFunctionMinusOne \u003d functionEvaluations - 1;\n        final int previousFunctionEvaluationCount \u003d numFunctionEvaluations - 1;\n        double stepSize \u003d 0;\n        double stepb \u003d 0;\n        if (2 * dimensionCount \u003c functionEvaluations) {\n            final int tempIndex \u003d (functionEvaluations - numPoints) / dimensionCount;\n            jpt \u003d functionEvaluations - tempIndex * dimensionCount - dimensionCount;\n            indexOfInterpolationPoint \u003d jpt + tempIndex;\n            if (dimensionCount \u003c indexOfInterpolationPoint) {\n                final int tmp2 \u003d jpt;\n                jpt \u003d indexOfInterpolationPoint - dimensionCount;\n                indexOfInterpolationPoint \u003d tmp2;\n                // XXX\n                throw new PathIsExploredException();\n            }\n            final int iptIndex \u003d indexOfInterpolationPoint;\n            final int jptPrevious \u003d jpt;\n            interpolationPoints.setEntry(functionEvaluations, iptIndex, interpolationPoints.getEntry(indexOfInterpolationPoint, iptIndex));\n            interpolationPoints.setEntry(functionEvaluations, jptPrevious, interpolationPoints.getEntry(jpt, jptPrevious));\n        } else {\n            if (1 \u003e functionEvaluations || dimensionCount \u003c functionEvaluations) {\n                if (dimensionCount \u003c functionEvaluations) {\n                    stepSize \u003d interpolationPoints.getEntry(numFunctionEvaluations, previousFunctionEvaluationCount);\n                    stepb \u003d -initialTrustRegionRadius;\n                    if (ZERO \u003d\u003d lowerDifference.getEntry(previousFunctionEvaluationCount)) {\n                        stepb \u003d Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(previousFunctionEvaluationCount));\n                        // XXX\n                        throw new PathIsExploredException();\n                    }\n                    if (ZERO \u003d\u003d upperDifference.getEntry(previousFunctionEvaluationCount)) {\n                        stepb \u003d Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(previousFunctionEvaluationCount));\n                        // XXX\n                        throw new PathIsExploredException();\n                    }\n                    interpolationPoints.setEntry(functionEvaluations, previousFunctionEvaluationCount, stepb);\n                }\n            } else {\n                stepSize \u003d initialTrustRegionRadius;\n                if (ZERO \u003d\u003d upperDifference.getEntry(nFunctionMinusOne)) {\n                    stepSize \u003d -stepSize;\n                    // XXX\n                    throw new PathIsExploredException();\n                }\n                interpolationPoints.setEntry(functionEvaluations, nFunctionMinusOne, stepSize);\n            }\n        }\n        int index \u003d 0;\n        while (dimensionCount \u003e index) {\n            currentBest.setEntry(index, Math.min(Math.max(lowerBound[index], originShift.getEntry(index) + interpolationPoints.getEntry(functionEvaluations, index)), upperBound[index]));\n            if (lowerDifference.getEntry(index) \u003d\u003d interpolationPoints.getEntry(functionEvaluations, index)) {\n                currentBest.setEntry(index, lowerBound[index]);\n            }\n            if (upperDifference.getEntry(index) \u003d\u003d interpolationPoints.getEntry(functionEvaluations, index)) {\n                currentBest.setEntry(index, upperBound[index]);\n            }\n            index +\u003d 1;\n        }\n        // Calculate the next value of F. The least function value so far and\n        final double computedObjectiveValue \u003d computeObjectiveValue(currentBest.toArray());\n        final double f \u003d isMinimize ? computedObjectiveValue : -computedObjectiveValue;\n        // nfm + 1\n        final int numEval \u003d getEvaluations();\n        fAtInterpolationPoints.setEntry(functionEvaluations, f);\n        if (1 !\u003d numEval) {\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) \u003e f) {\n                trustRegionCenterInterpolationPointIndex \u003d functionEvaluations;\n            }\n        } else {\n            initialFunctionValue \u003d f;\n            trustRegionCenterInterpolationPointIndex \u003d 0;\n        }\n        // Set the nonzero initial elements of BMAT and the quadratic model in the\n        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n        // order that the function value at the first of them contributes to the\n        // off-diagonal second derivative terms of the initial quadratic model.\n        if (2 * dimensionCount + 1 \u003c numEval) {\n            zMatrix.setEntry(0, previousFunctionEvaluationCount, inverseRhoSquared);\n            zMatrix.setEntry(functionEvaluations, previousFunctionEvaluationCount, inverseRhoSquared);\n            zMatrix.setEntry(indexOfInterpolationPoint, previousFunctionEvaluationCount, -inverseRhoSquared);\n            zMatrix.setEntry(jpt, previousFunctionEvaluationCount, -inverseRhoSquared);\n            final int subscriptIndex \u003d indexOfInterpolationPoint * (indexOfInterpolationPoint - 1) / 2 + jpt - 1;\n            final double tmp \u003d interpolationPoints.getEntry(functionEvaluations, indexOfInterpolationPoint - 1) * interpolationPoints.getEntry(functionEvaluations, jpt - 1);\n            modelSecondDerivativesValues.setEntry(subscriptIndex, (initialFunctionValue - fAtInterpolationPoints.getEntry(indexOfInterpolationPoint) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n            // XXX\n            throw new PathIsExploredException();\n        } else {\n            if (2 \u003e numEval || dimensionCount + 1 \u003c numEval) {\n                if (dimensionCount + 2 \u003c\u003d numEval) {\n                    final int subscriptIndex \u003d numFunctionEvaluations * (numFunctionEvaluations + 1) / 2 - 1;\n                    final double tmp \u003d (f - initialFunctionValue) / stepb;\n                    final double change \u003d stepb - stepSize;\n                    modelSecondDerivativesValues.setEntry(subscriptIndex, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(previousFunctionEvaluationCount)) / change);\n                    gradientAtTrustRegionCenter.setEntry(previousFunctionEvaluationCount, (gradientAtTrustRegionCenter.getEntry(previousFunctionEvaluationCount) * stepb - tmp * stepSize) / change);\n                    if (ZERO \u003e stepSize * stepb) {\n                        if (fAtInterpolationPoints.getEntry(functionEvaluations - dimensionCount) \u003e f) {\n                            fAtInterpolationPoints.setEntry(functionEvaluations, fAtInterpolationPoints.getEntry(functionEvaluations - dimensionCount));\n                            fAtInterpolationPoints.setEntry(functionEvaluations - dimensionCount, f);\n                            if (functionEvaluations \u003d\u003d trustRegionCenterInterpolationPointIndex) {\n                                trustRegionCenterInterpolationPointIndex \u003d functionEvaluations - dimensionCount;\n                            }\n                            interpolationPoints.setEntry(functionEvaluations - dimensionCount, previousFunctionEvaluationCount, stepb);\n                            interpolationPoints.setEntry(functionEvaluations, previousFunctionEvaluationCount, stepSize);\n                        }\n                    }\n                    bMatrix.setEntry(0, previousFunctionEvaluationCount, -(stepSize + stepb) / (stepSize * stepb));\n                    bMatrix.setEntry(functionEvaluations, previousFunctionEvaluationCount, -HALF / interpolationPoints.getEntry(functionEvaluations - dimensionCount, previousFunctionEvaluationCount));\n                    bMatrix.setEntry(functionEvaluations - dimensionCount, previousFunctionEvaluationCount, -bMatrix.getEntry(0, previousFunctionEvaluationCount) - bMatrix.getEntry(functionEvaluations, previousFunctionEvaluationCount));\n                    zMatrix.setEntry(0, previousFunctionEvaluationCount, Math.sqrt(TWO) / (stepSize * stepb));\n                    zMatrix.setEntry(functionEvaluations, previousFunctionEvaluationCount, Math.sqrt(HALF) / trustRegionRadiusSquared);\n                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    zMatrix.setEntry(functionEvaluations - dimensionCount, previousFunctionEvaluationCount, -zMatrix.getEntry(0, previousFunctionEvaluationCount) - zMatrix.getEntry(functionEvaluations, previousFunctionEvaluationCount));\n                }\n            } else {\n                gradientAtTrustRegionCenter.setEntry(nFunctionMinusOne, (f - initialFunctionValue) / stepSize);\n                if (numEval + dimensionCount \u003e numInterpolationPoints) {\n                    final double inverseStepA \u003d ONE / stepSize;\n                    bMatrix.setEntry(0, nFunctionMinusOne, -inverseStepA);\n                    bMatrix.setEntry(functionEvaluations, nFunctionMinusOne, inverseStepA);\n                    bMatrix.setEntry(numInterpolationPoints + nFunctionMinusOne, nFunctionMinusOne, -HALF * trustRegionRadiusSquared);\n                    // XXX\n                    throw new PathIsExploredException();\n                }\n            }\n            // Set the off-diagonal second derivatives of the Lagrange functions and\n            // the initial quadratic model.\n        }\n    } while (numInterpolationPoints \u003e getEvaluations());\n}",
  "JacksonDatabind-11": "protected JavaType _fromVariable(TypeVariable\u003c?\u003e type, TypeBindings context) {\n    final String variableName \u003d type.getName();\n    // 19-Mar-2015: Without context, all we can check are bounds.\n    if (null !\u003d context) {\n        // Ok: here\u0027s where context might come in handy!\n        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n         *   unresolved type variables to handle some cases where bounds\n         *   are enough. Let\u0027s hope it does not hide real fail cases.\n         */\n        JavaType resolvedType \u003d context.findType(variableName);\n        if (null !\u003d resolvedType) {\n            return resolvedType;\n        }\n    } else {\n        // And to prevent infinite loops, now need this:\n        return _unknownType();\n    }\n    /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n     *   bound: but the problem is that this can occur for generic \"base\"\n     *   method, overridden by sub-class. If so, we will want to ignore\n     *   current type (for method) since it will be masked.\n     */\n    Type[] constraints \u003d type.getBounds();\n    // With type variables we must use bound information.\n    // Theoretically this gets tricky, as there may be multiple\n    // bounds (\"... extends A \u0026 B\"); and optimally we might\n    // want to choose the best match. Also, bounds are optional;\n    // but here we are lucky in that implicit \"Object\" is\n    // added as bounds if so.\n    // Either way let\u0027s just use the first bound, for now, and\n    // worry about better match later on if there is need.\n    /* 29-Jan-2010, tatu: One more problem are recursive types\n     *   (T extends Comparable\u003cT\u003e). Need to add \"placeholder\"\n     *   for resolution to catch those.\n     */\n    context._addPlaceholder(variableName);\n    return _constructType(constraints[0], context);\n}",
  "Math-39": "public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean isForward \u003d equations.getTime() \u003c t;\n    // create some internal working arrays\n    final double[] initialState \u003d equations.getCompleteState();\n    final double[] stateVector \u003d initialState.clone();\n    final int steps \u003d c.length + 1;\n    final double[][] kStageDerivatives \u003d new double[steps][stateVector.length];\n    final double[] yIntermediate \u003d initialState.clone();\n    final double[] yDerivativeBuffer \u003d new double[stateVector.length];\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator evaluator \u003d (RungeKuttaStepInterpolator) prototype.copy();\n    evaluator.reinitialize(this, yIntermediate, kStageDerivatives, isForward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    evaluator.storeTime(equations.getTime());\n    // set up integration control objects\n    stepStart \u003d equations.getTime();\n    double stepSizeSuggested \u003d 0;\n    boolean isFirstIteration \u003d true;\n    initIntegration(equations.getTime(), initialState, t);\n    // main integration loop\n    isLastStep \u003d false;\n    do {\n        evaluator.shift();\n        // iterate over step size, ensuring local normalized error is smaller than 1\n        double deviation \u003d 10;\n        while (1.0 \u003c\u003d deviation) {\n            if (isFirstIteration || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, stateVector, kStageDerivatives[0]);\n            }\n            if (isFirstIteration) {\n                final double[] magnitude \u003d new double[mainSetDimension];\n                if (null !\u003d vecAbsoluteTolerance) {\n                    int index \u003d 0;\n                    while (magnitude.length \u003e index) {\n                        magnitude[index] \u003d vecAbsoluteTolerance[index] + vecRelativeTolerance[index] * FastMath.abs(stateVector[index]);\n                        ++index;\n                    }\n                } else {\n                    int index \u003d 0;\n                    while (magnitude.length \u003e index) {\n                        magnitude[index] \u003d scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(stateVector[index]);\n                        ++index;\n                    }\n                }\n                stepSizeSuggested \u003d initializeStep(isForward, getOrder(), magnitude, stepStart, stateVector, kStageDerivatives[0], yIntermediate, kStageDerivatives[1]);\n                isFirstIteration \u003d false;\n            }\n            stepSize \u003d stepSizeSuggested;\n            int stageIndex \u003d 1;\n            while (steps \u003e stageIndex) {\n                int j \u003d 0;\n                while (initialState.length \u003e j) {\n                    double total \u003d a[stageIndex - 1][0] * kStageDerivatives[0][j];\n                    int l \u003d 1;\n                    while (stageIndex \u003e l) {\n                        total +\u003d a[stageIndex - 1][l] * kStageDerivatives[l][j];\n                        ++l;\n                    }\n                    yIntermediate[j] \u003d stateVector[j] + stepSize * total;\n                    ++j;\n                }\n                computeDerivatives(stepStart + c[stageIndex - 1] * stepSize, yIntermediate, kStageDerivatives[stageIndex]);\n                ++stageIndex;\n            }\n            // estimate the state at the end of the step\n            for (int j \u003d 0; initialState.length \u003e j; ++j) {\n                double total \u003d b[0] * kStageDerivatives[0][j];\n                int l \u003d 1;\n                while (steps \u003e l) {\n                    total +\u003d b[l] * kStageDerivatives[l][j];\n                    ++l;\n                }\n                yIntermediate[j] \u003d stateVector[j] + stepSize * total;\n            }\n            // estimate the error at the end of the step\n            deviation \u003d estimateError(kStageDerivatives, stateVector, yIntermediate, stepSize);\n            if (1.0 \u003c\u003d deviation) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double multiplier \u003d FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(deviation, exp)));\n                stepSizeSuggested \u003d filterStep(stepSize * multiplier, isForward, false);\n            }\n        }\n        // local error is small enough: accept the step, trigger events and step handlers\n        evaluator.storeTime(stepStart + stepSize);\n        System.arraycopy(yIntermediate, 0, stateVector, 0, initialState.length);\n        System.arraycopy(kStageDerivatives[steps - 1], 0, yDerivativeBuffer, 0, initialState.length);\n        stepStart \u003d acceptStep(evaluator, stateVector, yDerivativeBuffer, t);\n        System.arraycopy(stateVector, 0, yIntermediate, 0, stateVector.length);\n        if (!isLastStep) {\n            // prepare next step\n            evaluator.storeTime(stepStart);\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDerivativeBuffer, 0, kStageDerivatives[0], 0, initialState.length);\n            }\n            // stepsize control for next step\n            final double multiplier \u003d FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(deviation, exp)));\n            final double adjustedStepSize \u003d stepSize * multiplier;\n            final double nextTime \u003d stepStart + adjustedStepSize;\n            final boolean nextStepIsFinal \u003d isForward ? (t \u003c\u003d nextTime) : (t \u003e\u003d nextTime);\n            stepSizeSuggested \u003d filterStep(adjustedStepSize, isForward, nextStepIsFinal);\n            final double adjustedNextT \u003d stepStart + stepSizeSuggested;\n            final boolean filteredNextIsTerminal \u003d isForward ? (t \u003c\u003d adjustedNextT) : (t \u003e\u003d adjustedNextT);\n            if (filteredNextIsTerminal) {\n                stepSizeSuggested \u003d t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(stateVector);\n    resetInternalState();\n}",
  "JacksonDatabind-12": "public boolean isCachable() {\n    /* As per [databind#735], existence of value or key deserializer (only passed\n     * if annotated to use non-standard one) should also prevent caching.\n     */\n    return (null \u003d\u003d _valueTypeDeserializer) \u0026\u0026 (null \u003d\u003d _ignorableProperties);\n}",
  "JacksonDatabind-14": "protected JsonNode _bindAsTree(JsonParser jp) throws IOException {\n    JsonNode output;\n    JsonToken token \u003d _initForReading(jp);\n    if (JsonToken.VALUE_NULL !\u003d token \u0026\u0026 JsonToken.END_ARRAY !\u003d token \u0026\u0026 JsonToken.END_OBJECT !\u003d token) {\n        DeserializationContext context \u003d createDeserializationContext(jp, _config);\n        JsonDeserializer\u003cObject\u003e deserializer \u003d _findRootDeserializer(context, JSON_NODE_TYPE);\n        if (!_unwrapRoot) {\n            output \u003d (JsonNode) deserializer.deserialize(jp, context);\n        } else {\n            output \u003d (JsonNode) _unwrapAndDeserialize(jp, context, JSON_NODE_TYPE, deserializer);\n        }\n    } else {\n        output \u003d NullNode.instance;\n    }\n    // Need to consume the token too\n    jp.clearCurrentToken();\n    return output;\n}",
  "JacksonDatabind-16": "protected final boolean _add(Annotation ann) {\n    if (null \u003d\u003d _annotations) {\n        _annotations \u003d new HashMap\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e();\n    }\n    Annotation existing \u003d _annotations.put(ann.annotationType(), ann);\n    return (null !\u003d existing) \u0026\u0026 existing.equals(ann);\n}",
  "Lang-28": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    // TODO: Protect from ArrayIndexOutOfBounds\n    if (\u0027\u0026\u0027 \u003d\u003d input.charAt(index) \u0026\u0026 \u0027#\u0027 \u003d\u003d input.charAt(index + 1)) {\n        int beginning \u003d index + 2;\n        boolean isHexadecimal \u003d false;\n        char initialChar \u003d input.charAt(beginning);\n        if (\u0027x\u0027 \u003d\u003d initialChar || \u0027X\u0027 \u003d\u003d initialChar) {\n            beginning +\u003d 1;\n            isHexadecimal \u003d true;\n        }\n        int finish \u003d beginning;\n        while (\u0027;\u0027 !\u003d input.charAt(finish)) {\n            finish +\u003d 1;\n        }\n        int numericValue;\n        try {\n            if (!isHexadecimal) {\n                numericValue \u003d Integer.parseInt(input.subSequence(beginning, finish).toString(), 10);\n            } else {\n                numericValue \u003d Integer.parseInt(input.subSequence(beginning, finish).toString(), 16);\n            }\n        } catch (NumberFormatException nfe) {\n            return 0;\n        }\n        out.write(numericValue);\n        return 2 + (finish - beginning) + (isHexadecimal ? 1 : 0) + 1;\n    }\n    return 0;\n}",
  "Cli-12": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\n    List elements \u003d new ArrayList();\n    boolean consumeRemaining \u003d false;\n    int index \u003d 0;\n    while (arguments.length \u003e index) {\n        String argument \u003d arguments[index];\n        if (!\"--\".equals(argument)) {\n            if (!\"-\".equals(argument)) {\n                if (!argument.startsWith(\"-\")) {\n                    elements.add(argument);\n                } else {\n                    String option \u003d Util.stripLeadingHyphens(argument);\n                    if (!options.hasOption(option)) {\n                        if (!options.hasOption(argument.substring(0, 2))) {\n                            consumeRemaining \u003d stopAtNonOption;\n                            elements.add(argument);\n                        } else {\n                            // the format is --foo\u003dvalue or -foo\u003dvalue\n                            // the format is a special properties option (-Dproperty\u003dvalue)\n                            // -D\n                            elements.add(argument.substring(0, 2));\n                            // property\u003dvalue\n                            elements.add(argument.substring(2));\n                        }\n                    } else {\n                        elements.add(argument);\n                    }\n                }\n            } else {\n                elements.add(\"-\");\n            }\n        } else {\n            consumeRemaining \u003d true;\n            elements.add(\"--\");\n        }\n        if (consumeRemaining) {\n            index +\u003d 1;\n            while (arguments.length \u003e index) {\n                elements.add(arguments[index]);\n                index +\u003d 1;\n            }\n        }\n        index +\u003d 1;\n    }\n    return (String[]) elements.toArray(new String[elements.size()]);\n}",
  "JacksonDatabind-17": "public boolean useForType(JavaType t) {\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t \u003d t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            //                return t.isJavaLangObject() ||\n            return (Object.class \u003d\u003d t.getRawClass()) || (// [databind#88] Should not apply to JSON tree models:\n            !t.isConcrete() || TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t \u003d t.getContentType();\n            }\n            // [Issue#88] Should not apply to JSON tree models:\n            return !t.isFinal() \u0026\u0026 !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            //                return t.isJavaLangObject();\n            return (Object.class \u003d\u003d t.getRawClass());\n    }\n}",
  "Lang-27": "public static Number createNumber(String str) throws NumberFormatException {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char finalChar \u003d str.charAt(str.length() - 1);\n    String coefficient;\n    String fraction;\n    String exponent;\n    int decimalPosition \u003d str.indexOf(\u0027.\u0027);\n    int exponentPosition \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (-1 \u003e\u003d decimalPosition) {\n        if (-1 \u003e\u003d exponentPosition) {\n            coefficient \u003d str;\n        } else {\n            coefficient \u003d str.substring(0, exponentPosition);\n        }\n        fraction \u003d null;\n    } else {\n        if (-1 \u003e\u003d exponentPosition) {\n            fraction \u003d str.substring(decimalPosition + 1);\n        } else {\n            if (decimalPosition \u003e exponentPosition) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            fraction \u003d str.substring(decimalPosition + 1, exponentPosition);\n        }\n        coefficient \u003d str.substring(0, decimalPosition);\n    }\n    if (Character.isDigit(finalChar) || \u0027.\u0027 \u003d\u003d finalChar) {\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length());\n        }\n        if (null !\u003d fraction || null !\u003d exponent) {\n            //Must be a float,double,BigDec\n            boolean isZeroOnly \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n            try {\n                Float floatValue \u003d createFloat(str);\n                if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isZeroOnly))) {\n                    return floatValue;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (0.0D \u003d\u003d d.doubleValue() \u0026\u0026 !isZeroOnly))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigDecimal(str);\n        } else {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n    } else {\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length() - 1);\n        }\n        //Requesting a specific type..\n        String numberString \u003d str.substring(0, str.length() - 1);\n        boolean isZeroOnly \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n        switch(finalChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (null \u003d\u003d fraction \u0026\u0026 null \u003d\u003d exponent \u0026\u0026 (\u0027-\u0027 \u003d\u003d numberString.charAt(0) \u0026\u0026 isDigits(numberString.substring(1)) || isDigits(numberString))) {\n                    try {\n                        return createLong(numberString);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numberString);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float floatValue \u003d NumberUtils.createFloat(numberString);\n                    if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isZeroOnly))) {\n                        //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return floatValue;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numberString);\n                    if (!(d.isInfinite() || (0.0D \u003d\u003d d.floatValue() \u0026\u0026 !isZeroOnly))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numberString);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n}",
  "Cli-11": "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n    if (!required) {\n        buff.append(\"[\");\n    }\n    if (null \u003d\u003d option.getOpt()) {\n        buff.append(\"--\").append(option.getLongOpt());\n    } else {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    // if the Option has a value\n    if (option.hasArg() \u0026\u0026 (null !\u003d option.getArgName())) {\n        buff.append(\" \u003c\").append(option.getArgName()).append(\"\u003e\");\n    }\n    // if the Option is not a required option\n    if (!required) {\n        buff.append(\"]\");\n    }\n}",
  "Math-30": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException {\n    final int sampleSizeProduct \u003d n1 * n2;\n    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n    final double expectedU \u003d sampleSizeProduct / 2.0;\n    final double varianceU \u003d sampleSizeProduct * (n1 + n2 + 1) / 12.0;\n    final double standardScore \u003d (Umin - expectedU) / FastMath.sqrt(varianceU);\n    final NormalDistribution standardNormalDistribution \u003d new NormalDistribution(0, 1);\n    return 2 * standardNormalDistribution.cumulativeProbability(standardScore);\n}",
  "JacksonDatabind-19": "private JavaType _mapType(Class\u003c?\u003e rawClass) {\n    // 28-May-2015, tatu: Properties are special, as per [databind#810]\n    JavaType[] typeArguments \u003d findTypeParameters(rawClass, Map.class);\n    // ok to have no types (\"raw\")\n    if (null \u003d\u003d typeArguments) {\n        return MapType.construct(rawClass, _unknownType(), _unknownType());\n    }\n    // but exactly 2 types if any found\n    if (2 !\u003d typeArguments.length) {\n        throw new IllegalArgumentException(\"Strange Map type \" + rawClass.getName() + \": can not determine type parameters\");\n    }\n    return MapType.construct(rawClass, typeArguments[0], typeArguments[1]);\n}",
  "Lang-29": "static float toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}",
  "Math-31": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double minuscule \u003d 1e-50;\n    double hPrevious \u003d getA(0, x);\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrevious, 0.0, minuscule)) {\n        hPrevious \u003d minuscule;\n    }\n    int iterationCount \u003d 1;\n    double lastDenominator \u003d 0.0;\n    double pCurrent \u003d 1.0;\n    double qCurrent \u003d 1.0;\n    double previousCoefficient \u003d hPrevious;\n    double hCurrent \u003d hPrevious;\n    while (maxIterations \u003e iterationCount) {\n        final double coeffA \u003d getA(iterationCount, x);\n        final double coeffB \u003d getB(iterationCount, x);\n        double cCurrent \u003d coeffA * hPrevious + coeffB * pCurrent;\n        double q2 \u003d coeffA * qCurrent + coeffB * lastDenominator;\n        if (Double.isInfinite(cCurrent) || Double.isInfinite(q2)) {\n            double scalingFactor \u003d 1d;\n            double previousScaleFactor \u003d 1d;\n            final int maxDegree \u003d 5;\n            final double magnitude \u003d FastMath.max(coeffA, coeffB);\n            if (0 \u003e\u003d magnitude) {\n                // Can\u0027t scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            int index \u003d 0;\n            while (maxDegree \u003e index) {\n                previousScaleFactor \u003d scalingFactor;\n                scalingFactor *\u003d magnitude;\n                if (0.0 \u003d\u003d coeffA || coeffB \u003e\u003d coeffA) {\n                    if (0 !\u003d coeffB) {\n                        cCurrent \u003d (coeffA / scalingFactor * hPrevious) + pCurrent / previousScaleFactor;\n                        q2 \u003d (coeffA / scalingFactor * qCurrent) + lastDenominator / previousScaleFactor;\n                    }\n                } else {\n                    cCurrent \u003d hPrevious / previousScaleFactor + (coeffB / scalingFactor * pCurrent);\n                    q2 \u003d qCurrent / previousScaleFactor + (coeffB / scalingFactor * lastDenominator);\n                }\n                if (!(Double.isInfinite(cCurrent) || Double.isInfinite(q2))) {\n                    break;\n                }\n                index +\u003d 1;\n            }\n        }\n        final double ratioN \u003d cCurrent / q2 / previousCoefficient;\n        hCurrent \u003d previousCoefficient * ratioN;\n        if (Double.isInfinite(hCurrent)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hCurrent)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        if (epsilon \u003e FastMath.abs(ratioN - 1.0)) {\n            break;\n        }\n        lastDenominator \u003d qCurrent;\n        previousCoefficient \u003d cCurrent / q2;\n        pCurrent \u003d hPrevious;\n        hPrevious \u003d cCurrent;\n        qCurrent \u003d q2;\n        iterationCount +\u003d 1;\n    }\n    if (maxIterations \u003c\u003d iterationCount) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n    return hCurrent;\n}",
  "Cli-10": "protected void setOptions(final Options options) {\n    this.options \u003d options;\n    this.requiredOptions \u003d options.getRequiredOptions();\n}",
  "Lang-24": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int length \u003d chars.length;\n    boolean hasExponent \u003d false;\n    boolean hasDecimalSeparator \u003d false;\n    boolean permitSigns \u003d false;\n    boolean hasDigit \u003d false;\n    // deal with any possible sign up front\n    int initialIndex \u003d (\u0027-\u0027 \u003d\u003d chars[0]) ? 1 : 0;\n    if (initialIndex + 1 \u003c length) {\n        if (\u00270\u0027 \u003d\u003d chars[initialIndex] \u0026\u0026 \u0027x\u0027 \u003d\u003d chars[initialIndex + 1]) {\n            int index \u003d initialIndex + 2;\n            if (length \u003d\u003d index) {\n                // str \u003d\u003d \"0x\"\n                return false;\n            }\n            while (chars.length \u003e index) {\n                if ((\u00270\u0027 \u003e chars[index] || \u00279\u0027 \u003c chars[index]) \u0026\u0026 (\u0027a\u0027 \u003e chars[index] || \u0027f\u0027 \u003c chars[index]) \u0026\u0026 (\u0027A\u0027 \u003e chars[index] || \u0027F\u0027 \u003c chars[index])) {\n                    return false;\n                }\n                index +\u003d 1;\n            }\n            return true;\n        }\n    }\n    // don\u0027t want to loop to the last char, check it afterwords\n    length -\u003d 1;\n    // for type qualifiers\n    int index \u003d initialIndex;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n    while (length \u003e index || (length + 1 \u003e index \u0026\u0026 permitSigns \u0026\u0026 !hasDigit)) {\n        if (\u00270\u0027 \u003e chars[index] || \u00279\u0027 \u003c chars[index]) {\n            if (\u0027.\u0027 !\u003d chars[index]) {\n                if (\u0027e\u0027 !\u003d chars[index] \u0026\u0026 \u0027E\u0027 !\u003d chars[index]) {\n                    if (\u0027+\u0027 !\u003d chars[index] \u0026\u0026 \u0027-\u0027 !\u003d chars[index]) {\n                        return false;\n                    } else {\n                        if (!permitSigns) {\n                            return false;\n                        }\n                        permitSigns \u003d false;\n                        // we need a digit after the E\n                        hasDigit \u003d false;\n                    }\n                } else {\n                    // we\u0027ve already taken care of hex.\n                    if (hasExponent) {\n                        // two E\u0027s\n                        return false;\n                    }\n                    if (!hasDigit) {\n                        return false;\n                    }\n                    hasExponent \u003d true;\n                    permitSigns \u003d true;\n                }\n            } else {\n                if (hasDecimalSeparator || hasExponent) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecimalSeparator \u003d true;\n            }\n        } else {\n            hasDigit \u003d true;\n            permitSigns \u003d false;\n        }\n        index +\u003d 1;\n    }\n    if (chars.length \u003e index) {\n        if (\u00270\u0027 \u003c\u003d chars[index] \u0026\u0026 \u00279\u0027 \u003e\u003d chars[index]) {\n            // no type qualifier, OK\n            return true;\n        }\n        if (\u0027e\u0027 \u003d\u003d chars[index] || \u0027E\u0027 \u003d\u003d chars[index]) {\n            // can\u0027t have an E at the last byte\n            return false;\n        }\n        if (\u0027.\u0027 \u003d\u003d chars[index]) {\n            if (hasDecimalSeparator || hasExponent) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return hasDigit;\n        }\n        if (!permitSigns \u0026\u0026 (\u0027d\u0027 \u003d\u003d chars[index] || \u0027D\u0027 \u003d\u003d chars[index] || \u0027f\u0027 \u003d\u003d chars[index] || \u0027F\u0027 \u003d\u003d chars[index])) {\n            return hasDigit;\n        }\n        if (\u0027l\u0027 \u003d\u003d chars[index] || \u0027L\u0027 \u003d\u003d chars[index]) {\n            // not allowing L with an exponent or decimal point\n            return hasDigit \u0026\u0026 !hasExponent;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in \u0027E\u0027\n    // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n    return !permitSigns \u0026\u0026 hasDigit;\n}",
  "Math-32": "protected void computeGeometricalProperties() {\n    final Vector2D[][] vertices \u003d getVertices();\n    if (0 !\u003d vertices.length) {\n        if (null !\u003d vertices[0][0]) {\n            // all loops are closed, we compute some integrals around the shape\n            double total \u003d 0;\n            double totalX \u003d 0;\n            double totalY \u003d 0;\n            for (Vector2D[] contour : vertices) {\n                double previousX \u003d contour[contour.length - 1].getX();\n                double yCurrent \u003d contour[contour.length - 1].getY();\n                for (final Vector2D vertex : contour) {\n                    final double x0 \u003d previousX;\n                    final double yPrevious \u003d yCurrent;\n                    previousX \u003d vertex.getX();\n                    yCurrent \u003d vertex.getY();\n                    final double areaFactor \u003d x0 * yCurrent - yPrevious * previousX;\n                    total +\u003d areaFactor;\n                    totalX +\u003d areaFactor * (x0 + previousX);\n                    totalY +\u003d areaFactor * (yPrevious + yCurrent);\n                }\n            }\n            if (0 \u003c\u003d total) {\n                setSize(total / 2);\n                setBarycenter(new Vector2D(totalX / (3 * total), totalY / (3 * total)));\n            } else {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            }\n        } else {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        }\n    } else {\n        final BSPTree\u003cEuclidean2D\u003e bspTree \u003d getTree(false);\n        if (!((Boolean) bspTree.getAttribute())) {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        } else {\n            // the instance covers the whole space\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        }\n    }\n}",
  "Math-33": "protected void dropPhase1Objective() {\n    if (1 \u003d\u003d getNumObjectiveFunctions()) {\n        return;\n    }\n    List\u003cInteger\u003e columnsToRemove \u003d new ArrayList\u003cInteger\u003e();\n    columnsToRemove.add(0);\n    // positive cost non-artificial variables\n    for (int index \u003d getNumObjectiveFunctions(); getArtificialVariableOffset() \u003e index; index++) {\n        final double value \u003d tableau.getEntry(0, index);\n        if (0 \u003c Precision.compareTo(value, 0d, maxUlps)) {\n            columnsToRemove.add(index);\n        }\n    }\n    // non-basic artificial variables\n    for (int index \u003d 0; getNumArtificialVariables() \u003e index; index++) {\n        int columnIndex \u003d index + getArtificialVariableOffset();\n        if (null \u003d\u003d getBasicRow(columnIndex)) {\n            columnsToRemove.add(columnIndex);\n        }\n    }\n    double[][] array \u003d new double[getHeight() - 1][getWidth() - columnsToRemove.size()];\n    for (int index \u003d 1; getHeight() \u003e index; index++) {\n        int columnIndex \u003d 0;\n        int j \u003d 0;\n        while (getWidth() \u003e j) {\n            if (!columnsToRemove.contains(j)) {\n                array[index - 1][columnIndex++] \u003d tableau.getEntry(index, j);\n            }\n            j +\u003d 1;\n        }\n    }\n    for (int index \u003d columnsToRemove.size() - 1; 0 \u003c\u003d index; index--) {\n        columnLabels.remove((int) columnsToRemove.get(index));\n    }\n    this.tableau \u003d new Array2DRowRealMatrix(array);\n    this.numArtificialVariables \u003d 0;\n}",
  "Lang-26": "public String format(Date date) {\n    Calendar calendar \u003d new GregorianCalendar(mTimeZone);\n    calendar.setTime(date);\n    return applyRules(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
  "Math-34": "public Iterator\u003cChromosome\u003e iterator() {\n    return chromosomes.iterator();\n}",
  "Lang-42": "public void escape(Writer writer, String str) throws IOException {\n    int length \u003d str.length();\n    int index \u003d 0;\n    while (length \u003e index) {\n        char character \u003d str.charAt(index);\n        String characterEntityName \u003d this.entityName(character);\n        if (null !\u003d characterEntityName) {\n            writer.write(\u0027\u0026\u0027);\n            writer.write(characterEntityName);\n            writer.write(\u0027;\u0027);\n        } else {\n            if (0x7F \u003e\u003d character) {\n                writer.write(character);\n            } else {\n                writer.write(\"\u0026#\");\n                writer.write(Integer.toString(character, 10));\n                writer.write(\u0027;\u0027);\n            }\n        }\n        index +\u003d 1;\n    }\n}",
  "Lang-44": "public static Number createNumber(String val) throws NumberFormatException {\n    if (null \u003d\u003d val) {\n        return null;\n    }\n    if (0 \u003d\u003d val.length()) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char finalChar \u003d val.charAt(val.length() - 1);\n    String coefficient;\n    String fraction;\n    String exponent;\n    int decimalPosition \u003d val.indexOf(\u0027.\u0027);\n    int exponentPosition \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (-1 \u003e\u003d decimalPosition) {\n        if (-1 \u003e\u003d exponentPosition) {\n            coefficient \u003d val;\n        } else {\n            coefficient \u003d val.substring(0, exponentPosition);\n        }\n        fraction \u003d null;\n    } else {\n        if (-1 \u003e\u003d exponentPosition) {\n            fraction \u003d val.substring(decimalPosition + 1);\n        } else {\n            if (decimalPosition \u003e exponentPosition) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            fraction \u003d val.substring(decimalPosition + 1, exponentPosition);\n        }\n        coefficient \u003d val.substring(0, decimalPosition);\n    }\n    if (Character.isDigit(finalChar)) {\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (-1 \u003e\u003d exponentPosition || val.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d val.substring(exponentPosition + 1, val.length());\n        }\n        if (null !\u003d fraction || null !\u003d exponent) {\n            //Must be a float,double,BigDec\n            boolean isAllZeros \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n            try {\n                Float floatValue \u003d createFloat(val);\n                if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isAllZeros))) {\n                    return floatValue;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double dbl \u003d createDouble(val);\n                if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.doubleValue() \u0026\u0026 !isAllZeros))) {\n                    return dbl;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigDecimal(val);\n        } else {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n        }\n    } else {\n        if (-1 \u003e\u003d exponentPosition || val.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d val.substring(exponentPosition + 1, val.length() - 1);\n        }\n        //Requesting a specific type..\n        String numericValue \u003d val.substring(0, val.length() - 1);\n        boolean isAllZeros \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n        switch(finalChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (null \u003d\u003d fraction \u0026\u0026 null \u003d\u003d exponent \u0026\u0026 (\u0027-\u0027 \u003d\u003d numericValue.charAt(0) \u0026\u0026 isDigits(numericValue.substring(1)) || isDigits(numericValue))) {\n                    try {\n                        return createLong(numericValue);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numericValue);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float floatValue \u003d NumberUtils.createFloat(numericValue);\n                    if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isAllZeros))) {\n                        //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return floatValue;\n                    }\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n            //Fall through\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double dbl \u003d NumberUtils.createDouble(numericValue);\n                    if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.floatValue() \u0026\u0026 !isAllZeros))) {\n                        return dbl;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numericValue);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n            //Fall through\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    }\n}",
  "Lang-43": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n    int initialIndex \u003d pos.getIndex();\n    char[] chars \u003d pattern.toCharArray();\n    if (escapingOn \u0026\u0026 QUOTE \u003d\u003d chars[initialIndex]) {\n        return null \u003d\u003d appendTo ? null : appendTo.append(QUOTE);\n    }\n    int lastIndex \u003d initialIndex;\n    int index \u003d pos.getIndex();\n    while (pattern.length() \u003e index) {\n        if (escapingOn \u0026\u0026 pattern.substring(index).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(chars, lastIndex, pos.getIndex() - lastIndex).append(QUOTE);\n            pos.setIndex(index + ESCAPED_QUOTE.length());\n            lastIndex \u003d pos.getIndex();\n            continue;\n        }\n        switch(chars[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return null \u003d\u003d appendTo ? null : appendTo.append(chars, lastIndex, pos.getIndex() - lastIndex);\n            default:\n                next(pos);\n        }\n        index +\u003d 1;\n    }\n    throw new IllegalArgumentException(\"Unterminated quoted string at position \" + initialIndex);\n}",
  "Math-90": "public void addValue(Object v) {\n    /**\n     * Adds 1 to the frequency count for v.\n     * \u003cp\u003e\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * \u003c/p\u003e\n     *\n     * @param v the value to add.\n     * @throws IllegalArgumentException if \u003ccode\u003ev\u003c/code\u003e is not comparable with previous entries\n     */\n    Object value \u003d v;\n    if (v instanceof Integer) {\n        value \u003d Long.valueOf(((Integer) v).longValue());\n    }\n    try {\n        Long frequency \u003d (Long) freqTable.get(value);\n        if (null !\u003d frequency) {\n            freqTable.put(value, Long.valueOf(frequency.longValue() + 1));\n        } else {\n            freqTable.put(value, Long.valueOf(1));\n        }\n    } catch (ClassCastException ex) {\n        //TreeMap will throw ClassCastException if v is not comparable\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}",
  "Math-91": "public int compareTo(Fraction object) {\n    double numeratorValue \u003d doubleValue();\n    double denominatorValue \u003d object.doubleValue();\n    return (denominatorValue \u003e numeratorValue) ? -1 : ((denominatorValue \u003c numeratorValue) ? +1 : 0);\n}",
  "Lang-40": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (null \u003d\u003d str || null \u003d\u003d searchStr) {\n        return false;\n    }\n    return contains(str.toUpperCase(), searchStr.toUpperCase());\n}",
  "JxPath-5": "private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) {\n    if (depth2 \u003e depth1) {\n        int result \u003d compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return 0 \u003d\u003d result ? -1 : result;\n    }\n    if (depth2 \u003c depth1) {\n        int result \u003d compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return 0 \u003d\u003d result ? 1 : result;\n    }\n    if (null \u003d\u003d p1 \u0026\u0026 null \u003d\u003d p2) {\n        return 0;\n    }\n    if (null !\u003d p1 \u0026\u0026 p1.equals(p2)) {\n        return 0;\n    }\n    if (1 \u003d\u003d depth1) {\n        throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: \u0027\" + p1 + \"\u0027 and \u0027\" + p2 + \"\u0027\");\n    }\n    int result \u003d compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n    if (0 !\u003d result) {\n        return result;\n    }\n    return p1.parent.compareChildNodePointers(p1, p2);\n}",
  "JxPath-8": "private boolean compute(Object left, Object right) {\n    left \u003d reduce(left);\n    right \u003d reduce(right);\n    if (left instanceof InitialContext) {\n        ((InitialContext) left).reset();\n    }\n    if (right instanceof InitialContext) {\n        ((InitialContext) right).reset();\n    }\n    if (left instanceof Iterator \u0026\u0026 right instanceof Iterator) {\n        return findMatch((Iterator) left, (Iterator) right);\n    }\n    if (left instanceof Iterator) {\n        return containsMatch((Iterator) left, right);\n    }\n    if (right instanceof Iterator) {\n        return containsMatch((Iterator) right, left);\n    }\n    double leftDoubleValue \u003d InfoSetUtil.doubleValue(left);\n    double rightValue \u003d InfoSetUtil.doubleValue(right);\n    return evaluateCompare(rightValue \u003d\u003d leftDoubleValue ? 0 : rightValue \u003e leftDoubleValue ? -1 : 1);\n}",
  "JxPath-6": "protected boolean equal(EvalContext context, Expression left, Expression right) {\n    Object leftValue \u003d left.compute(context);\n    Object objRight \u003d right.compute(context);\n    System.err.println(\"COMPARING: \" + (null \u003d\u003d leftValue ? \"null\" : leftValue.getClass().getName()) + \" \" + (null \u003d\u003d objRight ? \"null\" : objRight.getClass().getName()));\n    if (leftValue instanceof InitialContext || leftValue instanceof SelfContext) {\n        leftValue \u003d ((EvalContext) leftValue).getSingleNodePointer();\n    }\n    if (objRight instanceof InitialContext || objRight instanceof SelfContext) {\n        objRight \u003d ((EvalContext) objRight).getSingleNodePointer();\n    }\n    if (leftValue instanceof Collection) {\n        leftValue \u003d ((Collection) leftValue).iterator();\n    }\n    if (objRight instanceof Collection) {\n        objRight \u003d ((Collection) objRight).iterator();\n    }\n    if ((leftValue instanceof Iterator) \u0026\u0026 !(objRight instanceof Iterator)) {\n        return contains((Iterator) leftValue, objRight);\n    }\n    if (!(leftValue instanceof Iterator) \u0026\u0026 (objRight instanceof Iterator)) {\n        return contains((Iterator) objRight, leftValue);\n    }\n    if (leftValue instanceof Iterator \u0026\u0026 objRight instanceof Iterator) {\n        return findMatch((Iterator) leftValue, (Iterator) objRight);\n    }\n    return equal(leftValue, objRight);\n}",
  "Lang-39": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (null \u003d\u003d text || 0 \u003d\u003d text.length() || null \u003d\u003d searchList || 0 \u003d\u003d searchList.length || null \u003d\u003d replacementList || 0 \u003d\u003d replacementList.length) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (0 \u003e timeToLive) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int patternCount \u003d searchList.length;\n    int substitutionLength \u003d replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (substitutionLength !\u003d patternCount) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + patternCount + \" vs \" + substitutionLength);\n    }\n    // keep track of which still have matches\n    boolean[] matchesExhaustedForReplacementIndex \u003d new boolean[patternCount];\n    // index on index that the match was found\n    int matchIndex \u003d -1;\n    int substitutionIndex \u003d -1;\n    int tempIndex \u003d -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int j \u003d 0; patternCount \u003e j; j++) {\n        if (matchesExhaustedForReplacementIndex[j] || null \u003d\u003d searchList[j] || 0 \u003d\u003d searchList[j].length() || null \u003d\u003d replacementList[j]) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[j]);\n        // see if we need to keep searching for this\n        if (-1 !\u003d tempIndex) {\n            if (-1 \u003d\u003d matchIndex || matchIndex \u003e tempIndex) {\n                matchIndex \u003d tempIndex;\n                substitutionIndex \u003d j;\n            }\n        } else {\n            matchesExhaustedForReplacementIndex[j] \u003d true;\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (-1 \u003d\u003d matchIndex) {\n        return text;\n    }\n    int initialIndex \u003d 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int growth \u003d 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int j \u003d 0; searchList.length \u003e j; j++) {\n        int larger \u003d replacementList[j].length() - searchList[j].length();\n        if (0 \u003c larger) {\n            // assume 3 matches\n            growth +\u003d 3 * larger;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    growth \u003d Math.min(growth, text.length() / 5);\n    StringBuilder stringBuilder \u003d new StringBuilder(text.length() + growth);\n    while (-1 !\u003d matchIndex) {\n        for (int j \u003d initialIndex; matchIndex \u003e j; j++) {\n            stringBuilder.append(text.charAt(j));\n        }\n        stringBuilder.append(replacementList[substitutionIndex]);\n        initialIndex \u003d matchIndex + searchList[substitutionIndex].length();\n        matchIndex \u003d -1;\n        substitutionIndex \u003d -1;\n        tempIndex \u003d -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int j \u003d 0; patternCount \u003e j; j++) {\n            if (matchesExhaustedForReplacementIndex[j] || null \u003d\u003d searchList[j] || 0 \u003d\u003d searchList[j].length() || null \u003d\u003d replacementList[j]) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[j], initialIndex);\n            // see if we need to keep searching for this\n            if (-1 !\u003d tempIndex) {\n                if (-1 \u003d\u003d matchIndex || matchIndex \u003e tempIndex) {\n                    matchIndex \u003d tempIndex;\n                    substitutionIndex \u003d j;\n                }\n            } else {\n                matchesExhaustedForReplacementIndex[j] \u003d true;\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    int finalTextLength \u003d text.length();\n    for (int j \u003d initialIndex; finalTextLength \u003e j; j++) {\n        stringBuilder.append(text.charAt(j));\n    }\n    String output \u003d stringBuilder.toString();\n    if (!repeat) {\n        return output;\n    }\n    return replaceEach(output, searchList, replacementList, repeat, timeToLive - 1);\n}",
  "Lang-38": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar \u003d (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}",
  "Math-84": "protected void iterateSimplex(final Comparator\u003cRealPointValuePair\u003e comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    while (true) {\n        incrementIterationsCounter();\n        // save the original vertex\n        final RealPointValuePair[] initial \u003d simplex;\n        final RealPointValuePair optimal \u003d initial[0];\n        // perform a reflection step\n        final RealPointValuePair reflated \u003d evaluateNewSimplex(initial, 1.0, comparator);\n        if (0 \u003e comparator.compare(reflated, optimal)) {\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedShape \u003d simplex;\n            final RealPointValuePair extended \u003d evaluateNewSimplex(initial, khi, comparator);\n            if (0 \u003e\u003d comparator.compare(reflated, extended)) {\n                // accept the reflected simplex\n                simplex \u003d reflectedShape;\n            }\n            return;\n        }\n        // compute the contracted simplex\n        final RealPointValuePair adjusted \u003d evaluateNewSimplex(initial, gamma, comparator);\n        if (0 \u003e comparator.compare(adjusted, optimal)) {\n            // accept the contracted simplex\n            // check convergence\n            return;\n        }\n    }\n}",
  "Closure-7": "public JSType caseObjectType(ObjectType type) {\n    if (value.equals(\"function\")) {\n        JSType constructorType \u003d getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue \u0026\u0026 constructorType.isSubtype(type) ? constructorType : null;\n        // Objects are restricted to \"Function\", subtypes are left\n        // Only filter out subtypes of \"function\"\n    }\n    return matchesExpectation(\"object\") ? type : null;\n}",
  "Math-85": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException {\n    if (null \u003d\u003d function) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (0 \u003e\u003d maximumIterations) {\n        throw MathRuntimeException.createIllegalArgumentException(\"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (lowerBound \u003e initial || upperBound \u003c initial || upperBound \u003c\u003d lowerBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\"invalid bracketing parameters:  lower bound\u003d{0},  initial\u003d{1}, upper bound\u003d{2}\", lowerBound, initial, upperBound);\n    }\n    double startPoint \u003d initial;\n    double upperLimit \u003d initial;\n    double f_a;\n    double fB;\n    int iterationCount \u003d 0;\n    do {\n        startPoint \u003d Math.max(startPoint - 1.0, lowerBound);\n        upperLimit \u003d Math.min(upperLimit + 1.0, upperBound);\n        f_a \u003d function.value(startPoint);\n        fB \u003d function.value(upperLimit);\n        iterationCount +\u003d 1;\n    } while ((0.0 \u003c f_a * fB) \u0026\u0026 (maximumIterations \u003e iterationCount) \u0026\u0026 ((lowerBound \u003c startPoint) || (upperBound \u003e upperLimit)));\n    if (0.0 \u003c\u003d f_a * fB) {\n        throw new ConvergenceException(\"number of iterations\u003d{0}, maximum iterations\u003d{1}, \" + \"initial\u003d{2}, lower bound\u003d{3}, upper bound\u003d{4}, final a value\u003d{5}, \" + \"final b value\u003d{6}, f(a)\u003d{7}, f(b)\u003d{8}\", iterationCount, maximumIterations, initial, lowerBound, upperBound, startPoint, upperLimit, f_a, fB);\n    }\n    return new double[] { startPoint, upperLimit };\n}",
  "Math-86": "public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n    }\n    final int dimension \u003d matrix.getRowDimension();\n    lTData \u003d matrix.getData();\n    cachedL \u003d null;\n    cachedLT \u003d null;\n    // check the matrix before transformation\n    for (int rowIndex \u003d 0; dimension \u003e rowIndex; ++rowIndex) {\n        final double[] lowerRowElements \u003d lTData[rowIndex];\n        if (absolutePositivityThreshold \u003e lTData[rowIndex][rowIndex]) {\n            throw new NotPositiveDefiniteMatrixException();\n        }\n        int columnIndex \u003d rowIndex + 1;\n        while (dimension \u003e columnIndex) {\n            final double[] lK \u003d lTData[columnIndex];\n            final double lElement \u003d lowerRowElements[columnIndex];\n            final double lJIValue \u003d lK[rowIndex];\n            final double maxDifference \u003d relativeSymmetryThreshold * Math.max(Math.abs(lElement), Math.abs(lJIValue));\n            if (maxDifference \u003c Math.abs(lElement - lJIValue)) {\n                throw new NotSymmetricMatrixException();\n            }\n            lK[rowIndex] \u003d 0;\n            ++columnIndex;\n        }\n    }\n    // transform the matrix\n    for (int rowIndex \u003d 0; dimension \u003e rowIndex; ++rowIndex) {\n        final double[] lTI \u003d lTData[rowIndex];\n        // check diagonal element\n        lTI[rowIndex] \u003d Math.sqrt(lTI[rowIndex]);\n        final double reciprocal \u003d 1.0 / lTI[rowIndex];\n        int colIndex \u003d dimension - 1;\n        while (rowIndex \u003c colIndex) {\n            lTI[colIndex] *\u003d reciprocal;\n            final double[] ltTemp \u003d lTData[colIndex];\n            int idx \u003d colIndex;\n            while (dimension \u003e idx) {\n                ltTemp[idx] -\u003d lTI[colIndex] * lTI[idx];\n                ++idx;\n            }\n            --colIndex;\n        }\n    }\n}",
  "Closure-5": "private boolean isInlinableObject(List\u003cReference\u003e refs) {\n    boolean result \u003d false;\n    Set\u003cString\u003e permittedProperties \u003d Sets.newHashSet();\n    for (Reference reference : refs) {\n        Node identifier \u003d reference.getNode();\n        Node ancestor \u003d reference.getParent();\n        Node gramps \u003d reference.getGrandparent();\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference \u0027this\u0027).\n        //\n        if (ancestor.isGetProp()) {\n            Preconditions.checkState(identifier \u003d\u003d ancestor.getFirstChild());\n            // A call target may be using the object as a \u0027this\u0027 value.\n            if (gramps.isCall() \u0026\u0026 ancestor \u003d\u003d gramps.getFirstChild()) {\n                return false;\n            }\n            // Deleting a property has different semantics from deleting\n            // a variable, so deleted properties should not be inlined.\n            // NOTE(nicksantos): This pass\u0027s object-splitting algorithm has\n            // a blind spot. It assumes that if a property isn\u0027t defined on an\n            // object, then the value is undefined. This is not true, because\n            // Object.prototype can have arbitrary properties on it.\n            //\n            // We short-circuit this problem by bailing out if we see a reference\n            // to a property that isn\u0027t defined on the object literal. This\n            // isn\u0027t a perfect algorithm, but it should catch most cases.\n            String propertyName \u003d ancestor.getLastChild().getString();\n            if (!permittedProperties.contains(propertyName)) {\n                if (!NodeUtil.isVarOrSimpleAssignLhs(ancestor, gramps)) {\n                    return false;\n                } else {\n                    permittedProperties.add(propertyName);\n                }\n            }\n            continue;\n        }\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(identifier)) {\n            return false;\n        }\n        Node assignmentValue \u003d reference.getAssignedValue();\n        if (null \u003d\u003d assignmentValue) {\n            // A var with no assignment.\n            continue;\n        }\n        // We\u0027re looking for object literal assignments only.\n        if (!assignmentValue.isObjectLit()) {\n            return false;\n        }\n        Node descendant \u003d assignmentValue.getFirstChild();\n        while (null !\u003d descendant) {\n            if (descendant.isGetterDef() || descendant.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n            permittedProperties.add(descendant.getString());\n            Node childNode \u003d descendant.getFirstChild();\n            // Check if childVal is the parent of any of the passed in\n            // references, as that is how self-referential assignments\n            // will happen.\n            for (Reference t : refs) {\n                Node referencedNode \u003d t.getParent();\n                while (!NodeUtil.isStatementBlock(referencedNode)) {\n                    if (childNode \u003d\u003d referencedNode) {\n                        // There\u0027s a self-referential assignment\n                        return false;\n                    }\n                    referencedNode \u003d referencedNode.getParent();\n                }\n            }\n            descendant \u003d descendant.getNext();\n        }\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x \u003d {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x \u003d {a: x.b, b: x.a} is not orderable,\n        // but x \u003d {a: 1, b: x.a} is.\n        //\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        result \u003d true;\n    }\n    return result;\n}",
  "Math-87": "private Integer getBasicRow(final int col) {\n    Integer index \u003d null;\n    int i \u003d getNumObjectiveFunctions();\n    while (getHeight() \u003e i) {\n        if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n            if (null !\u003d index) {\n                return null;\n            } else {\n                index \u003d i;\n            }\n        }\n        i +\u003d 1;\n    }\n    return index;\n}",
  "Closure-4": "JSType resolveInternal(ErrorReporter t, StaticScope\u003cJSType\u003e enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean successful \u003d resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    if (successful) {\n        super.resolveInternal(t, enclosing);\n        finishPropertyContinuations();\n        return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n        finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}",
  "Math-88": "protected RealPointValuePair getSolution() {\n    double[] parameters \u003d new double[getOriginalNumDecisionVariables()];\n    Integer basicRowIndex \u003d getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n    double mostNegativeValue \u003d null \u003d\u003d basicRowIndex ? 0 : getEntry(basicRowIndex, getRhsOffset());\n    int index \u003d 0;\n    while (parameters.length \u003e index) {\n        basicRowIndex \u003d getBasicRow(getNumObjectiveFunctions() + index);\n        // if multiple variables can take a given value\n        // then we choose the first and set the rest equal to 0\n        parameters[index] \u003d (null \u003d\u003d basicRowIndex ? 0 : getEntry(basicRowIndex, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegativeValue);\n        if (null !\u003d basicRowIndex) {\n            int j \u003d getNumObjectiveFunctions();\n            while (getNumObjectiveFunctions() + index \u003e j) {\n                if (1 \u003d\u003d tableau.getEntry(basicRowIndex, j)) {\n                    parameters[index] \u003d 0;\n                }\n                j +\u003d 1;\n            }\n        }\n        index +\u003d 1;\n    }\n    return new RealPointValuePair(parameters, f.getValue(parameters));\n}",
  "Lang-37": "public static \u003cT\u003e T[] addAll(T[] array1, T... array2) {\n    if (null !\u003d array1) {\n        if (null \u003d\u003d array2) {\n            return clone(array1);\n        }\n    } else {\n        return clone(array2);\n    }\n    final Class\u003c?\u003e componentType \u003d array1.getClass().getComponentType();\n    T[] combinedArray \u003d (T[]) Array.newInstance(componentType, array1.length + array2.length);\n    System.arraycopy(array1, 0, combinedArray, 0, array1.length);\n    System.arraycopy(array2, 0, combinedArray, array1.length, array2.length);\n    // Check if problem is incompatible types\n    return combinedArray;\n}",
  "Math-89": "public void addValue(Object v) {\n    addValue((Comparable\u003c?\u003e) v);\n}",
  "Closure-2": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap\u003cString, ObjectType\u003e properties, HashMap\u003cString, ObjectType\u003e currentProperties, ObjectType interfaceType) {\n    ObjectType inferredProto \u003d interfaceType.getImplicitPrototype();\n    Set\u003cString\u003e existingPropertyNames;\n    // This can be the case if interfaceType is proxy to a non-existent\n    // object (which is a bad type annotation, but shouldn\u0027t crash).\n    existingPropertyNames \u003d inferredProto.getOwnPropertyNames();\n    for (String propertyName : existingPropertyNames) {\n        ObjectType objectType \u003d properties.get(propertyName);\n        if (null !\u003d objectType) {\n            if (!interfaceType.getPropertyType(propertyName).isEquivalentTo(objectType.getPropertyType(propertyName))) {\n                compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, propertyName, objectType.toString(), interfaceType.toString()));\n            }\n        }\n        currentProperties.put(propertyName, interfaceType);\n    }\n    for (ObjectType extendedInterfaceType : interfaceType.getCtorExtendedInterfaces()) {\n        checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, extendedInterfaceType);\n    }\n}",
  "Chart-4": "public Range getDataRange(ValueAxis axis) {\n    Range finalRange \u003d null;\n    List associatedDatasets \u003d new ArrayList();\n    List collectedAnnotations \u003d new ArrayList();\n    boolean isXAxis \u003d true;\n    // is it a domain axis?\n    int axisIndex \u003d getDomainAxisIndex(axis);\n    if (0 \u003c\u003d axisIndex) {\n        isXAxis \u003d true;\n        associatedDatasets.addAll(getDatasetsMappedToDomainAxis(new Integer(axisIndex)));\n        if (0 \u003d\u003d axisIndex) {\n            // grab the plot\u0027s annotations\n            Iterator cursor \u003d this.annotations.iterator();\n            while (cursor.hasNext()) {\n                XYAnnotation includedMarkings \u003d (XYAnnotation) cursor.next();\n                if (includedMarkings instanceof XYAnnotationBoundsInfo) {\n                    collectedAnnotations.add(includedMarkings);\n                }\n            }\n        }\n    }\n    // or is it a range axis?\n    int rangeIndex \u003d getRangeAxisIndex(axis);\n    if (0 \u003c\u003d rangeIndex) {\n        isXAxis \u003d false;\n        associatedDatasets.addAll(getDatasetsMappedToRangeAxis(new Integer(rangeIndex)));\n        if (0 \u003d\u003d rangeIndex) {\n            Iterator cursor \u003d this.annotations.iterator();\n            while (cursor.hasNext()) {\n                XYAnnotation includedMarkings \u003d (XYAnnotation) cursor.next();\n                if (includedMarkings instanceof XYAnnotationBoundsInfo) {\n                    collectedAnnotations.add(includedMarkings);\n                }\n            }\n        }\n    }\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator cursor \u003d associatedDatasets.iterator();\n    while (cursor.hasNext()) {\n        XYDataset dataset \u003d (XYDataset) cursor.next();\n        if (null !\u003d dataset) {\n            XYItemRenderer renderer \u003d getRendererForDataset(dataset);\n            if (!isXAxis) {\n                if (null \u003d\u003d renderer) {\n                    finalRange \u003d Range.combine(finalRange, DatasetUtilities.findRangeBounds(dataset));\n                } else {\n                    finalRange \u003d Range.combine(finalRange, renderer.findRangeBounds(dataset));\n                }\n            } else {\n                if (null \u003d\u003d renderer) {\n                    finalRange \u003d Range.combine(finalRange, DatasetUtilities.findDomainBounds(dataset));\n                } else {\n                    finalRange \u003d Range.combine(finalRange, renderer.findDomainBounds(dataset));\n                }\n            }\n            Collection annotationsCollection \u003d renderer.getAnnotations();\n            Iterator iteratorForAnnotations \u003d annotationsCollection.iterator();\n            while (iteratorForAnnotations.hasNext()) {\n                XYAnnotation a \u003d (XYAnnotation) iteratorForAnnotations.next();\n                if (a instanceof XYAnnotationBoundsInfo) {\n                    collectedAnnotations.add(a);\n                }\n            }\n        }\n    }\n    Iterator it \u003d collectedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo annotationBoundsInfo \u003d (XYAnnotationBoundsInfo) it.next();\n        if (annotationBoundsInfo.getIncludeInDataBounds()) {\n            if (!isXAxis) {\n                finalRange \u003d Range.combine(finalRange, annotationBoundsInfo.getYRange());\n            } else {\n                finalRange \u003d Range.combine(finalRange, annotationBoundsInfo.getXRange());\n            }\n        }\n    }\n    return finalRange;\n}",
  "Lang-53": "private static void modify(Calendar val, int field, boolean round) {\n    if (280000000 \u003c val.get(Calendar.YEAR)) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (Calendar.MILLISECOND \u003d\u003d field) {\n        return;\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    Date timestamp \u003d val.getTime();\n    long epoch \u003d timestamp.getTime();\n    boolean completed \u003d false;\n    // truncate milliseconds\n    int milliseconds \u003d val.get(Calendar.MILLISECOND);\n    if (!round || 500 \u003e milliseconds) {\n        epoch \u003d epoch - milliseconds;\n        if (Calendar.SECOND \u003d\u003d field) {\n            completed \u003d true;\n        }\n    }\n    // truncate seconds\n    int ticks \u003d val.get(Calendar.SECOND);\n    if (!completed \u0026\u0026 (!round || 30 \u003e ticks)) {\n        epoch \u003d epoch - (ticks * 1000L);\n        if (Calendar.MINUTE \u003d\u003d field) {\n            completed \u003d true;\n        }\n    }\n    // truncate minutes\n    int trimester \u003d val.get(Calendar.MINUTE);\n    if (!completed \u0026\u0026 (!round || 30 \u003e trimester)) {\n        epoch \u003d epoch - (trimester * 60000L);\n    }\n    // reset time\n    if (epoch !\u003d timestamp.getTime()) {\n        timestamp.setTime(epoch);\n        val.setTime(timestamp);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean shouldRoundUp \u003d false;\n    int index \u003d 0;\n    while (fields.length \u003e index) {\n        int j \u003d 0;\n        while (fields[index].length \u003e j) {\n            if (field \u003d\u003d fields[index][j]) {\n                //This is our field... we stop looping\n                if (round \u0026\u0026 shouldRoundUp) {\n                    if (DateUtils.SEMI_MONTH !\u003d field) {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[index][0], 1);\n                    } else {\n                        //This is a special case that\u0027s hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (1 !\u003d val.get(Calendar.DATE)) {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        } else {\n                            val.add(Calendar.DATE, 15);\n                        }\n                    }\n                }\n                return;\n            }\n            j +\u003d 1;\n        }\n        //We have various fields that are not easy roundings\n        int adjustment \u003d 0;\n        boolean offsetAssigned \u003d false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (Calendar.DATE \u003d\u003d fields[index][0]) {\n                    //If we\u0027re going to drop the DATE field\u0027s value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    adjustment \u003d val.get(Calendar.DATE) - 1;\n                    //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (15 \u003c\u003d adjustment) {\n                        adjustment -\u003d 15;\n                    }\n                    //Record whether we\u0027re in the top or bottom half of that range\n                    shouldRoundUp \u003d 7 \u003c adjustment;\n                    offsetAssigned \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (Calendar.HOUR_OF_DAY \u003d\u003d fields[index][0]) {\n                    //If we\u0027re going to drop the HOUR field\u0027s value,\n                    //  we want to do this our own way.\n                    adjustment \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (12 \u003c\u003d adjustment) {\n                        adjustment -\u003d 12;\n                    }\n                    shouldRoundUp \u003d 6 \u003c adjustment;\n                    offsetAssigned \u003d true;\n                }\n                break;\n        }\n        if (!offsetAssigned) {\n            int minimum \u003d val.getActualMinimum(fields[index][0]);\n            int upperLimit \u003d val.getActualMaximum(fields[index][0]);\n            //Calculate the offset from the minimum allowed value\n            adjustment \u003d val.get(fields[index][0]) - minimum;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            shouldRoundUp \u003d ((upperLimit - minimum) / 2) \u003c adjustment;\n        }\n        //We need to remove this field\n        if (0 !\u003d adjustment) {\n            val.set(fields[index][0], val.get(fields[index][0]) - adjustment);\n        }\n        index +\u003d 1;\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
  "Chart-3": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException {\n    if (0 \u003e start) {\n        throw new IllegalArgumentException(\"Requires start \u003e\u003d 0.\");\n    }\n    if (start \u003e end) {\n        throw new IllegalArgumentException(\"Requires start \u003c\u003d end.\");\n    }\n    TimeSeries copy \u003d (TimeSeries) super.clone();\n    copy.data \u003d new java.util.ArrayList();\n    if (0 \u003c this.data.size()) {\n        int position \u003d start;\n        while (end \u003e\u003d position) {\n            TimeSeriesDataItem dataItem \u003d (TimeSeriesDataItem) this.data.get(position);\n            TimeSeriesDataItem duplicate \u003d (TimeSeriesDataItem) dataItem.clone();\n            try {\n                copy.add(duplicate);\n            } catch (SeriesException e) {\n                e.printStackTrace();\n            }\n            position +\u003d 1;\n        }\n    }\n    return copy;\n}",
  "Lang-52": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n    if (null \u003d\u003d out) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (null \u003d\u003d str) {\n        return;\n    }\n    int length;\n    length \u003d str.length();\n    int index \u003d 0;\n    while (length \u003e index) {\n        char character \u003d str.charAt(index);\n        // handle unicode\n        if (0xfff \u003e\u003d character) {\n            if (0xff \u003e\u003d character) {\n                if (0x7f \u003e\u003d character) {\n                    if (32 \u003c\u003d character) {\n                        switch(character) {\n                            case \u0027\\\u0027\u0027:\n                                if (escapeSingleQuote) {\n                                    out.write(\u0027\\\\\u0027);\n                                }\n                                out.write(\u0027\\\u0027\u0027);\n                                break;\n                            case \u0027\"\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027\"\u0027);\n                                break;\n                            case \u0027\\\\\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027\\\\\u0027);\n                                break;\n                            default:\n                                out.write(character);\n                                break;\n                        }\n                    } else {\n                        switch(character) {\n                            case \u0027\\b\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027b\u0027);\n                                break;\n                            case \u0027\\n\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027n\u0027);\n                                break;\n                            case \u0027\\t\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027t\u0027);\n                                break;\n                            case \u0027\\f\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027f\u0027);\n                                break;\n                            case \u0027\\r\u0027:\n                                out.write(\u0027\\\\\u0027);\n                                out.write(\u0027r\u0027);\n                                break;\n                            default:\n                                if (0xf \u003e\u003d character) {\n                                    out.write(\"\\\\u000\" + hex(character));\n                                } else {\n                                    out.write(\"\\\\u00\" + hex(character));\n                                }\n                                break;\n                        }\n                    }\n                } else {\n                    out.write(\"\\\\u00\" + hex(character));\n                }\n            } else {\n                out.write(\"\\\\u0\" + hex(character));\n            }\n        } else {\n            out.write(\"\\\\u\" + hex(character));\n        }\n        index +\u003d 1;\n    }\n}",
  "Chart-6": "public boolean equals(Object obj) {\n    if (this \u003d\u003d obj) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    return super.equals(obj);\n}",
  "Lang-55": "public void stop() {\n    if (STATE_RUNNING !\u003d this.runningState \u0026\u0026 STATE_SUSPENDED !\u003d this.runningState) {\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n    stopTime \u003d System.currentTimeMillis();\n    this.runningState \u003d STATE_STOPPED;\n}",
  "Chart-5": "public XYDataItem addOrUpdate(Number x, Number y) {\n    if (null \u003d\u003d x) {\n        throw new IllegalArgumentException(\"Null \u0027x\u0027 argument.\");\n    }\n    // if we get to here, we know that duplicate X values are not permitted\n    XYDataItem replaced \u003d null;\n    int position \u003d indexOf(x);\n    if (0 \u003e position || this.allowDuplicateXValues) {\n        // if the series is sorted, the negative index is a result from\n        // Collections.binarySearch() and tells us where to insert the\n        // new item...otherwise it will be just -1 and we should just\n        // append the value to the list...\n        if (!(this.autoSort)) {\n            this.data.add(new XYDataItem(x, y));\n        } else {\n            this.data.add(-position - 1, new XYDataItem(x, y));\n        }\n        // check if this addition will exceed the maximum item count...\n        if (this.maximumItemCount \u003c getItemCount()) {\n            this.data.remove(0);\n        }\n    } else {\n        XYDataItem current \u003d (XYDataItem) this.data.get(position);\n        try {\n            replaced \u003d (XYDataItem) current.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new SeriesException(\"Couldn\u0027t clone XYDataItem!\");\n        }\n        current.setY(y);\n    }\n    fireSeriesChanged();\n    return replaced;\n}",
  "Lang-54": "public static Locale toLocale(String str) {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    int length \u003d str.length();\n    if (2 !\u003d length \u0026\u0026 5 !\u003d length \u0026\u0026 7 \u003e length) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char firstChar \u003d str.charAt(0);\n    char ch2 \u003d str.charAt(1);\n    if (\u0027a\u0027 \u003e firstChar || \u0027z\u0027 \u003c firstChar || \u0027a\u0027 \u003e ch2 || \u0027z\u0027 \u003c ch2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (2 !\u003d length) {\n        if (\u0027_\u0027 !\u003d str.charAt(2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char chCountry \u003d str.charAt(3);\n        char ch5 \u003d str.charAt(4);\n        if (\u0027A\u0027 \u003e chCountry || \u0027Z\u0027 \u003c chCountry || \u0027A\u0027 \u003e ch5 || \u0027Z\u0027 \u003c ch5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (5 !\u003d length) {\n            if (\u0027_\u0027 !\u003d str.charAt(5)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        } else {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        }\n    } else {\n        return new Locale(str, \"\");\n    }\n}",
  "Lang-51": "public static boolean toBoolean(String str) {\n    // Previously used equalsIgnoreCase, which was fast for interned \u0027true\u0027.\n    // Non interned \u0027true\u0027 matched 15 times slower.\n    //\n    // Optimisation provides same performance as before for interned \u0027true\u0027.\n    // Similar performance for null, \u0027false\u0027, and other strings not length 2/3/4.\n    // \u0027true\u0027/\u0027TRUE\u0027 match 4 times slower, \u0027tRUE\u0027/\u0027True\u0027 7 times slower.\n    if (\"true\" \u003d\u003d str) {\n        return true;\n    }\n    if (null \u003d\u003d str) {\n        return false;\n    }\n    switch(str.length()) {\n        case 2:\n            {\n                char firstChar \u003d str.charAt(0);\n                char ch2 \u003d str.charAt(1);\n                return (\u0027o\u0027 \u003d\u003d firstChar || \u0027O\u0027 \u003d\u003d firstChar) \u0026\u0026 (\u0027n\u0027 \u003d\u003d ch2 || \u0027N\u0027 \u003d\u003d ch2);\n            }\n        case 3:\n            {\n                char character \u003d str.charAt(0);\n                if (\u0027y\u0027 \u003d\u003d character) {\n                    return (\u0027e\u0027 \u003d\u003d str.charAt(1) || \u0027E\u0027 \u003d\u003d str.charAt(1)) \u0026\u0026 (\u0027s\u0027 \u003d\u003d str.charAt(2) || \u0027S\u0027 \u003d\u003d str.charAt(2));\n                }\n                if (\u0027Y\u0027 \u003d\u003d character) {\n                    return (\u0027E\u0027 \u003d\u003d str.charAt(1) || \u0027e\u0027 \u003d\u003d str.charAt(1)) \u0026\u0026 (\u0027S\u0027 \u003d\u003d str.charAt(2) || \u0027s\u0027 \u003d\u003d str.charAt(2));\n                }\n            }\n        case 4:\n            {\n                char character \u003d str.charAt(0);\n                if (\u0027t\u0027 \u003d\u003d character) {\n                    return (\u0027r\u0027 \u003d\u003d str.charAt(1) || \u0027R\u0027 \u003d\u003d str.charAt(1)) \u0026\u0026 (\u0027u\u0027 \u003d\u003d str.charAt(2) || \u0027U\u0027 \u003d\u003d str.charAt(2)) \u0026\u0026 (\u0027e\u0027 \u003d\u003d str.charAt(3) || \u0027E\u0027 \u003d\u003d str.charAt(3));\n                }\n                if (\u0027T\u0027 \u003d\u003d character) {\n                    return (\u0027R\u0027 \u003d\u003d str.charAt(1) || \u0027r\u0027 \u003d\u003d str.charAt(1)) \u0026\u0026 (\u0027U\u0027 \u003d\u003d str.charAt(2) || \u0027u\u0027 \u003d\u003d str.charAt(2)) \u0026\u0026 (\u0027E\u0027 \u003d\u003d str.charAt(3) || \u0027e\u0027 \u003d\u003d str.charAt(3));\n                }\n            }\n    }\n    return false;\n}",
  "Chart-1": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection legendItems \u003d new LegendItemCollection();\n    if (null \u003d\u003d this.plot) {\n        return legendItems;\n    }\n    int position \u003d this.plot.getIndexOf(this);\n    CategoryDataset dataCollection \u003d this.plot.getDataset(position);\n    if (null !\u003d dataCollection) {\n        return legendItems;\n    }\n    int totalSeries \u003d dataCollection.getRowCount();\n    if (!plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        int j \u003d totalSeries - 1;\n        while (0 \u003c\u003d j) {\n            if (isSeriesVisibleInLegend(j)) {\n                LegendItem legendItem \u003d getLegendItem(position, j);\n                if (null !\u003d legendItem) {\n                    legendItems.add(legendItem);\n                }\n            }\n            j -\u003d 1;\n        }\n    } else {\n        int j \u003d 0;\n        while (totalSeries \u003e j) {\n            if (isSeriesVisibleInLegend(j)) {\n                LegendItem legendItem \u003d getLegendItem(position, j);\n                if (null !\u003d legendItem) {\n                    legendItems.add(legendItem);\n                }\n            }\n            j +\u003d 1;\n        }\n    }\n    return legendItems;\n}",
  "Chart-8": "public Week(Date time, TimeZone zone) {\n    // defer argument checking...\n    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n}",
  "Chart-7": "private void updateBounds(TimePeriod period, int index) {\n    long beginning \u003d period.getStart().getTime();\n    long finish \u003d period.getEnd().getTime();\n    long median \u003d beginning + ((finish - beginning) / 2);\n    if (0 \u003e this.minStartIndex) {\n        this.minStartIndex \u003d index;\n    } else {\n        long minimumStartTime \u003d getDataItem(this.minStartIndex).getPeriod().getStart().getTime();\n        if (minimumStartTime \u003e beginning) {\n            this.minStartIndex \u003d index;\n        }\n    }\n    if (0 \u003e this.maxStartIndex) {\n        this.maxStartIndex \u003d index;\n    } else {\n        long latestStart \u003d getDataItem(this.maxStartIndex).getPeriod().getStart().getTime();\n        if (latestStart \u003c beginning) {\n            this.maxStartIndex \u003d index;\n        }\n    }\n    if (0 \u003e this.minMiddleIndex) {\n        this.minMiddleIndex \u003d index;\n    } else {\n        long startTimestamp \u003d getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();\n        long endTime \u003d getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();\n        long midpoint \u003d startTimestamp + (endTime - startTimestamp) / 2;\n        if (midpoint \u003e median) {\n            this.minMiddleIndex \u003d index;\n        }\n    }\n    if (0 \u003e this.maxMiddleIndex) {\n        this.maxMiddleIndex \u003d index;\n    } else {\n        long startTimestamp \u003d getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();\n        long endTime \u003d getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();\n        long maxMedian \u003d startTimestamp + (endTime - startTimestamp) / 2;\n        if (maxMedian \u003c median) {\n            this.maxMiddleIndex \u003d index;\n        }\n    }\n    if (0 \u003e this.minEndIndex) {\n        this.minEndIndex \u003d index;\n    } else {\n        long minEndTime \u003d getDataItem(this.minEndIndex).getPeriod().getEnd().getTime();\n        if (minEndTime \u003e finish) {\n            this.minEndIndex \u003d index;\n        }\n    }\n    if (0 \u003e this.maxEndIndex) {\n        this.maxEndIndex \u003d index;\n    } else {\n        long latestEnd \u003d getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime();\n        if (latestEnd \u003c finish) {\n            this.maxEndIndex \u003d index;\n        }\n    }\n}",
  "Chart-9": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\n    if (null \u003d\u003d start) {\n        throw new IllegalArgumentException(\"Null \u0027start\u0027 argument.\");\n    }\n    if (null \u003d\u003d end) {\n        throw new IllegalArgumentException(\"Null \u0027end\u0027 argument.\");\n    }\n    if (0 \u003c start.compareTo(end)) {\n        throw new IllegalArgumentException(\"Requires start on or before end.\");\n    }\n    boolean isRangeEmpty \u003d false;\n    int initialIndex \u003d getIndex(start);\n    if (0 \u003e initialIndex) {\n        initialIndex \u003d -(initialIndex + 1);\n        if (this.data.size() \u003d\u003d initialIndex) {\n            // start is after last data item\n            isRangeEmpty \u003d true;\n        }\n    }\n    int finalIndex \u003d getIndex(end);\n    if (0 \u003e finalIndex) {\n        // end period is not in original series\n        // this is first item AFTER end period\n        finalIndex \u003d -(finalIndex + 1);\n        // so this is last item BEFORE end\n        finalIndex \u003d finalIndex - 1;\n    }\n    if (0 \u003e finalIndex) {\n        isRangeEmpty \u003d true;\n    }\n    if (!isRangeEmpty) {\n        return createCopy(initialIndex, finalIndex);\n    } else {\n        TimeSeries duplicate \u003d (TimeSeries) super.clone();\n        duplicate.data \u003d new java.util.ArrayList();\n        return duplicate;\n    }\n}",
  "Math-94": "public static int gcd(int u, int v) {\n    if (0 \u003d\u003d u * v) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can\u0027t necessarily negate a negative number without\n    // overflow)\n    /* assert u!\u003d0 \u0026\u0026 v!\u003d0; */\n    if (0 \u003c u) {\n        u \u003d -u;\n    }\n    // make u negative\n    if (0 \u003c v) {\n        v \u003d -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int exponent \u003d 0;\n    while (0 \u003d\u003d (u \u0026 1) \u0026\u0026 0 \u003d\u003d (v \u0026 1) \u0026\u0026 31 \u003e exponent) {\n        // while u and v are\n        // both even...\n        u /\u003d 2;\n        v /\u003d 2;\n        // cast out twos.\n        exponent +\u003d 1;\n    }\n    if (31 \u003d\u003d exponent) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int temp \u003d (1 \u003d\u003d (u \u0026 1)) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u\u003c0 \u0026\u0026 v\u003c0; */\n        // B4/B3: cast out twos from t.\n        while (0 \u003d\u003d (temp \u0026 1)) {\n            // while t is even..\n            // cast out twos\n            temp /\u003d 2;\n        }\n        // B5 [reset max(u,v)]\n        if (0 \u003e\u003d temp) {\n            v \u003d temp;\n        } else {\n            u \u003d -temp;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        temp \u003d (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (0 !\u003d temp);\n    // gcd is u*2^k\n    return -u * (1 \u003c\u003c exponent);\n}",
  "Lang-49": "public Fraction reduce() {\n    int commonDivisor \u003d greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (1 \u003d\u003d commonDivisor) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / commonDivisor, denominator / commonDivisor);\n}",
  "Math-95": "protected double getInitialDomain(double p) {\n    double result;\n    double denominatorDegreesOfFreedom \u003d getDenominatorDegreesOfFreedom();\n    // use mean\n    result \u003d denominatorDegreesOfFreedom / (denominatorDegreesOfFreedom - 2.0);\n    return result;\n}",
  "Math-96": "public boolean equals(Object other) {\n    boolean isEqual;\n    if (other !\u003d this) {\n        if (null !\u003d other) {\n            try {\n                Complex otherComplex \u003d (Complex) other;\n                if (!otherComplex.isNaN()) {\n                    isEqual \u003d (Double.doubleToRawLongBits(otherComplex.getReal()) \u003d\u003d Double.doubleToRawLongBits(real)) \u0026\u0026 (Double.doubleToRawLongBits(otherComplex.getImaginary()) \u003d\u003d Double.doubleToRawLongBits(imaginary));\n                } else {\n                    isEqual \u003d this.isNaN();\n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                isEqual \u003d false;\n            }\n        } else {\n            isEqual \u003d false;\n        }\n    } else {\n        isEqual \u003d true;\n    }\n    return isEqual;\n}",
  "Math-97": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double result \u003d Double.NaN;\n    double yStart \u003d f.value(min);\n    double yMaximum \u003d f.value(max);\n    // Verify bracketing\n    double product \u003d yStart * yMaximum;\n    if (0 \u003e product) {\n        // solve using only the first endpoint as initial guess\n        result \u003d solve(min, yStart, max, yMaximum, min, yStart);\n        // either min or max is a root\n    } else {\n        // check if either value is close to a zero\n        // neither value is close to zero and min and max do not bracket root.\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yStart + \",\" + yMaximum + \"]\");\n    }\n    return result;\n}",
  "Lang-45": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n    // initial parameter checks\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    if (0 \u003d\u003d str.length()) {\n        return StringUtils.EMPTY;\n    }\n    // if the lower value is greater than the length of the string,\n    // set to the length of the string\n    // if the upper value is -1 (i.e. no limit) or is greater\n    // than the length of the string, set to the length of the string\n    if (-1 \u003d\u003d upper || str.length() \u003c upper) {\n        upper \u003d str.length();\n    }\n    // if upper is less than lower, raise it to lower\n    if (lower \u003e upper) {\n        upper \u003d lower;\n    }\n    StringBuffer output \u003d new StringBuffer();\n    int position \u003d StringUtils.indexOf(str, \" \", lower);\n    if (-1 !\u003d position) {\n        if (upper \u003e\u003d position) {\n            output.append(str.substring(0, position));\n            output.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            output.append(str.substring(0, upper));\n            output.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else {\n        output.append(str.substring(0, upper));\n        // only if abbreviation has occured do we append the appendToEnd value\n        if (str.length() !\u003d upper) {\n            output.append(StringUtils.defaultString(appendToEnd));\n        }\n    }\n    return output.toString();\n}",
  "Lang-48": "public EqualsBuilder append(Object lhs, Object rhs) {\n    if (false \u003d\u003d isEquals) {\n        return this;\n    }\n    if (rhs \u003d\u003d lhs) {\n        return this;\n    }\n    if (null \u003d\u003d lhs || null \u003d\u003d rhs) {\n        this.setEquals(false);\n        return this;\n    }\n    Class lhsType \u003d lhs.getClass();\n    if (lhsType.isArray()) {\n        if (// \u0027Switch\u0027 on type of array, to dispatch to the correct handler\n        rhs.getClass() \u003d\u003d lhs.getClass()) {\n            // This handles multi dimensional arrays of the same depth\n            if (!(lhs instanceof long[])) {\n                if (!(lhs instanceof int[])) {\n                    if (!(lhs instanceof short[])) {\n                        if (!(lhs instanceof char[])) {\n                            if (!(lhs instanceof byte[])) {\n                                if (!(lhs instanceof double[])) {\n                                    if (!(lhs instanceof float[])) {\n                                        if (!(lhs instanceof boolean[])) {\n                                            // Not an array of primitives\n                                            append((Object[]) lhs, (Object[]) rhs);\n                                        } else {\n                                            append((boolean[]) lhs, (boolean[]) rhs);\n                                        }\n                                    } else {\n                                        append((float[]) lhs, (float[]) rhs);\n                                    }\n                                } else {\n                                    append((double[]) lhs, (double[]) rhs);\n                                }\n                            } else {\n                                append((byte[]) lhs, (byte[]) rhs);\n                            }\n                        } else {\n                            append((char[]) lhs, (char[]) rhs);\n                        }\n                    } else {\n                        append((short[]) lhs, (short[]) rhs);\n                    }\n                } else {\n                    append((int[]) lhs, (int[]) rhs);\n                }\n            } else {\n                append((long[]) lhs, (long[]) rhs);\n            }\n        } else {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\n            this.setEquals(false);\n        }\n    } else {\n        // The simple case, not an array, just test the element\n        isEquals \u003d lhs.equals(rhs);\n    }\n    return this;\n}",
  "Lang-65": "private static void modify(Calendar val, int field, boolean round) {\n    if (280000000 \u003c val.get(Calendar.YEAR)) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    // truncate seconds\n    // truncate minutes\n    // reset time\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean shouldRoundUp \u003d false;\n    int index \u003d 0;\n    while (fields.length \u003e index) {\n        int j \u003d 0;\n        while (fields[index].length \u003e j) {\n            if (field \u003d\u003d fields[index][j]) {\n                //This is our field... we stop looping\n                if (round \u0026\u0026 shouldRoundUp) {\n                    if (DateUtils.SEMI_MONTH !\u003d field) {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[index][0], 1);\n                    } else {\n                        //This is a special case that\u0027s hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (1 !\u003d val.get(Calendar.DATE)) {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        } else {\n                            val.add(Calendar.DATE, 15);\n                        }\n                    }\n                }\n                return;\n            }\n            j +\u003d 1;\n        }\n        //We have various fields that are not easy roundings\n        int adjustment \u003d 0;\n        boolean offsetAdjusted \u003d false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (Calendar.DATE \u003d\u003d fields[index][0]) {\n                    //If we\u0027re going to drop the DATE field\u0027s value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    adjustment \u003d val.get(Calendar.DATE) - 1;\n                    //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (15 \u003c\u003d adjustment) {\n                        adjustment -\u003d 15;\n                    }\n                    //Record whether we\u0027re in the top or bottom half of that range\n                    shouldRoundUp \u003d 7 \u003c adjustment;\n                    offsetAdjusted \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (Calendar.HOUR_OF_DAY \u003d\u003d fields[index][0]) {\n                    //If we\u0027re going to drop the HOUR field\u0027s value,\n                    //  we want to do this our own way.\n                    adjustment \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (12 \u003c\u003d adjustment) {\n                        adjustment -\u003d 12;\n                    }\n                    shouldRoundUp \u003d 6 \u003c adjustment;\n                    offsetAdjusted \u003d true;\n                }\n                break;\n        }\n        if (!offsetAdjusted) {\n            int lowerBound \u003d val.getActualMinimum(fields[index][0]);\n            int limit \u003d val.getActualMaximum(fields[index][0]);\n            //Calculate the offset from the minimum allowed value\n            adjustment \u003d val.get(fields[index][0]) - lowerBound;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            shouldRoundUp \u003d ((limit - lowerBound) / 2) \u003c adjustment;\n        }\n        //We need to remove this field\n        val.set(fields[index][0], val.get(fields[index][0]) - adjustment);\n        index +\u003d 1;\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
  "Math-70": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}",
  "Lang-61": "public int indexOf(String str, int startIndex) {\n    startIndex \u003d (0 \u003e startIndex ? 0 : startIndex);\n    if (null \u003d\u003d str || size \u003c\u003d startIndex) {\n        return -1;\n    }\n    int stringLength \u003d str.length();\n    if (1 \u003d\u003d stringLength) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (0 \u003d\u003d stringLength) {\n        return startIndex;\n    }\n    if (size \u003c stringLength) {\n        return -1;\n    }\n    char[] bufferArray \u003d buffer;\n    int bufferLength \u003d bufferArray.length - stringLength;\n    outer: for (int currentIndex \u003d startIndex; bufferLength \u003e currentIndex; currentIndex++) {\n        int index \u003d 0;\n        while (stringLength \u003e index) {\n            if (bufferArray[currentIndex + index] !\u003d str.charAt(index)) {\n                continue outer;\n            }\n            index +\u003d 1;\n        }\n        return currentIndex;\n    }\n    return -1;\n}",
  "JacksonCore-15": "public JsonToken nextToken() throws IOException {\n    //Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    // check for no buffered context _exposedContext - null\n    //If all the conditions matches then check for scalar / non-scalar property\n    //if not scalar and ended successfully, then return null\n    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    // then return null\n    // Anything buffered?\n    TokenFilterContext context \u003d _exposedContext;\n    if (null !\u003d context) {\n        while (true) {\n            JsonToken token \u003d context.nextTokenToRead();\n            if (null !\u003d token) {\n                _currToken \u003d token;\n                return token;\n            }\n            // all done with buffered stuff?\n            if (_headContext \u003d\u003d context) {\n                _exposedContext \u003d null;\n                if (context.inArray()) {\n                    token \u003d delegate.getCurrentToken();\n                    // Is this guaranteed to work without further checks?\n                    //                        if (t !\u003d JsonToken.START_ARRAY) {\n                    _currToken \u003d token;\n                    return token;\n                }\n                // Almost! Most likely still have the current token;\n                // with the sole exception of\n                /*\n                    t \u003d delegate.getCurrentToken();\n                    if (t !\u003d JsonToken.FIELD_NAME) {\n                        _currToken \u003d t;\n                        return t;\n                    }\n                    */\n                break;\n            }\n            // If not, traverse down the context chain\n            context \u003d _headContext.findChildOf(context);\n            _exposedContext \u003d context;\n            if (null \u003d\u003d context) {\n                // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n        }\n    }\n    // If not, need to read more. If we got any:\n    JsonToken token \u003d delegate.nextToken();\n    if (null \u003d\u003d token) {\n        // no strict need to close, since we have no state here\n        return (_currToken \u003d token);\n    }\n    // otherwise... to include or not?\n    TokenFilter filter;\n    switch(token.id()) {\n        case ID_START_ARRAY:\n            filter \u003d _itemFilter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildArrayContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            if (null \u003d\u003d filter) {\n                // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            filter \u003d _headContext.checkValue(filter);\n            if (null \u003d\u003d filter) {\n                delegate.skipChildren();\n                break;\n            }\n            if (TokenFilter.INCLUDE_ALL !\u003d filter) {\n                filter \u003d filter.filterStartArray();\n            }\n            _itemFilter \u003d filter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildArrayContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            _headContext \u003d _headContext.createChildArrayContext(filter, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                token \u003d _nextTokenWithBuffering(_headContext);\n                if (null !\u003d token) {\n                    _currToken \u003d token;\n                    return token;\n                }\n            }\n            break;\n        case ID_START_OBJECT:\n            filter \u003d _itemFilter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildObjectContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            if (null \u003d\u003d filter) {\n                // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            filter \u003d _headContext.checkValue(filter);\n            if (null \u003d\u003d filter) {\n                delegate.skipChildren();\n                break;\n            }\n            if (TokenFilter.INCLUDE_ALL !\u003d filter) {\n                filter \u003d filter.filterStartObject();\n            }\n            _itemFilter \u003d filter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildObjectContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            _headContext \u003d _headContext.createChildObjectContext(filter, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                token \u003d _nextTokenWithBuffering(_headContext);\n                if (null !\u003d token) {\n                    _currToken \u003d token;\n                    return token;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean isStartHandled \u003d _headContext.isStartHandled();\n                filter \u003d _headContext.getFilter();\n                if ((null !\u003d filter) \u0026\u0026 (TokenFilter.INCLUDE_ALL !\u003d filter)) {\n                    filter.filterFinishArray();\n                }\n                _headContext \u003d _headContext.getParent();\n                _itemFilter \u003d _headContext.getFilter();\n                if (isStartHandled) {\n                    return (_currToken \u003d token);\n                }\n            }\n            break;\n        case ID_FIELD_NAME:\n            {\n                final String identifier \u003d delegate.getCurrentName();\n                // note: this will also set \u0027needToHandleName\u0027\n                filter \u003d _headContext.setFieldName(identifier);\n                if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                    _itemFilter \u003d filter;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent \u0026\u0026 !_headContext.isStartHandled()) {\n                            // returns START_OBJECT but also marks it handled\n                            token \u003d _headContext.nextTokenToRead();\n                            _exposedContext \u003d _headContext;\n                        }\n                    }\n                    return (_currToken \u003d token);\n                }\n                if (null \u003d\u003d filter) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                filter \u003d filter.includeProperty(identifier);\n                if (null \u003d\u003d filter) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter \u003d filter;\n                if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                    if (_includePath) {\n                        return (_currToken \u003d token);\n                    }\n                }\n                if (_includePath) {\n                    token \u003d _nextTokenWithBuffering(_headContext);\n                    if (null !\u003d token) {\n                        _currToken \u003d token;\n                        return token;\n                    }\n                }\n                break;\n            }\n        default:\n            // scalar value\n            filter \u003d _itemFilter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                return (_currToken \u003d token);\n            }\n            if (null !\u003d filter) {\n                filter \u003d _headContext.checkValue(filter);\n                if ((TokenFilter.INCLUDE_ALL \u003d\u003d filter) || ((null !\u003d filter) \u0026\u0026 filter.includeValue(delegate))) {\n                    return (_currToken \u003d token);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n    }\n    // We get here if token was not yet found; offlined handling\n    return _nextToken2();\n}",
  "JacksonCore-11": "private void _verifySharing() {\n    if (_hashShared) {\n        _hashArea \u003d Arrays.copyOf(_hashArea, _hashArea.length);\n        _names \u003d Arrays.copyOf(_names, _names.length);\n        _hashShared \u003d false;\n        // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n        //    we rehash as needed, as need-rehash flag is not copied from parent\n    }\n    if (_needRehash) {\n        rehash();\n    }\n}",
  "Math-69": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution studentTDistribution \u003d new TDistributionImpl(nObs - 2);\n    int numVariables \u003d correlationMatrix.getColumnDimension();\n    double[][] pValues \u003d new double[numVariables][numVariables];\n    int indexI \u003d 0;\n    while (numVariables \u003e indexI) {\n        int colIndex \u003d 0;\n        while (numVariables \u003e colIndex) {\n            if (colIndex !\u003d indexI) {\n                double correlationCoefficient \u003d correlationMatrix.getEntry(indexI, colIndex);\n                double tStatistic \u003d Math.abs(correlationCoefficient * Math.sqrt((nObs - 2) / (1 - correlationCoefficient * correlationCoefficient)));\n                pValues[indexI][colIndex] \u003d 2 * (1 - studentTDistribution.cumulativeProbability(tStatistic));\n            } else {\n                pValues[indexI][colIndex] \u003d 0d;\n            }\n            colIndex +\u003d 1;\n        }\n        indexI +\u003d 1;\n    }\n    return new BlockRealMatrix(pValues);\n}",
  "Math-61": "public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n    if (0 \u003e\u003d p) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n    }\n    mean \u003d p;\n    normal \u003d new NormalDistributionImpl(p, FastMath.sqrt(p));\n    this.epsilon \u003d epsilon;\n    this.maxIterations \u003d maxIterations;\n}",
  "Math-63": "public static boolean equals(double x, double y) {\n    return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || y \u003d\u003d x;\n}",
  "Math-64": "protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    // arrays shared with the other private methods\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    // local point\n    double stepBound \u003d 0;\n    double scaledXNorm \u003d 0;\n    double[] scale \u003d new double[cols];\n    double[] previousX \u003d new double[cols];\n    double[] previousResiduals \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] auxiliaryWork \u003d new double[cols];\n    double[] workspaceArray \u003d new double[cols];\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n    // outer loop\n    lmPar \u003d 0;\n    boolean isFirstIteration \u003d true;\n    VectorialPointValuePair latest \u003d new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair lastIteration \u003d latest;\n        updateJacobian();\n        qrDecomposition();\n        // compute Qt.res\n        qTy(residuals);\n        // now we don\u0027t need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int index \u003d 0; solvedCols \u003e index; ++index) {\n            int colIndex \u003d permutation[index];\n            jacobian[index][colIndex] \u003d diagR[colIndex];\n        }\n        if (isFirstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            scaledXNorm \u003d 0;\n            int index \u003d 0;\n            while (cols \u003e index) {\n                double scaleFactor \u003d jacNorm[index];\n                if (0 \u003d\u003d scaleFactor) {\n                    scaleFactor \u003d 1.0;\n                }\n                double scaledX \u003d scaleFactor * point[index];\n                scaledXNorm +\u003d scaledX * scaledX;\n                scale[index] \u003d scaleFactor;\n                ++index;\n            }\n            scaledXNorm \u003d Math.sqrt(scaledXNorm);\n            // initialize the step bound delta\n            stepBound \u003d (0 \u003d\u003d scaledXNorm) ? initialStepBoundFactor : (initialStepBoundFactor * scaledXNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosineValue \u003d 0;\n        if (0 !\u003d cost) {\n            int index_j \u003d 0;\n            while (solvedCols \u003e index_j) {\n                int indexInPermutation \u003d permutation[index_j];\n                double s \u003d jacNorm[indexInPermutation];\n                if (0 !\u003d s) {\n                    double total \u003d 0;\n                    int i \u003d 0;\n                    while (index_j \u003e\u003d i) {\n                        total +\u003d jacobian[i][indexInPermutation] * residuals[i];\n                        ++i;\n                    }\n                    maxCosineValue \u003d Math.max(maxCosineValue, Math.abs(total) / (s * cost));\n                }\n                ++index_j;\n            }\n        }\n        if (orthoTolerance \u003e\u003d maxCosineValue) {\n            // convergence has been reached\n            return latest;\n        }\n        // rescale if necessary\n        for (int index_j \u003d 0; cols \u003e index_j; ++index_j) {\n            scale[index_j] \u003d Math.max(scale[index_j], jacNorm[index_j]);\n        }\n        double proportion \u003d 0;\n        while (1.0e-4 \u003e proportion) {\n            // save the state\n            for (int index_j \u003d 0; solvedCols \u003e index_j; ++index_j) {\n                int indexInPermutation \u003d permutation[index_j];\n                previousX[indexInPermutation] \u003d point[indexInPermutation];\n            }\n            double lastCost \u003d cost;\n            double[] tempResiduals \u003d residuals;\n            residuals \u003d previousResiduals;\n            previousResiduals \u003d tempResiduals;\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(previousResiduals, stepBound, scale, work1, auxiliaryWork, workspaceArray);\n            // compute the new point and the norm of the evolution direction\n            double directionNorm \u003d 0;\n            for (int index_j \u003d 0; solvedCols \u003e index_j; ++index_j) {\n                int indexInPermutation \u003d permutation[index_j];\n                lmDir[indexInPermutation] \u003d -lmDir[indexInPermutation];\n                point[indexInPermutation] \u003d previousX[indexInPermutation] + lmDir[indexInPermutation];\n                double s \u003d scale[indexInPermutation] * lmDir[indexInPermutation];\n                directionNorm +\u003d s * s;\n            }\n            directionNorm \u003d Math.sqrt(directionNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (isFirstIteration) {\n                stepBound \u003d Math.min(stepBound, directionNorm);\n            }\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            latest \u003d new VectorialPointValuePair(point, objective);\n            // compute the scaled actual reduction\n            double actualReduction \u003d -1.0;\n            if (lastCost \u003e 0.1 * cost) {\n                double ratioValue \u003d cost / lastCost;\n                actualReduction \u003d 1.0 - ratioValue * ratioValue;\n            }\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int index_j \u003d 0; solvedCols \u003e index_j; ++index_j) {\n                int indexInPermutation \u003d permutation[index_j];\n                double directionalUpdate \u003d lmDir[indexInPermutation];\n                work1[index_j] \u003d 0;\n                int i \u003d 0;\n                while (index_j \u003e\u003d i) {\n                    work1[i] +\u003d jacobian[i][indexInPermutation] * directionalUpdate;\n                    ++i;\n                }\n            }\n            double costCoefficient \u003d 0;\n            for (int index_j \u003d 0; solvedCols \u003e index_j; ++index_j) {\n                costCoefficient +\u003d work1[index_j] * work1[index_j];\n            }\n            double previousCostSquared \u003d lastCost * lastCost;\n            costCoefficient \u003d costCoefficient / previousCostSquared;\n            double coeff2 \u003d lmPar * directionNorm * directionNorm / previousCostSquared;\n            double predictedReduction \u003d costCoefficient + 2 * coeff2;\n            double directionalDerivative \u003d -(costCoefficient + coeff2);\n            // ratio of the actual to the predicted reduction\n            proportion \u003d (0 \u003d\u003d predictedReduction) ? 0 : (actualReduction / predictedReduction);\n            // update the step bound\n            if (0.25 \u003c proportion) {\n                if ((0 \u003d\u003d lmPar) || (0.75 \u003c\u003d proportion)) {\n                    stepBound \u003d 2 * directionNorm;\n                    lmPar *\u003d 0.5;\n                }\n            } else {\n                double tempVector \u003d (0 \u003e actualReduction) ? (0.5 * directionalDerivative / (directionalDerivative + 0.5 * actualReduction)) : 0.5;\n                if ((lastCost \u003c\u003d 0.1 * cost) || (0.1 \u003e tempVector)) {\n                    tempVector \u003d 0.1;\n                }\n                stepBound \u003d tempVector * Math.min(stepBound, 10.0 * directionNorm);\n                lmPar /\u003d tempVector;\n            }\n            // test for successful iteration.\n            if (1.0e-4 \u003e proportion) {\n                // failed iteration, reset the previous values\n                cost \u003d lastCost;\n                int index_j \u003d 0;\n                while (solvedCols \u003e index_j) {\n                    int indexInPermutation \u003d permutation[index_j];\n                    point[indexInPermutation] \u003d previousX[indexInPermutation];\n                    ++index_j;\n                }\n                tempResiduals \u003d residuals;\n                residuals \u003d previousResiduals;\n                previousResiduals \u003d tempResiduals;\n            } else {\n                // successful iteration, update the norm\n                isFirstIteration \u003d false;\n                scaledXNorm \u003d 0;\n                // tests for convergence.\n                // we use the vectorial convergence checker\n                int index \u003d 0;\n                while (cols \u003e index) {\n                    double xK \u003d scale[index] * point[index];\n                    scaledXNorm +\u003d xK * xK;\n                    ++index;\n                }\n                scaledXNorm \u003d Math.sqrt(scaledXNorm);\n            }\n            if (null !\u003d checker) {\n                if (checker.converged(getIterations(), lastIteration, latest)) {\n                    return latest;\n                }\n            } else {\n                if (((costRelativeTolerance \u003e\u003d Math.abs(actualReduction)) \u0026\u0026 (costRelativeTolerance \u003e\u003d predictedReduction) \u0026\u0026 (2.0 \u003e\u003d proportion)) || (parRelativeTolerance * scaledXNorm \u003e\u003d stepBound)) {\n                    return latest;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if (!((2.2204e-16 \u003e\u003d Math.abs(actualReduction))) || !((2.2204e-16 \u003e\u003d predictedReduction)) || !((2.0 \u003e\u003d proportion))) {\n                if (2.2204e-16 * scaledXNorm \u003c stepBound) {\n                    if (2.2204e-16 \u003e\u003d maxCosineValue) {\n                        throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n                    }\n                } else {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n                }\n            } else {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            }\n        }\n    }\n}",
  "Lang-57": "public static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}",
  "Lang-59": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (0 \u003c width) {\n        ensureCapacity(size + width);\n        String text \u003d (null \u003d\u003d obj ? getNullText() : obj.toString());\n        int stringLength \u003d text.length();\n        if (width \u003e stringLength) {\n            int paddingLength \u003d width - stringLength;\n            text.getChars(0, stringLength, buffer, size);\n            int padIndex \u003d 0;\n            while (paddingLength \u003e padIndex) {\n                buffer[size + stringLength + padIndex] \u003d padChar;\n                padIndex +\u003d 1;\n            }\n        } else {\n            text.getChars(0, stringLength, buffer, size);\n        }\n        size +\u003d width;\n    }\n    return this;\n}",
  "Lang-58": "public static Number createNumber(String str) throws NumberFormatException {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char finalChar \u003d str.charAt(str.length() - 1);\n    String coefficient;\n    String fractionalPart;\n    String exponent;\n    int decimalPosition \u003d str.indexOf(\u0027.\u0027);\n    int exponentPosition \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (-1 \u003e\u003d decimalPosition) {\n        if (-1 \u003e\u003d exponentPosition) {\n            coefficient \u003d str;\n        } else {\n            coefficient \u003d str.substring(0, exponentPosition);\n        }\n        fractionalPart \u003d null;\n    } else {\n        if (-1 \u003e\u003d exponentPosition) {\n            fractionalPart \u003d str.substring(decimalPosition + 1);\n        } else {\n            if (decimalPosition \u003e exponentPosition) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            fractionalPart \u003d str.substring(decimalPosition + 1, exponentPosition);\n        }\n        coefficient \u003d str.substring(0, decimalPosition);\n    }\n    if (Character.isDigit(finalChar)) {\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length());\n        }\n        if (null !\u003d fractionalPart || null !\u003d exponent) {\n            //Must be a float,double,BigDec\n            boolean isAllZeroes \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (0.0F \u003d\u003d f.floatValue() \u0026\u0026 !isAllZeroes))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double dbl \u003d createDouble(str);\n                if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.doubleValue() \u0026\u0026 !isAllZeroes))) {\n                    return dbl;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigDecimal(str);\n        } else {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n    } else {\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length() - 1);\n        }\n        //Requesting a specific type..\n        String value \u003d str.substring(0, str.length() - 1);\n        boolean isAllZeroes \u003d isAllZeros(coefficient) \u0026\u0026 isAllZeros(exponent);\n        switch(finalChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (null \u003d\u003d fractionalPart \u0026\u0026 null \u003d\u003d exponent \u0026\u0026 isDigits(value.substring(1)) \u0026\u0026 (\u0027-\u0027 \u003d\u003d value.charAt(0) || Character.isDigit(value.charAt(0)))) {\n                    try {\n                        return createLong(value);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(value);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(value);\n                    if (!(f.isInfinite() || (0.0F \u003d\u003d f.floatValue() \u0026\u0026 !isAllZeroes))) {\n                        //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n            //Fall through\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double dbl \u003d NumberUtils.createDouble(value);\n                    if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.floatValue() \u0026\u0026 !isAllZeroes))) {\n                        return dbl;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(value);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n            //Fall through\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n}",
  "JxPath-18": "public boolean nextNode() {\n    super.setPosition(getCurrentPosition() + 1);\n    if (!setStarted) {\n        setStarted \u003d true;\n        if (!(nodeTest instanceof NodeNameTest)) {\n            return false;\n        }\n        QName nodeQName \u003d ((NodeNameTest) nodeTest).getNodeName();\n        iterator \u003d parentContext.getCurrentNodePointer().attributeIterator(nodeQName);\n    }\n    if (null \u003d\u003d iterator) {\n        return false;\n    }\n    if (!iterator.setPosition(iterator.getPosition() + 1)) {\n        return false;\n    }\n    currentNodePointer \u003d iterator.getNodePointer();\n    return true;\n}",
  "Math-80": "private boolean flipIfWarranted(final int n, final int step) {\n    if (work[4 * (n - 1) + pingPong] \u003e 1.5 * work[pingPong]) {\n        // flip array\n        int index \u003d 4 * n - 1;\n        int i \u003d 0;\n        while (index \u003e i) {\n            int k \u003d 0;\n            while (4 \u003e k) {\n                final double tempValue \u003d work[i + k];\n                work[i + k] \u003d work[index - k];\n                work[index - k] \u003d tempValue;\n                k +\u003d step;\n            }\n            index -\u003d 4;\n            i +\u003d 4;\n        }\n        return true;\n    }\n    return false;\n}",
  "Math-82": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double leastRatio \u003d Double.MAX_VALUE;\n    Integer minRatioIndex \u003d null;\n    int rowIndex \u003d tableau.getNumObjectiveFunctions();\n    while (tableau.getHeight() \u003e rowIndex) {\n        final double rightHandSide \u003d tableau.getEntry(rowIndex, tableau.getWidth() - 1);\n        final double value \u003d tableau.getEntry(rowIndex, col);\n        if (0 \u003c\u003d MathUtils.compareTo(value, 0, epsilon)) {\n            final double quotient \u003d rightHandSide / value;\n            if (leastRatio \u003e quotient) {\n                leastRatio \u003d quotient;\n                minRatioIndex \u003d rowIndex;\n            }\n        }\n        rowIndex +\u003d 1;\n    }\n    return minRatioIndex;\n}",
  "JacksonCore-26": "public void feedInput(byte[] buf, int start, int end) throws IOException {\n    // Must not have remaining input\n    if (_inputEnd \u003e _inputPtr) {\n        _reportError(\"Still have %d undecoded bytes, should not call \u0027feedInput\u0027\", _inputEnd - _inputPtr);\n    }\n    if (start \u003e end) {\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n    }\n    // and shouldn\u0027t have been marked as end-of-input\n    if (_endOfInput) {\n        _reportError(\"Already closed, can not feed more input\");\n    }\n    // Time to update pointers first\n    _currInputProcessed +\u003d _origBufferLen;\n    // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n    _currInputRowStart \u003d start - (_inputEnd - _currInputRowStart);\n    // And then update buffer settings\n    _inputBuffer \u003d buf;\n    _inputPtr \u003d start;\n    _inputEnd \u003d end;\n    _origBufferLen \u003d end - start;\n}",
  "JacksonCore-25": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException {\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outputBuffer \u003d _textBuffer.getCurrentSegment();\n    int outputPointer \u003d _textBuffer.getCurrentSegmentSize();\n    final int maxLength \u003d codes.length;\n    while (true) {\n        if (_inputEnd \u003c\u003d _inputPtr) {\n            if (!_loadMore()) {\n                // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char character \u003d _inputBuffer[_inputPtr];\n        int charCode \u003d (int) character;\n        if (maxLength \u003c charCode) {\n            if (!Character.isJavaIdentifierPart(character)) {\n                break;\n            }\n        } else {\n            if (0 !\u003d codes[charCode]) {\n                break;\n            }\n        }\n        ++_inputPtr;\n        hash \u003d (hash * CharsToNameCanonicalizer.HASH_MULT) + charCode;\n        // Ok, let\u0027s add char to output:\n        outputBuffer[outputPointer++] \u003d character;\n        // Need more room?\n        if (outputBuffer.length \u003c\u003d outputPointer) {\n            outputBuffer \u003d _textBuffer.finishCurrentSegment();\n            outputPointer \u003d 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outputPointer);\n    {\n        TextBuffer textBuffer \u003d _textBuffer;\n        char[] buffer \u003d textBuffer.getTextBuffer();\n        int beginIndex \u003d textBuffer.getTextOffset();\n        int length \u003d textBuffer.size();\n        return _symbols.findSymbol(buffer, beginIndex, length, hash);\n    }\n}",
  "JacksonCore-23": "public DefaultPrettyPrinter createInstance() {\n    return new DefaultPrettyPrinter(this);\n}",
  "JacksonCore-21": "public JsonToken nextToken() throws IOException {\n    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don\u0027t like all\n    //    conditionals; and it seems odd to return `null` but NOT considering input\n    //    as closed... would love a rewrite to simplify/clear up logic here.\n    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n    // check for no buffered context _exposedContext - null\n    // If all the conditions matches then check for scalar / non-scalar property\n    if (!_allowMultipleMatches \u0026\u0026 (null !\u003d _currToken) \u0026\u0026 (null \u003d\u003d _exposedContext)) {\n        //if not scalar and ended successfully, and !includePath, then return null\n        if (!_currToken.isStructEnd()) {\n            if (_currToken.isScalarValue()) {\n                //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                // then return null\n                if (!_headContext.isStartHandled() \u0026\u0026 (TokenFilter.INCLUDE_ALL \u003d\u003d _itemFilter)) {\n                    return (_currToken \u003d null);\n                }\n            }\n        } else {\n            if (_headContext.isStartHandled()) {\n                return (_currToken \u003d null);\n            }\n        }\n    }\n    // Anything buffered?\n    TokenFilterContext context \u003d _exposedContext;\n    if (null !\u003d context) {\n        while (true) {\n            JsonToken token \u003d context.nextTokenToRead();\n            if (null !\u003d token) {\n                _currToken \u003d token;\n                return token;\n            }\n            // all done with buffered stuff?\n            if (_headContext \u003d\u003d context) {\n                _exposedContext \u003d null;\n                if (context.inArray()) {\n                    token \u003d delegate.getCurrentToken();\n                    // Is this guaranteed to work without further checks?\n                    //                        if (t !\u003d JsonToken.START_ARRAY) {\n                    _currToken \u003d token;\n                    return token;\n                }\n                // Almost! Most likely still have the current token;\n                // with the sole exception of\n                /*\n                    t \u003d delegate.getCurrentToken();\n                    if (t !\u003d JsonToken.FIELD_NAME) {\n                        _currToken \u003d t;\n                        return t;\n                    }\n                    */\n                break;\n            }\n            // If not, traverse down the context chain\n            context \u003d _headContext.findChildOf(context);\n            _exposedContext \u003d context;\n            if (null \u003d\u003d context) {\n                // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n        }\n    }\n    // If not, need to read more. If we got any:\n    JsonToken token \u003d delegate.nextToken();\n    if (null \u003d\u003d token) {\n        // no strict need to close, since we have no state here\n        _currToken \u003d token;\n        return token;\n    }\n    // otherwise... to include or not?\n    TokenFilter filter;\n    switch(token.id()) {\n        case ID_START_ARRAY:\n            filter \u003d _itemFilter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildArrayContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            if (null \u003d\u003d filter) {\n                // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            filter \u003d _headContext.checkValue(filter);\n            if (null \u003d\u003d filter) {\n                delegate.skipChildren();\n                break;\n            }\n            if (TokenFilter.INCLUDE_ALL !\u003d filter) {\n                filter \u003d filter.filterStartArray();\n            }\n            _itemFilter \u003d filter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildArrayContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            _headContext \u003d _headContext.createChildArrayContext(filter, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                token \u003d _nextTokenWithBuffering(_headContext);\n                if (null !\u003d token) {\n                    _currToken \u003d token;\n                    return token;\n                }\n            }\n            break;\n        case ID_START_OBJECT:\n            filter \u003d _itemFilter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildObjectContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            if (null \u003d\u003d filter) {\n                // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            filter \u003d _headContext.checkValue(filter);\n            if (null \u003d\u003d filter) {\n                delegate.skipChildren();\n                break;\n            }\n            if (TokenFilter.INCLUDE_ALL !\u003d filter) {\n                filter \u003d filter.filterStartObject();\n            }\n            _itemFilter \u003d filter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                _headContext \u003d _headContext.createChildObjectContext(filter, true);\n                return (_currToken \u003d token);\n            }\n            _headContext \u003d _headContext.createChildObjectContext(filter, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                token \u003d _nextTokenWithBuffering(_headContext);\n                if (null !\u003d token) {\n                    _currToken \u003d token;\n                    return token;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean isEndHandled \u003d _headContext.isStartHandled();\n                filter \u003d _headContext.getFilter();\n                if ((null !\u003d filter) \u0026\u0026 (TokenFilter.INCLUDE_ALL !\u003d filter)) {\n                    filter.filterFinishArray();\n                }\n                _headContext \u003d _headContext.getParent();\n                _itemFilter \u003d _headContext.getFilter();\n                if (isEndHandled) {\n                    return (_currToken \u003d token);\n                }\n            }\n            break;\n        case ID_FIELD_NAME:\n            {\n                final String fieldName \u003d delegate.getCurrentName();\n                // note: this will also set \u0027needToHandleName\u0027\n                filter \u003d _headContext.setFieldName(fieldName);\n                if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                    _itemFilter \u003d filter;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent \u0026\u0026 !_headContext.isStartHandled()) {\n                            // returns START_OBJECT but also marks it handled\n                            token \u003d _headContext.nextTokenToRead();\n                            _exposedContext \u003d _headContext;\n                        }\n                    }\n                    return (_currToken \u003d token);\n                }\n                if (null \u003d\u003d filter) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                filter \u003d filter.includeProperty(fieldName);\n                if (null \u003d\u003d filter) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter \u003d filter;\n                if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                    if (_includePath) {\n                        return (_currToken \u003d token);\n                    }\n                }\n                if (_includePath) {\n                    token \u003d _nextTokenWithBuffering(_headContext);\n                    if (null !\u003d token) {\n                        _currToken \u003d token;\n                        return token;\n                    }\n                }\n                break;\n            }\n        default:\n            // scalar value\n            filter \u003d _itemFilter;\n            if (TokenFilter.INCLUDE_ALL \u003d\u003d filter) {\n                return (_currToken \u003d token);\n            }\n            if (null !\u003d filter) {\n                filter \u003d _headContext.checkValue(filter);\n                if ((TokenFilter.INCLUDE_ALL \u003d\u003d filter) || ((null !\u003d filter) \u0026\u0026 filter.includeValue(delegate))) {\n                    return (_currToken \u003d token);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n    }\n    // We get here if token was not yet found; offlined handling\n    return _nextToken2();\n}",
  "JacksonCore-20": "public void writeEmbeddedObject(Object object) throws IOException {\n    // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n    throw new JsonGenerationException(\"No native support for writing embedded objects\", this);\n}",
  "Math-72": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double yStart \u003d f.value(initial);\n    if (functionValueAccuracy \u003e\u003d Math.abs(yStart)) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yLowerBound \u003d f.value(min);\n    if (functionValueAccuracy \u003e\u003d Math.abs(yLowerBound)) {\n        setResult(yLowerBound, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (0 \u003e yStart * yLowerBound) {\n        return solve(f, min, yLowerBound, initial, yStart, min, yLowerBound);\n    }\n    // return the second endpoint if it is good enough\n    double yUpper \u003d f.value(max);\n    if (functionValueAccuracy \u003e\u003d Math.abs(yUpper)) {\n        setResult(yUpper, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (0 \u003e yStart * yUpper) {\n        return solve(f, initial, yStart, max, yUpper, initial, yStart);\n    }\n    if (0 \u003c yLowerBound * yUpper) {\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yLowerBound, yUpper);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yLowerBound, max, yUpper, initial, yStart);\n}",
  "JxPath-20": "private boolean compute(Object left, Object right) {\n    left \u003d reduce(left);\n    right \u003d reduce(right);\n    if (left instanceof InitialContext) {\n        ((InitialContext) left).reset();\n    }\n    if (right instanceof InitialContext) {\n        ((InitialContext) right).reset();\n    }\n    if (left instanceof Iterator \u0026\u0026 right instanceof Iterator) {\n        return findMatch((Iterator) left, (Iterator) right);\n    }\n    if (left instanceof Iterator) {\n        return containsMatch((Iterator) left, right);\n    }\n    if (right instanceof Iterator) {\n        return containsMatch((Iterator) right, left);\n    }\n    double leftDoubleValue \u003d InfoSetUtil.doubleValue(left);\n    if (Double.isNaN(leftDoubleValue)) {\n        return false;\n    }\n    double rightValue \u003d InfoSetUtil.doubleValue(right);\n    if (Double.isNaN(rightValue)) {\n        return false;\n    }\n    return evaluateCompare(rightValue \u003d\u003d leftDoubleValue ? 0 : rightValue \u003e leftDoubleValue ? -1 : 1);\n}",
  "JxPath-21": "public int getLength() {\n    return ValueUtils.getLength(getBaseValue());\n}",
  "Math-73": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double initialFunctionValue \u003d f.value(initial);\n    if (functionValueAccuracy \u003e\u003d Math.abs(initialFunctionValue)) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yLower \u003d f.value(min);\n    if (functionValueAccuracy \u003e\u003d Math.abs(yLower)) {\n        setResult(yLower, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (0 \u003e initialFunctionValue * yLower) {\n        return solve(f, min, yLower, initial, initialFunctionValue, min, yLower);\n    }\n    // return the second endpoint if it is good enough\n    double yUpper \u003d f.value(max);\n    if (functionValueAccuracy \u003e\u003d Math.abs(yUpper)) {\n        setResult(yUpper, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (0 \u003e initialFunctionValue * yUpper) {\n        return solve(f, initial, initialFunctionValue, max, yUpper, initial, initialFunctionValue);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yLower, max, yUpper, initial, initialFunctionValue);\n}",
  "JxPath-22": "public static String getNamespaceURI(Node node) {\n    if (node instanceof Document) {\n        node \u003d ((Document) node).getDocumentElement();\n    }\n    Element el \u003d (Element) node;\n    String namespaceUri \u003d el.getNamespaceURI();\n    if (null \u003d\u003d namespaceUri) {\n        String namespacePrefix \u003d getPrefix(node);\n        String qualifiedName \u003d null \u003d\u003d namespacePrefix ? \"xmlns\" : \"xmlns:\" + namespacePrefix;\n        Node parentNode \u003d node;\n        while (null !\u003d parentNode) {\n            if (Node.ELEMENT_NODE \u003d\u003d parentNode.getNodeType()) {\n                Attr attributeNode \u003d ((Element) parentNode).getAttributeNode(qualifiedName);\n                if (null !\u003d attributeNode) {\n                    return attributeNode.getValue();\n                }\n            }\n            parentNode \u003d parentNode.getParentNode();\n        }\n        return null;\n    }\n    return namespaceUri;\n}",
  "Math-74": "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean isForward \u003d t0 \u003c t;\n    // create some internal working arrays\n    final int steps \u003d c.length + 1;\n    if (y0 !\u003d y) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] stateDerivatives \u003d new double[steps][y0.length];\n    final double[] intermediateState \u003d new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator stepInterpolator;\n    if (!requiresDenseOutput() \u0026\u0026 !((!eventsHandlersManager.isEmpty()))) {\n        stepInterpolator \u003d new DummyStepInterpolator(intermediateState, isForward);\n    } else {\n        final RungeKuttaStepInterpolator rkInterpolator \u003d (RungeKuttaStepInterpolator) prototype.copy();\n        rkInterpolator.reinitialize(this, intermediateState, stateDerivatives, isForward);\n        stepInterpolator \u003d rkInterpolator;\n    }\n    stepInterpolator.storeTime(t0);\n    // set up integration control objects\n    stepStart \u003d t0;\n    double hNext \u003d 0;\n    boolean isFirstIteration \u003d true;\n    for (StepHandler stepObserver : stepHandlers) {\n        stepObserver.reset();\n    }\n    CombinedEventsManager eventsHandlerController \u003d addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep \u003d false;\n    // main integration loop\n    while (!lastStep) {\n        stepInterpolator.shift();\n        double deviation \u003d 0;\n        boolean iteration \u003d true;\n        while (iteration) {\n            if (isFirstIteration || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, stateDerivatives[0]);\n            }\n            if (isFirstIteration) {\n                final double[] magnitude;\n                if (null !\u003d vecAbsoluteTolerance) {\n                    magnitude \u003d vecAbsoluteTolerance;\n                } else {\n                    magnitude \u003d new double[y0.length];\n                    java.util.Arrays.fill(magnitude, scalAbsoluteTolerance);\n                }\n                hNext \u003d initializeStep(equations, isForward, getOrder(), magnitude, stepStart, y, stateDerivatives[0], intermediateState, stateDerivatives[1]);\n                isFirstIteration \u003d false;\n            }\n            stepSize \u003d hNext;\n            int stageIndex \u003d 1;\n            while (steps \u003e stageIndex) {\n                int index \u003d 0;\n                while (y0.length \u003e index) {\n                    double total \u003d a[stageIndex - 1][0] * stateDerivatives[0][index];\n                    int l \u003d 1;\n                    while (stageIndex \u003e l) {\n                        total +\u003d a[stageIndex - 1][l] * stateDerivatives[l][index];\n                        ++l;\n                    }\n                    intermediateState[index] \u003d y[index] + stepSize * total;\n                    ++index;\n                }\n                computeDerivatives(stepStart + c[stageIndex - 1] * stepSize, intermediateState, stateDerivatives[stageIndex]);\n                ++stageIndex;\n            }\n            // estimate the state at the end of the step\n            for (int index \u003d 0; y0.length \u003e index; ++index) {\n                double total \u003d b[0] * stateDerivatives[0][index];\n                int l \u003d 1;\n                while (steps \u003e l) {\n                    total +\u003d b[l] * stateDerivatives[l][index];\n                    ++l;\n                }\n                intermediateState[index] \u003d y[index] + stepSize * total;\n            }\n            // estimate the error at the end of the step\n            deviation \u003d estimateError(stateDerivatives, y, intermediateState, stepSize);\n            if (1.0 \u003c deviation) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double scaling_factor \u003d Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(deviation, exp)));\n                hNext \u003d filterStep(stepSize * scaling_factor, isForward, false);\n            } else {\n                // discrete events handling\n                stepInterpolator.storeTime(stepStart + stepSize);\n                if (!eventsHandlerController.evaluateStep(stepInterpolator)) {\n                    // accept the step\n                    iteration \u003d false;\n                } else {\n                    final double duration \u003d eventsHandlerController.getEventTime() - stepStart;\n                    if (Math.ulp(stepStart) \u003c Math.abs(duration)) {\n                        // reject the step to match exactly the next switch time\n                        hNext \u003d duration;\n                    } else {\n                        // rejecting the step would lead to a too small next step, we accept it\n                        iteration \u003d false;\n                    }\n                }\n            }\n        }\n        // the step has been accepted\n        final double subsequentStep \u003d stepStart + stepSize;\n        System.arraycopy(intermediateState, 0, y, 0, y0.length);\n        eventsHandlerController.stepAccepted(subsequentStep, y);\n        lastStep \u003d eventsHandlerController.stop();\n        // provide the step data to the step handler\n        stepInterpolator.storeTime(subsequentStep);\n        for (StepHandler stepObserver : stepHandlers) {\n            stepObserver.handleStep(stepInterpolator, lastStep);\n        }\n        stepStart \u003d subsequentStep;\n        if (fsal) {\n            // save the last evaluation for the next step\n            System.arraycopy(stateDerivatives[steps - 1], 0, stateDerivatives[0], 0, y0.length);\n        }\n        if (eventsHandlerController.reset(stepStart, y) \u0026\u0026 !lastStep) {\n            // some event handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            computeDerivatives(stepStart, y, stateDerivatives[0]);\n        }\n        if (!lastStep) {\n            // in some rare cases we may get here with stepSize \u003d 0, for example\n            // when an event occurs at integration start, reducing the first step\n            // to zero; we have to reset the step to some safe non zero value\n            stepSize \u003d filterStep(stepSize, isForward, true);\n            // stepsize control for next step\n            final double scaling_factor \u003d Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(deviation, exp)));\n            final double adjustedStepSize \u003d stepSize * scaling_factor;\n            final double nextTime \u003d stepStart + adjustedStepSize;\n            final boolean isFinalStep \u003d isForward ? (t \u003c\u003d nextTime) : (t \u003e\u003d nextTime);\n            hNext \u003d filterStep(adjustedStepSize, isForward, isFinalStep);\n        }\n    }\n    final double stopTime \u003d stepStart;\n    resetInternalState();\n    return stopTime;\n}",
  "Math-75": "public double getPct(Object v) {\n    return getCumPct((Comparable\u003c?\u003e) v);\n}",
  "Math-78": "public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\n    try {\n        forward \u003d interpolator.isForward();\n        final double currentTime \u003d interpolator.getCurrentTime();\n        final int stepCount \u003d Math.max(1, (int) Math.ceil(Math.abs(currentTime - t0) / maxCheckInterval));\n        final double stepSize \u003d (currentTime - t0) / stepCount;\n        double stepStartTime \u003d t0;\n        double newGValue \u003d g0;\n        double tbEnd \u003d t0 + (interpolator.isForward() ? convergence : -convergence);\n        int index \u003d 0;\n        while (stepCount \u003e index) {\n            // evaluate handler value at the end of the substep\n            tbEnd +\u003d stepSize;\n            interpolator.setInterpolatedTime(tbEnd);\n            final double gb \u003d handler.g(tbEnd, interpolator.getInterpolatedState());\n            // check events occurrence\n            if (!(g0Positive ^ (0 \u003c\u003d gb))) {\n                // no sign change: there is no event for now\n                stepStartTime \u003d tbEnd;\n                newGValue \u003d gb;\n            } else {\n                // there is a sign change: an event is expected during this step\n                // this is a corner case:\n                // - there was an event near ta,\n                // - there is another event between ta and tb\n                // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                // this implies that the real sign of ga is the same as gb, so we need to slightly\n                // shift ta to make sure ga and gb get opposite signs and the solver won\u0027t complain\n                // about bracketing\n                // this should never happen\n                // variation direction, with respect to the integration direction\n                increasing \u003d newGValue \u003c\u003d gb;\n                final UnivariateRealFunction function \u003d new UnivariateRealFunction() {\n\n                    public double value(final double t) throws FunctionEvaluationException {\n                        try {\n                            interpolator.setInterpolatedTime(t);\n                            return handler.g(t, interpolator.getInterpolatedState());\n                        } catch (DerivativeException e) {\n                            throw new FunctionEvaluationException(e, t);\n                        } catch (EventException e) {\n                            throw new FunctionEvaluationException(e, t);\n                        }\n                    }\n                };\n                final BrentSolver rootFinder \u003d new BrentSolver();\n                rootFinder.setAbsoluteAccuracy(convergence);\n                rootFinder.setMaximalIterationCount(maxIterationCount);\n                final double solution \u003d (tbEnd \u003e\u003d stepStartTime) ? rootFinder.solve(function, stepStartTime, tbEnd) : rootFinder.solve(function, tbEnd, stepStartTime);\n                if (!((convergence \u003e\u003d Math.abs(solution - stepStartTime))) || !((convergence \u003e\u003d Math.abs(solution - previousEventTime)))) {\n                    if (Double.isNaN(previousEventTime) || (convergence \u003c Math.abs(previousEventTime - solution))) {\n                        pendingEventTime \u003d solution;\n                        if (pendingEvent \u0026\u0026 (convergence \u003e\u003d Math.abs(currentTime - pendingEventTime))) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent \u003d true;\n                        return true;\n                    }\n                } else {\n                    // we have either found nothing or found (again ?) a past event, we simply ignore it\n                    stepStartTime \u003d tbEnd;\n                    newGValue \u003d gb;\n                }\n            }\n            ++index;\n        }\n        // no event during the whole step\n        pendingEvent \u003d false;\n        pendingEventTime \u003d Double.NaN;\n        return false;\n    } catch (FunctionEvaluationException e) {\n        final Throwable rootCause \u003d e.getCause();\n        if (!((null !\u003d rootCause)) || !((rootCause instanceof DerivativeException))) {\n            if ((null !\u003d rootCause) \u0026\u0026 (rootCause instanceof EventException)) {\n                throw (EventException) rootCause;\n            }\n        } else {\n            throw (DerivativeException) rootCause;\n        }\n        throw new EventException(e);\n    }\n}",
  "Math-79": "public static double distance(int[] p1, int[] p2) {\n    int total \u003d 0;\n    int index \u003d 0;\n    while (p1.length \u003e index) {\n        final int difference \u003d p1[index] - p2[index];\n        total +\u003d difference * difference;\n        index +\u003d 1;\n    }\n    return Math.sqrt(total);\n}",
  "Lang-9": "private void init() {\n    thisYear \u003d Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n    nameValues \u003d new ConcurrentHashMap\u003cInteger, KeyValue[]\u003e();\n    StringBuilder patternBuilder \u003d new StringBuilder();\n    List\u003cStrategy\u003e strategiesList \u003d new ArrayList\u003cStrategy\u003e();\n    Matcher patternMatcherInstance \u003d formatPattern.matcher(pattern);\n    if (!patternMatcherInstance.lookingAt()) {\n        throw new IllegalArgumentException(\"Invalid pattern\");\n    }\n    currentFormatField \u003d patternMatcherInstance.group();\n    Strategy activeStrategy \u003d getStrategy(currentFormatField);\n    while (true) {\n        patternMatcherInstance.region(patternMatcherInstance.end(), patternMatcherInstance.regionEnd());\n        if (!patternMatcherInstance.lookingAt()) {\n            nextStrategy \u003d null;\n            break;\n        }\n        String subsequentFormatField \u003d patternMatcherInstance.group();\n        nextStrategy \u003d getStrategy(subsequentFormatField);\n        if (activeStrategy.addRegex(this, patternBuilder)) {\n            strategiesList.add(activeStrategy);\n        }\n        currentFormatField \u003d subsequentFormatField;\n        activeStrategy \u003d nextStrategy;\n    }\n    if (activeStrategy.addRegex(this, patternBuilder)) {\n        strategiesList.add(activeStrategy);\n    }\n    currentFormatField \u003d null;\n    strategies \u003d strategiesList.toArray(new Strategy[strategiesList.size()]);\n    parsePattern \u003d Pattern.compile(patternBuilder.toString());\n}",
  "Lang-1": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hexIdentifiers \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int prefixLength \u003d 0;\n    for (final String pfx : hexIdentifiers) {\n        if (str.startsWith(pfx)) {\n            prefixLength +\u003d pfx.length();\n            break;\n        }\n    }\n    if (0 \u003c prefixLength) {\n        // we have a hex number\n        final int hexLength \u003d str.length() - prefixLength;\n        if (16 \u003c hexLength) {\n            // too many for Long\n            return createBigInteger(str);\n        }\n        if (8 \u003c hexLength) {\n            // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mantissa;\n    String fractionalPart;\n    String exponent;\n    final int decimalPosition \u003d str.indexOf(\u0027.\u0027);\n    // assumes both not present\n    final int expIndex \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n    // Check required precision (LANG-693)\n    int decimalCount \u003d 0;\n    if (-1 \u003e\u003d decimalPosition) {\n        if (-1 \u003e\u003d expIndex) {\n            mantissa \u003d str;\n        } else {\n            if (str.length() \u003c expIndex) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mantissa \u003d str.substring(0, expIndex);\n        }\n        fractionalPart \u003d null;\n    } else {\n        // there is a decimal point\n        if (-1 \u003e\u003d expIndex) {\n            fractionalPart \u003d str.substring(decimalPosition + 1);\n        } else {\n            // there is an exponent\n            if (decimalPosition \u003e expIndex || str.length() \u003c expIndex) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            fractionalPart \u003d str.substring(decimalPosition + 1, expIndex);\n        }\n        mantissa \u003d str.substring(0, decimalPosition);\n        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        decimalCount \u003d fractionalPart.length();\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 \u0027.\u0027 !\u003d lastChar) {\n        if (-1 \u003e\u003d expIndex || str.length() - 1 \u003c\u003d expIndex) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(expIndex + 1, str.length() - 1);\n        }\n        //Requesting a specific type..\n        final String numericString \u003d str.substring(0, str.length() - 1);\n        final boolean isAllZeroes \u003d isAllZeros(mantissa) \u0026\u0026 isAllZeros(exponent);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (null \u003d\u003d fractionalPart \u0026\u0026 null \u003d\u003d exponent \u0026\u0026 (\u0027-\u0027 \u003d\u003d numericString.charAt(0) \u0026\u0026 isDigits(numericString.substring(1)) || isDigits(numericString))) {\n                    try {\n                        return createLong(numericString);\n                    } catch (final NumberFormatException nfe) {\n                        // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numericString);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float floatValue \u003d NumberUtils.createFloat(numericString);\n                    if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isAllZeroes))) {\n                        //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return floatValue;\n                    }\n                } catch (final NumberFormatException nfe) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double dbl \u003d NumberUtils.createDouble(numericString);\n                    if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.floatValue() \u0026\u0026 !isAllZeroes))) {\n                        return dbl;\n                    }\n                } catch (final NumberFormatException nfe) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numericString);\n                } catch (final NumberFormatException e) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    //User doesn\u0027t have a preference on the return type, so let\u0027s start\n    //small and go from there...\n    if (-1 \u003e\u003d expIndex || str.length() - 1 \u003c\u003d expIndex) {\n        exponent \u003d null;\n    } else {\n        exponent \u003d str.substring(expIndex + 1, str.length());\n    }\n    if (null \u003d\u003d fractionalPart \u0026\u0026 null \u003d\u003d exponent) {\n        // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n    //Must be a Float, Double, BigDecimal\n    final boolean isAllZeroes \u003d isAllZeros(mantissa) \u0026\u0026 isAllZeros(exponent);\n    try {\n        if (7 \u003e\u003d decimalCount) {\n            // If number has 7 or fewer digits past the decimal point then make it a float\n            final Float floatValue \u003d createFloat(str);\n            if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isAllZeroes))) {\n                return floatValue;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n    }\n    try {\n        if (16 \u003e\u003d decimalCount) {\n            // If number has between 8 and 16 digits past the decimal point then make it a double\n            final Double dbl \u003d createDouble(str);\n            if (!(dbl.isInfinite() || (0.0D \u003d\u003d dbl.doubleValue() \u0026\u0026 !isAllZeroes))) {\n                return dbl;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n    }\n    return createBigDecimal(str);\n}",
  "Lang-5": "public static Locale toLocale(final String str) {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    final int length \u003d str.length();\n    if (2 \u003e length) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char firstChar \u003d str.charAt(0);\n    final char ch2 \u003d str.charAt(1);\n    if (!Character.isLowerCase(firstChar) || !Character.isLowerCase(ch2)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (2 \u003d\u003d length) {\n        return new Locale(str);\n    }\n    if (5 \u003e length) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (\u0027_\u0027 !\u003d str.charAt(2)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char chCountry \u003d str.charAt(3);\n    if (\u0027_\u0027 \u003d\u003d chCountry) {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4UpperCase \u003d str.charAt(4);\n    if (!Character.isUpperCase(chCountry) || !Character.isUpperCase(ch4UpperCase)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (5 \u003d\u003d length) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (7 \u003e length) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (\u0027_\u0027 !\u003d str.charAt(5)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
  "Lang-6": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (null \u003d\u003d out) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (null \u003d\u003d input) {\n        return;\n    }\n    int index \u003d 0;\n    int length \u003d input.length();\n    while (length \u003e index) {\n        int processed \u003d translate(input, index, out);\n        if (0 \u003d\u003d processed) {\n            char[] charArray \u003d Character.toChars(Character.codePointAt(input, index));\n            out.write(charArray);\n            index +\u003d charArray.length;\n            continue;\n        }\n        // contract with translators is that they have to understand codepoints\n        int codePointIndex \u003d 0;\n        while (processed \u003e codePointIndex) {\n            index +\u003d Character.charCount(Character.codePointAt(input, index));\n            codePointIndex +\u003d 1;\n        }\n    }\n}",
  "Lang-3": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (null \u003d\u003d str) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_identifiers \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int prefixLength \u003d 0;\n    for (final String pfx : hex_identifiers) {\n        if (str.startsWith(pfx)) {\n            prefixLength +\u003d pfx.length();\n            break;\n        }\n    }\n    if (0 \u003c prefixLength) {\n        // we have a hex number\n        final int hexLength \u003d str.length() - prefixLength;\n        if (16 \u003c hexLength) {\n            // too many for Long\n            return createBigInteger(str);\n        }\n        if (8 \u003c hexLength) {\n            // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String magnitude;\n    String fractionalPart;\n    String exponent;\n    final int decimalPosition \u003d str.indexOf(\u0027.\u0027);\n    // assumes both not present\n    final int exponentPosition \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n    // Check required precision (LANG-693)\n    int decimalCount \u003d 0;\n    if (-1 \u003e\u003d decimalPosition) {\n        if (-1 \u003e\u003d exponentPosition) {\n            magnitude \u003d str;\n        } else {\n            if (str.length() \u003c exponentPosition) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            magnitude \u003d str.substring(0, exponentPosition);\n        }\n        fractionalPart \u003d null;\n    } else {\n        // there is a decimal point\n        if (-1 \u003e\u003d exponentPosition) {\n            fractionalPart \u003d str.substring(decimalPosition + 1);\n        } else {\n            // there is an exponent\n            if (decimalPosition \u003e exponentPosition || str.length() \u003c exponentPosition) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            fractionalPart \u003d str.substring(decimalPosition + 1, exponentPosition);\n        }\n        magnitude \u003d str.substring(0, decimalPosition);\n        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        decimalCount \u003d fractionalPart.length();\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 \u0027.\u0027 !\u003d lastChar) {\n        if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n            exponent \u003d null;\n        } else {\n            exponent \u003d str.substring(exponentPosition + 1, str.length() - 1);\n        }\n        //Requesting a specific type..\n        final String decimalValue \u003d str.substring(0, str.length() - 1);\n        final boolean isAllZeroes \u003d isAllZeros(magnitude) \u0026\u0026 isAllZeros(exponent);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (null \u003d\u003d fractionalPart \u0026\u0026 null \u003d\u003d exponent \u0026\u0026 (\u0027-\u0027 \u003d\u003d decimalValue.charAt(0) \u0026\u0026 isDigits(decimalValue.substring(1)) || isDigits(decimalValue))) {\n                    try {\n                        return createLong(decimalValue);\n                    } catch (final NumberFormatException nfe) {\n                        // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(decimalValue);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float floatValue \u003d NumberUtils.createFloat(decimalValue);\n                    if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isAllZeroes))) {\n                        //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return floatValue;\n                    }\n                } catch (final NumberFormatException nfe) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double value \u003d NumberUtils.createDouble(decimalValue);\n                    if (!(value.isInfinite() || (0.0D \u003d\u003d value.floatValue() \u0026\u0026 !isAllZeroes))) {\n                        return value;\n                    }\n                } catch (final NumberFormatException nfe) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(decimalValue);\n                } catch (final NumberFormatException e) {\n                    // NOPMD\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    //User doesn\u0027t have a preference on the return type, so let\u0027s start\n    //small and go from there...\n    if (-1 \u003e\u003d exponentPosition || str.length() - 1 \u003c\u003d exponentPosition) {\n        exponent \u003d null;\n    } else {\n        exponent \u003d str.substring(exponentPosition + 1, str.length());\n    }\n    if (null \u003d\u003d fractionalPart \u0026\u0026 null \u003d\u003d exponent) {\n        // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n    //Must be a Float, Double, BigDecimal\n    final boolean isAllZeroes \u003d isAllZeros(magnitude) \u0026\u0026 isAllZeros(exponent);\n    try {\n        final Float floatValue \u003d createFloat(str);\n        if (!(floatValue.isInfinite() || (0.0F \u003d\u003d floatValue.floatValue() \u0026\u0026 !isAllZeroes))) {\n            return floatValue;\n        }\n    } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n    }\n    try {\n        final Double value \u003d createDouble(str);\n        if (!(value.isInfinite() || (0.0D \u003d\u003d value.doubleValue() \u0026\u0026 !isAllZeroes))) {\n            return value;\n        }\n    } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n    }\n    return createBigDecimal(str);\n}",
  "Closure-33": "public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n        for (String attribute : constraintObj.getOwnPropertyNames()) {\n            JSType propertyType \u003d constraintObj.getPropertyType(attribute);\n            if (!isPropertyTypeDeclared(attribute)) {\n                JSType typeToDetermine \u003d propertyType;\n                if (!hasProperty(attribute)) {\n                    typeToDetermine \u003d getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propertyType);\n                }\n                defineInferredProperty(attribute, typeToDetermine, null);\n            }\n        }\n    }\n}",
  "Closure-31": "Node parseInputs() {\n    boolean isDevelopmentMode \u003d DevMode.OFF !\u003d options.devMode;\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (null !\u003d externsRoot) {\n        externsRoot.detachChildren();\n    }\n    if (null !\u003d jsRoot) {\n        jsRoot.detachChildren();\n    }\n    // Parse main js sources.\n    jsRoot \u003d IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot \u003d IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot \u003d IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer monitor \u003d newTracer(\"parseInputs\");\n    try {\n        // Parse externs sources.\n        for (CompilerInput source : externs) {\n            Node astNode \u003d source.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(astNode);\n        }\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n        // Check if inputs need to be rebuilt from modules.\n        boolean outdatedInputs \u003d false;\n        // Check if the sources need to be re-ordered.\n        if (options.dependencyOptions.needsManagement() \u0026\u0026 !options.skipAllPasses \u0026\u0026 options.closurePass) {\n            for (CompilerInput source : inputs) {\n                // Forward-declare all the provided types, so that they\n                // are not flagged even if they are dropped from the process.\n                for (String supply : source.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(supply);\n                }\n            }\n            try {\n                inputs \u003d (null \u003d\u003d moduleGraph ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\n                outdatedInputs \u003d true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n        for (CompilerInput source : inputs) {\n            Node astNode \u003d source.getAstRoot(this);\n            // Inputs can have a null AST during initial parse.\n            if (null \u003d\u003d astNode) {\n                continue;\n            }\n            if (null !\u003d astNode.getJSDocInfo()) {\n                JSDocInfo documentation \u003d astNode.getJSDocInfo();\n                if (!documentation.isExterns()) {\n                    if (documentation.isNoCompile()) {\n                        source.getModule().remove(source);\n                        outdatedInputs \u003d true;\n                    }\n                } else {\n                    // If the input file is explicitly marked as an externs file, then\n                    // assume the programmer made a mistake and throw it into\n                    // the externs pile anyways.\n                    externsRoot.addChildToBack(astNode);\n                    source.setIsExtern(true);\n                    source.getModule().remove(source);\n                    externs.add(source);\n                    outdatedInputs \u003d true;\n                }\n            }\n        }\n        if (outdatedInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        // Build the AST.\n        for (CompilerInput source : inputs) {\n            Node astNode \u003d source.getAstRoot(this);\n            if (null \u003d\u003d astNode) {\n                continue;\n            }\n            if (isDevelopmentMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (null !\u003d options.sourceMapOutputPath || null !\u003d options.nameReferenceReportPath) {\n                // Annotate the nodes in the tree with information from the\n                // input file. This information is used to construct the SourceMap.\n                SourceInformationAnnotator sourceInfoAnnotator \u003d new SourceInformationAnnotator(source.getName(), DevMode.OFF !\u003d options.devMode);\n                NodeTraversal.traverse(this, astNode, sourceInfoAnnotator);\n            }\n            jsRoot.addChildToBack(astNode);\n        }\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(monitor, \"parseInputs\");\n    }\n}",
  "Closure-32": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (JsDocToken.EOC \u003d\u003d token || JsDocToken.EOL \u003d\u003d token || JsDocToken.EOF \u003d\u003d token) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineNumber \u003d stream.getLineno();\n    int startCharacterNumber \u003d stream.getCharno() + 1;\n    // Read the content from the first line.\n    String contentLine \u003d stream.getRemainingJSDocLine();\n    if (WhitespaceOption.PRESERVE !\u003d option) {\n        contentLine \u003d contentLine.trim();\n    }\n    StringBuilder stringBuilder \u003d new StringBuilder();\n    stringBuilder.append(contentLine);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean skipStar \u003d false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it\u0027s easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (!skipStar) {\n                    // The star is part of the comment.\n                    if (0 \u003c stringBuilder.length()) {\n                        stringBuilder.append(\u0027 \u0027);\n                    }\n                    stringBuilder.append(\u0027*\u0027);\n                } else {\n                    // Mark the position after the star as the new start of the line.\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (WhitespaceOption.SINGLE_LINE !\u003d option) {\n                    stringBuilder.append(\"\\n\");\n                }\n                skipStar \u003d true;\n                token \u003d next();\n                continue;\n            default:\n                skipStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (// When we\u0027re capturing a license block, annotations\n                // in the block are ok.\n                JsDocToken.EOC \u003d\u003d token || JsDocToken.EOF \u003d\u003d token || (JsDocToken.ANNOTATION \u003d\u003d token \u0026\u0026 WhitespaceOption.PRESERVE !\u003d option)) {\n                    String extractedTextBlock \u003d stringBuilder.toString();\n                    if (WhitespaceOption.PRESERVE !\u003d option) {\n                        extractedTextBlock \u003d extractedTextBlock.trim();\n                    }\n                    int endLineNumber \u003d stream.getLineno();\n                    int endCharacterNumber \u003d stream.getCharno();\n                    if (0 \u003c extractedTextBlock.length()) {\n                        jsdocBuilder.markText(extractedTextBlock, startLineNumber, startCharacterNumber, endLineNumber, endCharacterNumber);\n                    }\n                    return new ExtractionInfo(extractedTextBlock, token);\n                }\n                if (0 \u003c stringBuilder.length()) {\n                    stringBuilder.append(\u0027 \u0027);\n                }\n                stringBuilder.append(toString(token));\n                contentLine \u003d stream.getRemainingJSDocLine();\n                if (WhitespaceOption.PRESERVE !\u003d option) {\n                    contentLine \u003d trimEnd(contentLine);\n                }\n                stringBuilder.append(contentLine);\n                token \u003d next();\n        }\n    } while (true);\n}",
  "Closure-38": "void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char lastChar \u003d getLastChar();\n    boolean isNegativeZeroValue \u003d isNegativeZero(x);\n    if (0 \u003e x \u0026\u0026 \u0027-\u0027 \u003d\u003d lastChar) {\n        add(\" \");\n    }\n    if (x !\u003d (long) x || isNegativeZeroValue) {\n        add(String.valueOf(x));\n    } else {\n        long numberValue \u003d (long) x;\n        long coefficient \u003d numberValue;\n        int exponent \u003d 0;\n        if (100 \u003c\u003d Math.abs(x)) {\n            while (numberValue \u003d\u003d coefficient / 10 * Math.pow(10, exponent + 1)) {\n                coefficient /\u003d 10;\n                exponent +\u003d 1;\n            }\n        }\n        if (2 \u003e\u003d exponent) {\n            add(Long.toString(numberValue));\n        } else {\n            add(Long.toString(coefficient) + \"E\" + Integer.toString(exponent));\n        }\n    }\n}",
  "Closure-35": "private void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) {\n    if (null \u003d\u003d type || null \u003d\u003d constraint) {\n        return;\n    }\n    ObjectType propertyConstraintObj \u003d ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (null !\u003d propertyConstraintObj \u0026\u0026 propertyConstraintObj.isRecordType()) {\n        ObjectType objType \u003d ObjectType.cast(type.restrictByNotNullOrUndefined());\n        if (null !\u003d objType) {\n            for (String attribute : propertyConstraintObj.getOwnPropertyNames()) {\n                JSType propertyType \u003d propertyConstraintObj.getPropertyType(attribute);\n                if (!objType.isPropertyTypeDeclared(attribute)) {\n                    JSType inferredType \u003d propertyType;\n                    if (!objType.hasProperty(attribute)) {\n                        inferredType \u003d getNativeType(VOID_TYPE).getLeastSupertype(propertyType);\n                    }\n                    objType.defineInferredProperty(attribute, inferredType, null);\n                }\n            }\n        }\n    }\n}",
  "Closure-36": "private boolean canInline(Reference declaration, Reference initialization, Reference reference) {\n    if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {\n        return false;\n    }\n    // If the value is read more than once, skip it.\n    // VAR declarations and EXPR_RESULT don\u0027t need the value, but other\n    // ASSIGN expressions parents do.\n    if (initialization !\u003d declaration \u0026\u0026 !initialization.getGrandparent().isExprResult()) {\n        return false;\n    }\n    // Be very conservative and do no cross control structures or\n    // scope boundaries\n    if (initialization.getBasicBlock() !\u003d declaration.getBasicBlock() || reference.getBasicBlock() !\u003d declaration.getBasicBlock()) {\n        return false;\n    }\n    // Do not inline into a call node. This would change\n    // the context in which it was being called. For example,\n    //   var a \u003d b.c;\n    //   a();\n    // should not be inlined, because it calls a in the context of b\n    // rather than the context of the window.\n    //   var a \u003d b.c;\n    //   f(a)\n    // is ok.\n    Node node \u003d initialization.getAssignedValue();\n    Preconditions.checkState(null !\u003d node);\n    if (node.isGetProp() \u0026\u0026 reference.getParent().isCall() \u0026\u0026 reference.getNode() \u003d\u003d reference.getParent().getFirstChild()) {\n        return false;\n    }\n    if (node.isFunction()) {\n        Node invokeNode \u003d reference.getParent();\n        if (reference.getParent().isCall()) {\n            CodingConvention codingStandard \u003d compiler.getCodingConvention();\n            // Bug 2388531: Don\u0027t inline subclass definitions into class defining\n            // calls as this confused class removing logic.\n            SubclassRelationship SubclassAssociation \u003d codingStandard.getClassesDefinedByCall(invokeNode);\n            if (null !\u003d SubclassAssociation) {\n                return false;\n            }\n            // issue 668: Don\u0027t inline singleton getter methods\n            // calls as this confused class removing logic.\n        }\n    }\n    return canMoveAggressively(node) || canMoveModerately(initialization, reference);\n}",
  "Closure-39": "String toStringHelper(boolean forAnnotations) {\n    if (!hasReferenceName()) {\n        if (!prettyPrint) {\n            return \"{...}\";\n        } else {\n            // Don\u0027t pretty print recursively.\n            prettyPrint \u003d false;\n            // Use a tree set so that the properties are sorted.\n            Set\u003cString\u003e propertyKeys \u003d Sets.newTreeSet();\n            ObjectType current \u003d this;\n            while (null !\u003d current \u0026\u0026 !current.isNativeObjectType() \u0026\u0026 MAX_PRETTY_PRINTED_PROPERTIES \u003e\u003d propertyKeys.size()) {\n                propertyKeys.addAll(current.getOwnPropertyNames());\n                current \u003d current.getImplicitPrototype();\n            }\n            StringBuilder stringBuilder \u003d new StringBuilder();\n            stringBuilder.append(\"{\");\n            int index \u003d 0;\n            for (String attribute : propertyKeys) {\n                if (0 \u003c index) {\n                    stringBuilder.append(\", \");\n                }\n                stringBuilder.append(attribute);\n                stringBuilder.append(\": \");\n                stringBuilder.append(getPropertyType(attribute).toString());\n                ++index;\n                if (MAX_PRETTY_PRINTED_PROPERTIES \u003d\u003d index) {\n                    stringBuilder.append(\", ...\");\n                    break;\n                }\n            }\n            stringBuilder.append(\"}\");\n            prettyPrint \u003d true;\n            return stringBuilder.toString();\n        }\n    } else {\n        return getReferenceName();\n    }\n}",
  "Closure-40": "public void visit(NodeTraversal t, Node n, Node parent) {\n    // Record global variable and function declarations\n    if (t.inGlobalScope()) {\n        if (!NodeUtil.isVarDeclaration(n)) {\n            if (!NodeUtil.isFunctionDeclaration(n)) {\n                if (NodeUtil.isObjectLitKey(n, parent)) {\n                    NameInformation ns \u003d createNameInformation(t, n, parent);\n                    if (null !\u003d ns) {\n                        recordSet(ns.name, n);\n                    }\n                }\n            } else {\n                Node functionNode \u003d n.getFirstChild();\n                NameInformation ns \u003d createNameInformation(t, functionNode, n);\n                if (null !\u003d ns) {\n                    JsName jsName \u003d getName(functionNode.getString(), true);\n                    recordSet(jsName.name, functionNode);\n                }\n            }\n        } else {\n            NameInformation ns \u003d createNameInformation(t, n, parent);\n            Preconditions.checkNotNull(ns);\n            recordSet(ns.name, n);\n        }\n    }\n    // Record assignments and call sites\n    if (!n.isAssign()) {\n        if (n.isCall()) {\n            Node functionNode \u003d n.getFirstChild();\n            NameInformation ns \u003d createNameInformation(t, functionNode, n);\n            if (null !\u003d ns \u0026\u0026 ns.onlyAffectsClassDef) {\n                JsName identifier \u003d getName(ns.name, false);\n                if (null !\u003d identifier) {\n                    refNodes.add(new ClassDefiningFunctionNode(identifier, n, parent, parent.getParent()));\n                }\n            }\n        }\n    } else {\n        Node functionNode \u003d n.getFirstChild();\n        NameInformation ns \u003d createNameInformation(t, functionNode, n);\n        if (null !\u003d ns) {\n            if (!(ns.isPrototype)) {\n                recordSet(ns.name, functionNode);\n            } else {\n                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n            }\n        }\n    }\n}",
  "Closure-44": "void add(String newcode) {\n    maybeEndStatement();\n    if (0 \u003d\u003d newcode.length()) {\n        return;\n    }\n    char character \u003d newcode.charAt(0);\n    if ((isWordChar(character) || \u0027\\\\\u0027 \u003d\u003d character) \u0026\u0026 isWordChar(getLastChar())) {\n        // need space to separate. This is not pretty printing.\n        // For example: \"return foo;\"\n        append(\" \");\n        // Do not allow a forward slash to appear after a DIV.\n        // For example,\n        // REGEXP DIV REGEXP\n        // is valid and should print like\n        // / // / /\n    }\n    append(newcode);\n}",
  "Closure-42": "Node processForInLoop(ForInLoop loopNode) {\n    // Return the bare minimum to put the AST in a valid state.\n    return newNode(Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));\n}",
  "Closure-48": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node parentNode \u003d n.getFirstChild();\n    String entityName \u003d parentNode.getQualifiedName();\n    String qualifiedName \u003d n.getQualifiedName();\n    String propertyName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(null !\u003d qualifiedName \u0026\u0026 null !\u003d entityName);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType typeValue \u003d getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (null \u003d\u003d typeValue \u0026\u0026 null !\u003d rhsValue) {\n        // Determining type for #5\n        typeValue \u003d rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It\u0027s a common JS idiom to do:\n    // F.prototype \u003d { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propertyName)) {\n        Var declaredVar \u003d scope.getVar(qualifiedName);\n        if (null !\u003d declaredVar) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal\u0027s\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            ObjectType qVariableType \u003d ObjectType.cast(declaredVar.getType());\n            if (null \u003d\u003d qVariableType || null \u003d\u003d rhsValue || !rhsValue.isObjectLit()) {\n                if (!declaredVar.isTypeInferred()) {\n                    // If the programmer has declared that F inherits from Super,\n                    // and they assign F.prototype to some arbitrary expression,\n                    // there\u0027s not much we can do. We just ignore the expression,\n                    // and hope they\u0027ve annotated their code in a way to tell us\n                    // what props are going to be on that prototype.\n                    return;\n                }\n            } else {\n                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVariableType.getImplicitPrototype());\n            }\n            if (scope \u003d\u003d declaredVar.getScope()) {\n                scope.undeclare(declaredVar);\n            }\n        }\n    }\n    if (null \u003d\u003d typeValue) {\n        if (parent.isExprResult()) {\n            stubDeclarations.add(new StubDeclaration(n, null !\u003d t.getInput() \u0026\u0026 t.getInput().isExtern(), entityName));\n        }\n        return;\n    }\n    // NOTE(nicksantos): Determining whether a property is declared or not\n    // is really really obnoxious.\n    //\n    // The problem is that there are two (equally valid) coding styles:\n    //\n    // (function() {\n    //   /* The authoritative definition of goog.bar. */\n    //   goog.bar \u003d function() {};\n    // })();\n    //\n    // function f() {\n    //   goog.bar();\n    //   /* Reset goog.bar to a no-op. */\n    //   goog.bar \u003d function() {};\n    // }\n    //\n    // In a dynamic language with first-class functions, it\u0027s very difficult\n    // to know which one the user intended without looking at lots of\n    // contextual information (the second example demonstrates a small case\n    // of this, but there are some really pathological cases as well).\n    //\n    // The current algorithm checks if either the declaration has\n    // jsdoc type information, or @const with a known type,\n    // or a function literal with a name we haven\u0027t seen before.\n    boolean assumed \u003d true;\n    if (null !\u003d info) {\n        // Determining declaration for #1 + #3 + #4\n        assumed \u003d !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() \u0026\u0026 null !\u003d typeValue \u0026\u0026 !typeValue.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (assumed) {\n        // Determining declaration for #2\n        assumed \u003d !(null !\u003d rhsValue \u0026\u0026 rhsValue.isFunction() \u0026\u0026 (null !\u003d info || !scope.isDeclared(qualifiedName, false)));\n    }\n    if (assumed) {\n        if (null !\u003d rhsValue \u0026\u0026 rhsValue.isTrue()) {\n            // We declare these for delegate proxy method properties.\n            FunctionType objectType \u003d JSType.toMaybeFunctionType(getObjectSlot(entityName));\n            if (null !\u003d objectType) {\n                JSType ownerThisType \u003d objectType.getTypeOfThis();\n                String superclassName \u003d codingConvention.getDelegateSuperclassName();\n                JSType delegateClassType \u003d null \u003d\u003d superclassName ? null : typeRegistry.getType(superclassName);\n                if (null !\u003d delegateClassType \u0026\u0026 ownerThisType.isSubtype(delegateClassType)) {\n                    defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n                }\n            }\n        }\n    } else {\n        ObjectType objectType \u003d getObjectSlot(entityName);\n        if (null !\u003d objectType) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExternal \u003d null !\u003d t.getInput() \u0026\u0026 t.getInput().isExtern();\n            if ((!objectType.hasOwnProperty(propertyName) || objectType.isPropertyTypeInferred(propertyName)) \u0026\u0026 ((isExternal \u0026\u0026 !objectType.isNativeObjectType()) || !objectType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                objectType.defineDeclaredProperty(propertyName, typeValue, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, typeValue, assumed);\n    }\n}",
  "Codec-3": "private int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\n    if (\u0027H\u0027 !\u003d charAt(value, index + 1)) {\n        if (\u0027N\u0027 !\u003d charAt(value, index + 1)) {\n            if (!contains(value, index + 1, 2, \"LI\") || slavoGermanic) {\n                if (0 !\u003d index || !((\u0027Y\u0027 \u003d\u003d charAt(value, index + 1) || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER)))) {\n                    if (!((contains(value, index + 1, 2, \"ER\") || \u0027Y\u0027 \u003d\u003d charAt(value, index + 1))) || contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") || contains(value, index - 1, 1, \"E\", \"I\") || contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n                        if (!contains(value, index + 1, 1, \"E\", \"I\", \"Y\") \u0026\u0026 !contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n                            if (\u0027G\u0027 !\u003d charAt(value, index + 1)) {\n                                index +\u003d 1;\n                                result.append(\u0027K\u0027);\n                            } else {\n                                index +\u003d 2;\n                                result.append(\u0027K\u0027);\n                            }\n                        } else {\n                            //-- Italian \"biaggi\" --//\n                            if (!((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\"))) \u0026\u0026 !contains(value, index + 1, 2, \"ET\")) {\n                                if (!contains(value, index + 1, 4, \"IER\")) {\n                                    result.append(\u0027J\u0027, \u0027K\u0027);\n                                } else {\n                                    result.append(\u0027J\u0027);\n                                }\n                            } else {\n                                //-- obvious germanic --//\n                                result.append(\u0027K\u0027);\n                            }\n                            index +\u003d 2;\n                        }\n                    } else {\n                        //-- -ger-, -gy- --//\n                        result.append(\u0027K\u0027, \u0027J\u0027);\n                        index +\u003d 2;\n                    }\n                } else {\n                    //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n                    result.append(\u0027K\u0027, \u0027J\u0027);\n                    index +\u003d 2;\n                }\n            } else {\n                result.append(\"KL\", \"L\");\n                index +\u003d 2;\n            }\n        } else {\n            if (1 !\u003d index || !isVowel(charAt(value, 0)) || slavoGermanic) {\n                if (contains(value, index + 2, 2, \"EY\") || \u0027Y\u0027 \u003d\u003d charAt(value, index + 1) || slavoGermanic) {\n                    result.append(\"KN\");\n                } else {\n                    result.append(\"N\", \"KN\");\n                }\n            } else {\n                result.append(\"KN\", \"N\");\n            }\n            index \u003d index + 2;\n        }\n    } else {\n        index \u003d handleGH(value, result, index);\n    }\n    return index;\n}",
  "Collections-26": "private Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}",
  "Codec-4": "public Base64() {\n    this(false);\n}",
  "Codec-5": "void decode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (0 \u003e inAvail) {\n        eof \u003d true;\n    }\n    int index \u003d 0;\n    while (inAvail \u003e index) {\n        if (null \u003d\u003d buffer || decodeSize \u003e buffer.length - pos) {\n            resizeBuffer();\n        }\n        byte b \u003d in[inPos++];\n        if (PAD !\u003d b) {\n            if (0 \u003c\u003d b \u0026\u0026 DECODE_TABLE.length \u003e b) {\n                int output \u003d DECODE_TABLE[b];\n                if (0 \u003c\u003d output) {\n                    modulus \u003d (++modulus) % 4;\n                    x \u003d (x \u003c\u003c 6) + output;\n                    if (0 \u003d\u003d modulus) {\n                        buffer[pos++] \u003d (byte) ((x \u003e\u003e 16) \u0026 MASK_8BITS);\n                        buffer[pos++] \u003d (byte) ((x \u003e\u003e 8) \u0026 MASK_8BITS);\n                        buffer[pos++] \u003d (byte) (x \u0026 MASK_8BITS);\n                    }\n                }\n            }\n        } else {\n            // We\u0027re done.\n            eof \u003d true;\n            break;\n        }\n        index +\u003d 1;\n    }\n    // Two forms of EOF as far as base64 decoder is concerned: actual\n    // EOF (-1) and first time \u0027\u003d\u0027 character is encountered in stream.\n    // This approach makes the \u0027\u003d\u0027 padding characters completely optional.\n    if (eof \u0026\u0026 0 !\u003d modulus) {\n        x \u003d x \u003c\u003c 6;\n        switch(modulus) {\n            case 2:\n                x \u003d x \u003c\u003c 6;\n                buffer[pos++] \u003d (byte) ((x \u003e\u003e 16) \u0026 MASK_8BITS);\n                break;\n            case 3:\n                buffer[pos++] \u003d (byte) ((x \u003e\u003e 16) \u0026 MASK_8BITS);\n                buffer[pos++] \u003d (byte) ((x \u003e\u003e 8) \u0026 MASK_8BITS);\n                break;\n        }\n    }\n}",
  "Codec-6": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (null !\u003d b) {\n        if (0 \u003c\u003d offset \u0026\u0026 0 \u003c\u003d len) {\n            if (b.length \u003e\u003d offset \u0026\u0026 b.length \u003e\u003d offset + len) {\n                if (0 !\u003d len) {\n                    /*\n         Rationale for while-loop on (readLen \u003d\u003d 0):\n         -----\n         Base64.readResults() usually returns \u003e 0 or EOF (-1).  In the\n         rare case where it returns 0, we just keep trying.\n\n         This is essentially an undocumented contract for InputStream\n         implementors that want their code to work properly with\n         java.io.InputStreamReader, since the latter hates it when\n         InputStream.read(byte[]) returns a zero.  Unfortunately our\n         readResults() call must return 0 if a large amount of the data\n         being decoded was non-base64, so this while-loop enables proper\n         interop with InputStreamReader for that scenario.\n         -----\n         This is a fix for CODEC-101\n        */\n                    if (!base64.hasData()) {\n                        byte[] buffer \u003d new byte[doEncode ? 4096 : 8192];\n                        int bytesRead \u003d in.read(buffer);\n                        // A little optimization to avoid System.arraycopy()\n                        // when possible.\n                        if (0 \u003c bytesRead \u0026\u0026 len \u003d\u003d b.length) {\n                            base64.setInitialBuffer(b, offset, len);\n                        }\n                        if (!doEncode) {\n                            base64.decode(buffer, 0, bytesRead);\n                        } else {\n                            base64.encode(buffer, 0, bytesRead);\n                        }\n                    }\n                    return base64.readResults(b, offset, len);\n                } else {\n                    return 0;\n                }\n            } else {\n                throw new IndexOutOfBoundsException();\n            }\n        } else {\n            throw new IndexOutOfBoundsException();\n        }\n    } else {\n        throw new NullPointerException();\n    }\n}",
  "Closure-109": "private Node parseContextTypeExpression(JsDocToken token) {\n    return parseTypeName(token);\n}",
  "Codec-2": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    // inAvail \u003c 0 is how we\u0027re informed of EOF in the underlying data we\u0027re\n    // encoding.\n    if (0 \u003c\u003d inAvail) {\n        int index \u003d 0;\n        while (inAvail \u003e index) {\n            if (null \u003d\u003d buf || encodeSize \u003e buf.length - pos) {\n                resizeBuf();\n            }\n            modulus \u003d (++modulus) % 3;\n            int byteValue \u003d in[inPos++];\n            if (0 \u003e byteValue) {\n                byteValue +\u003d 256;\n            }\n            x \u003d (x \u003c\u003c 8) + byteValue;\n            if (modulus \u003d\u003d 0) {\n                buf[pos++] \u003d encodeTable[(x \u003e\u003e 18) \u0026 MASK_6BITS];\n                buf[pos++] \u003d encodeTable[(x \u003e\u003e 12) \u0026 MASK_6BITS];\n                buf[pos++] \u003d encodeTable[(x \u003e\u003e 6) \u0026 MASK_6BITS];\n                buf[pos++] \u003d encodeTable[x \u0026 MASK_6BITS];\n                currentLinePos +\u003d 4;\n                if (0 \u003c lineLength \u0026\u0026 currentLinePos \u003e\u003d lineLength) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos +\u003d lineSeparator.length;\n                    currentLinePos \u003d 0;\n                }\n            }\n            index +\u003d 1;\n        }\n    } else {\n        eof \u003d true;\n        if (null \u003d\u003d buf || encodeSize \u003e buf.length - pos) {\n            resizeBuf();\n        }\n        switch(modulus) {\n            case 1:\n                buf[pos++] \u003d encodeTable[(x \u003e\u003e 2) \u0026 MASK_6BITS];\n                buf[pos++] \u003d encodeTable[(x \u003c\u003c 4) \u0026 MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (STANDARD_ENCODE_TABLE \u003d\u003d encodeTable) {\n                    buf[pos++] \u003d PAD;\n                    buf[pos++] \u003d PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] \u003d encodeTable[(x \u003e\u003e 10) \u0026 MASK_6BITS];\n                buf[pos++] \u003d encodeTable[(x \u003e\u003e 4) \u0026 MASK_6BITS];\n                buf[pos++] \u003d encodeTable[(x \u003c\u003c 2) \u0026 MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (STANDARD_ENCODE_TABLE \u003d\u003d encodeTable) {\n                    buf[pos++] \u003d PAD;\n                }\n                break;\n        }\n        if (0 \u003c lineLength) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos +\u003d lineSeparator.length;\n        }\n    }\n}",
  "Closure-107": "protected CompilerOptions createOptions() {\n    CompilerOptions settings \u003d new CompilerOptions();\n    if (!(flags.processJqueryPrimitives)) {\n        settings.setCodingConvention(new ClosureCodingConvention());\n    } else {\n        settings.setCodingConvention(new JqueryCodingConvention());\n    }\n    settings.setExtraAnnotationNames(flags.extraAnnotationName);\n    CompilationLevel compilationStage \u003d flags.compilationLevel;\n    compilationStage.setOptionsForCompilationLevel(settings);\n    if (flags.debug) {\n        compilationStage.setDebugOptionsForCompilationLevel(settings);\n    }\n    if (flags.useTypesForOptimization) {\n        compilationStage.setTypeBasedOptimizationOptions(settings);\n    }\n    if (flags.generateExports) {\n        settings.setGenerateExports(flags.generateExports);\n    }\n    WarningLevel warningLevel \u003d flags.warningLevel;\n    warningLevel.setOptionsForWarningLevel(settings);\n    for (FormattingOption formattingSetting : flags.formatting) {\n        formattingSetting.applyToOptions(settings);\n    }\n    settings.closurePass \u003d flags.processClosurePrimitives;\n    settings.jqueryPass \u003d compilationStage \u003d\u003d CompilationLevel.ADVANCED_OPTIMIZATIONS \u0026\u0026 flags.processJqueryPrimitives;\n    settings.angularPass \u003d flags.angularPass;\n    if (flags.translationsFile.isEmpty()) {\n        if (compilationStage \u003d\u003d CompilationLevel.ADVANCED_OPTIMIZATIONS) {\n            // In SIMPLE or WHITESPACE mode, if the user hasn\u0027t specified a\n            // translations file, they might reasonably try to write their own\n            // implementation of goog.getMsg that makes the substitution at\n            // run-time.\n            //\n            // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n            // so we might as well inline it. But shut off the i18n warnings,\n            // because the user didn\u0027t really ask for i18n.\n            settings.messageBundle \u003d new EmptyMessageBundle();\n        }\n    } else {\n        try {\n            settings.messageBundle \u003d new XtbMessageBundle(new FileInputStream(flags.translationsFile), flags.translationsProject);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Reading XTB file\", e);\n        }\n    }\n    return settings;\n}",
  "Closure-105": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n    Node listNode \u003d left.getFirstChild();\n    Node joinFunction \u003d listNode.getNext();\n    if ((Token.ARRAYLIT !\u003d listNode.getType()) || !joinFunction.getString().equals(\"join\")) {\n        return;\n    }\n    String delimiterString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e joinedArrayChildren \u003d Lists.newLinkedList();\n    StringBuilder stringBuilder \u003d new StringBuilder();\n    int compressedSize \u003d 0;\n    Node childNode \u003d listNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (null !\u003d childNode) {\n        if (!NodeUtil.isImmutableValue(childNode)) {\n            if (0 \u003c stringBuilder.length()) {\n                // + 2 for the quotes.\n                compressedSize +\u003d stringBuilder.length() + 2;\n                joinedArrayChildren.add(Node.newString(stringBuilder.toString()));\n                stringBuilder \u003d new StringBuilder();\n            }\n            compressedSize +\u003d InlineCostEstimator.getCost(childNode);\n            joinedArrayChildren.add(childNode);\n        } else {\n            if (0 \u003c stringBuilder.length()) {\n                stringBuilder.append(delimiterString);\n            }\n            stringBuilder.append(NodeUtil.getStringValue(childNode));\n        }\n        childNode \u003d childNode.getNext();\n    }\n    if (0 \u003c stringBuilder.length()) {\n        // + 2 for the quotes.\n        compressedSize +\u003d stringBuilder.length() + 2;\n        joinedArrayChildren.add(Node.newString(stringBuilder.toString()));\n    }\n    // one for each comma.\n    compressedSize +\u003d joinedArrayChildren.size() - 1;\n    int initialSize \u003d InlineCostEstimator.getCost(n);\n    switch(joinedArrayChildren.size()) {\n        case 0:\n            Node emptyStringLiteral \u003d Node.newString(\"\");\n            parent.replaceChild(n, emptyStringLiteral);\n            break;\n        case 1:\n            Node mergedStringNode \u003d joinedArrayChildren.remove(0);\n            if (initialSize \u003c compressedSize) {\n                return;\n            }\n            listNode.detachChildren();\n            if (Token.STRING !\u003d mergedStringNode.getType()) {\n                // If the Node is not a string literal, ensure that\n                // it is coerced to a string.\n                Node substitution \u003d new Node(Token.ADD, Node.newString(\"\"), mergedStringNode);\n                mergedStringNode \u003d substitution;\n            }\n            parent.replaceChild(n, mergedStringNode);\n            break;\n        default:\n            // No folding could actually be performed.\n            if (listNode.getChildCount() \u003d\u003d joinedArrayChildren.size()) {\n                return;\n            }\n            int joinFunctionOverhead \u003d \"[].join()\".length();\n            compressedSize +\u003d joinFunctionOverhead;\n            compressedSize +\u003d InlineCostEstimator.getCost(right);\n            if (initialSize \u003c compressedSize) {\n                return;\n            }\n            listNode.detachChildren();\n            for (Node element : joinedArrayChildren) {\n                listNode.addChildToBack(element);\n            }\n            break;\n    }\n    t.getCompiler().reportCodeChange();\n}",
  "Closure-104": "JSType meet(JSType that) {\n    UnionTypeBuilder unionBuilder \u003d new UnionTypeBuilder(registry);\n    for (JSType option : alternates) {\n        if (option.isSubtype(that)) {\n            unionBuilder.addAlternate(option);\n        }\n    }\n    if (!(that instanceof UnionType)) {\n        if (that.isSubtype(this)) {\n            unionBuilder.addAlternate(that);\n        }\n    } else {\n        for (JSType anotherAlternate : ((UnionType) that).alternates) {\n            if (anotherAlternate.isSubtype(this)) {\n                unionBuilder.addAlternate(anotherAlternate);\n            }\n        }\n    }\n    JSType mergedType \u003d unionBuilder.build();\n    if (null \u003d\u003d mergedType) {\n        if (!this.isObject() || !that.isObject()) {\n            return getNativeType(JSTypeNative.NO_TYPE);\n        } else {\n            return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n        }\n    } else {\n        return mergedType;\n    }\n}",
  "Closure-102": "public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique nameTransformer \u003d new MakeDeclaredNamesUnique();\n        NodeTraversal traversal \u003d new NodeTraversal(compiler, nameTransformer);\n        traversal.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}",
  "Closure-101": "protected CompilerOptions createOptions() {\n    CompilerOptions configurations \u003d new CompilerOptions();\n    configurations.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel compilationStage \u003d flags.compilation_level;\n    compilationStage.setOptionsForCompilationLevel(configurations);\n    if (flags.debug) {\n        compilationStage.setDebugOptionsForCompilationLevel(configurations);\n    }\n    WarningLevel warnLevel \u003d flags.warning_level;\n    warnLevel.setOptionsForWarningLevel(configurations);\n    for (FormattingOption formattingSetting : flags.formatting) {\n        formattingSetting.applyToOptions(configurations);\n    }\n    if (flags.process_closure_primitives) {\n        configurations.closurePass \u003d true;\n    }\n    initOptionsFromFlags(configurations);\n    return configurations;\n}",
  "Closure-11": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn\u0027t.\n    Node field \u003d n.getLastChild();\n    Node sourceNode \u003d n.getFirstChild();\n    JSType childJSType \u003d getJSType(sourceNode);\n    if (!childJSType.isDict()) {\n        if (null \u003d\u003d n.getJSType() || !parent.isAssign()) {\n            if (validator.expectNotNullOrUndefined(t, n, childJSType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n                checkPropertyAccess(childJSType, field.getString(), t, n);\n            }\n        } else {\n            return;\n        }\n    } else {\n        report(t, field, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"\u0027.\u0027\", \"dict\");\n    }\n    ensureTyped(t, n);\n}",
  "Closure-111": "protected JSType caseTopType(JSType topType) {\n    return topType;\n}",
  "Closure-12": "private boolean hasExceptionHandler(Node cfgNode) {\n    return false;\n}",
  "Closure-10": "static boolean mayBeString(Node n, boolean recurse) {\n    if (!recurse) {\n        return mayBeStringHelper(n);\n    } else {\n        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    }\n}",
  "Closure-15": "public boolean apply(Node n) {\n    // When the node is null it means, we reached the implicit return\n    // where the function returns (possibly without an return statement)\n    if (null \u003d\u003d n) {\n        return false;\n    }\n    // TODO(user): We only care about calls to functions that\n    // passes one of the dependent variable to a non-side-effect free\n    // function.\n    if (n.isCall() \u0026\u0026 NodeUtil.functionCallHasSideEffects(n)) {\n        return true;\n    }\n    if (n.isNew() \u0026\u0026 NodeUtil.constructorCallHasSideEffects(n)) {\n        return true;\n    }\n    Node childNode \u003d n.getFirstChild();\n    while (null !\u003d childNode) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(childNode) \u0026\u0026 apply(childNode)) {\n            return true;\n        }\n        childNode \u003d childNode.getNext();\n    }\n    return false;\n}",
  "Closure-13": "private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n        return;\n    }\n    int count \u003d 0;\n    do {\n        Node childNode \u003d node.getFirstChild();\n        while (null !\u003d childNode) {\n            traverse(childNode);\n            Node sibling \u003d childNode.getNext();\n            childNode \u003d sibling;\n        }\n        visit(node);\n        count +\u003d 1;\n        Preconditions.checkState(10000 \u003e count, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n}",
  "Closure-14": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n    Node ancestor \u003d node.getParent();\n    if (null \u003d\u003d ancestor || ancestor.isFunction() || (null !\u003d cfa \u0026\u0026 cfa.root \u003d\u003d node)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(ancestor.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, ancestor, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (null \u003d\u003d ancestor.getNext()) {\n                return computeFollowNode(fromNode, ancestor, cfa);\n            } else {\n                if (!ancestor.getNext().isCase()) {\n                    if (!ancestor.getNext().isDefaultCase()) {\n                        Preconditions.checkState(false, \"Not reachable\");\n                    } else {\n                        return ancestor.getNext().getFirstChild();\n                    }\n                } else {\n                    return ancestor.getNext().getFirstChild().getNext();\n                }\n            }\n            break;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(ancestor)) {\n                return ancestor.getFirstChild().getNext().getNext();\n            } else {\n                return ancestor;\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return ancestor;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (node !\u003d ancestor.getFirstChild()) {\n                if (node !\u003d NodeUtil.getCatchBlock(ancestor)) {\n                    if (node \u003d\u003d ancestor.getLastChild()) {\n                        if (null !\u003d cfa) {\n                            for (Node finalNode : cfa.finallyMap.get(ancestor)) {\n                                cfa.createEdge(fromNode, Branch.UNCOND, finalNode);\n                            }\n                        }\n                        return computeFollowNode(fromNode, ancestor, cfa);\n                    }\n                } else {\n                    if (!NodeUtil.hasFinally(ancestor)) {\n                        return computeFollowNode(fromNode, ancestor, cfa);\n                    } else {\n                        // and have FINALLY block.\n                        return computeFallThrough(node.getNext());\n                    }\n                    // If we are coming out of the FINALLY block...\n                }\n            } else {\n                if (!NodeUtil.hasFinally(ancestor)) {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, ancestor, cfa);\n                } else {\n                    // and have FINALLY block.\n                    return computeFallThrough(ancestor.getLastChild());\n                }\n                // CATCH block.\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node siblingNode \u003d node.getNext();\n    // Skip function declarations because control doesn\u0027t get pass into it.\n    while (null !\u003d siblingNode \u0026\u0026 siblingNode.isFunction()) {\n        siblingNode \u003d siblingNode.getNext();\n    }\n    if (null \u003d\u003d siblingNode) {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, ancestor, cfa);\n    } else {\n        return computeFallThrough(siblingNode);\n    }\n}",
  "Closure-19": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch(node.getType()) {\n        case Token.NAME:\n            scope.inferSlotType(node.getString(), type);\n            break;\n        case Token.GETPROP:\n            String fullyQualifiedName \u003d node.getQualifiedName();\n            Preconditions.checkNotNull(fullyQualifiedName);\n            JSType initialType \u003d node.getJSType();\n            initialType \u003d null \u003d\u003d initialType ? getNativeType(UNKNOWN_TYPE) : initialType;\n            scope.inferQualifiedSlot(node, fullyQualifiedName, initialType, type);\n            break;\n        // \"this\" references aren\u0027t currently modeled in the CFG.\n        default:\n            throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree());\n    }\n}",
  "Closure-17": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (null \u003d\u003d info || !info.hasType()) {\n        if (null \u003d\u003d rValue || !rValue.isFunction() || !shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n            if (null !\u003d info) {\n                if (!info.hasEnumParameterType()) {\n                    if (!info.isConstructor() \u0026\u0026 !info.isInterface()) {\n                        // Check if this is constant, and if it has a known type.\n                        if (info.isConstant()) {\n                            JSType inferredType \u003d null;\n                            if (null !\u003d rValue) {\n                                if (null \u003d\u003d rValue.getJSType() || rValue.getJSType().isUnknownType()) {\n                                    if (rValue.isOr()) {\n                                        // Check for a very specific JS idiom:\n                                        // var x \u003d x || TYPE;\n                                        // This is used by Closure\u0027s base namespace for esoteric\n                                        // reasons.\n                                        Node initialClause \u003d rValue.getFirstChild();\n                                        Node nextClause \u003d initialClause.getNext();\n                                        boolean identifiersMatch \u003d initialClause.isName() \u0026\u0026 lValue.isName() \u0026\u0026 initialClause.getString().equals(lValue.getString());\n                                        if (identifiersMatch \u0026\u0026 null !\u003d nextClause.getJSType() \u0026\u0026 !nextClause.getJSType().isUnknownType()) {\n                                            return nextClause.getJSType();\n                                        }\n                                    }\n                                } else {\n                                    // If rValue has a type-cast, we use the type in the type-cast.\n                                    // If rValue\u0027s type was already computed during scope creation,\n                                    // then we can safely use that.\n                                    return rValue.getJSType();\n                                }\n                            }\n                        }\n                    } else {\n                        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n                    }\n                } else {\n                    if (null \u003d\u003d rValue || !rValue.isObjectLit()) {\n                        return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n                    } else {\n                        return rValue.getJSType();\n                    }\n                }\n            }\n        } else {\n            return rValue.getJSType();\n        }\n    } else {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
  "Closure-18": "Node parseInputs() {\n    boolean isDevMode \u003d DevMode.OFF !\u003d options.devMode;\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (null !\u003d externsRoot) {\n        externsRoot.detachChildren();\n    }\n    if (null !\u003d jsRoot) {\n        jsRoot.detachChildren();\n    }\n    // Parse main JS sources.\n    jsRoot \u003d IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot \u003d IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot \u003d IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer monitor \u003d newTracer(\"parseInputs\");\n    try {\n        // Parse externs sources.\n        for (CompilerInput source : externs) {\n            Node astRootNode \u003d source.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(astRootNode);\n        }\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n        hoistExterns(externsRoot);\n        // Check if the sources need to be re-ordered.\n        boolean isInputsStale \u003d false;\n        if (options.dependencyOptions.needsManagement() \u0026\u0026 options.closurePass) {\n            for (CompilerInput source : inputs) {\n                // Forward-declare all the provided types, so that they\n                // are not flagged even if they are dropped from the process.\n                for (String supply : source.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(supply);\n                }\n            }\n            try {\n                inputs \u003d (null \u003d\u003d moduleGraph ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\n                isInputsStale \u003d true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n        hoistNoCompileFiles();\n        if (isInputsStale) {\n            repartitionInputs();\n        }\n        // Build the AST.\n        for (CompilerInput source : inputs) {\n            Node astRootNode \u003d source.getAstRoot(this);\n            if (null \u003d\u003d astRootNode) {\n                continue;\n            }\n            if (isDevMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (null !\u003d options.sourceMapOutputPath || null !\u003d options.nameReferenceReportPath) {\n                // Annotate the nodes in the tree with information from the\n                // input file. This information is used to construct the SourceMap.\n                SourceInformationAnnotator sourceInfoAnnotator \u003d new SourceInformationAnnotator(source.getName(), DevMode.OFF !\u003d options.devMode);\n                NodeTraversal.traverse(this, astRootNode, sourceInfoAnnotator);\n            }\n            jsRoot.addChildToBack(astRootNode);\n        }\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(monitor, \"parseInputs\");\n    }\n}",
  "Closure-1": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don\u0027t really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function\u0027s lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it\u0027s OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id\u003d253\n    Node method \u003d fnScope.getRootNode();\n    Preconditions.checkState(method.isFunction());\n    if (NodeUtil.isGetOrSetKey(method.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node parametersList \u003d getFunctionArgList(method);\n    boolean canAdjustCallers \u003d modifyCallSites \u0026\u0026 callSiteOptimizer.canModifyCallers(method);\n    if (canAdjustCallers) {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    } else {\n        // Strip unreferenced args off the end of the function declaration.\n        Node finalArg;\n        while (null !\u003d (finalArg \u003d parametersList.getLastChild())) {\n            Var variable \u003d fnScope.getVar(finalArg.getString());\n            if (referenced.contains(variable)) {\n                break;\n            } else {\n                parametersList.removeChild(finalArg);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n}",
  "Closure-119": "public void collect(JSModule module, Scope scope, Node n) {\n    Node ancestor \u003d n.getParent();\n    String identifier;\n    boolean isAssigned \u003d false;\n    Name.Type category \u003d Name.Type.OTHER;\n    boolean isPropertyAssignment \u003d false;\n    switch(n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n            // This may be a key in an object literal declaration.\n            identifier \u003d null;\n            if (null !\u003d ancestor \u0026\u0026 ancestor.isObjectLit()) {\n                identifier \u003d getNameForObjLitKey(n);\n            }\n            if (null \u003d\u003d identifier) {\n                return;\n            }\n            isAssigned \u003d true;\n            switch(n.getType()) {\n                case Token.STRING_KEY:\n                    category \u003d getValueType(n.getFirstChild());\n                    break;\n                case Token.GETTER_DEF:\n                    category \u003d Name.Type.GET;\n                    break;\n                case Token.SETTER_DEF:\n                    category \u003d Name.Type.SET;\n                    break;\n                default:\n                    throw new IllegalStateException(\"unexpected:\" + n);\n            }\n            break;\n        case Token.NAME:\n            // This may be a variable get or set.\n            if (null !\u003d ancestor) {\n                switch(ancestor.getType()) {\n                    case Token.VAR:\n                        isAssigned \u003d true;\n                        Node tempValue \u003d n.getFirstChild();\n                        category \u003d null \u003d\u003d tempValue ? Name.Type.OTHER : getValueType(tempValue);\n                        break;\n                    case Token.ASSIGN:\n                        if (n \u003d\u003d ancestor.getFirstChild()) {\n                            isAssigned \u003d true;\n                            category \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d ancestor.getParent();\n                        if (null \u003d\u003d gramps || NodeUtil.isFunctionExpression(ancestor)) {\n                            return;\n                        }\n                        isAssigned \u003d true;\n                        category \u003d Name.Type.FUNCTION;\n                        break;\n                    case Token.INC:\n                    case Token.DEC:\n                        isAssigned \u003d true;\n                        category \u003d Name.Type.OTHER;\n                        break;\n                    default:\n                        if (NodeUtil.isAssignmentOp(ancestor) \u0026\u0026 n \u003d\u003d ancestor.getFirstChild()) {\n                            isAssigned \u003d true;\n                            category \u003d Name.Type.OTHER;\n                        }\n                }\n            }\n            identifier \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            // This may be a namespaced name get or set.\n            if (null !\u003d ancestor) {\n                switch(ancestor.getType()) {\n                    case Token.ASSIGN:\n                        if (n \u003d\u003d ancestor.getFirstChild()) {\n                            isAssigned \u003d true;\n                            category \u003d getValueType(n.getNext());\n                            isPropertyAssignment \u003d true;\n                        }\n                        break;\n                    case Token.INC:\n                    case Token.DEC:\n                        isAssigned \u003d true;\n                        category \u003d Name.Type.OTHER;\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    default:\n                        if (NodeUtil.isAssignmentOp(ancestor) \u0026\u0026 n \u003d\u003d ancestor.getFirstChild()) {\n                            isAssigned \u003d true;\n                            category \u003d Name.Type.OTHER;\n                        }\n                }\n            }\n            identifier \u003d n.getQualifiedName();\n            if (null \u003d\u003d identifier) {\n                return;\n            }\n            break;\n        default:\n            return;\n    }\n    // We are only interested in global names.\n    if (!isGlobalNameReference(identifier, scope)) {\n        return;\n    }\n    if (!isAssigned) {\n        handleGet(module, scope, n, ancestor, identifier);\n    } else {\n        if (!isGlobalScope(scope)) {\n            handleSetFromLocal(module, scope, n, ancestor, identifier);\n        } else {\n            handleSetFromGlobal(module, scope, n, ancestor, identifier, isPropertyAssignment, category);\n        }\n    }\n}",
  "Closure-118": "private void handleObjectLit(NodeTraversal t, Node n) {\n    Node nodeChild \u003d n.getFirstChild();\n    while (null !\u003d nodeChild) {\n        // Maybe STRING, GET, SET\n        // We should never see a mix of numbers and strings.\n        String identifier \u003d nodeChild.getString();\n        T kind \u003d typeSystem.getType(getScope(), n, identifier);\n        Property attribute \u003d getProperty(identifier);\n        if (!attribute.scheduleRenaming(nodeChild, processProperty(t, attribute, kind, null))) {\n            // TODO(user): It doesn\u0027t look like the user can do much in this\n            // case right now.\n            if (propertiesToErrorFor.containsKey(identifier)) {\n                compiler.report(JSError.make(t.getSourceName(), nodeChild, propertiesToErrorFor.get(identifier), Warnings.INVALIDATION, identifier, (null \u003d\u003d kind ? \"null\" : kind.toString()), n.toString(), \"\"));\n            }\n        }\n        nodeChild \u003d nodeChild.getNext();\n    }\n}",
  "Closure-117": "String getReadableJSTypeName(Node n, boolean dereference) {\n    // The best type name is the actual type name.\n    // If we\u0027re analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n        ObjectType classType \u003d getJSType(n.getFirstChild()).dereference();\n        if (null !\u003d classType) {\n            String propertyName \u003d n.getLastChild().getString();\n            if (null \u003d\u003d classType.getConstructor() || !classType.getConstructor().isInterface()) {\n                // classes\n                while (null !\u003d classType \u0026\u0026 !classType.hasOwnProperty(propertyName)) {\n                    classType \u003d classType.getImplicitPrototype();\n                }\n            } else {\n                classType \u003d FunctionType.getTopDefiningInterface(classType, propertyName);\n            }\n            // Don\u0027t show complex function names or anonymous types.\n            // Instead, try to get a human-readable type name.\n            if (null !\u003d classType \u0026\u0026 (null !\u003d classType.getConstructor() || classType.isFunctionPrototypeType())) {\n                return classType.toString() + \".\" + propertyName;\n            }\n        }\n    }\n    JSType dataType \u003d getJSType(n);\n    if (dereference) {\n        ObjectType resolved \u003d dataType.dereference();\n        if (null !\u003d resolved) {\n            dataType \u003d resolved;\n        }\n    }\n    if (dataType.isFunctionPrototypeType() || (null !\u003d dataType.toObjectType() \u0026\u0026 null !\u003d dataType.toObjectType().getConstructor())) {\n        return dataType.toString();\n    }\n    String fullyQualifiedName \u003d n.getQualifiedName();\n    if (null \u003d\u003d fullyQualifiedName) {\n        if (!dataType.isFunctionType()) {\n            return dataType.toString();\n        } else {\n            // Don\u0027t show complex function names.\n            return \"function\";\n        }\n    } else {\n        return fullyQualifiedName;\n    }\n}",
  "Closure-116": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node body \u003d fnNode.getLastChild();\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node argumentNode \u003d callNode.getFirstChild().getNext();\n    // Functions called via \u0027call\u0027 and \u0027apply\u0027 have a this-object as\n    // the first parameter, but this is not part of the called function\u0027s\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (!NodeUtil.isFunctionObjectCall(callNode)) {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        } else {\n            // TODO(johnlenz): Support replace this with a value.\n            if (null \u003d\u003d argumentNode || !argumentNode.isThis()) {\n                return CanInlineResult.NO;\n            }\n            argumentNode \u003d argumentNode.getNext();\n        }\n    }\n    // FUNCTION NODE -\u003e LP NODE: [ ARG1, ARG2, ... ]\n    Node parameterNode \u003d NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (null !\u003d argumentNode || null !\u003d parameterNode) {\n        // For each named parameter check if a mutable argument use more than one.\n        if (null !\u003d parameterNode) {\n            if (null !\u003d argumentNode) {\n                // Check for arguments that are evaluated more than once.\n                // Note: Unlike block inlining, there it is not possible that a\n                // parameter reference will be in a loop.\n                if (NodeUtil.mayEffectMutableState(argumentNode, compiler) \u0026\u0026 1 \u003c NodeUtil.getNameReferenceCount(body, parameterNode.getString())) {\n                    return CanInlineResult.NO;\n                }\n            }\n            // Move to the next name.\n            parameterNode \u003d parameterNode.getNext();\n        }\n        // For every call argument check for side-effects, even if there\n        // isn\u0027t a named parameter to match.\n        if (null !\u003d argumentNode) {\n            if (NodeUtil.mayHaveSideEffects(argumentNode, compiler)) {\n                return CanInlineResult.NO;\n            }\n            argumentNode \u003d argumentNode.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}",
  "Closure-115": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node body \u003d fnNode.getLastChild();\n    boolean hasUnintendedEffects \u003d false;\n    if (body.hasChildren()) {\n        Preconditions.checkState(body.hasOneChild());\n        Node statement \u003d body.getFirstChild();\n        if (statement.isReturn()) {\n            hasUnintendedEffects \u003d NodeUtil.mayHaveSideEffects(statement.getFirstChild(), compiler);\n        }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node argumentNode \u003d callNode.getFirstChild().getNext();\n    // Functions called via \u0027call\u0027 and \u0027apply\u0027 have a this-object as\n    // the first parameter, but this is not part of the called function\u0027s\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (!NodeUtil.isFunctionObjectCall(callNode)) {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        } else {\n            // TODO(johnlenz): Support replace this with a value.\n            if (null \u003d\u003d argumentNode || !argumentNode.isThis()) {\n                return CanInlineResult.NO;\n            }\n            argumentNode \u003d argumentNode.getNext();\n        }\n    }\n    // FUNCTION NODE -\u003e LP NODE: [ ARG1, ARG2, ... ]\n    Node functionParameter \u003d NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (null !\u003d argumentNode || null !\u003d functionParameter) {\n        // For each named parameter check if a mutable argument use more than one.\n        if (null !\u003d functionParameter) {\n            if (null !\u003d argumentNode) {\n                if (hasUnintendedEffects \u0026\u0026 NodeUtil.canBeSideEffected(argumentNode)) {\n                    return CanInlineResult.NO;\n                }\n                // Check for arguments that are evaluated more than once.\n                // Note: Unlike block inlining, there it is not possible that a\n                // parameter reference will be in a loop.\n                if (NodeUtil.mayEffectMutableState(argumentNode, compiler) \u0026\u0026 1 \u003c NodeUtil.getNameReferenceCount(body, functionParameter.getString())) {\n                    return CanInlineResult.NO;\n                }\n            }\n            // Move to the next name.\n            functionParameter \u003d functionParameter.getNext();\n        }\n        // For every call argument check for side-effects, even if there\n        // isn\u0027t a named parameter to match.\n        if (null !\u003d argumentNode) {\n            if (NodeUtil.mayHaveSideEffects(argumentNode, compiler)) {\n                return CanInlineResult.NO;\n            }\n            argumentNode \u003d argumentNode.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}",
  "Closure-114": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n    Node childNode \u003d n.getFirstChild();\n    Node ancestor \u003d n.getParent();\n    NameInformation nameInfo \u003d createNameInformation(t, childNode);\n    if (null !\u003d nameInfo) {\n        if (!ancestor.isFor() || NodeUtil.isForIn(ancestor)) {\n            // The rhs of the assignment is the caller, so it\u0027s used by the\n            // context. Don\u0027t associate it w/ the lhs.\n            // FYI: this fixes only the specific case where the assignment is the\n            // caller expression, but it could be nested deeper in the caller and\n            // we would still get a bug.\n            // See testAssignWithCall2 for an example of this.\n            recordDepScope(recordNode, nameInfo);\n        } else {\n            // Patch for assignments that appear in the init,\n            // condition or iteration part of a FOR loop.  Without\n            // this change, all 3 of those parts try to claim the for\n            // loop as their dependency scope.  The last assignment in\n            // those three fields wins, which can result in incorrect\n            // reference edges between referenced and assigned variables.\n            //\n            // TODO(user) revisit the dependency scope calculation\n            // logic.\n            if (n \u003d\u003d ancestor.getFirstChild().getNext()) {\n                recordDepScope(childNode, nameInfo);\n            } else {\n                recordDepScope(recordNode, nameInfo);\n            }\n        }\n    }\n}",
  "Closure-113": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node firstChild \u003d n.getFirstChild();\n    Node argument \u003d firstChild.getNext();\n    if (verifyLastArgumentIsString(t, firstChild, argument)) {\n        String namespaceString \u003d argument.getString();\n        ProvidedName supplied \u003d providedNames.get(namespaceString);\n        if (null !\u003d supplied \u0026\u0026 supplied.isExplicitlyProvided()) {\n            JSModule exportedModule \u003d supplied.explicitModule;\n            // This must be non-null, because there was an explicit provide.\n            Preconditions.checkNotNull(exportedModule);\n            JSModule providedUnit \u003d t.getModule();\n            if (null !\u003d moduleGraph \u0026\u0026 exportedModule !\u003d providedUnit \u0026\u0026 !moduleGraph.dependsOn(providedUnit, exportedModule)) {\n                compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, namespaceString, exportedModule.getName(), providedUnit.getName()));\n            }\n        } else {\n            unrecognizedRequires.add(new UnrecognizedRequire(n, namespaceString, t.getSourceName()));\n        }\n        maybeAddToSymbolTable(firstChild);\n        maybeAddStringNodeToSymbolTable(argument);\n        // Requires should be removed before further processing.\n        // Some clients run closure pass multiple times, first with\n        // the checks for broken requires turned off. In these cases, we\n        // allow broken requires to be preserved by the first run to\n        // let them be caught in the subsequent run.\n        if (null !\u003d supplied) {\n            parent.detachFromParent();\n            compiler.reportCodeChange();\n        }\n    }\n}",
  "Closure-112": "private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {\n    final ImmutableList\u003cTemplateType\u003e templateKeys \u003d fnType.getTemplateTypeMap().getTemplateKeys();\n    if (templateKeys.isEmpty()) {\n        return false;\n    }\n    // Try to infer the template types\n    Map\u003cTemplateType, JSType\u003e deduced \u003d inferTemplateTypesFromParameters(fnType, n);\n    // Replace all template types. If we couldn\u0027t find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer templateTypeUpdater \u003d new TemplateTypeReplacer(registry, deduced);\n    Node functionCallNode \u003d n.getFirstChild();\n    FunctionType substitutedFnType \u003d fnType.visit(templateTypeUpdater).toMaybeFunctionType();\n    Preconditions.checkNotNull(substitutedFnType);\n    functionCallNode.setJSType(substitutedFnType);\n    n.setJSType(substitutedFnType.getReturnType());\n    return templateTypeUpdater.madeChanges;\n}",
  "Closure-122": "private void handleBlockComment(Comment comment) {\n    if (-1 !\u003d comment.getValue().indexOf(\"/* @\") || -1 !\u003d comment.getValue().indexOf(\"\\n * @\")) {\n        errorReporter.warning(SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0);\n    }\n}",
  "Closure-22": "public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I\u0027ve been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we\u0027ll allow it.\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (null \u003d\u003d parent) {\n        return;\n    }\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (Token.COMMA !\u003d parent.getType()) {\n        if (Token.EXPR_RESULT !\u003d parent.getType() \u0026\u0026 Token.BLOCK !\u003d parent.getType()) {\n            if (Token.FOR !\u003d parent.getType() || 4 !\u003d parent.getChildCount() || !((parent.getFirstChild() \u003d\u003d n || parent.getFirstChild().getNext().getNext() \u003d\u003d n))) {\n                return;\n            } else {\n            }\n        }\n    } else {\n        Node ancestor \u003d parent.getParent();\n        if (ancestor.isCall() \u0026\u0026 ancestor.getFirstChild() \u003d\u003d parent) {\n            if (parent.getFirstChild() \u003d\u003d n \u0026\u0026 2 \u003d\u003d parent.getChildCount() \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        // This no-op statement was there so that JSDoc information could\n        // be attached to the name. This check should not complain about it.\n        if (parent.getLastChild() \u003d\u003d n) {\n            for (Node ancestorNode : parent.getAncestors()) {\n                int ancestorKind \u003d ancestorNode.getType();\n                if (Token.COMMA \u003d\u003d ancestorKind)\n                    continue;\n                if (Token.EXPR_RESULT !\u003d ancestorKind \u0026\u0026 Token.BLOCK !\u003d ancestorKind)\n                    return;\n                else\n                    break;\n            }\n        }\n    }\n    boolean isResultReferenced \u003d NodeUtil.isExpressionResultUsed(n);\n    boolean isBasicOperator \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultReferenced \u0026\u0026 (isBasicOperator || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n        if (!n.isQualifiedName() || null \u003d\u003d n.getJSDocInfo()) {\n            if (n.isExprResult()) {\n                return;\n            }\n        } else {\n            return;\n        }\n        String notification \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (!n.isString()) {\n            if (isBasicOperator) {\n                notification \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n            }\n        } else {\n            notification \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, notification));\n        // TODO(johnlenz): determine if it is necessary to\n        // try to protect side-effect free statements as well.\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}",
  "Closure-121": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n    int referenceCount \u003d referenceInfo.references.size();\n    Reference definition \u003d referenceInfo.references.get(0);\n    Reference initializationReference \u003d referenceInfo.getInitializingReference();\n    int firstReferenceAfterInitialization \u003d (initializationReference \u003d\u003d definition) ? 2 : 3;\n    if (1 \u003e\u003d referenceCount || !isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        if (firstReferenceAfterInitialization !\u003d referenceCount) {\n            if (initializationReference !\u003d definition \u0026\u0026 2 \u003d\u003d referenceCount) {\n                if (isValidDeclaration(definition) \u0026\u0026 isValidInitialization(initializationReference)) {\n                    // The only reference is the initialization, remove the assignment and\n                    // the variable declaration.\n                    Node nodeValue \u003d initializationReference.getAssignedValue();\n                    Preconditions.checkNotNull(nodeValue);\n                    inlineWellDefinedVariable(v, nodeValue, referenceInfo.references);\n                    staleVars.add(v);\n                }\n            }\n        } else {\n            // The variable likely only read once, try some more\n            // complex inlining heuristics.\n            Reference refCollection \u003d referenceInfo.references.get(firstReferenceAfterInitialization - 1);\n            if (canInline(definition, initializationReference, refCollection)) {\n                inline(v, definition, initializationReference, refCollection);\n                staleVars.add(v);\n            }\n        }\n    } else {\n        // if the variable is referenced more than once, we can only\n        // inline it if it\u0027s immutable and never defined before referenced.\n        Node nodeValue;\n        if (null \u003d\u003d initializationReference) {\n            // Create a new node for variable that is never initialized.\n            Node sourceLocation \u003d definition.getNode();\n            nodeValue \u003d NodeUtil.newUndefinedNode(sourceLocation);\n        } else {\n            nodeValue \u003d initializationReference.getAssignedValue();\n        }\n        Preconditions.checkNotNull(nodeValue);\n        inlineWellDefinedVariable(v, nodeValue, referenceInfo.references);\n        staleVars.add(v);\n    }\n    // If this variable was not inlined normally, check if we can\n    // inline an alias of it. (If the variable was inlined, then the\n    // reference data is out of sync. We\u0027re better off just waiting for\n    // the next pass.)\n    if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n        // Inlining the variable based solely on well-defined and assigned\n        // once is *NOT* correct. We relax the correctness requirement if\n        // the variable is declared constant.\n        List\u003cReference\u003e references \u003d referenceInfo.references;\n        int j \u003d 1;\n        while (references.size() \u003e j) {\n            Node nodeReference \u003d references.get(j).getNode();\n            if (aliasCandidates.containsKey(nodeReference)) {\n                AliasCandidate aliasOption \u003d aliasCandidates.get(nodeReference);\n                if (!staleVars.contains(aliasOption.alias) \u0026\u0026 !isVarInlineForbidden(aliasOption.alias)) {\n                    Reference aliasInitialization;\n                    aliasInitialization \u003d aliasOption.refInfo.getInitializingReference();\n                    Node nodeValue \u003d aliasInitialization.getAssignedValue();\n                    Preconditions.checkNotNull(nodeValue);\n                    inlineWellDefinedVariable(aliasOption.alias, nodeValue, aliasOption.refInfo.references);\n                    staleVars.add(aliasOption.alias);\n                }\n            }\n            j +\u003d 1;\n        }\n    }\n}",
  "Closure-23": "private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node ancestor \u003d n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can\u0027t fold it here:\n    //    \"[][0] +\u003d 1\"\n    if (isAssignmentTarget(n)) {\n        return n;\n    }\n    if (!right.isNumber()) {\n        // Sometimes people like to use complex expressions to index into\n        // arrays, or strings to index into array methods.\n        return n;\n    }\n    double elementIndex \u003d right.getDouble();\n    int arrayIndex \u003d (int) elementIndex;\n    if (elementIndex !\u003d arrayIndex) {\n        error(INVALID_GETELEM_INDEX_ERROR, right);\n        return n;\n    }\n    if (0 \u003e arrayIndex) {\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n        return n;\n    }\n    Node node \u003d left.getFirstChild();\n    Node item \u003d null;\n    int i \u003d 0;\n    while (null !\u003d node \u0026\u0026 arrayIndex \u003e i) {\n        item \u003d node;\n        node \u003d node.getNext();\n        i +\u003d 1;\n    }\n    if (null \u003d\u003d item) {\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n        return n;\n    }\n    if (!item.isEmpty()) {\n        left.removeChild(item);\n    } else {\n        item \u003d NodeUtil.newUndefinedNode(item);\n    }\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, item);\n    reportCodeChange();\n    return item;\n}",
  "Closure-120": "boolean isAssignedOnceInLifetime() {\n    Reference assignmentRef \u003d getOneAndOnlyAssignment();\n    if (null \u003d\u003d assignmentRef) {\n        return false;\n    }\n    BasicBlock basicBlock \u003d assignmentRef.getBasicBlock();\n    while (null !\u003d basicBlock) {\n        if (!(basicBlock.isFunction)) {\n            if (basicBlock.isLoop) {\n                return false;\n            }\n        } else {\n            break;\n        }\n        basicBlock \u003d basicBlock.getParent();\n    }\n    return true;\n}",
  "Closure-20": "private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node functionName \u003d n.getFirstChild();\n    if (null !\u003d functionName \u0026\u0026 functionName.isName() \u0026\u0026 functionName.getString().equals(\"String\")) {\n        // Fold String(a) to \u0027\u0027 + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can\u0027t do this in the general case, because String(a) has\n        // slightly different semantics than \u0027\u0027 + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id\u003d759\n        Node literal \u003d functionName.getNext();\n        if (null !\u003d literal) {\n            Node concatenation \u003d IR.add(IR.string(\"\").srcref(functionName), literal.detachFromParent());\n            n.getParent().replaceChild(n, concatenation);\n            reportCodeChange();\n            return concatenation;\n        }\n    }\n    return n;\n}",
  "Codec-10": "public String caverphone(String txt) {\n    // NOTE: Version 1.0 of Caverphone is easily derivable from this code\n    // by commenting out the 2.0 lines and adding in the 1.0 lines\n    if (null \u003d\u003d txt || 0 \u003d\u003d txt.length()) {\n        return \"1111111111\";\n    }\n    // 1. Convert to lowercase\n    txt \u003d txt.toLowerCase(java.util.Locale.ENGLISH);\n    // 2. Remove anything not A-Z\n    txt \u003d txt.replaceAll(\"[^a-z]\", \"\");\n    // 2.5. Remove final e\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"e$\", \"\");\n    // 3. Handle various start options\n    txt \u003d txt.replaceAll(\"^cough\", \"cou2f\");\n    txt \u003d txt.replaceAll(\"^rough\", \"rou2f\");\n    txt \u003d txt.replaceAll(\"^tough\", \"tou2f\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"^enough\", \"enou2f\");\n    // 2.0 only - note the spec says ^enough here again, c+p error I assume\n    txt \u003d txt.replaceAll(\"^trough\", \"trou2f\");\n    txt \u003d txt.replaceAll(\"^gn\", \"2n\");\n    // End\n    txt \u003d txt.replaceAll(\"^mb\", \"m2\");\n    // 4. Handle replacements\n    txt \u003d txt.replaceAll(\"cq\", \"2q\");\n    txt \u003d txt.replaceAll(\"ci\", \"si\");\n    txt \u003d txt.replaceAll(\"ce\", \"se\");\n    txt \u003d txt.replaceAll(\"cy\", \"sy\");\n    txt \u003d txt.replaceAll(\"tch\", \"2ch\");\n    txt \u003d txt.replaceAll(\"c\", \"k\");\n    txt \u003d txt.replaceAll(\"q\", \"k\");\n    txt \u003d txt.replaceAll(\"x\", \"k\");\n    txt \u003d txt.replaceAll(\"v\", \"f\");\n    txt \u003d txt.replaceAll(\"dg\", \"2g\");\n    txt \u003d txt.replaceAll(\"tio\", \"sio\");\n    txt \u003d txt.replaceAll(\"tia\", \"sia\");\n    txt \u003d txt.replaceAll(\"d\", \"t\");\n    txt \u003d txt.replaceAll(\"ph\", \"fh\");\n    txt \u003d txt.replaceAll(\"b\", \"p\");\n    txt \u003d txt.replaceAll(\"sh\", \"s2\");\n    txt \u003d txt.replaceAll(\"z\", \"s\");\n    txt \u003d txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt \u003d txt.replaceAll(\"[aeiou]\", \"3\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"j\", \"y\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"^y3\", \"Y3\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"^y\", \"A\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"y\", \"3\");\n    txt \u003d txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt \u003d txt.replaceAll(\"gh\", \"22\");\n    txt \u003d txt.replaceAll(\"g\", \"k\");\n    txt \u003d txt.replaceAll(\"s+\", \"S\");\n    txt \u003d txt.replaceAll(\"t+\", \"T\");\n    txt \u003d txt.replaceAll(\"p+\", \"P\");\n    txt \u003d txt.replaceAll(\"k+\", \"K\");\n    txt \u003d txt.replaceAll(\"f+\", \"F\");\n    txt \u003d txt.replaceAll(\"m+\", \"M\");\n    txt \u003d txt.replaceAll(\"n+\", \"N\");\n    txt \u003d txt.replaceAll(\"w3\", \"W3\");\n    //txt \u003d txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n    txt \u003d txt.replaceAll(\"wh3\", \"Wh3\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"w$\", \"3\");\n    //txt \u003d txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n    txt \u003d txt.replaceAll(\"w\", \"2\");\n    txt \u003d txt.replaceAll(\"^h\", \"A\");\n    txt \u003d txt.replaceAll(\"h\", \"2\");\n    txt \u003d txt.replaceAll(\"r3\", \"R3\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"r$\", \"3\");\n    //txt \u003d txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n    txt \u003d txt.replaceAll(\"r\", \"2\");\n    txt \u003d txt.replaceAll(\"l3\", \"L3\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"l$\", \"3\");\n    //txt \u003d txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n    txt \u003d txt.replaceAll(\"l\", \"2\");\n    //txt \u003d txt.replaceAll(\"j\", \"y\");      // 1.0 only\n    //txt \u003d txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n    //txt \u003d txt.replaceAll(\"y\", \"2\");      // 1.0 only\n    // 5. Handle removals\n    txt \u003d txt.replaceAll(\"2\", \"\");\n    // 2.0 only\n    txt \u003d txt.replaceAll(\"3$\", \"A\");\n    txt \u003d txt.replaceAll(\"3\", \"\");\n    // 6. put ten 1s on the end\n    // 1.0 only has 6 1s\n    txt \u003d txt + \"111111\" + \"1111\";\n    // 7. take the first six characters as the code\n    // 1.0 truncates to 6\n    return txt.substring(0, 10);\n}",
  "Closure-21": "public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I\u0027ve been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we\u0027ll allow it.\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (null \u003d\u003d parent) {\n        return;\n    }\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n        return;\n    }\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() \u0026\u0026 null !\u003d n.getJSDocInfo()) {\n        return;\n    }\n    boolean isExpressionResultUtilized \u003d NodeUtil.isExpressionResultUsed(n);\n    boolean isBasicOperator \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (Token.COMMA !\u003d parent.getType()) {\n        if (Token.EXPR_RESULT !\u003d parent.getType() \u0026\u0026 Token.BLOCK !\u003d parent.getType()) {\n            if (!(Token.FOR \u003d\u003d parent.getType() \u0026\u0026 4 \u003d\u003d parent.getChildCount() \u0026\u0026 (parent.getFirstChild() \u003d\u003d n || parent.getFirstChild().getNext().getNext() \u003d\u003d n))) {\n                return;\n            }\n        }\n    } else {\n        if (isExpressionResultUtilized) {\n            return;\n        }\n        if (parent.getLastChild() \u003d\u003d n) {\n            for (Node ancestorNode : parent.getAncestors()) {\n                int ancestorCategory \u003d ancestorNode.getType();\n                if (Token.COMMA \u003d\u003d ancestorCategory)\n                    continue;\n                if (Token.EXPR_RESULT !\u003d ancestorCategory \u0026\u0026 Token.BLOCK !\u003d ancestorCategory)\n                    return;\n                else\n                    break;\n            }\n        }\n    }\n    if ((isBasicOperator || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n        String message \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (!n.isString()) {\n            if (isBasicOperator) {\n                message \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n            }\n        } else {\n            message \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, message));\n        // TODO(johnlenz): determine if it is necessary to\n        // try to protect side-effect free statements as well.\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}",
  "Closure-24": "private void findAliases(NodeTraversal t) {\n    Scope context \u003d t.getScope();\n    for (Var variable : context.getVarIterable()) {\n        Node node \u003d variable.getNode();\n        int category \u003d node.getType();\n        Node ancestor \u003d node.getParent();\n        if (ancestor.isVar()) {\n            if (!node.hasChildren() || !node.getFirstChild().isQualifiedName()) {\n                // TODO(robbyw): Support using locals for private variables.\n                report(t, node, GOOG_SCOPE_NON_ALIAS_LOCAL, node.getString());\n            } else {\n                String identifier \u003d node.getString();\n                Var alternativeVar \u003d context.getVar(identifier);\n                aliases.put(identifier, alternativeVar);\n                String fullyQualifiedName \u003d alternativeVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(identifier, fullyQualifiedName);\n                // Bleeding functions already get a BAD_PARAMETERS error, so just\n                // do nothing.\n                // Parameters of the scope function also get a BAD_PARAMETERS\n                // error.\n            }\n        }\n    }\n}",
  "Closure-25": "private FlowScope traverseNew(Node n, FlowScope scope) {\n    Node initializer \u003d n.getFirstChild();\n    scope \u003d traverse(initializer, scope);\n    JSType builderType \u003d initializer.getJSType();\n    JSType dataType \u003d null;\n    if (null !\u003d builderType) {\n        builderType \u003d builderType.restrictByNotNullOrUndefined();\n        if (!builderType.isUnknownType()) {\n            FunctionType funcType \u003d builderType.toMaybeFunctionType();\n            if (null \u003d\u003d funcType \u0026\u0026 builderType instanceof FunctionType) {\n                // If constructorType is a NoObjectType, then toMaybeFunctionType will\n                // return null. But NoObjectType implements the FunctionType\n                // interface, precisely because it can validly construct objects.\n                funcType \u003d (FunctionType) builderType;\n            }\n            if (null !\u003d funcType \u0026\u0026 funcType.isConstructor()) {\n                dataType \u003d funcType.getInstanceType();\n            }\n        } else {\n            dataType \u003d getNativeType(UNKNOWN_TYPE);\n        }\n    }\n    n.setJSType(dataType);\n    Node parameter \u003d initializer.getNext();\n    while (null !\u003d parameter) {\n        scope \u003d traverse(parameter, scope);\n        parameter \u003d parameter.getNext();\n    }\n    return scope;\n}",
  "Codec-17": "public static String newStringIso8859_1(final byte[] bytes) {\n    return new String(bytes, Charsets.ISO_8859_1);\n}",
  "Codec-18": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs2 \u003d\u003d cs1) {\n        return true;\n    }\n    if (null \u003d\u003d cs1 || null \u003d\u003d cs2) {\n        return false;\n    }\n    if (cs1 instanceof String \u0026\u0026 cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}",
  "Closure-29": "private boolean isInlinableObject(List\u003cReference\u003e refs) {\n    boolean isInlinable \u003d false;\n    for (Reference reference : refs) {\n        Node identifier \u003d reference.getNode();\n        Node guardian \u003d reference.getParent();\n        Node ancestor \u003d reference.getGrandparent();\n        // Ignore indirect references, like x.y (except x.y(), since\n        // the function referenced by y might reference \u0027this\u0027).\n        //\n        if (guardian.isGetProp()) {\n            Preconditions.checkState(identifier \u003d\u003d guardian.getFirstChild());\n            // A call target maybe using the object as a \u0027this\u0027 value.\n            if (ancestor.isCall() \u0026\u0026 guardian \u003d\u003d ancestor.getFirstChild()) {\n                return false;\n            }\n            // NOTE(nicksantos): This pass\u0027s object-splitting algorithm has\n            // a blind spot. It assumes that if a property isn\u0027t defined on an\n            // object, then the value is undefined. This is not true, because\n            // Object.prototype can have arbitrary properties on it.\n            //\n            // We short-circuit this problem by bailing out if we see a reference\n            // to a property that isn\u0027t defined on the object literal. This\n            // isn\u0027t a perfect algorithm, but it should catch most cases.\n            continue;\n        }\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(identifier)) {\n            return false;\n        }\n        Node nodeValue \u003d reference.getAssignedValue();\n        if (null \u003d\u003d nodeValue) {\n            // A var with no assignment.\n            continue;\n        }\n        // We\u0027re looking for object literal assignments only.\n        if (!nodeValue.isObjectLit()) {\n            return false;\n        }\n        Node descendant \u003d nodeValue.getFirstChild();\n        while (null !\u003d descendant) {\n            if (descendant.isGetterDef() || descendant.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n            Node descendantValue \u003d descendant.getFirstChild();\n            // Check if childVal is the parent of any of the passed in\n            // references, as that is how self-referential assignments\n            // will happen.\n            for (Reference referenceNode : refs) {\n                Node referencedNode \u003d referenceNode.getParent();\n                while (!NodeUtil.isStatementBlock(referencedNode)) {\n                    if (descendantValue \u003d\u003d referencedNode) {\n                        // There\u0027s a self-referential assignment\n                        return false;\n                    }\n                    referencedNode \u003d referencedNode.getParent();\n                }\n            }\n            descendant \u003d descendant.getNext();\n        }\n        // Make sure that the value is not self-refential. IOW,\n        // disallow things like x \u003d {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x \u003d {a: x.b, b: x.a} is not orderable,\n        // but x \u003d {a: 1, b: x.a} is.\n        //\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        isInlinable \u003d true;\n    }\n    return isInlinable;\n}",
  "Codec-7": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}",
  "Codec-9": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (null \u003d\u003d binaryData || 0 \u003d\u003d binaryData.length) {\n        return binaryData;\n    }\n    long length \u003d getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (maxResultSize \u003c length) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + length + \") than the specified maxium size of \" + maxResultSize);\n    }\n    Base64 base64Encoder \u003d isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return base64Encoder.encode(binaryData);\n}",
  "Codec-15": "private char getMappingCode(final String str, final int index) {\n    // map() throws IllegalArgumentException\n    final char mappedCharacter \u003d this.map(str.charAt(index));\n    // HW rule check\n    if (1 \u003c index \u0026\u0026 \u00270\u0027 !\u003d mappedCharacter) {\n        final char prevChar \u003d str.charAt(index - 1);\n        if (prevChar \u003d\u003d \u0027H\u0027 || prevChar \u003d\u003d \u0027W\u0027) {\n            final char previousChar \u003d str.charAt(index - 2);\n            final char initialCode \u003d this.map(previousChar);\n            if (mappedCharacter \u003d\u003d initialCode || previousChar \u003d\u003d \u0027H\u0027 || previousChar \u003d\u003d \u0027W\u0027) {\n                return 0;\n            }\n        }\n    }\n    return mappedCharacter;\n}",
  "Mockito-34": "public void captureArgumentsFrom(Invocation i) {\n    int index \u003d 0;\n    for (Matcher matcher : matchers) {\n        if (matcher instanceof CapturesArguments) {\n            ((CapturesArguments) matcher).captureFrom(i.getArguments()[index]);\n        }\n        index +\u003d 1;\n    }\n}",
  "Mockito-36": "public Object callRealMethod() throws Throwable {\n    return realMethod.invoke(mock, rawArguments);\n}",
  "Mockito-37": "public void validate(Answer\u003c?\u003e answer, Invocation invocation) {\n    if (answer instanceof ThrowsException) {\n        validateException((ThrowsException) answer, invocation);\n    }\n    if (answer instanceof Returns) {\n        validateReturnValue((Returns) answer, invocation);\n    }\n    if (answer instanceof DoesNothing) {\n        validateDoNothing((DoesNothing) answer, invocation);\n    }\n}",
  "Mockito-31": "private String formatMethodCall() {\n    return invocation.getMethod().getName() + \"()\";\n}",
  "Mockito-32": "@SuppressWarnings(\"deprecation\")\npublic void process(Class\u003c?\u003e context, Object testClass) {\n    Field[] members \u003d context.getDeclaredFields();\n    for (Field member : members) {\n        if (member.isAnnotationPresent(Spy.class)) {\n            assertNoAnnotations(Spy.class, member, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n            boolean wasAccessibleBefore \u003d member.isAccessible();\n            member.setAccessible(true);\n            try {\n                Object object \u003d member.get(testClass);\n                if (null \u003d\u003d object) {\n                    throw new MockitoException(\"Cannot create a @Spy for \u0027\" + member.getName() + \"\u0027 field because the *instance* is missing\\n\" + \"The instance must be created *before* initMocks();\\n\" + \"Example of correct usage of @Spy:\\n\" + \"   @Spy List mock \u003d new LinkedList();\\n\" + \"   //also, don\u0027t forget about MockitoAnnotations.initMocks();\");\n                }\n                if (!new MockUtil().isMock(object)) {\n                    member.set(testClass, Mockito.spy(object));\n                } else {\n                    // instance has been spied earlier\n                    Mockito.reset(object);\n                }\n            } catch (IllegalAccessException e) {\n                throw new MockitoException(\"Problems initiating spied field \" + member.getName(), e);\n            } finally {\n                member.setAccessible(wasAccessibleBefore);\n            }\n        }\n    }\n}",
  "Mockito-33": "public boolean hasSameMethod(Invocation candidate) {\n    //not using method.equals() for 1 good reason:\n    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method method1 \u003d invocation.getMethod();\n    Method method2 \u003d candidate.getMethod();\n    /* Avoid unnecessary cloning */\n    return method1.equals(method2);\n}",
  "Closure-129": "private void annotateCalls(Node n) {\n    Preconditions.checkState(n.isCall());\n    // Keep track of of the \"this\" context of a call.  A call without an\n    // explicit \"this\" is a free call.\n    Node initial \u003d n.getFirstChild();\n    // ignore cast nodes.\n    if (!NodeUtil.isGet(initial)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n    }\n    // Keep track of the context in which eval is called. It is important\n    // to distinguish between \"(0, eval)()\" and \"eval()\".\n    if (initial.isName() \u0026\u0026 \"eval\".equals(initial.getString())) {\n        initial.putBooleanProp(Node.DIRECT_EVAL, true);\n    }\n}",
  "Closure-70": "private void declareArguments(Node functionNode) {\n    Node paramList \u003d functionNode.getFirstChild().getNext();\n    Node codeBlock \u003d paramList.getNext();\n    FunctionType methodType \u003d (FunctionType) functionNode.getJSType();\n    if (null !\u003d methodType) {\n        Node docParameters \u003d methodType.getParametersNode();\n        if (null !\u003d docParameters) {\n            Node docParameterNode \u003d docParameters.getFirstChild();\n            for (Node paramNode : paramList.children()) {\n                if (null \u003d\u003d docParameterNode) {\n                    defineSlot(paramNode, functionNode, null, true);\n                } else {\n                    defineSlot(paramNode, functionNode, docParameterNode.getJSType(), true);\n                    docParameterNode \u003d docParameterNode.getNext();\n                }\n            }\n        }\n    }\n}",
  "Closure-128": "static boolean isSimpleNumber(String s) {\n    int length \u003d s.length();\n    int i \u003d 0;\n    while (length \u003e i) {\n        char digit \u003d s.charAt(i);\n        if (\u00270\u0027 \u003e digit || \u00279\u0027 \u003c digit) {\n            return false;\n        }\n        i +\u003d 1;\n    }\n    return 0 \u003c length \u0026\u0026 \u00270\u0027 !\u003d s.charAt(0);\n}",
  "Closure-126": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an \u0027exit\u0027.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an \u0027if\u0027.\n    if (n.isIf()) {\n        Node conditionalBlock \u003d n.getFirstChild().getNext();\n        tryMinimizeExits(conditionalBlock, exitType, labelName);\n        Node alternativeBlock \u003d conditionalBlock.getNext();\n        if (null !\u003d alternativeBlock) {\n            tryMinimizeExits(alternativeBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a \u0027try/catch/finally\u0027.\n    if (n.isTry()) {\n        Node executionBlock \u003d n.getFirstChild();\n        tryMinimizeExits(executionBlock, exitType, labelName);\n        Node catchBlockNodes \u003d NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(catchBlockNodes)) {\n            Preconditions.checkState(catchBlockNodes.hasOneChild());\n            Node exceptionNode \u003d catchBlockNodes.getFirstChild();\n            Node catchBlockCode \u003d exceptionNode.getLastChild();\n            tryMinimizeExits(catchBlockCode, exitType, labelName);\n        }\n        /* Don\u0027t try to minimize the exits of finally blocks, as this\n     * can cause problems if it changes the completion type of the finally\n     * block. See ECMA 262 Sections 8.9 \u0026 12.14\n     */\n        if (NodeUtil.hasFinally(n)) {\n            Node finalBlock \u003d n.getLastChild();\n            tryMinimizeExits(finalBlock, exitType, labelName);\n        }\n    }\n    // Just a \u0027label\u0027.\n    if (n.isLabel()) {\n        Node exitBlock \u003d n.getLastChild();\n        tryMinimizeExits(exitBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || null \u003d\u003d n.getLastChild()) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah \u0026\u0026 !blah2) { other_stmt; }\".\n    for (Node childNode : n.children()) {\n        // An \u0027if\u0027 block to process below.\n        if (childNode.isIf()) {\n            Node ifNode \u003d childNode;\n            Node successBlock, falseBlock;\n            // First, the true condition block.\n            successBlock \u003d ifNode.getFirstChild().getNext();\n            falseBlock \u003d successBlock.getNext();\n            tryMinimizeIfBlockExits(successBlock, falseBlock, ifNode, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            successBlock \u003d ifNode.getFirstChild().getNext();\n            falseBlock \u003d successBlock.getNext();\n            if (null !\u003d falseBlock) {\n                tryMinimizeIfBlockExits(falseBlock, successBlock, ifNode, exitType, labelName);\n            }\n        }\n        if (n.getLastChild() \u003d\u003d childNode) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node childNode \u003d n.getLastChild(); null !\u003d childNode; childNode \u003d n.getLastChild()) {\n        tryMinimizeExits(childNode, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (n.getLastChild() \u003d\u003d childNode) {\n            break;\n        }\n    }\n}",
  "Closure-73": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() + 2);\n    stringBuilder.append(quote);\n    int index \u003d 0;\n    while (s.length() \u003e index) {\n        char character \u003d s.charAt(index);\n        switch(character) {\n            case \u0027\\0\u0027:\n                stringBuilder.append(\"\\\\0\");\n                break;\n            case \u0027\\n\u0027:\n                stringBuilder.append(\"\\\\n\");\n                break;\n            case \u0027\\r\u0027:\n                stringBuilder.append(\"\\\\r\");\n                break;\n            case \u0027\\t\u0027:\n                stringBuilder.append(\"\\\\t\");\n                break;\n            case \u0027\\\\\u0027:\n                stringBuilder.append(backslashEscape);\n                break;\n            case \u0027\\\"\u0027:\n                stringBuilder.append(doublequoteEscape);\n                break;\n            case \u0027\\\u0027\u0027:\n                stringBuilder.append(singlequoteEscape);\n                break;\n            case // Break --\u003e into --\\\u003e or ]]\u003e into ]]\\\u003e\n            \u0027\u003e\u0027:\n                if (2 \u003e index || !(((\u0027-\u0027 \u003d\u003d s.charAt(index - 1) \u0026\u0026 \u0027-\u0027 \u003d\u003d s.charAt(index - 2)) || (\u0027]\u0027 \u003d\u003d s.charAt(index - 1) \u0026\u0026 \u0027]\u0027 \u003d\u003d s.charAt(index - 2))))) {\n                    stringBuilder.append(character);\n                } else {\n                    stringBuilder.append(\"\\\\\u003e\");\n                }\n                break;\n            case \u0027\u003c\u0027:\n                // Break \u003c/script into \u003c\\/script\n                final String SCRIPT_END \u003d \"/script\";\n                // Break \u003c!-- into \u003c\\!--\n                final String START_COMMENT \u003d \"!--\";\n                if (!s.regionMatches(true, index + 1, SCRIPT_END, 0, SCRIPT_END.length())) {\n                    if (!s.regionMatches(false, index + 1, START_COMMENT, 0, START_COMMENT.length())) {\n                        stringBuilder.append(character);\n                    } else {\n                        stringBuilder.append(\"\u003c\\\\\");\n                    }\n                } else {\n                    stringBuilder.append(\"\u003c\\\\\");\n                }\n                break;\n            default:\n                // If we\u0027re given an outputCharsetEncoder, then check if the\n                //  character can be represented in this character set.\n                if (null \u003d\u003d outputCharsetEncoder) {\n                    // No charsetEncoder provided - pass straight latin characters\n                    // through, and escape the rest.  Doing the explicit character\n                    // check is measurably faster than using the CharsetEncoder.\n                    if (0x1f \u003e\u003d character || 0x7f \u003c character) {\n                        // Other characters can be misinterpreted by some js parsers,\n                        // or perhaps mangled by proxies along the way,\n                        // so we play it safe and unicode escape them.\n                        appendHexJavaScriptRepresentation(stringBuilder, character);\n                    } else {\n                        stringBuilder.append(character);\n                    }\n                } else {\n                    if (!outputCharsetEncoder.canEncode(character)) {\n                        // Unicode-escape the character.\n                        appendHexJavaScriptRepresentation(stringBuilder, character);\n                    } else {\n                        stringBuilder.append(character);\n                    }\n                }\n        }\n        index +\u003d 1;\n    }\n    stringBuilder.append(quote);\n    return stringBuilder.toString();\n}",
  "Mockito-38": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg.toString());\n}",
  "Closure-125": "private void visitNew(NodeTraversal t, Node n) {\n    Node initializer \u003d n.getFirstChild();\n    JSType classification \u003d getJSType(initializer).restrictByNotNullOrUndefined();\n    if (!classification.isConstructor() \u0026\u0026 !classification.isEmptyType() \u0026\u0026 !classification.isUnknownType()) {\n        report(t, n, NOT_A_CONSTRUCTOR);\n        ensureTyped(t, n);\n    } else {\n        FunctionType functionType \u003d classification.toMaybeFunctionType();\n        if (null \u003d\u003d functionType) {\n            ensureTyped(t, n);\n        } else {\n            visitParameterList(t, n, functionType);\n            ensureTyped(t, n, functionType.getInstanceType());\n        }\n    }\n}",
  "Closure-124": "private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n        return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n    node \u003d node.getFirstChild();\n    if (node.isName() \u0026\u0026 isNameAssignedTo(node.getString(), replacement)) {\n        return false;\n    }\n    return true;\n}",
  "Closure-71": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType typeOfObject \u003d ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String fieldName \u003d getprop.getLastChild().getString();\n    if (null !\u003d typeOfObject) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverriding \u003d t.inGlobalScope() \u0026\u0026 Token.ASSIGN \u003d\u003d parent.getType() \u0026\u0026 getprop \u003d\u003d parent.getFirstChild();\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverriding) {\n            typeOfObject \u003d typeOfObject.getImplicitPrototype();\n        }\n        JSDocInfo jsDocDetails \u003d null;\n        while (null !\u003d typeOfObject) {\n            jsDocDetails \u003d typeOfObject.getOwnPropertyJSDocInfo(fieldName);\n            if (null !\u003d jsDocDetails \u0026\u0026 Visibility.INHERITED !\u003d jsDocDetails.getVisibility()) {\n                break;\n            }\n            typeOfObject \u003d typeOfObject.getImplicitPrototype();\n        }\n        if (null \u003d\u003d typeOfObject) {\n            // We couldn\u0027t find a visibility modifier; assume it\u0027s public.\n            return;\n        }\n        boolean isSameInput \u003d t.getInput().getName().equals(jsDocDetails.getSourceName());\n        Visibility accessibility \u003d jsDocDetails.getVisibility();\n        JSType classType \u003d normalizeClassType(typeOfObject);\n        if (!isOverriding) {\n            if (!isSameInput) {\n                if (Visibility.PRIVATE !\u003d accessibility || !((null \u003d\u003d currentClass || classType.differsFrom(currentClass)))) {\n                    if (Visibility.PROTECTED \u003d\u003d accessibility) {\n                        // There are 3 types of legal accesses of a protected property:\n                        // 1) Accesses in the same file\n                        // 2) Overriding the property in a subclass\n                        // 3) Accessing the property from inside a subclass\n                        // The first two have already been checked for.\n                        if (null \u003d\u003d currentClass || !currentClass.isSubtype(classType)) {\n                            compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, fieldName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                        }\n                    }\n                } else {\n                    if (jsDocDetails.isConstructor() \u0026\u0026 isValidPrivateConstructorAccess(parent)) {\n                        return;\n                    }\n                    // private access is not allowed outside the file from a different\n                    // enclosing class.\n                    compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, fieldName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            } else {\n                // private access is always allowed in the same file.\n                return;\n            }\n        } else {\n            // Check an ASSIGN statement that\u0027s trying to override a property\n            // on a superclass.\n            JSDocInfo overridingDocInfo \u003d parent.getJSDocInfo();\n            Visibility overridingAccessLevel \u003d null \u003d\u003d overridingDocInfo ? Visibility.INHERITED : overridingDocInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (Visibility.PRIVATE !\u003d accessibility || isSameInput) {\n                if (Visibility.INHERITED !\u003d overridingAccessLevel \u0026\u0026 accessibility !\u003d overridingAccessLevel) {\n                    compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, accessibility.name(), typeOfObject.toString(), overridingAccessLevel.name()));\n                }\n            } else {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, typeOfObject.toString()));\n            }\n        }\n    }\n}",
  "Closure-123": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int kind \u003d n.getType();\n    String operatorString \u003d NodeUtil.opToStr(kind);\n    int numChildren \u003d n.getChildCount();\n    Node child \u003d n.getFirstChild();\n    Node finalChild \u003d n.getLastChild();\n    // Handle all binary operators\n    if (null !\u003d operatorString \u0026\u0026 finalChild !\u003d child) {\n        Preconditions.checkState(2 \u003d\u003d numChildren, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", operatorString, numChildren);\n        int operatorPrecedence \u003d NodeUtil.precedence(kind);\n        // For right-hand-side of operations, only pass context if it\u0027s\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rightSideContext \u003d getContextForNoInOperator(context);\n        // Handle associativity.\n        // e.g. if the parse tree is a * (b * c),\n        // we can simply generate a * b * c.\n        if (kind !\u003d finalChild.getType() || !NodeUtil.isAssociative(kind)) {\n            if (!NodeUtil.isAssignmentOp(n) || !NodeUtil.isAssignmentOp(finalChild)) {\n                unrollBinaryOperator(n, kind, operatorString, context, rightSideContext, operatorPrecedence, operatorPrecedence + 1);\n            } else {\n                // Assignments are the only right-associative binary operators\n                addExpr(child, operatorPrecedence, context);\n                cc.addOp(operatorString, true);\n                addExpr(finalChild, operatorPrecedence, rightSideContext);\n            }\n        } else {\n            addExpr(child, operatorPrecedence, context);\n            cc.addOp(operatorString, true);\n            addExpr(finalChild, operatorPrecedence, rightSideContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(kind) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(child.getNext().isBlock() \u0026\u0026 !child.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(2 \u003c\u003d numChildren \u0026\u0026 3 \u003e\u003d numChildren);\n                add(\"try\");\n                add(child, Context.PRESERVE_BLOCK);\n                // second child contains the catch block, or nothing if there\n                // isn\u0027t a catch block\n                Node catchClause \u003d child.getNext().getFirstChild();\n                if (null !\u003d catchClause) {\n                    add(catchClause);\n                }\n                if (3 \u003d\u003d numChildren) {\n                    add(\"finally\");\n                    add(finalChild, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            add(\"catch(\");\n            add(child);\n            add(\")\");\n            add(finalChild, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(1 \u003d\u003d numChildren);\n            add(\"throw\");\n            add(child);\n            // Must have a \u0027;\u0027 after a throw statement, otherwise safari can\u0027t\n            // parse this.\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (1 !\u003d numChildren) {\n                Preconditions.checkState(0 \u003d\u003d numChildren);\n            } else {\n                add(child);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (null !\u003d child) {\n                add(\"var \");\n                addList(child, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (null !\u003d child \u0026\u0026 !child.isEmpty()) {\n                Preconditions.checkState(1 \u003d\u003d numChildren);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (!child.isComma()) {\n                    // Add expression, consider nearby code at lowest level of\n                    // precedence.\n                    addExpr(child, 0, getContextForNoInOperator(context));\n                } else {\n                    addExpr(child, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                }\n            } else {\n                addIdentifier(n.getString());\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(child);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(child);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                // All of these unary operators are right-associative\n                Preconditions.checkState(1 \u003d\u003d numChildren);\n                cc.addOp(NodeUtil.opToStrNoFail(kind), false);\n                addExpr(child, NodeUtil.precedence(kind), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(1 \u003d\u003d numChildren);\n                // It\u0027s important to our sanity checker that the code\n                // we print produces the same AST as the code we parse back.\n                // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n                if (!n.getFirstChild().isNumber()) {\n                    cc.addOp(NodeUtil.opToStrNoFail(kind), false);\n                    addExpr(child, NodeUtil.precedence(kind), Context.OTHER);\n                } else {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(3 \u003d\u003d numChildren);\n                int operatorPrecedence \u003d NodeUtil.precedence(kind);\n                Context rightSideContext \u003d Context.OTHER;\n                addExpr(child, operatorPrecedence + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(child.getNext(), 1, rightSideContext);\n                cc.addOp(\":\", true);\n                addExpr(finalChild, 1, rightSideContext);\n                break;\n            }\n        case Token.REGEXP:\n            if (!child.isString() || !finalChild.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String pattern \u003d regexpEscape(child.getString(), outputCharsetEncoder);\n            // I only use one .add because whitespace matters\n            if (2 !\u003d numChildren) {\n                Preconditions.checkState(1 \u003d\u003d numChildren);\n                add(pattern);\n            } else {\n                add(pattern + finalChild.getString());\n            }\n            break;\n        case Token.FUNCTION:\n            if (Node.class !\u003d n.getClass()) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(3 \u003d\u003d numChildren);\n            boolean needsParentheses \u003d (Context.START_OF_EXPR \u003d\u003d context);\n            if (needsParentheses) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(child);\n            add(child.getNext());\n            add(finalChild, Context.PRESERVE_BLOCK);\n            cc.endFunction(Context.STATEMENT \u003d\u003d context);\n            if (needsParentheses) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(1 \u003d\u003d numChildren);\n            Preconditions.checkState(child.isFunction());\n            // Get methods are unnamed\n            Preconditions.checkState(child.getFirstChild().getString().isEmpty());\n            if (Token.GETTER_DEF !\u003d kind) {\n                // Set methods have one parameter.\n                Preconditions.checkState(child.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            } else {\n                // Get methods have no parameters.\n                Preconditions.checkState(!child.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            }\n            // The name is on the GET or SET node.\n            String identifier \u003d n.getString();\n            Node functionNode \u003d child;\n            Node arguments \u003d functionNode.getChildAtIndex(1);\n            Node statementBody \u003d functionNode.getLastChild();\n            // Add the property name.\n            if (// do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            n.isQuotedString() || !TokenStream.isJSIdentifier(identifier) || !NodeUtil.isLatin(identifier)) {\n                // Determine if the string is a simple number.\n                double num \u003d getSimpleNumber(identifier);\n                if (Double.isNaN(num)) {\n                    addJsString(n);\n                } else {\n                    cc.addNumber(num);\n                }\n            } else {\n                add(identifier);\n            }\n            add(arguments);\n            add(statementBody, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (Node.class !\u003d n.getClass()) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean retainBlock \u003d Context.PRESERVE_BLOCK \u003d\u003d context;\n                if (retainBlock) {\n                    cc.beginBlock();\n                }\n                boolean useLineBreaks \u003d Token.SCRIPT \u003d\u003d kind || (Token.BLOCK \u003d\u003d kind \u0026\u0026 !retainBlock \u0026\u0026 null !\u003d n.getParent() \u0026\u0026 n.getParent().isScript());\n                Node c \u003d child;\n                while (null !\u003d c) {\n                    add(c, Context.STATEMENT);\n                    // VAR doesn\u0027t include \u0027;\u0027 since it gets used in expressions\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    // Prefer to break lines in between top-level statements\n                    // because top-level statements are more homogeneous.\n                    if (useLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                    c \u003d c.getNext();\n                }\n                if (retainBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, Context.STATEMENT \u003d\u003d context));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (4 !\u003d numChildren) {\n                Preconditions.checkState(3 \u003d\u003d numChildren);\n                add(\"for(\");\n                add(child);\n                add(\"in\");\n                add(child.getNext());\n                add(\")\");\n                addNonEmptyStatement(finalChild, getContextForNonEmptyExpression(context), false);\n            } else {\n                add(\"for(\");\n                if (!child.isVar()) {\n                    addExpr(child, 0, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    add(child, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(child.getNext());\n                add(\";\");\n                add(child.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(finalChild, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            add(\"do\");\n            addNonEmptyStatement(child, Context.OTHER, false);\n            add(\"while(\");\n            add(finalChild);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            add(\"while(\");\n            add(child);\n            add(\")\");\n            addNonEmptyStatement(finalChild, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(2 \u003d\u003d numChildren, \"Bad GETPROP: expected 2 children, but got %s\", numChildren);\n                Preconditions.checkState(finalChild.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (child.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(child, NodeUtil.precedence(kind), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                if (LanguageMode.ECMASCRIPT3 !\u003d this.languageMode || !TokenStream.isKeyword(finalChild.getString())) {\n                    add(\".\");\n                    addIdentifier(finalChild.getString());\n                } else {\n                    // Check for ECMASCRIPT3 keywords.\n                    add(\"[\");\n                    add(finalChild);\n                    add(\"]\");\n                }\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(2 \u003d\u003d numChildren, \"Bad GETELEM: expected 2 children but got %s\", numChildren);\n            addExpr(child, NodeUtil.precedence(kind), context);\n            add(\"[\");\n            add(child.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            add(\"with(\");\n            add(child);\n            add(\")\");\n            addNonEmptyStatement(finalChild, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(1 \u003d\u003d numChildren);\n                String operatorSymbol \u003d Token.INC \u003d\u003d kind ? \"++\" : \"--\";\n                int postIncrementFlag \u003d n.getIntProp(Node.INCRDECR_PROP);\n                // A non-zero post-prop value indicates a post inc/dec, default of zero\n                // is a pre-inc/dec.\n                if (0 \u003d\u003d postIncrementFlag) {\n                    cc.addOp(operatorSymbol, false);\n                    add(child);\n                } else {\n                    addExpr(child, NodeUtil.precedence(kind), context);\n                    cc.addOp(operatorSymbol, false);\n                }\n                break;\n            }\n        case Token.CALL:\n            // We have two special cases here:\n            // 1) If the left hand side of the call is a direct reference to eval,\n            // then it must have a DIRECT_EVAL annotation. If it does not, then\n            // that means it was originally an indirect call to eval, and that\n            // indirectness must be preserved.\n            // 2) If the left hand side of the call is a property reference,\n            // then the call must not a FREE_CALL annotation. If it does, then\n            // that means it was originally an call without an explicit this and\n            // that must be preserved.\n            if (!isIndirectEval(child) \u0026\u0026 !n.getBooleanProp(Node.FREE_CALL) || !NodeUtil.isGet(child)) {\n                addExpr(child, NodeUtil.precedence(kind), context);\n            } else {\n                add(\"(0,\");\n                addExpr(child, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            }\n            add(\"(\");\n            addList(child.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasAlternative \u003d 3 \u003d\u003d numChildren;\n            boolean confusingElseClause \u003d Context.BEFORE_DANGLING_ELSE \u003d\u003d context \u0026\u0026 !hasAlternative;\n            if (confusingElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(child);\n            add(\")\");\n            if (!hasAlternative) {\n                addNonEmptyStatement(child.getNext(), Context.OTHER, false);\n                Preconditions.checkState(2 \u003d\u003d numChildren);\n            } else {\n                addNonEmptyStatement(child.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(finalChild, getContextForNonEmptyExpression(context), false);\n            }\n            if (confusingElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(1 \u003e\u003d numChildren);\n            add(\"continue\");\n            if (1 \u003d\u003d numChildren) {\n                if (!child.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(child);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(0 \u003d\u003d numChildren);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(1 \u003e\u003d numChildren);\n            add(\"break\");\n            if (1 \u003d\u003d numChildren) {\n                if (!child.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(child);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(1 \u003d\u003d numChildren);\n            add(child, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(kind);\n            // If the first child contains a CALL, then claim higher precedence\n            // to force parentheses. Otherwise, when parsed, NEW will bind to the\n            // first viable parentheses (don\u0027t traverse into functions).\n            if (NodeUtil.containsType(child, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(child.getType()) + 1;\n            }\n            addExpr(child, precedence, Context.OTHER);\n            // \u0027()\u0027 is optional when no arguments are present\n            Node subsequent \u003d child.getNext();\n            if (null !\u003d subsequent) {\n                add(\"(\");\n                addList(subsequent);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(1 \u003d\u003d numChildren, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(0 \u003d\u003d numChildren, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(1 \u003d\u003d numChildren);\n            add(\"delete \");\n            add(child);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (Context.START_OF_EXPR \u003d\u003d context);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                Node c \u003d child;\n                while (null !\u003d c) {\n                    if (child !\u003d c) {\n                        cc.listSeparator();\n                    }\n                    if (!c.isGetterDef() \u0026\u0026 !c.isSetterDef()) {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        // Object literal property names don\u0027t have to be quoted if they\n                        // are not JavaScript keywords\n                        if (// do not encode literally any non-literal characters that\n                        // were Unicode escaped.\n                        c.isQuotedString() || (LanguageMode.ECMASCRIPT3 \u003d\u003d languageMode \u0026\u0026 TokenStream.isKeyword(key)) || !TokenStream.isJSIdentifier(key) || !NodeUtil.isLatin(key)) {\n                            // Determine if the string is a simple number.\n                            double num \u003d getSimpleNumber(key);\n                            if (Double.isNaN(num)) {\n                                addExpr(c, 1, Context.OTHER);\n                            } else {\n                                cc.addNumber(num);\n                            }\n                        } else {\n                            add(key);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    } else {\n                        add(c);\n                    }\n                    c \u003d c.getNext();\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(child);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(child.getNext());\n            cc.endBlock(Context.STATEMENT \u003d\u003d context);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            add(\"case \");\n            add(child);\n            addCaseBody(finalChild);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(1 \u003d\u003d numChildren);\n            add(\"default\");\n            addCaseBody(child);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(2 \u003d\u003d numChildren);\n            if (!child.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(child);\n            add(\":\");\n            addNonEmptyStatement(finalChild, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.CAST:\n            add(\"(\");\n            add(child);\n            add(\")\");\n            break;\n        default:\n            throw new Error(\"Unknown type \" + kind + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
  "Closure-133": "private String getRemainingJSDocLine() {\n    String output \u003d stream.getRemainingJSDocLine();\n    return output;\n}",
  "Closure-77": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() + 2);\n    stringBuilder.append(quote);\n    int index \u003d 0;\n    while (s.length() \u003e index) {\n        char character \u003d s.charAt(index);\n        switch(character) {\n            case \u0027\\n\u0027:\n                stringBuilder.append(\"\\\\n\");\n                break;\n            case \u0027\\r\u0027:\n                stringBuilder.append(\"\\\\r\");\n                break;\n            case \u0027\\t\u0027:\n                stringBuilder.append(\"\\\\t\");\n                break;\n            case \u0027\\\\\u0027:\n                stringBuilder.append(backslashEscape);\n                break;\n            case \u0027\\\"\u0027:\n                stringBuilder.append(doublequoteEscape);\n                break;\n            case \u0027\\\u0027\u0027:\n                stringBuilder.append(singlequoteEscape);\n                break;\n            case // Break --\u003e into --\\\u003e or ]]\u003e into ]]\\\u003e\n            \u0027\u003e\u0027:\n                if (2 \u003e index || !(((\u0027-\u0027 \u003d\u003d s.charAt(index - 1) \u0026\u0026 \u0027-\u0027 \u003d\u003d s.charAt(index - 2)) || (\u0027]\u0027 \u003d\u003d s.charAt(index - 1) \u0026\u0026 \u0027]\u0027 \u003d\u003d s.charAt(index - 2))))) {\n                    stringBuilder.append(character);\n                } else {\n                    stringBuilder.append(\"\\\\\u003e\");\n                }\n                break;\n            case \u0027\u003c\u0027:\n                // Break \u003c/script into \u003c\\/script\n                final String END_TAG \u003d \"/script\";\n                // Break \u003c!-- into \u003c\\!--\n                final String COMMENT_START \u003d \"!--\";\n                if (!s.regionMatches(true, index + 1, END_TAG, 0, END_TAG.length())) {\n                    if (!s.regionMatches(false, index + 1, COMMENT_START, 0, COMMENT_START.length())) {\n                        stringBuilder.append(character);\n                    } else {\n                        stringBuilder.append(\"\u003c\\\\\");\n                    }\n                } else {\n                    stringBuilder.append(\"\u003c\\\\\");\n                }\n                break;\n            default:\n                // If we\u0027re given an outputCharsetEncoder, then check if the\n                //  character can be represented in this character set.\n                if (null \u003d\u003d outputCharsetEncoder) {\n                    // No charsetEncoder provided - pass straight latin characters\n                    // through, and escape the rest.  Doing the explicit character\n                    // check is measurably faster than using the CharsetEncoder.\n                    if (0x1f \u003e\u003d character || 0x7f \u003c character) {\n                        // Other characters can be misinterpreted by some js parsers,\n                        // or perhaps mangled by proxies along the way,\n                        // so we play it safe and unicode escape them.\n                        appendHexJavaScriptRepresentation(stringBuilder, character);\n                    } else {\n                        stringBuilder.append(character);\n                    }\n                } else {\n                    if (!outputCharsetEncoder.canEncode(character)) {\n                        // Unicode-escape the character.\n                        appendHexJavaScriptRepresentation(stringBuilder, character);\n                    } else {\n                        stringBuilder.append(character);\n                    }\n                }\n        }\n        index +\u003d 1;\n    }\n    stringBuilder.append(quote);\n    return stringBuilder.toString();\n}",
  "Closure-132": "private Node tryMinimizeIf(Node n) {\n    Node ancestor \u003d n.getParent();\n    Node conditionNode \u003d n.getFirstChild();\n    /* If the condition is a literal, we\u0027ll let other\n   * optimizations try to remove useless code.\n   */\n    if (NodeUtil.isLiteralValue(conditionNode, true)) {\n        return n;\n    }\n    Node thenClause \u003d conditionNode.getNext();\n    Node alternativeBranch \u003d thenClause.getNext();\n    if (null \u003d\u003d alternativeBranch) {\n        if (!isFoldableExpressBlock(thenClause)) {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenClause) \u0026\u0026 thenClause.hasOneChild()) {\n                Node innerIfStatement \u003d thenClause.getFirstChild();\n                if (innerIfStatement.isIf()) {\n                    Node innerCondition \u003d innerIfStatement.getFirstChild();\n                    Node innerThenNode \u003d innerCondition.getNext();\n                    Node innerElseNode \u003d innerThenNode.getNext();\n                    if (null \u003d\u003d innerElseNode \u0026\u0026 !(isLowerPrecedenceInExpression(conditionNode, AND_PRECEDENCE) \u0026\u0026 isLowerPrecedenceInExpression(innerCondition, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(conditionNode, innerCondition.detachFromParent()).srcref(conditionNode));\n                        n.addChildrenToBack(innerThenNode.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into \u0026\u0026 because\n                        // the inner IF-ELSE wasn\u0027t able to be folded into \u0026\u0026 anyways.\n                        return n;\n                    }\n                }\n            }\n        } else {\n            Node expression \u003d getBlockExpression(thenClause);\n            if (!late \u0026\u0026 isPropertyAssignmentInExpression(expression)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier \u003d ... -\u003e var a \u003d ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (conditionNode.isNot()) {\n                // if(!x)bar(); -\u003e x||bar();\n                if (isLowerPrecedenceInExpression(conditionNode, OR_PRECEDENCE) \u0026\u0026 isLowerPrecedenceInExpression(expression.getFirstChild(), OR_PRECEDENCE)) {\n                    // It\u0027s not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node xor \u003d IR.or(conditionNode.removeFirstChild(), expression.removeFirstChild()).srcref(n);\n                Node optimizedExpr \u003d NodeUtil.newExpr(xor);\n                ancestor.replaceChild(n, optimizedExpr);\n                reportCodeChange();\n                return optimizedExpr;\n            }\n            // if(x)foo(); -\u003e x\u0026\u0026foo();\n            if (isLowerPrecedenceInExpression(conditionNode, AND_PRECEDENCE) \u0026\u0026 isLowerPrecedenceInExpression(expression.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(conditionNode);\n            Node and \u003d IR.and(conditionNode, expression.removeFirstChild()).srcref(n);\n            Node optimizedExpr \u003d NodeUtil.newExpr(and);\n            ancestor.replaceChild(n, optimizedExpr);\n            reportCodeChange();\n            return optimizedExpr;\n        }\n        return n;\n    }\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n   * peephole optimization. This should probably get moved to another pass.\n   */\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -\u003e if(x)bar();else foo();\n    // An additional set of curly braces isn\u0027t worth it.\n    if (conditionNode.isNot() \u0026\u0026 !consumesDanglingElse(alternativeBranch)) {\n        n.replaceChild(conditionNode, conditionNode.removeFirstChild());\n        n.removeChild(thenClause);\n        n.addChildToBack(thenClause);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -\u003e return x?1:2;\n    if (isReturnExpressBlock(thenClause) \u0026\u0026 isReturnExpressBlock(alternativeBranch)) {\n        Node thenBranchExpr \u003d getBlockReturnExpression(thenClause);\n        Node alternateExpr \u003d getBlockReturnExpression(alternativeBranch);\n        n.removeChild(conditionNode);\n        thenBranchExpr.detachFromParent();\n        alternateExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnStatementNode \u003d IR.returnNode(IR.hook(conditionNode, thenBranchExpr, alternateExpr).srcref(n));\n        ancestor.replaceChild(n, returnStatementNode);\n        reportCodeChange();\n        return returnStatementNode;\n    }\n    boolean isThenBranchExpressionBlock \u003d isFoldableExpressBlock(thenClause);\n    boolean elseBranchIsExpressionBlock \u003d isFoldableExpressBlock(alternativeBranch);\n    if (isThenBranchExpressionBlock \u0026\u0026 elseBranchIsExpressionBlock) {\n        Node thenOp \u003d getBlockExpression(thenClause).getFirstChild();\n        Node alternativeOp \u003d getBlockExpression(alternativeBranch).getFirstChild();\n        if (alternativeOp.getType() \u003d\u003d thenOp.getType()) {\n            // if(x)a\u003d1;else a\u003d2; -\u003e a\u003dx?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhsNode \u003d thenOp.getFirstChild();\n                if (// if LHS has side effects, don\u0027t proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                areNodesEqualForInlining(lhsNode, alternativeOp.getFirstChild()) \u0026\u0026 !mayEffectMutableState(lhsNode)) {\n                    n.removeChild(conditionNode);\n                    Node assignmentIdentifier \u003d thenOp.removeFirstChild();\n                    Node thenBranchExpr \u003d thenOp.removeFirstChild();\n                    Node alternateExpr \u003d alternativeOp.getLastChild();\n                    alternativeOp.removeChild(alternateExpr);\n                    Node ternaryNode \u003d IR.hook(conditionNode, thenBranchExpr, alternateExpr).srcref(n);\n                    Node set \u003d new Node(thenOp.getType(), assignmentIdentifier, ternaryNode).srcref(thenOp);\n                    Node expression \u003d NodeUtil.newExpr(set);\n                    ancestor.replaceChild(n, expression);\n                    reportCodeChange();\n                    return expression;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -\u003e x?foo():bar()\n        n.removeChild(conditionNode);\n        thenOp.detachFromParent();\n        alternativeOp.detachFromParent();\n        Node expression \u003d IR.exprResult(IR.hook(conditionNode, thenOp, alternativeOp).srcref(n));\n        ancestor.replaceChild(n, expression);\n        reportCodeChange();\n        return expression;\n    }\n    boolean thenBranchIsVariable \u003d isVarBlock(thenClause);\n    boolean elseBranchIsVar \u003d isVarBlock(alternativeBranch);\n    // if(x)var y\u003d1;else y\u003d2  -\u003e  var y\u003dx?1:2\n    if (!thenBranchIsVariable || !elseBranchIsExpressionBlock || !getBlockExpression(alternativeBranch).getFirstChild().isAssign()) {\n        if (elseBranchIsVar \u0026\u0026 isThenBranchExpressionBlock \u0026\u0026 getBlockExpression(thenClause).getFirstChild().isAssign()) {\n            Node node \u003d getBlockVar(alternativeBranch);\n            Node thenExpression \u003d getBlockExpression(thenClause).getFirstChild();\n            Node maybeVar1 \u003d thenExpression.getFirstChild();\n            Node name2 \u003d node.getFirstChild();\n            if (name2.hasChildren() \u0026\u0026 maybeVar1.isName() \u0026\u0026 maybeVar1.getString().equals(name2.getString())) {\n                Node thenBranchExpr \u003d thenExpression.getLastChild().detachFromParent();\n                Node alternateExpr \u003d name2.removeChildren();\n                conditionNode.detachFromParent();\n                Node ternaryNode \u003d IR.hook(conditionNode, thenBranchExpr, alternateExpr).srcref(n);\n                node.detachFromParent();\n                name2.addChildrenToBack(ternaryNode);\n                ancestor.replaceChild(n, node);\n                reportCodeChange();\n                return node;\n            }\n        }\n    } else {\n        Node node \u003d getBlockVar(thenClause);\n        Node elseAssignment \u003d getBlockExpression(alternativeBranch).getFirstChild();\n        Node alternativeName1 \u003d node.getFirstChild();\n        Node alternativeName2 \u003d elseAssignment.getFirstChild();\n        if (alternativeName1.hasChildren() \u0026\u0026 alternativeName2.isName() \u0026\u0026 alternativeName1.getString().equals(alternativeName2.getString())) {\n            Node thenBranchExpr \u003d alternativeName1.removeChildren();\n            Node alternateExpr \u003d elseAssignment.getLastChild().detachFromParent();\n            conditionNode.detachFromParent();\n            Node ternaryNode \u003d IR.hook(conditionNode, thenBranchExpr, alternateExpr).srcref(n);\n            node.detachFromParent();\n            alternativeName1.addChildrenToBack(ternaryNode);\n            ancestor.replaceChild(n, node);\n            reportCodeChange();\n            return node;\n        }\n        // if(x)y\u003d1;else var y\u003d2  -\u003e  var y\u003dx?1:2\n    }\n    return n;\n}",
  "Closure-78": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (Token.ADD \u003d\u003d opType \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double outcome;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double leftValueObject \u003d NodeUtil.getNumberValue(left);\n    if (null \u003d\u003d leftValueObject) {\n        return null;\n    }\n    Double rightValueObject \u003d NodeUtil.getNumberValue(right);\n    if (null \u003d\u003d rightValueObject) {\n        return null;\n    }\n    double leftValue \u003d leftValueObject;\n    double rValue \u003d rightValueObject;\n    switch(opType) {\n        case Token.BITAND:\n            outcome \u003d ScriptRuntime.toInt32(leftValue) \u0026 ScriptRuntime.toInt32(rValue);\n            break;\n        case Token.BITOR:\n            outcome \u003d ScriptRuntime.toInt32(leftValue) | ScriptRuntime.toInt32(rValue);\n            break;\n        case Token.BITXOR:\n            outcome \u003d ScriptRuntime.toInt32(leftValue) ^ ScriptRuntime.toInt32(rValue);\n            break;\n        case Token.ADD:\n            outcome \u003d leftValue + rValue;\n            break;\n        case Token.SUB:\n            outcome \u003d leftValue - rValue;\n            break;\n        case Token.MUL:\n            outcome \u003d leftValue * rValue;\n            break;\n        case Token.MOD:\n            if (0 \u003d\u003d rValue) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            outcome \u003d leftValue % rValue;\n            break;\n        case Token.DIV:\n            if (0 \u003d\u003d rValue) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            outcome \u003d leftValue / rValue;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (// Do not try to fold arithmetic for numbers \u003e 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    String.valueOf(leftValue).length() + String.valueOf(rValue).length() + 1 \u003c String.valueOf(outcome).length() || MAX_FOLD_NUMBER \u003c Math.abs(outcome)) {\n        if (!Double.isNaN(outcome)) {\n            if (Double.POSITIVE_INFINITY !\u003d outcome) {\n                if (Double.NEGATIVE_INFINITY \u003d\u003d outcome) {\n                    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n                }\n            } else {\n                return Node.newString(Token.NAME, \"Infinity\");\n            }\n        } else {\n            return Node.newString(Token.NAME, \"NaN\");\n        }\n    } else {\n        Node computedNumber \u003d Node.newNumber(outcome);\n        return computedNumber;\n    }\n    return null;\n}",
  "Closure-131": "public static boolean isJSIdentifier(String s) {\n    int size \u003d s.length();\n    if (0 \u003d\u003d size || !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n    }\n    int index \u003d 1;\n    while (size \u003e index) {\n        if (!Character.isJavaIdentifierPart(s.charAt(index))) {\n            return false;\n        }\n        index +\u003d 1;\n    }\n    return true;\n}",
  "Closure-130": "private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque\u003cName\u003e processList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n    while (!processList.isEmpty()) {\n        Name identifier \u003d processList.pop();\n        // Don\u0027t attempt to inline a getter or setter property as a variable.\n        if (Name.Type.GET \u003d\u003d identifier.type || Name.Type.SET \u003d\u003d identifier.type) {\n            continue;\n        }\n        if (1 \u003d\u003d identifier.globalSets \u0026\u0026 0 \u003d\u003d identifier.localSets \u0026\u0026 0 \u003c identifier.aliasingGets) {\n            // {@code name} meets condition (b). Find all of its local aliases\n            // and try to inline them.\n            List\u003cRef\u003e aliases \u003d Lists.newArrayList(identifier.getRefs());\n            for (Ref aliasRef : aliases) {\n                if (Type.ALIASING_GET \u003d\u003d aliasRef.type \u0026\u0026 aliasRef.scope.isLocal()) {\n                    // {@code name} meets condition (c). Try to inline it.\n                    if (inlineAliasIfPossible(aliasRef, namespace)) {\n                        identifier.removeRef(aliasRef);\n                    }\n                }\n            }\n        }\n        // Check if {@code name} has any aliases left after the\n        // local-alias-inlining above.\n        if ((Name.Type.OBJECTLIT \u003d\u003d identifier.type || Name.Type.FUNCTION \u003d\u003d identifier.type) \u0026\u0026 0 \u003d\u003d identifier.aliasingGets \u0026\u0026 null !\u003d identifier.props) {\n            // All of {@code name}\u0027s children meet condition (a), so they can be\n            // added to the worklist.\n            processList.addAll(identifier.props);\n        }\n    }\n}",
  "Closure-81": "Node processFunctionNode(FunctionNode functionNode) {\n    Name functionName \u003d functionNode.getFunctionName();\n    Boolean isAnonymousFunction \u003d false;\n    if (null \u003d\u003d functionName) {\n        functionName \u003d new Name();\n        functionName.setIdentifier(\"\");\n        isAnonymousFunction \u003d true;\n    }\n    Node element \u003d newNode(Token.FUNCTION);\n    Node transformedName \u003d transform(functionName);\n    if (isAnonymousFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        transformedName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int leftParenColumn \u003d functionNode.getAbsolutePosition() + functionNode.getLp();\n        transformedName.setCharno(position2charno(leftParenColumn));\n    }\n    element.addChildToBack(transformedName);\n    Node leftParenNode \u003d newNode(Token.LP);\n    // The left paren\u0027s complicated because it\u0027s not represented by an\n    // AstNode, so there\u0027s nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there\u0027s no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName \u003d functionNode.getFunctionName();\n    if (null \u003d\u003d fnName) {\n        leftParenNode.setLineno(functionNode.getLineno());\n    } else {\n        leftParenNode.setLineno(fnName.getLineno());\n    }\n    int leftParenCharno \u003d functionNode.getLp() + functionNode.getAbsolutePosition();\n    leftParenNode.setCharno(position2charno(leftParenCharno));\n    for (AstNode argument : functionNode.getParams()) {\n        leftParenNode.addChildToBack(transform(argument));\n    }\n    element.addChildToBack(leftParenNode);\n    Node bodyAstNode \u003d transform(functionNode.getBody());\n    parseDirectives(bodyAstNode);\n    element.addChildToBack(bodyAstNode);\n    return element;\n}",
  "Closure-82": "public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType();\n}",
  "Closure-83": "public int parseArguments(Parameters params) throws CmdLineException {\n    String argument \u003d params.getParameter(0);\n    if (null !\u003d argument) {\n        String normalizedParam \u003d argument.toLowerCase();\n        if (!TRUES.contains(normalizedParam)) {\n            if (!FALSES.contains(normalizedParam)) {\n                setter.addValue(true);\n                return 0;\n            } else {\n                setter.addValue(false);\n            }\n        } else {\n            setter.addValue(true);\n        }\n        return 1;\n    } else {\n        setter.addValue(true);\n        return 0;\n    }\n}",
  "Closure-88": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    if (NodeUtil.isName(n) \u0026\u0026 variable.equals(n.getString())) {\n        if (!NodeUtil.isLhs(n, n.getParent())) {\n            return VariableLiveness.READ;\n        } else {\n            // The expression to which the assignment is made is evaluated before\n            // the RHS is evaluated (normal left to right evaluation) but the KILL\n            // occurs after the RHS is evaluated.\n            return VariableLiveness.KILL;\n        }\n    }\n    Node descendant \u003d n.getFirstChild();\n    while (null !\u003d descendant) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(descendant)) {\n            // Not a FUNCTION\n            VariableLiveness liveness \u003d isVariableReadBeforeKill(descendant, variable);\n            if (VariableLiveness.MAYBE_LIVE !\u003d liveness) {\n                return liveness;\n            }\n        }\n        descendant \u003d descendant.getNext();\n    }\n    return VariableLiveness.MAYBE_LIVE;\n}",
  "Math-15": "public static double pow(double x, double y) {\n    final double[] logValues \u003d new double[2];\n    if (0.0 \u003d\u003d y) {\n        return 1.0;\n    }\n    if (x !\u003d x) {\n        // X is NaN\n        return x;\n    }\n    if (0 \u003d\u003d x) {\n        long bits \u003d Double.doubleToLongBits(x);\n        if (0 !\u003d (bits \u0026 0x8000000000000000L)) {\n            // -zero\n            long yi \u003d (long) y;\n            if (0 \u003e y \u0026\u0026 yi \u003d\u003d y \u0026\u0026 1 \u003d\u003d (yi \u0026 1)) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            if (0 \u003c y \u0026\u0026 yi \u003d\u003d y \u0026\u0026 1 \u003d\u003d (yi \u0026 1)) {\n                return -0.0;\n            }\n        }\n        if (0 \u003e y) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (0 \u003c y) {\n            return 0.0;\n        }\n        return Double.NaN;\n    }\n    if (Double.POSITIVE_INFINITY \u003d\u003d x) {\n        if (y !\u003d y) {\n            // y is NaN\n            return y;\n        }\n        if (0.0 \u003c\u003d y) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n    if (Double.POSITIVE_INFINITY \u003d\u003d y) {\n        if (1.0 \u003d\u003d x * x) {\n            return Double.NaN;\n        }\n        if (1.0 \u003e\u003d x * x) {\n            return 0.0;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (Double.NEGATIVE_INFINITY \u003d\u003d x) {\n        if (y !\u003d y) {\n            // y is NaN\n            return y;\n        }\n        if (0 \u003e y) {\n            long yi \u003d (long) y;\n            if (yi \u003d\u003d y \u0026\u0026 1 \u003d\u003d (yi \u0026 1)) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n        if (0 \u003c y) {\n            long yi \u003d (long) y;\n            if (yi \u003d\u003d y \u0026\u0026 1 \u003d\u003d (yi \u0026 1)) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (Double.NEGATIVE_INFINITY \u003d\u003d y) {\n        if (1.0 \u003d\u003d x * x) {\n            return Double.NaN;\n        }\n        if (1.0 \u003c\u003d x * x) {\n            return 0.0;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    /* Handle special case x\u003c0 */\n    if (0 \u003e x) {\n        // y is an even integer in this case\n        if (TWO_POWER_52 \u003c\u003d y || -TWO_POWER_52 \u003e\u003d y) {\n            return pow(-x, y);\n        }\n        if ((long) y !\u003d y) {\n            return Double.NaN;\n        } else {\n            // If y is an integer\n            return 0 \u003d\u003d ((long) y \u0026 1) ? pow(-x, y) : -pow(-x, y);\n        }\n    }\n    /* Split y into ya and yb such that y \u003d ya+yb */\n    double baseExponent;\n    double yb_subcomponent;\n    if (8e298 \u003c\u003d y || -8e298 \u003e\u003d y) {\n        double temp1 \u003d y * 9.31322574615478515625E-10;\n        double temp2 \u003d temp1 * 9.31322574615478515625E-10;\n        baseExponent \u003d (temp1 + temp2 - temp1) * HEX_40000000 * HEX_40000000;\n        yb_subcomponent \u003d y - baseExponent;\n    } else {\n        double temp1 \u003d y * HEX_40000000;\n        baseExponent \u003d y + temp1 - temp1;\n        yb_subcomponent \u003d y - baseExponent;\n    }\n    /* Compute ln(x) */\n    final double logApproximation \u003d log(x, logValues);\n    if (Double.isInfinite(logApproximation)) {\n        // don\u0027t allow this to be converted to NaN\n        return logApproximation;\n    }\n    double logarithmValue \u003d logValues[0];\n    double logCorrection \u003d logValues[1];\n    /* resplit lns */\n    double temp1 \u003d logarithmValue * HEX_40000000;\n    double temp2 \u003d logarithmValue + temp1 - temp1;\n    logCorrection +\u003d logarithmValue - temp2;\n    logarithmValue \u003d temp2;\n    // y*ln(x) \u003d (aa+ab)\n    final double lnaAdjusted \u003d logarithmValue * baseExponent;\n    final double ab \u003d logarithmValue * yb_subcomponent + logCorrection * baseExponent + logCorrection * yb_subcomponent;\n    logarithmValue \u003d lnaAdjusted + ab;\n    logCorrection \u003d -(logarithmValue - lnaAdjusted - ab);\n    double temp \u003d 1.0 / 120.0;\n    temp \u003d temp * logCorrection + (1.0 / 24.0);\n    temp \u003d temp * logCorrection + (1.0 / 6.0);\n    temp \u003d temp * logCorrection + 0.5;\n    temp \u003d temp * logCorrection + 1.0;\n    temp \u003d temp * logCorrection;\n    final double output \u003d exp(logarithmValue, temp, null);\n    //result \u003d result + result * z;\n    return output;\n}",
  "Closure-86": "static boolean evaluatesToLocalValue(Node value, Predicate\u003cNode\u003e locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // A result that is aliased by a non-local name, is the effectively the\n            // same as returning a non-local name, but this doesn\u0027t matter if the\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) \u0026\u0026 evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) \u0026\u0026 evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) \u0026\u0026 evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (!value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return true;\n            } else {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            }\n        case Token.THIS:\n            return locals.apply(value);\n        case Token.NAME:\n            return isImmutableValue(value) || locals.apply(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.apply(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\n        case Token.NEW:\n            // TODO(nicksantos): This needs to be changed so that it\n            // returns true iff we\u0027re sure the value was never aliased from inside\n            // the constructor (similar to callHasLocalResult)\n            return true;\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literals objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        default:\n            // Other op force a local value:\n            //  x \u003d \u0027\u0027 + g (x is now an local string)\n            //  x -\u003d g (x is now an local number)\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}",
  "Closure-87": "private boolean isFoldableExpressBlock(Node n) {\n    if (Token.BLOCK \u003d\u003d n.getType()) {\n        if (n.hasOneChild()) {\n            Node possibleExpr \u003d n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It\u0027s pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id\u003d291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit \u0027this\u0027\n            // param, or this doesn\u0027t happen.\n            return NodeUtil.isExpressionNode(possibleExpr);\n        }\n    }\n    return false;\n}",
  "Math-17": "public Dfp multiply(final int x) {\n    return multiplyFast(x);\n}",
  "Csv-15": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n    boolean shouldQuote \u003d false;\n    int initial \u003d offset;\n    int index \u003d offset;\n    final int limit \u003d offset + len;\n    final char separatorChar \u003d getDelimiter();\n    final char encapsulatingChar \u003d getQuoteCharacter().charValue();\n    QuoteMode quoteModeSetting \u003d getQuoteMode();\n    if (null \u003d\u003d quoteModeSetting) {\n        quoteModeSetting \u003d QuoteMode.MINIMAL;\n    }\n    switch(quoteModeSetting) {\n        case ALL:\n        case ALL_NON_NULL:\n            shouldQuote \u003d true;\n            break;\n        case NON_NUMERIC:\n            shouldQuote \u003d !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (0 \u003c len) {\n                char character \u003d value.charAt(index);\n                if (!newRecord || !((0x20 \u003e character || 0x21 \u003c character \u0026\u0026 0x23 \u003e character || 0x2B \u003c character \u0026\u0026 0x2D \u003e character || 0x7E \u003c character))) {\n                    if (COMMENT \u003c character) {\n                        while (limit \u003e index) {\n                            character \u003d value.charAt(index);\n                            if (LF \u003d\u003d character || CR \u003d\u003d character || encapsulatingChar \u003d\u003d character || separatorChar \u003d\u003d character) {\n                                shouldQuote \u003d true;\n                                break;\n                            }\n                            index +\u003d 1;\n                        }\n                        if (!shouldQuote) {\n                            index \u003d limit - 1;\n                            character \u003d value.charAt(index);\n                            // Some other chars at the end caused the parser to fail, so for now\n                            // encapsulate if we end in anything less than \u0027 \u0027\n                            if (SP \u003e\u003d character) {\n                                shouldQuote \u003d true;\n                            }\n                        }\n                    } else {\n                        // Some other chars at the start of a value caused the parser to fail, so for now\n                        // encapsulate if we start in anything less than \u0027#\u0027. We are being conservative\n                        // by including the default comment char too.\n                        shouldQuote \u003d true;\n                    }\n                } else {\n                    shouldQuote \u003d true;\n                }\n            } else {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    shouldQuote \u003d true;\n                }\n            }\n            if (!shouldQuote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, initial, limit);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModeSetting);\n    }\n    if (!shouldQuote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, initial, limit);\n        return;\n    }\n    // we hit something that needed encapsulation\n    out.append(encapsulatingChar);\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (limit \u003e index) {\n        final char character \u003d value.charAt(index);\n        if (encapsulatingChar \u003d\u003d character) {\n            // write out the chunk up until this point\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, initial, index + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            initial \u003d index;\n        }\n        index +\u003d 1;\n    }\n    // write the last segment\n    out.append(value, initial, index);\n    out.append(encapsulatingChar);\n}",
  "Jsoup-5": "private Attribute parseAttribute() {\n    tq.consumeWhitespace();\n    String attributeKey \u003d tq.consumeAttributeKey();\n    String stringValue \u003d \"\";\n    tq.consumeWhitespace();\n    if (tq.matchChomp(\"\u003d\")) {\n        tq.consumeWhitespace();\n        if (!tq.matchChomp(SQ)) {\n            if (!tq.matchChomp(DQ)) {\n                StringBuilder valueBuilder \u003d new StringBuilder();\n                // no \u0027 or \" to look for, so scan to end tag or space (or end of stream)\n                while (!tq.matchesAny(\"\u003c\", \"/\u003e\", \"\u003e\") \u0026\u0026 !tq.matchesWhitespace() \u0026\u0026 !tq.isEmpty()) {\n                    valueBuilder.append(tq.consume());\n                }\n                stringValue \u003d valueBuilder.toString();\n            } else {\n                stringValue \u003d tq.chompTo(DQ);\n            }\n        } else {\n            stringValue \u003d tq.chompTo(SQ);\n        }\n        tq.consumeWhitespace();\n    }\n    if (0 \u003d\u003d attributeKey.length()) {\n        tq.consume();\n        return null;\n    } else\n        return Attribute.createFromEncoded(attributeKey, stringValue);\n}",
  "Csv-14": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n    boolean isQuoted \u003d false;\n    int begin \u003d offset;\n    int index \u003d offset;\n    final int end \u003d offset + len;\n    final char separatorChar \u003d getDelimiter();\n    final char enclosingChar \u003d getQuoteCharacter().charValue();\n    QuoteMode quotePolicy \u003d getQuoteMode();\n    if (null \u003d\u003d quotePolicy) {\n        quotePolicy \u003d QuoteMode.MINIMAL;\n    }\n    switch(quotePolicy) {\n        case ALL:\n            isQuoted \u003d true;\n            break;\n        case NON_NUMERIC:\n            isQuoted \u003d !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (0 \u003c len) {\n                char character \u003d value.charAt(index);\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA \u003d  %x20-21 / %x23-2B / %x2D-7E\n                if (!newRecord || !((\u00270\u0027 \u003e character || \u00279\u0027 \u003c character \u0026\u0026 \u0027A\u0027 \u003e character || \u0027Z\u0027 \u003c character \u0026\u0026 \u0027a\u0027 \u003e character || \u0027z\u0027 \u003c character))) {\n                    if (COMMENT \u003c character) {\n                        while (end \u003e index) {\n                            character \u003d value.charAt(index);\n                            if (LF \u003d\u003d character || CR \u003d\u003d character || enclosingChar \u003d\u003d character || separatorChar \u003d\u003d character) {\n                                isQuoted \u003d true;\n                                break;\n                            }\n                            index +\u003d 1;\n                        }\n                        if (!isQuoted) {\n                            index \u003d end - 1;\n                            character \u003d value.charAt(index);\n                            // Some other chars at the end caused the parser to fail, so for now\n                            // encapsulate if we end in anything less than \u0027 \u0027\n                            if (SP \u003e\u003d character) {\n                                isQuoted \u003d true;\n                            }\n                        }\n                    } else {\n                        // Some other chars at the start of a value caused the parser to fail, so for now\n                        // encapsulate if we start in anything less than \u0027#\u0027. We are being conservative\n                        // by including the default comment char too.\n                        isQuoted \u003d true;\n                    }\n                } else {\n                    isQuoted \u003d true;\n                }\n            } else {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    isQuoted \u003d true;\n                }\n            }\n            if (!isQuoted) {\n                // no encapsulation needed - write out the original value\n                out.append(value, begin, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n    }\n    if (!isQuoted) {\n        // no encapsulation needed - write out the original value\n        out.append(value, begin, end);\n        return;\n    }\n    // we hit something that needed encapsulation\n    out.append(enclosingChar);\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (end \u003e index) {\n        final char character \u003d value.charAt(index);\n        if (enclosingChar \u003d\u003d character) {\n            // write out the chunk up until this point\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, begin, index + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            begin \u003d index;\n        }\n        index +\u003d 1;\n    }\n    // write the last segment\n    out.append(value, begin, index);\n    out.append(enclosingChar);\n}",
  "Math-19": "private void checkParameters() {\n    final double[] startPoint \u003d getStartPoint();\n    final double[] lowerBounds \u003d getLowerBound();\n    final double[] upperBound \u003d getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteLimits \u003d false;\n    for (int index \u003d 0; lowerBounds.length \u003e index; index++) {\n        if (!Double.isInfinite(lowerBounds[index]) || !Double.isInfinite(upperBound[index])) {\n            hasFiniteLimits \u003d true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasUnboundedLimits \u003d false;\n    if (!hasFiniteLimits) {\n        // Convert API to internal handling of boundaries.\n        boundaries \u003d null;\n    } else {\n        int index \u003d 0;\n        while (lowerBounds.length \u003e index) {\n            if (Double.isInfinite(lowerBounds[index]) || Double.isInfinite(upperBound[index])) {\n                hasUnboundedLimits \u003d true;\n                break;\n            }\n            index +\u003d 1;\n        }\n        if (!hasUnboundedLimits) {\n            // Convert API to internal handling of boundaries.\n            boundaries \u003d new double[2][];\n            boundaries[0] \u003d lowerBounds;\n            boundaries[1] \u003d upperBound;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        } else {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        }\n    }\n    if (null !\u003d inputSigma) {\n        if (startPoint.length !\u003d inputSigma.length) {\n            throw new DimensionMismatchException(inputSigma.length, startPoint.length);\n        }\n        int index \u003d 0;\n        while (startPoint.length \u003e index) {\n            if (0 \u003e inputSigma[index]) {\n                throw new NotPositiveException(inputSigma[index]);\n            }\n            if (null !\u003d boundaries) {\n                if (boundaries[1][index] - boundaries[0][index] \u003c inputSigma[index]) {\n                    throw new OutOfRangeException(inputSigma[index], 0, boundaries[1][index] - boundaries[0][index]);\n                }\n            }\n            index +\u003d 1;\n        }\n    }\n}",
  "Jsoup-6": "static String unescape(String string) {\n    if (!string.contains(\"\u0026\"))\n        return string;\n    // \u0026(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    Matcher matcher \u003d unescapePattern.matcher(string);\n    // pity matcher can\u0027t use stringbuilder, avoid syncs\n    StringBuffer buffer \u003d new StringBuffer(string.length());\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n    while (matcher.find()) {\n        int unicodeValue \u003d -1;\n        String numberString \u003d matcher.group(3);\n        if (null \u003d\u003d numberString) {\n            String symbol \u003d matcher.group(1);\n            if (full.containsKey(symbol))\n                unicodeValue \u003d full.get(symbol);\n        } else {\n            try {\n                // 2 is hex indicator\n                int radix \u003d null !\u003d matcher.group(2) ? 16 : 10;\n                unicodeValue \u003d Integer.valueOf(numberString, radix);\n            } catch (NumberFormatException e) {\n            }\n            // skip\n        }\n        if (-1 \u003d\u003d unicodeValue \u0026\u0026 0xFFFF \u003e\u003d unicodeValue) {\n            matcher.appendReplacement(buffer, matcher.group(0));\n        } else {\n            // out of range\n            String characterString \u003d Character.toString((char) unicodeValue);\n            matcher.appendReplacement(buffer, characterString);\n        }\n    }\n    matcher.appendTail(buffer);\n    return buffer.toString();\n}",
  "Csv-11": "private Map\u003cString, Integer\u003e initializeHeader() throws IOException {\n    Map\u003cString, Integer\u003e headerMap \u003d null;\n    final String[] headerFormat \u003d this.format.getHeader();\n    if (null !\u003d headerFormat) {\n        headerMap \u003d new LinkedHashMap\u003cString, Integer\u003e();\n        String[] columnHeader \u003d null;\n        if (0 !\u003d headerFormat.length) {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            columnHeader \u003d headerFormat;\n        } else {\n            // read the header from the first line of the file\n            final CSVRecord csvRecord \u003d this.nextRecord();\n            if (null !\u003d csvRecord) {\n                columnHeader \u003d csvRecord.values();\n            }\n        }\n        // build the name to index mappings\n        if (null !\u003d columnHeader) {\n            int index \u003d 0;\n            while (columnHeader.length \u003e index) {\n                final String header \u003d columnHeader[index];\n                final boolean hasHeader \u003d headerMap.containsKey(header);\n                final boolean isHeaderEmpty \u003d header.trim().isEmpty();\n                if (hasHeader \u0026\u0026 (!isHeaderEmpty || (isHeaderEmpty \u0026\u0026 !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(columnHeader));\n                }\n                headerMap.put(header, Integer.valueOf(index));\n                index +\u003d 1;\n            }\n        }\n    }\n    return headerMap;\n}",
  "Jsoup-1": "private void normalise(Element element) {\n    List\u003cNode\u003e nodesToMove \u003d new ArrayList\u003cNode\u003e();\n    for (Node childNode : element.childNodes) {\n        if (childNode instanceof TextNode) {\n            TextNode textNode \u003d (TextNode) childNode;\n            if (!textNode.isBlank())\n                nodesToMove.add(textNode);\n        }\n    }\n    for (Node childNode : nodesToMove) {\n        element.removeChild(childNode);\n        body().appendChild(new TextNode(\" \", \"\"));\n        body().appendChild(childNode);\n    }\n}",
  "Csv-10": "public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n    Assertions.notNull(out, \"out\");\n    Assertions.notNull(format, \"format\");\n    this.out \u003d out;\n    this.format \u003d format;\n    this.format.validate();\n    // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n    // It seems a pain to have to track whether the header has already been printed or not.\n}",
  "Jsoup-2": "private void parseStartTag() {\n    tq.consume(\"\u003c\");\n    String elementName \u003d tq.consumeWord();\n    if (0 \u003d\u003d elementName.length()) {\n        // doesn\u0027t look like a start tag after all; put \u003c back on stack and handle as text\n        tq.addFirst(\"\u0026lt;\");\n        parseTextNode();\n        return;\n    }\n    Attributes properties \u003d new Attributes();\n    while (!tq.matchesAny(\"\u003c\", \"/\u003e\", \"\u003e\") \u0026\u0026 !tq.isEmpty()) {\n        Attribute attr \u003d parseAttribute();\n        if (null !\u003d attr)\n            properties.put(attr);\n    }\n    Tag elementTag \u003d Tag.valueOf(elementName);\n    Element offspring \u003d new Element(elementTag, baseUri, properties);\n    // empty element if empty tag (e.g. img) or self-closed el (\u003cdiv/\u003e\n    boolean isSelfClosingElement \u003d elementTag.isEmpty();\n    if (!tq.matchChomp(\"/\u003e\")) {\n        tq.matchChomp(\"\u003e\");\n    } else {\n        // close empty element or tag\n        isSelfClosingElement \u003d true;\n    }\n    addChildToParent(offspring, isSelfClosingElement);\n    // pc data only tags (textarea, script): chomp to end tag, add content as text node\n    if (elementTag.isData()) {\n        String content \u003d tq.chompTo(\"\u003c/\" + elementName);\n        tq.chompTo(\"\u003e\");\n        Node contentNode;\n        if (// want to show as text, but not contain inside tags (so not a data tag?)\n        elementTag.equals(titleTag) || elementTag.equals(textareaTag))\n            contentNode \u003d TextNode.createFromEncoded(content, baseUri);\n        else\n            // data not encoded but raw (for \" in script)\n            contentNode \u003d new DataNode(content, baseUri);\n        offspring.appendChild(contentNode);\n    }\n    // \u003cbase href\u003e: update the base uri\n    if (offspring.tagName().equals(\"base\")) {\n        String linkHref \u003d offspring.absUrl(\"href\");\n        if (0 !\u003d linkHref.length()) {\n            // ignore \u003cbase target\u003e etc\n            baseUri \u003d linkHref;\n            // set on the doc so doc.createElement(Tag) will get updated base\n            doc.setBaseUri(linkHref);\n        }\n    }\n}",
  "Math-10": "public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n    // compute r \u003d sqrt(x^2+y^2)\n    double[] intermediateResult \u003d new double[getSize()];\n    // x^2\n    multiply(x, xOffset, x, xOffset, intermediateResult, 0);\n    double[] tmpYSquared \u003d new double[getSize()];\n    // y^2\n    multiply(y, yOffset, y, yOffset, tmpYSquared, 0);\n    // x^2 + y^2\n    add(intermediateResult, 0, tmpYSquared, 0, tmpYSquared, 0);\n    // r \u003d sqrt(x^2 + y^2)\n    rootN(tmpYSquared, 0, 2, intermediateResult, 0);\n    if (0 \u003e x[xOffset]) {\n        // compute atan2(y, x) \u003d +/- pi - 2 atan(y / (r - x))\n        // r - x\n        subtract(intermediateResult, 0, x, xOffset, tmpYSquared, 0);\n        // y /(r - x)\n        divide(y, yOffset, tmpYSquared, 0, intermediateResult, 0);\n        // atan(y / (r - x))\n        atan(intermediateResult, 0, tmpYSquared, 0);\n        // +/-pi - 2 * atan(y / (r - x))\n        result[resultOffset] \u003d ((0 \u003e\u003d tmpYSquared[0]) ? -FastMath.PI : FastMath.PI) - 2 * tmpYSquared[0];\n        int index \u003d 1;\n        while (tmpYSquared.length \u003e index) {\n            // +/-pi - 2 * atan(y / (r - x))\n            result[resultOffset + index] \u003d -2 * tmpYSquared[index];\n            ++index;\n        }\n    } else {\n        // compute atan2(y, x) \u003d 2 atan(y / (r + x))\n        // r + x\n        add(intermediateResult, 0, x, xOffset, tmpYSquared, 0);\n        // y /(r + x)\n        divide(y, yOffset, tmpYSquared, 0, intermediateResult, 0);\n        // atan(y / (r + x))\n        atan(intermediateResult, 0, tmpYSquared, 0);\n        int index \u003d 0;\n        while (tmpYSquared.length \u003e index) {\n            // 2 * atan(y / (r + x))\n            result[resultOffset + index] \u003d 2 * tmpYSquared[index];\n            ++index;\n        }\n    }\n    // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n}",
  "Math-11": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dimension \u003d getDimension();\n    if (dimension !\u003d vals.length) {\n        throw new DimensionMismatchException(vals.length, dimension);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dimension / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);\n}",
  "Math-13": "private RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition eigDec \u003d new EigenDecomposition(m);\n    return eigDec.getSquareRoot();\n}",
  "Mockito-12": "public Class getGenericType(Field field) {\n    Type parameterized \u003d field.getGenericType();\n    if (null !\u003d parameterized \u0026\u0026 parameterized instanceof ParameterizedType) {\n        Type resolved \u003d ((ParameterizedType) parameterized).getActualTypeArguments()[0];\n        return (Class) resolved;\n        //in case of nested generics we don\u0027t go deep\n    }\n    return Object.class;\n}",
  "Mockito-13": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationPatternMatcher \u003d matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationPatternMatcher);\n        return null;\n    }\n    VerificationMode validationMode \u003d mockingProgress.pullVerificationMode();\n    InvocationMatcher invocationPatternMatcher \u003d matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n    mockingProgress.validateState();\n    //if verificationMode is not null then someone is doing verify()\n    if (null !\u003d validationMode) {\n        //We need to check if verification was started on the correct mock\n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (validationMode instanceof MockAwareVerificationMode \u0026\u0026 invocation.getMock() \u003d\u003d ((MockAwareVerificationMode) validationMode).getMock()) {\n            VerificationDataImpl verificationInfo \u003d new VerificationDataImpl(invocationContainerImpl, invocationPatternMatcher);\n            validationMode.verify(verificationInfo);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode\n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        }\n    }\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationPatternMatcher);\n    OngoingStubbingImpl\u003cT\u003e activeStubbing \u003d new OngoingStubbingImpl\u003cT\u003e(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(activeStubbing);\n    StubbedInvocationMatcher mockedInvocation \u003d invocationContainerImpl.findAnswerFor(invocation);\n    if (null \u003d\u003d mockedInvocation) {\n        Object result \u003d mockSettings.getDefaultAnswer().answer(invocation);\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside \u0027when\u0027 might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationPatternMatcher);\n        return result;\n    } else {\n        mockedInvocation.captureArgumentsFrom(invocation);\n        return mockedInvocation.answer(invocation);\n    }\n}",
  "Mockito-15": "public OngoingInjecter filterCandidate(final Collection\u003cObject\u003e mocks, final Field field, final Object fieldInstance) {\n    if (1 \u003d\u003d mocks.size()) {\n        final Object selectedMock \u003d mocks.iterator().next();\n        return new OngoingInjecter() {\n\n            public boolean thenInject() {\n                try {\n                    new FieldSetter(fieldInstance, field).set(selectedMock);\n                } catch (Exception e) {\n                    throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                }\n                return true;\n            }\n        };\n    }\n    return new OngoingInjecter() {\n\n        public boolean thenInject() {\n            return false;\n        }\n    };\n}",
  "Chart-24": "public Paint getPaint(double value) {\n    double boundedValue \u003d Math.max(value, this.lowerBound);\n    boundedValue \u003d Math.min(boundedValue, this.upperBound);\n    int grayscaleValue \u003d (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0);\n    return new Color(grayscaleValue, grayscaleValue, grayscaleValue);\n}",
  "Chart-26": "protected AxisState drawLabel(String label, Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, AxisState state, PlotRenderingInfo plotState) {\n    // it is unlikely that \u0027state\u0027 will be null, but check anyway...\n    if (null \u003d\u003d state) {\n        throw new IllegalArgumentException(\"Null \u0027state\u0027 argument.\");\n    }\n    if ((null \u003d\u003d label) || (label.equals(\"\"))) {\n        return state;\n    }\n    Font typeface \u003d getLabelFont();\n    RectangleInsets padding \u003d getLabelInsets();\n    g2.setFont(typeface);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fontMetrics \u003d g2.getFontMetrics();\n    Rectangle2D textBounds \u003d TextUtilities.getTextBounds(label, g2, fontMetrics);\n    Shape labelArea \u003d null;\n    if (RectangleEdge.TOP !\u003d edge) {\n        if (RectangleEdge.BOTTOM !\u003d edge) {\n            if (RectangleEdge.LEFT !\u003d edge) {\n                if (RectangleEdge.RIGHT \u003d\u003d edge) {\n                    AffineTransform transform \u003d AffineTransform.getRotateInstance(getLabelAngle() + Math.PI / 2.0, textBounds.getCenterX(), textBounds.getCenterY());\n                    Shape transformedLabelBounds \u003d transform.createTransformedShape(textBounds);\n                    textBounds \u003d transformedLabelBounds.getBounds2D();\n                    float width \u003d (float) textBounds.getWidth();\n                    float height \u003d (float) textBounds.getHeight();\n                    float labelXCenter \u003d (float) (state.getCursor() + padding.getLeft() + width / 2.0);\n                    float labelY \u003d (float) (dataArea.getY() + dataArea.getHeight() / 2.0);\n                    TextUtilities.drawRotatedString(label, g2, labelXCenter, labelY, TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, TextAnchor.CENTER);\n                    labelArea \u003d new Rectangle2D.Float(labelXCenter - width / 2.0f, labelY - height / 2.0f, width, height);\n                    state.cursorRight(padding.getLeft() + textBounds.getWidth() + padding.getRight());\n                }\n            } else {\n                AffineTransform transform \u003d AffineTransform.getRotateInstance(getLabelAngle() - Math.PI / 2.0, textBounds.getCenterX(), textBounds.getCenterY());\n                Shape transformedLabelBounds \u003d transform.createTransformedShape(textBounds);\n                textBounds \u003d transformedLabelBounds.getBounds2D();\n                float width \u003d (float) textBounds.getWidth();\n                float height \u003d (float) textBounds.getHeight();\n                float labelXCenter \u003d (float) (state.getCursor() - padding.getRight() - width / 2.0);\n                float labelY \u003d (float) dataArea.getCenterY();\n                TextUtilities.drawRotatedString(label, g2, labelXCenter, labelY, TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, TextAnchor.CENTER);\n                labelArea \u003d new Rectangle2D.Float(labelXCenter - width / 2.0f, labelY - height / 2.0f, width, height);\n                state.cursorLeft(padding.getLeft() + textBounds.getWidth() + padding.getRight());\n            }\n        } else {\n            AffineTransform transform \u003d AffineTransform.getRotateInstance(getLabelAngle(), textBounds.getCenterX(), textBounds.getCenterY());\n            Shape transformedLabelBounds \u003d transform.createTransformedShape(textBounds);\n            textBounds \u003d transformedLabelBounds.getBounds2D();\n            float width \u003d (float) textBounds.getWidth();\n            float height \u003d (float) textBounds.getHeight();\n            float labelXCenter \u003d (float) dataArea.getCenterX();\n            float labelY \u003d (float) (state.getCursor() + padding.getTop() + height / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelXCenter, labelY, TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            labelArea \u003d new Rectangle2D.Float(labelXCenter - width / 2.0f, labelY - height / 2.0f, width, height);\n            state.cursorDown(padding.getTop() + textBounds.getHeight() + padding.getBottom());\n        }\n    } else {\n        AffineTransform transform \u003d AffineTransform.getRotateInstance(getLabelAngle(), textBounds.getCenterX(), textBounds.getCenterY());\n        Shape transformedLabelBounds \u003d transform.createTransformedShape(textBounds);\n        textBounds \u003d transformedLabelBounds.getBounds2D();\n        float width \u003d (float) textBounds.getWidth();\n        float height \u003d (float) textBounds.getHeight();\n        float labelXCenter \u003d (float) dataArea.getCenterX();\n        float labelY \u003d (float) (state.getCursor() - padding.getBottom() - height / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelXCenter, labelY, TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        labelArea \u003d new Rectangle2D.Float(labelXCenter - width / 2.0f, labelY - height / 2.0f, width, height);\n        state.cursorUp(padding.getTop() + textBounds.getHeight() + padding.getBottom());\n    }\n    if (null !\u003d plotState \u0026\u0026 null !\u003d labelArea) {\n        ChartRenderingInfo chartOwner \u003d plotState.getOwner();\n        EntityCollection entityCollection \u003d chartOwner.getEntityCollection();\n        if (null !\u003d entityCollection) {\n            entityCollection.add(new AxisLabelEntity(this, labelArea, this.labelToolTip, this.labelURL));\n        }\n    }\n    return state;\n}",
  "Closure-51": "void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char lastChar \u003d getLastChar();\n    if (0 \u003e x \u0026\u0026 \u0027-\u0027 \u003d\u003d lastChar) {\n        add(\" \");\n    }\n    if (x !\u003d (long) x) {\n        add(String.valueOf(x));\n    } else {\n        long numberValue \u003d (long) x;\n        long significand \u003d numberValue;\n        int exponent \u003d 0;\n        if (100 \u003c\u003d Math.abs(x)) {\n            while (numberValue \u003d\u003d significand / 10 * Math.pow(10, exponent + 1)) {\n                significand /\u003d 10;\n                exponent +\u003d 1;\n            }\n        }\n        if (2 \u003e\u003d exponent) {\n            add(Long.toString(numberValue));\n        } else {\n            add(Long.toString(significand) + \"E\" + Integer.toString(exponent));\n        }\n    }\n}",
  "Closure-52": "static boolean isSimpleNumber(String s) {\n    int length \u003d s.length();\n    int i \u003d 0;\n    while (length \u003e i) {\n        char digit \u003d s.charAt(i);\n        if (\u00270\u0027 \u003e digit || \u00279\u0027 \u003c digit) {\n            return false;\n        }\n        i +\u003d 1;\n    }\n    return 0 \u003c length;\n}",
  "Closure-146": "public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n        TypePair typePair \u003d that.getTypesUnderInequality(this);\n        return new TypePair(typePair.typeB, typePair.typeA);\n    }\n    // other types\n    switch(this.testForEquality(that)) {\n        case TRUE:\n            return new TypePair(null, null);\n        case FALSE:\n        case UNKNOWN:\n            return new TypePair(this, that);\n    }\n    // switch case is exhaustive\n    throw new IllegalStateException();\n}",
  "Mockito-18": "Object returnValueFor(Class\u003c?\u003e type) {\n    if (!Primitives.isPrimitiveOrWrapper(type)) {\n        if (Collection.class !\u003d type) {\n            if (Set.class !\u003d type) {\n                if (HashSet.class !\u003d type) {\n                    if (SortedSet.class !\u003d type) {\n                        if (TreeSet.class !\u003d type) {\n                            if (LinkedHashSet.class !\u003d type) {\n                                if (List.class !\u003d type) {\n                                    if (LinkedList.class !\u003d type) {\n                                        if (ArrayList.class !\u003d type) {\n                                            if (Map.class !\u003d type) {\n                                                if (HashMap.class !\u003d type) {\n                                                    if (SortedMap.class !\u003d type) {\n                                                        if (TreeMap.class !\u003d type) {\n                                                            if (LinkedHashMap.class \u003d\u003d type) {\n                                                                return new LinkedHashMap\u003cObject, Object\u003e();\n                                                            }\n                                                        } else {\n                                                            return new TreeMap\u003cObject, Object\u003e();\n                                                        }\n                                                    } else {\n                                                        return new TreeMap\u003cObject, Object\u003e();\n                                                    }\n                                                } else {\n                                                    return new HashMap\u003cObject, Object\u003e();\n                                                }\n                                            } else {\n                                                return new HashMap\u003cObject, Object\u003e();\n                                            }\n                                        } else {\n                                            return new ArrayList\u003cObject\u003e();\n                                        }\n                                    } else {\n                                        return new LinkedList\u003cObject\u003e();\n                                    }\n                                } else {\n                                    return new LinkedList\u003cObject\u003e();\n                                }\n                            } else {\n                                return new LinkedHashSet\u003cObject\u003e();\n                            }\n                        } else {\n                            return new TreeSet\u003cObject\u003e();\n                        }\n                    } else {\n                        return new TreeSet\u003cObject\u003e();\n                    }\n                } else {\n                    return new HashSet\u003cObject\u003e();\n                }\n            } else {\n                return new HashSet\u003cObject\u003e();\n            }\n        } else {\n            return new LinkedList\u003cObject\u003e();\n        }\n    } else {\n        return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n    }\n    //Let\u0027s not care about the rest of collections.\n    return null;\n}",
  "Closure-145": "private boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn\u0027t generated when extraneous BLOCKs\n    // are skipped.\n    // Either a empty statement or an block with more than one child,\n    // way it isn\u0027t a FUNCTION or DO.\n    return (Token.FUNCTION \u003d\u003d n.getType() || Token.DO \u003d\u003d n.getType());\n}",
  "Closure-50": "private Node tryFoldArrayJoin(Node n) {\n    Node targetNode \u003d n.getFirstChild();\n    if (null \u003d\u003d targetNode || !NodeUtil.isGetProp(targetNode)) {\n        return n;\n    }\n    Node separator \u003d targetNode.getNext();\n    if (null !\u003d separator) {\n        if (!NodeUtil.isImmutableValue(separator)) {\n            return n;\n        }\n    }\n    Node listNode \u003d targetNode.getFirstChild();\n    Node methodName \u003d listNode.getNext();\n    if ((Token.ARRAYLIT !\u003d listNode.getType()) || !methodName.getString().equals(\"join\")) {\n        return n;\n    }\n    // \",\" is the default, it doesn\u0027t need to be explicit\n    String delimiterString \u003d (null \u003d\u003d separator) ? \",\" : NodeUtil.getStringValue(separator);\n    List\u003cNode\u003e foldedArrayChildren \u003d Lists.newLinkedList();\n    StringBuilder stringBuilder \u003d null;\n    int combinedSize \u003d 0;\n    Node previousNode \u003d null;\n    Node childNode \u003d listNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (null !\u003d childNode) {\n        if (!NodeUtil.isImmutableValue(childNode) \u0026\u0026 Token.EMPTY !\u003d childNode.getType()) {\n            if (null !\u003d stringBuilder) {\n                Preconditions.checkNotNull(previousNode);\n                // + 2 for the quotes.\n                combinedSize +\u003d stringBuilder.length() + 2;\n                foldedArrayChildren.add(Node.newString(stringBuilder.toString()).copyInformationFrom(previousNode));\n                stringBuilder \u003d null;\n            }\n            combinedSize +\u003d InlineCostEstimator.getCost(childNode);\n            foldedArrayChildren.add(childNode);\n        } else {\n            if (null !\u003d stringBuilder) {\n                stringBuilder.append(delimiterString);\n            } else {\n                stringBuilder \u003d new StringBuilder();\n            }\n            stringBuilder.append(NodeUtil.getArrayElementStringValue(childNode));\n        }\n        previousNode \u003d childNode;\n        childNode \u003d childNode.getNext();\n    }\n    if (null !\u003d stringBuilder) {\n        Preconditions.checkNotNull(previousNode);\n        // + 2 for the quotes.\n        combinedSize +\u003d stringBuilder.length() + 2;\n        foldedArrayChildren.add(Node.newString(stringBuilder.toString()).copyInformationFrom(previousNode));\n    }\n    // one for each comma.\n    combinedSize +\u003d foldedArrayChildren.size() - 1;\n    int initialSize \u003d InlineCostEstimator.getCost(n);\n    switch(foldedArrayChildren.size()) {\n        case 0:\n            Node emptyStringLiteral \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringLiteral);\n            reportCodeChange();\n            return emptyStringLiteral;\n        case 1:\n            Node mergedStringNode \u003d foldedArrayChildren.remove(0);\n            if (initialSize \u003c combinedSize) {\n                return n;\n            }\n            listNode.detachChildren();\n            if (Token.STRING !\u003d mergedStringNode.getType()) {\n                // If the Node is not a string literal, ensure that\n                // it is coerced to a string.\n                Node substitution \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), mergedStringNode);\n                mergedStringNode \u003d substitution;\n            }\n            n.getParent().replaceChild(n, mergedStringNode);\n            reportCodeChange();\n            return mergedStringNode;\n        default:\n            // No folding could actually be performed.\n            if (listNode.getChildCount() \u003d\u003d foldedArrayChildren.size()) {\n                return n;\n            }\n            int kJoinCost \u003d \"[].join()\".length();\n            combinedSize +\u003d kJoinCost;\n            combinedSize +\u003d (null !\u003d separator) ? InlineCostEstimator.getCost(separator) : 0;\n            if (initialSize \u003c combinedSize) {\n                return n;\n            }\n            listNode.detachChildren();\n            for (Node element : foldedArrayChildren) {\n                listNode.addChildToBack(element);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
  "Closure-55": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n}",
  "Closure-56": "public String getLine(int lineNumber) {\n    String sourceCode \u003d \"\";\n    try {\n        // NOTE(nicksantos): Right now, this is optimized for few warnings.\n        // This is probably the right trade-off, but will be slow if there\n        // are lots of warnings in one file.\n        sourceCode \u003d getCode();\n    } catch (IOException e) {\n        return null;\n    }\n    int index \u003d 0;\n    int beginLine \u003d 1;\n    // If we\u0027ve saved a previous offset and it\u0027s for a line less than the\n    // one we\u0027re searching for, then start at that point.\n    if (lastLine \u003c\u003d lineNumber) {\n        index \u003d lastOffset;\n        beginLine \u003d lastLine;\n    }\n    int lineIndex \u003d beginLine;\n    while (lineNumber \u003e lineIndex) {\n        int nextLinePos \u003d sourceCode.indexOf(\u0027\\n\u0027, index);\n        if (-1 \u003d\u003d nextLinePos) {\n            return null;\n        }\n        index \u003d nextLinePos + 1;\n        lineIndex +\u003d 1;\n    }\n    // Remember this offset for the next search we do.\n    lastOffset \u003d index;\n    lastLine \u003d lineNumber;\n    if (-1 !\u003d sourceCode.indexOf(\u0027\\n\u0027, index)) {\n        return sourceCode.substring(index, sourceCode.indexOf(\u0027\\n\u0027, index));\n    } else {\n        // If next new line cannot be found, there are two cases\n        // 1. pos already reaches the end of file, then null should be returned\n        // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    }\n}",
  "Closure-53": "private void replaceAssignmentExpression(Var v, Reference ref, Map\u003cString, String\u003e varmap) {\n    // Compute all of the assignments necessary\n    List\u003cNode\u003e assignments \u003d Lists.newArrayList();\n    Node replacementNode \u003d ref.getAssignedValue();\n    blacklistVarReferencesInTree(replacementNode, v.scope);\n    Preconditions.checkState(Token.OBJECTLIT \u003d\u003d replacementNode.getType());\n    Set\u003cString\u003e complete \u003d Sets.newLinkedHashSet(varmap.keySet());\n    Node item \u003d replacementNode.getFirstChild();\n    while (null !\u003d item) {\n        String variable \u003d item.getString();\n        Node nodeValue \u003d item.removeFirstChild();\n        // TODO(user): Copy type information.\n        assignments.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(variable)), nodeValue));\n        complete.remove(variable);\n        item \u003d item.getNext();\n    }\n    // TODO(user): Better source information.\n    for (String variable : complete) {\n        assignments.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(variable)), NodeUtil.newUndefinedNode(null)));\n    }\n    Node substitution;\n    // All assignments evaluate to true, so make sure that the\n    // expr statement evaluates to true in case it matters.\n    assignments.add(new Node(Token.TRUE));\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    assignments \u003d Lists.reverse(assignments);\n    substitution \u003d new Node(Token.COMMA);\n    Node currentNode \u003d substitution;\n    int index;\n    index \u003d 0;\n    while (assignments.size() - 2 \u003e index) {\n        currentNode.addChildToFront(assignments.get(index));\n        Node current \u003d new Node(Token.COMMA);\n        currentNode.addChildToFront(current);\n        currentNode \u003d current;\n        index +\u003d 1;\n    }\n    currentNode.addChildToFront(assignments.get(index));\n    currentNode.addChildToFront(assignments.get(index + 1));\n    Node substitute \u003d ref.getParent();\n    substitution.copyInformationFromForTree(substitute);\n    if (Token.VAR !\u003d substitute.getType()) {\n        substitute.getParent().replaceChild(substitute, substitution);\n    } else {\n        substitute.getParent().replaceChild(substitute, NodeUtil.newExpr(substitution));\n    }\n}",
  "Closure-152": "JSType resolveInternal(ErrorReporter t, StaticScope\u003cJSType\u003e scope) {\n    setResolvedTypeInternal(this);\n    call \u003d (ArrowType) safeResolve(call, t, scope);\n    prototype \u003d (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn\u0027t resolve to an ObjectType\n    // is handled further upstream.\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    typeOfThis \u003d (ObjectType) safeResolve(typeOfThis, t, scope);\n    boolean modified \u003d false;\n    ImmutableList.Builder\u003cObjectType\u003e resolvedTypes \u003d ImmutableList.builder();\n    for (ObjectType interfaceType : implementedInterfaces) {\n        ObjectType resolvedInterface \u003d (ObjectType) interfaceType.resolve(t, scope);\n        resolvedTypes.add(resolvedInterface);\n        modified |\u003d (interfaceType !\u003d resolvedInterface);\n    }\n    if (modified) {\n        implementedInterfaces \u003d resolvedTypes.build();\n    }\n    if (null !\u003d subTypes) {\n        int index \u003d 0;\n        while (subTypes.size() \u003e index) {\n            subTypes.set(index, (FunctionType) subTypes.get(index).resolve(t, scope));\n            index +\u003d 1;\n        }\n    }\n    return super.resolveInternal(t, scope);\n}",
  "Closure-59": "public void initOptions(CompilerOptions options) {\n    this.options \u003d options;\n    if (null \u003d\u003d errorManager) {\n        if (null !\u003d outStream) {\n            PrintStreamErrorManager outputManager \u003d new PrintStreamErrorManager(createMessageFormatter(), outStream);\n            outputManager.setSummaryDetailLevel(options.summaryDetailLevel);\n            setErrorManager(outputManager);\n        } else {\n            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));\n        }\n    }\n    // DiagnosticGroups override the plain checkTypes option.\n    if (!options.enables(DiagnosticGroups.CHECK_TYPES)) {\n        if (!options.disables(DiagnosticGroups.CHECK_TYPES)) {\n            if (!options.checkTypes) {\n                // If DiagnosticGroups did not override the plain checkTypes\n                // option, and checkTypes is enabled, then turn off the\n                // parser type warnings.\n                options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);\n            }\n        } else {\n            options.checkTypes \u003d false;\n        }\n    } else {\n        options.checkTypes \u003d true;\n    }\n    if (options.checkGlobalThisLevel.isOn()) {\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);\n    }\n    if (LanguageMode.ECMASCRIPT5_STRICT \u003d\u003d options.getLanguageIn()) {\n        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);\n    }\n    // Initialize the warnings guard.\n    List\u003cWarningsGuard\u003e warningsHandlers \u003d Lists.newArrayList();\n    warningsHandlers.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));\n    warningsHandlers.add(options.getWarningsGuard());\n    ComposeWarningsGuard combinedGuards \u003d new ComposeWarningsGuard(warningsHandlers);\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn\u0027t crash. It also\n    // checks the externs file for validity. If you don\u0027t want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols \u0026\u0026 !combinedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n        combinedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n    this.warningsGuard \u003d combinedGuards;\n}",
  "Chart-20": "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, paint, stroke, alpha);\n    this.value \u003d value;\n}",
  "Closure-150": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (scope.getRootNode() \u003d\u003d n)\n        return;\n    if (Token.LP \u003d\u003d n.getType() \u0026\u0026 scope.getRootNode() \u003d\u003d parent) {\n        handleFunctionInputs(parent);\n        return;\n    }\n    attachLiteralTypes(n);\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            if (Token.NAME \u003d\u003d parent.getType()) {\n                return;\n            }\n            defineDeclaredFunction(n, parent);\n            break;\n        case Token.CATCH:\n            defineCatch(n, parent);\n            break;\n        case Token.VAR:\n            defineVar(n, parent);\n            break;\n    }\n}",
  "Closure-57": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {\n    String clsName \u003d null;\n    if (NodeUtil.isExprCall(parent)) {\n        Node functionCaller \u003d node.getFirstChild();\n        if (null !\u003d functionCaller \u0026\u0026 Token.GETPROP \u003d\u003d functionCaller.getType()) {\n            String fullName \u003d functionCaller.getQualifiedName();\n            if (functionName.equals(fullName)) {\n                Node receiver \u003d functionCaller.getNext();\n                if (null !\u003d receiver) {\n                    clsName \u003d receiver.getString();\n                }\n            }\n        }\n    }\n    return clsName;\n}",
  "Closure-58": "private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\n    switch(n.getType()) {\n        case Token.SCRIPT:\n        case Token.BLOCK:\n        case Token.FUNCTION:\n            return;\n        case Token.WHILE:\n        case Token.DO:\n        case Token.IF:\n            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\n            return;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                // for(x in y) {...}\n                Node leftHandSide \u003d n.getFirstChild();\n                Node operand \u003d leftHandSide.getNext();\n                if (NodeUtil.isVar(leftHandSide)) {\n                    // for(var x in y) {...}\n                    leftHandSide \u003d leftHandSide.getLastChild();\n                }\n                addToSetIfLocal(leftHandSide, kill);\n                addToSetIfLocal(leftHandSide, gen);\n                computeGenKill(operand, gen, kill, conditional);\n            } else {\n                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\n            }\n            return;\n        case Token.VAR:\n            for (Node childNode \u003d n.getFirstChild(); null !\u003d childNode; childNode \u003d childNode.getNext()) {\n                if (childNode.hasChildren()) {\n                    computeGenKill(childNode.getFirstChild(), gen, kill, conditional);\n                    if (!conditional) {\n                        addToSetIfLocal(childNode, kill);\n                    }\n                }\n            }\n            return;\n        case Token.AND:\n        case Token.OR:\n            computeGenKill(n.getFirstChild(), gen, kill, conditional);\n            // May short circuit.\n            computeGenKill(n.getLastChild(), gen, kill, true);\n            return;\n        case Token.HOOK:\n            computeGenKill(n.getFirstChild(), gen, kill, conditional);\n            // Assume both sides are conditional.\n            computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n            computeGenKill(n.getLastChild(), gen, kill, true);\n            return;\n        case Token.NAME:\n            if (!isArgumentsName(n)) {\n                addToSetIfLocal(n, gen);\n            } else {\n                markAllParametersEscaped();\n            }\n            return;\n        default:\n            if (!NodeUtil.isAssignmentOp(n) || !NodeUtil.isName(n.getFirstChild())) {\n                Node childNode \u003d n.getFirstChild();\n                while (null !\u003d childNode) {\n                    computeGenKill(childNode, gen, kill, conditional);\n                    childNode \u003d childNode.getNext();\n                }\n            } else {\n                Node leftHandSide \u003d n.getFirstChild();\n                if (!conditional) {\n                    addToSetIfLocal(leftHandSide, kill);\n                }\n                if (!NodeUtil.isAssign(n)) {\n                    // assignments such as a +\u003d 1 reads a.\n                    addToSetIfLocal(leftHandSide, gen);\n                }\n                computeGenKill(leftHandSide.getNext(), gen, kill, conditional);\n            }\n            return;\n    }\n}",
  "Mockito-24": "public Object answer(InvocationOnMock invocation) {\n    if (!methodsGuru.isToString(invocation.getMethod())) {\n        if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return 1;\n        }\n    } else {\n        Object proxy \u003d invocation.getMock();\n        MockName mockName \u003d mockUtil.getMockName(proxy);\n        if (!mockName.isDefault()) {\n            return mockName.toString();\n        } else {\n            return \"Mock for \" + mockUtil.getMockSettings(proxy).getTypeToMock().getSimpleName() + \", hashCode: \" + proxy.hashCode();\n        }\n    }\n    Class\u003c?\u003e resultType \u003d invocation.getMethod().getReturnType();\n    return returnValueFor(resultType);\n}",
  "Mockito-20": "public \u003cT\u003e T createMock(MockCreationSettings\u003cT\u003e settings, MockHandler handler) {\n    if (SerializableMode.ACROSS_CLASSLOADERS \u003d\u003d settings.getSerializableMode()) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class\u003c? extends T\u003e mockedProxyClass \u003d cachingMockBytecodeGenerator.get(settings.getTypeToMock(), settings.getExtraInterfaces());\n    T mockObject \u003d null;\n    try {\n        mockObject \u003d classInstantiator.instantiate(mockedProxyClass);\n        MockMethodInterceptor.MockAccess mockAccessControl \u003d (MockMethodInterceptor.MockAccess) mockObject;\n        mockAccessControl.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n        return ensureMockIsAssignableToMockedType(settings, mockObject);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\"ClassCastException occurred while creating the mockito mock :\", \"  class to mock : \" + describeClass(mockedProxyClass), \"  created class : \" + describeClass(settings.getTypeToMock()), \"  proxy instance class : \" + describeClass(mockObject), \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(), \"\", \"You might experience classloading issues, please ask the mockito mailing-list.\", \"\"), cce);\n    } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n        throw new MockitoException(\"Unable to create mock instance of type \u0027\" + mockedProxyClass.getSuperclass().getSimpleName() + \"\u0027\", e);\n    }\n}",
  "Mockito-22": "public static boolean areEqual(Object o1, Object o2) {\n    if (null !\u003d o1 \u0026\u0026 null !\u003d o2) {\n        if (!isArray(o1)) {\n            return o1.equals(o2);\n        } else {\n            return isArray(o2) \u0026\u0026 areArraysEqual(o1, o2);\n        }\n    } else {\n        return null \u003d\u003d o1 \u0026\u0026 null \u003d\u003d o2;\n    }\n}",
  "Chart-12": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset \u003d dataset;\n    PiePlot donutPlot \u003d new PiePlot(null);\n    this.pieChart \u003d new JFreeChart(donutPlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder \u003d TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle chartTitle \u003d new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12));\n    chartTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(chartTitle);\n    this.aggregatedItemsKey \u003d \"Other\";\n    this.aggregatedItemsPaint \u003d Color.lightGray;\n    this.sectionPaints \u003d new HashMap();\n}",
  "Chart-13": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) {\n    double[] widthArray \u003d new double[5];\n    double[] heightValues \u003d new double[5];\n    widthArray[0] \u003d constraint.getWidth();\n    if (null !\u003d this.topBlock) {\n        RectangleConstraint topBlockConstraint \u003d new RectangleConstraint(widthArray[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE);\n        Size2D dimension \u003d this.topBlock.arrange(g2, topBlockConstraint);\n        heightValues[0] \u003d dimension.height;\n    }\n    widthArray[1] \u003d widthArray[0];\n    if (null !\u003d this.bottomBlock) {\n        RectangleConstraint cBottom \u003d new RectangleConstraint(widthArray[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - heightValues[0]), LengthConstraintType.RANGE);\n        Size2D dimension \u003d this.bottomBlock.arrange(g2, cBottom);\n        heightValues[1] \u003d dimension.height;\n    }\n    heightValues[2] \u003d constraint.getHeight() - heightValues[1] - heightValues[0];\n    if (null !\u003d this.leftBlock) {\n        RectangleConstraint rectangleConstraintLeft \u003d new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, heightValues[2], null, LengthConstraintType.FIXED);\n        Size2D dimension \u003d this.leftBlock.arrange(g2, rectangleConstraintLeft);\n        widthArray[2] \u003d dimension.width;\n    }\n    heightValues[3] \u003d heightValues[2];\n    if (null !\u003d this.rightBlock) {\n        RectangleConstraint cRight \u003d new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - widthArray[2]), LengthConstraintType.RANGE, heightValues[2], null, LengthConstraintType.FIXED);\n        Size2D dimension \u003d this.rightBlock.arrange(g2, cRight);\n        widthArray[3] \u003d dimension.width;\n    }\n    heightValues[4] \u003d heightValues[2];\n    widthArray[4] \u003d constraint.getWidth() - widthArray[3] - widthArray[2];\n    RectangleConstraint cCenter \u003d new RectangleConstraint(widthArray[4], heightValues[4]);\n    if (null !\u003d this.centerBlock) {\n        this.centerBlock.arrange(g2, cCenter);\n    }\n    if (null !\u003d this.topBlock) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, widthArray[0], heightValues[0]));\n    }\n    if (null !\u003d this.bottomBlock) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, heightValues[0] + heightValues[2], widthArray[1], heightValues[1]));\n    }\n    if (null !\u003d this.leftBlock) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, heightValues[0], widthArray[2], heightValues[2]));\n    }\n    if (null !\u003d this.rightBlock) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(widthArray[2] + widthArray[4], heightValues[0], widthArray[3], heightValues[3]));\n    }\n    if (null !\u003d this.centerBlock) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(widthArray[2], heightValues[0], widthArray[4], heightValues[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}",
  "Closure-159": "private void findCalledFunctions(Node node, Set\u003cString\u003e changed) {\n    Preconditions.checkArgument(null !\u003d changed);\n    // For each referenced function, add a new reference\n    if (Token.CALL \u003d\u003d node.getType()) {\n        Node descendant \u003d node.getFirstChild();\n        if (Token.NAME \u003d\u003d descendant.getType()) {\n            changed.add(descendant.getString());\n        }\n    }\n    Node childNode \u003d node.getFirstChild();\n    while (null !\u003d childNode) {\n        findCalledFunctions(childNode, changed);\n        childNode \u003d childNode.getNext();\n    }\n}",
  "Closure-62": "private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider excerptProvider \u003d getSource();\n    String snippetExcerpt \u003d null \u003d\u003d excerptProvider ? null : excerpt.get(excerptProvider, error.sourceName, error.lineNumber, excerptFormatter);\n    // formatting the message\n    StringBuilder stringBuilder \u003d new StringBuilder();\n    if (null !\u003d error.sourceName) {\n        stringBuilder.append(error.sourceName);\n        if (0 \u003c error.lineNumber) {\n            stringBuilder.append(\u0027:\u0027);\n            stringBuilder.append(error.lineNumber);\n        }\n        stringBuilder.append(\": \");\n    }\n    stringBuilder.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    stringBuilder.append(\" - \");\n    stringBuilder.append(error.description);\n    stringBuilder.append(\u0027\\n\u0027);\n    if (null !\u003d snippetExcerpt) {\n        stringBuilder.append(snippetExcerpt);\n        stringBuilder.append(\u0027\\n\u0027);\n        int offset \u003d error.getCharno();\n        // padding equal to the excerpt and arrow at the end\n        // charno \u003d\u003d sourceExpert.length() means something is missing\n        // at the end of the line\n        if (excerpt.equals(LINE) \u0026\u0026 offset \u003e\u003d 0 \u0026\u0026 snippetExcerpt.length() \u003e offset) {\n            int index \u003d 0;\n            while (offset \u003e index) {\n                char character \u003d snippetExcerpt.charAt(index);\n                if (!Character.isWhitespace(character)) {\n                    stringBuilder.append(\u0027 \u0027);\n                } else {\n                    stringBuilder.append(character);\n                }\n                index +\u003d 1;\n            }\n            stringBuilder.append(\"^\\n\");\n        }\n    }\n    return stringBuilder.toString();\n}",
  "Mockito-27": "public \u003cT\u003e void resetMock(T mock) {\n    MockHandlerInterface\u003cT\u003e previousMockHandler \u003d getMockHandler(mock);\n    MockHandler\u003cT\u003e updatedMockHandler \u003d new MockHandler\u003cT\u003e(previousMockHandler);\n    MethodInterceptorFilter methodInterceptorFilter \u003d new MethodInterceptorFilter(updatedMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    ((Factory) mock).setCallback(0, methodInterceptorFilter);\n}",
  "Chart-17": "public Object clone() throws CloneNotSupportedException {\n    Object duplicate \u003d createCopy(0, getItemCount() - 1);\n    return duplicate;\n}",
  "Mockito-28": "private void injectMockCandidate(Class\u003c?\u003e awaitingInjectionClazz, Set\u003cObject\u003e mocks, Object fieldInstance) {\n    for (Field property : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, property, fieldInstance).thenInject();\n    }\n}",
  "Mockito-29": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}",
  "Closure-61": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (Token.CALL !\u003d callNode.getType()) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node functionNameNode \u003d callNode.getFirstChild();\n    // Built-in functions with no side effects.\n    if (Token.NAME !\u003d functionNameNode.getType()) {\n        if (Token.GETPROP \u003d\u003d functionNameNode.getType()) {\n            if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(functionNameNode.getLastChild().getString())) {\n                return false;\n            }\n            if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(functionNameNode.getFirstChild())) {\n                return false;\n            }\n            // Functions in the \"Math\" namespace have no side effects.\n            if (null !\u003d compiler \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n                if (Token.REGEXP !\u003d functionNameNode.getFirstChild().getType() || !REGEXP_METHODS.contains(functionNameNode.getLastChild().getString())) {\n                    if (Token.STRING \u003d\u003d functionNameNode.getFirstChild().getType() \u0026\u0026 STRING_REGEXP_METHODS.contains(functionNameNode.getLastChild().getString())) {\n                        Node argument \u003d functionNameNode.getNext();\n                        if (null !\u003d argument \u0026\u0026 (Token.STRING \u003d\u003d argument.getType() || Token.REGEXP \u003d\u003d argument.getType()))\n                            return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n    } else {\n        String functionName \u003d functionNameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(functionName)) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Closure-166": "public void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n        return;\n    }\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraint {{prop: (number|undefined)}}\n    // function f(constraint) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraint.isRecordType()) {\n        matchRecordTypeConstraint(constraint.toObjectType());\n    }\n}",
  "Closure-66": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType nodeType;\n    JSType leftType, rhsType;\n    Node firstChild, operandRight;\n    // To be explicitly set to false if the node is not typeable.\n    boolean processable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            processable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            // If this is under a FUNCTION node, it is a parameter list and can be\n            // ignored here.\n            if (Token.FUNCTION \u003d\u003d parent.getType()) {\n                processable \u003d false;\n            } else {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            // Object literal keys are handled with OBJECTLIT\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n                // Object literal keys are not typeable\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            // Object literal keys are handled with OBJECTLIT\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            processable \u003d !(Token.ASSIGN \u003d\u003d parent.getType() \u0026\u0026 n \u003d\u003d parent.getFirstChild());\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            // The type of GETELEM is always unknown, so no point counting that.\n            // If that unknown leaks elsewhere (say by an assignment to another\n            // variable), then it will be counted.\n            processable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            processable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            processable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            processable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            processable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            firstChild \u003d n.getFirstChild();\n            validator.expectNumber(t, firstChild, getJSType(firstChild), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            nodeType \u003d getJSType(n.getFirstChild());\n            if (!nodeType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), nodeType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            firstChild \u003d n.getFirstChild();\n            validator.expectNumber(t, firstChild, getJSType(firstChild), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rhsType \u003d getJSType(n.getLastChild());\n                JSType leftTypeConstrained \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeConstrained \u003d rhsType.restrictByNotNullOrUndefined();\n                TernaryValue outcome \u003d leftTypeConstrained.testForEquality(rightTypeConstrained);\n                if (TernaryValue.UNKNOWN !\u003d outcome) {\n                    if (Token.NE \u003d\u003d n.getType()) {\n                        outcome \u003d outcome.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rhsType.toString(), outcome.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rhsType \u003d getJSType(n.getLastChild());\n                JSType leftTypeConstrained \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeConstrained \u003d rhsType.restrictByNotNullOrUndefined();\n                if (!leftTypeConstrained.canTestForShallowEqualityWith(rightTypeConstrained)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rhsType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rhsType \u003d getJSType(n.getLastChild());\n            if (!rhsType.isNumber()) {\n                if (!leftType.isNumber()) {\n                    if (!leftType.matchesNumberContext() || !rhsType.matchesNumberContext()) {\n                        // Whether the comparison is numeric will be determined at runtime\n                        // each time the expression is evaluated. Regardless, both operands\n                        // should match a string context.\n                        String warning \u003d \"left side of comparison\";\n                        validator.expectString(t, n, leftType, warning);\n                        validator.expectNotNullOrUndefined(t, n, leftType, warning, getNativeType(STRING_TYPE));\n                        warning \u003d \"right side of comparison\";\n                        validator.expectString(t, n, rhsType, warning);\n                        validator.expectNotNullOrUndefined(t, n, rhsType, warning, getNativeType(STRING_TYPE));\n                    } else {\n                        // OK.\n                    }\n                } else {\n                    validator.expectNumber(t, n, rhsType, \"right side of numeric comparison\");\n                }\n            } else {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            firstChild \u003d n.getFirstChild();\n            operandRight \u003d n.getLastChild();\n            leftType \u003d getJSType(firstChild);\n            rhsType \u003d getJSType(operandRight);\n            validator.expectObject(t, n, rhsType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, firstChild, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            firstChild \u003d n.getFirstChild();\n            operandRight \u003d n.getLastChild();\n            leftType \u003d getJSType(firstChild);\n            rhsType \u003d getJSType(operandRight).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, firstChild, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, operandRight, rhsType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            processable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType controlType \u003d getJSType(parent.getFirstChild());\n            JSType caseValue \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, controlType, caseValue);\n            processable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node descendant \u003d n.getFirstChild();\n                nodeType \u003d getJSType(descendant);\n                validator.expectObject(t, descendant, nodeType, \"with requires an object\");\n                processable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        // These nodes have no interesting type behavior.\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            processable \u003d false;\n            break;\n        // These nodes require data flow analysis.\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            processable \u003d false;\n            break;\n        // These nodes are typed during the type inference.\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (null \u003d\u003d n.getJSType()) {\n                // If this is an enum, then give that type to the objectlit as well.\n                if (!((Token.OBJECTLIT \u003d\u003d n.getType())) || !((parent.getJSType() instanceof EnumType))) {\n                    ensureTyped(t, n);\n                } else {\n                    ensureTyped(t, n, parent.getJSType());\n                }\n            } else {\n                // If we didn\u0027t run type inference.\n                ensureTyped(t, n);\n            }\n            if (Token.OBJECTLIT \u003d\u003d n.getType()) {\n                for (Node nodeKey : n.children()) {\n                    visitObjLitKey(t, nodeKey, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    // Don\u0027t count externs since the user\u0027s code may not even use that part.\n    processable \u003d processable \u0026\u0026 !inExterns;\n    if (processable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
  "Closure-67": "private boolean isPrototypePropertyAssign(Node assign) {\n    Node propertyNode \u003d assign.getFirstChild();\n    if (null !\u003d propertyNode \u0026\u0026 NodeUtil.isVarOrSimpleAssignLhs(propertyNode, assign) \u0026\u0026 Token.GETPROP \u003d\u003d propertyNode.getType()) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isNestedProperty \u003d Token.GETPROP \u003d\u003d propertyNode.getFirstChild().getType();\n        if (isNestedProperty) {\n            Node descendant \u003d propertyNode.getFirstChild().getFirstChild().getNext();\n            if (Token.STRING \u003d\u003d descendant.getType() \u0026\u0026 descendant.getString().equals(\"prototype\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
  "Closure-164": "public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n        return false;\n    }\n    ArrowType otherArrowType \u003d (ArrowType) other;\n    // This is described in Draft 2 of the ES4 spec,\n    // Section 3.4.7: Subtyping Function Types.\n    // this.returnType \u003c: that.returnType (covariant)\n    if (!this.returnType.isSubtype(otherArrowType.returnType)) {\n        return false;\n    }\n    // that.paramType[i] \u003c: this.paramType[i] (contravariant)\n    //\n    // If this.paramType[i] is required,\n    // then that.paramType[i] is required.\n    //\n    // In theory, the \"required-ness\" should work in the other direction as\n    // well. In other words, if we have\n    //\n    // function f(number, number) {}\n    // function g(number) {}\n    //\n    // Then f *should* not be a subtype of g, and g *should* not be\n    // a subtype of f. But in practice, we do not implement it this way.\n    // We want to support the use case where you can pass g where f is\n    // expected, and pretend that g ignores the second argument.\n    // That way, you can have a single \"no-op\" function, and you don\u0027t have\n    // to create a new no-op function for every possible type signature.\n    //\n    // So, in this case, g \u003c f, but f !\u003c g\n    Node currentParam \u003d parameters.getFirstChild();\n    Node otherParam \u003d otherArrowType.parameters.getFirstChild();\n    while (null !\u003d currentParam \u0026\u0026 null !\u003d otherParam) {\n        JSType currentParamType \u003d currentParam.getJSType();\n        JSType thatParamType \u003d otherParam.getJSType();\n        if (null !\u003d currentParamType) {\n            if (null \u003d\u003d thatParamType || !thatParamType.isSubtype(currentParamType)) {\n                return false;\n            }\n        }\n        boolean isVariadic \u003d currentParam.isVarArgs();\n        boolean thatHasVarArgs \u003d otherParam.isVarArgs();\n        // \"that\" can\u0027t be a supertype, because it\u0027s missing a required argument.\n        // NOTE(nicksantos): In our type system, we use {function(...?)} and\n        // {function(...NoType)} to to indicate that arity should not be\n        // checked. Strictly speaking, this is not a correct formulation,\n        // because now a sub-function can required arguments that are var_args\n        // in the super-function. So we special-case this.\n        // don\u0027t advance if we have variable arguments\n        if (!isVariadic) {\n            currentParam \u003d currentParam.getNext();\n        }\n        if (!thatHasVarArgs) {\n            otherParam \u003d otherParam.getNext();\n        }\n        // both var_args indicates the end\n        if (isVariadic \u0026\u0026 thatHasVarArgs) {\n            currentParam \u003d null;\n            otherParam \u003d null;\n        }\n    }\n    // \"that\" can\u0027t be a supertype, because it\u0027s missing a required arguement.\n    return true;\n}",
  "Closure-65": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() + 2);\n    stringBuilder.append(quote);\n    int index \u003d 0;\n    while (s.length() \u003e index) {\n        char character \u003d s.charAt(index);\n        switch(character) {\n            case \u0027\\0\u0027:\n                stringBuilder.append(\"\\\\0\");\n                break;\n            case \u0027\\n\u0027:\n                stringBuilder.append(\"\\\\n\");\n                break;\n            case \u0027\\r\u0027:\n                stringBuilder.append(\"\\\\r\");\n                break;\n            case \u0027\\t\u0027:\n                stringBuilder.append(\"\\\\t\");\n                break;\n            case \u0027\\\\\u0027:\n                stringBuilder.append(backslashEscape);\n                break;\n            case \u0027\\\"\u0027:\n                stringBuilder.append(doublequoteEscape);\n                break;\n            case \u0027\\\u0027\u0027:\n                stringBuilder.append(singlequoteEscape);\n                break;\n            case // Break --\u003e into --\\\u003e or ]]\u003e into ]]\\\u003e\n            \u0027\u003e\u0027:\n                if (2 \u003e index || !(((\u0027-\u0027 \u003d\u003d s.charAt(index - 1) \u0026\u0026 \u0027-\u0027 \u003d\u003d s.charAt(index - 2)) || (\u0027]\u0027 \u003d\u003d s.charAt(index - 1) \u0026\u0026 \u0027]\u0027 \u003d\u003d s.charAt(index - 2))))) {\n                    stringBuilder.append(character);\n                } else {\n                    stringBuilder.append(\"\\\\\u003e\");\n                }\n                break;\n            case \u0027\u003c\u0027:\n                // Break \u003c/script into \u003c\\/script\n                final String SCRIPT_END \u003d \"/script\";\n                // Break \u003c!-- into \u003c\\!--\n                final String START_COMMENT_MARKER \u003d \"!--\";\n                if (!s.regionMatches(true, index + 1, SCRIPT_END, 0, SCRIPT_END.length())) {\n                    if (!s.regionMatches(false, index + 1, START_COMMENT_MARKER, 0, START_COMMENT_MARKER.length())) {\n                        stringBuilder.append(character);\n                    } else {\n                        stringBuilder.append(\"\u003c\\\\\");\n                    }\n                } else {\n                    stringBuilder.append(\"\u003c\\\\\");\n                }\n                break;\n            default:\n                // If we\u0027re given an outputCharsetEncoder, then check if the\n                //  character can be represented in this character set.\n                if (null \u003d\u003d outputCharsetEncoder) {\n                    // No charsetEncoder provided - pass straight latin characters\n                    // through, and escape the rest.  Doing the explicit character\n                    // check is measurably faster than using the CharsetEncoder.\n                    if (0x1f \u003e\u003d character || 0x7f \u003c\u003d character) {\n                        // Other characters can be misinterpreted by some js parsers,\n                        // or perhaps mangled by proxies along the way,\n                        // so we play it safe and unicode escape them.\n                        appendHexJavaScriptRepresentation(stringBuilder, character);\n                    } else {\n                        stringBuilder.append(character);\n                    }\n                } else {\n                    if (!outputCharsetEncoder.canEncode(character)) {\n                        // Unicode-escape the character.\n                        appendHexJavaScriptRepresentation(stringBuilder, character);\n                    } else {\n                        stringBuilder.append(character);\n                    }\n                }\n        }\n        index +\u003d 1;\n    }\n    stringBuilder.append(quote);\n    return stringBuilder.toString();\n}",
  "Closure-161": "private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node ancestor \u003d n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can\u0027t fold it here:\n    //    \"[][0] +\u003d 1\"\n    if (Token.NUMBER !\u003d right.getType()) {\n        // Sometimes people like to use complex expressions to index into\n        // arrays, or strings to index into array methods.\n        return n;\n    }\n    double arrayIndex \u003d right.getDouble();\n    int intIndex \u003d (int) arrayIndex;\n    if (arrayIndex !\u003d intIndex) {\n        error(INVALID_GETELEM_INDEX_ERROR, right);\n        return n;\n    }\n    if (0 \u003e intIndex) {\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n        return n;\n    }\n    Node childElement \u003d left.getFirstChild();\n    int indexIterator \u003d 0;\n    while (null !\u003d childElement \u0026\u0026 intIndex \u003e indexIterator) {\n        childElement \u003d childElement.getNext();\n        indexIterator +\u003d 1;\n    }\n    if (null \u003d\u003d childElement) {\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n        return n;\n    }\n    if (Token.EMPTY !\u003d childElement.getType()) {\n        left.removeChild(childElement);\n    } else {\n        childElement \u003d NodeUtil.newUndefinedNode(childElement);\n    }\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, childElement);\n    reportCodeChange();\n    return childElement;\n}",
  "Chart-10": "public String generateToolTipFragment(String toolTipText) {\n    return \" title\u003d\\\"\" + toolTipText + \"\\\" alt\u003d\\\"\\\"\";\n}",
  "Closure-160": "public void initOptions(CompilerOptions options) {\n    this.options \u003d options;\n    if (null \u003d\u003d errorManager) {\n        if (null !\u003d outStream) {\n            PrintStreamErrorManager outputManager \u003d new PrintStreamErrorManager(createMessageFormatter(), outStream);\n            outputManager.setSummaryDetailLevel(options.summaryDetailLevel);\n            setErrorManager(outputManager);\n        } else {\n            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));\n        }\n    }\n    // DiagnosticGroups override the plain checkTypes option.\n    if (!options.enables(DiagnosticGroups.CHECK_TYPES)) {\n        if (!options.disables(DiagnosticGroups.CHECK_TYPES)) {\n            if (!options.checkTypes) {\n                // If DiagnosticGroups did not override the plain checkTypes\n                // option, and checkTypes is enabled, then turn off the\n                // parser type warnings.\n                options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);\n            }\n        } else {\n            options.checkTypes \u003d false;\n        }\n    } else {\n        options.checkTypes \u003d true;\n    }\n    if (options.checkGlobalThisLevel.isOn()) {\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);\n    }\n    // Initialize the warnings guard.\n    List\u003cWarningsGuard\u003e safeguards \u003d Lists.newArrayList();\n    safeguards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));\n    safeguards.add(options.getWarningsGuard());\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn\u0027t crash. It also\n    // checks the externs file for validity. If you don\u0027t want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols \u0026\u0026 (null \u003d\u003d warningsGuard || !warningsGuard.disables(DiagnosticGroups.CHECK_VARIABLES))) {\n        safeguards.add(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n    this.warningsGuard \u003d new ComposeWarningsGuard(safeguards);\n}",
  "Chart-11": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (null \u003d\u003d p1) {\n        return (null \u003d\u003d p2);\n    }\n    if (null \u003d\u003d p2) {\n        return false;\n    }\n    if (p2.getWindingRule() !\u003d p1.getWindingRule()) {\n        return false;\n    }\n    PathIterator pathIterator1 \u003d p1.getPathIterator(null);\n    PathIterator iterator2Copy \u003d p1.getPathIterator(null);\n    double[] points1 \u003d new double[6];\n    double[] dPathArray \u003d new double[6];\n    boolean finished \u003d pathIterator1.isDone() \u0026\u0026 iterator2Copy.isDone();\n    while (!finished) {\n        if (iterator2Copy.isDone() !\u003d pathIterator1.isDone()) {\n            return false;\n        }\n        int segment1 \u003d pathIterator1.currentSegment(points1);\n        int segCurrent \u003d iterator2Copy.currentSegment(dPathArray);\n        if (segCurrent !\u003d segment1) {\n            return false;\n        }\n        if (!Arrays.equals(points1, dPathArray)) {\n            return false;\n        }\n        pathIterator1.next();\n        iterator2Copy.next();\n        finished \u003d pathIterator1.isDone() \u0026\u0026 iterator2Copy.isDone();\n    }\n    return true;\n}",
  "Closure-69": "private void visitCall(NodeTraversal t, Node n) {\n    Node descendant \u003d n.getFirstChild();\n    JSType descendantType \u003d getJSType(descendant).restrictByNotNullOrUndefined();\n    if (!descendantType.canBeCalled()) {\n        report(t, n, NOT_CALLABLE, descendantType.toString());\n        ensureTyped(t, n);\n        return;\n    }\n    // A couple of types can be called as if they were functions.\n    // If it is a function type, then validate parameters.\n    if (!(descendantType instanceof FunctionType)) {\n        ensureTyped(t, n);\n    } else {\n        FunctionType methodType \u003d (FunctionType) descendantType;\n        boolean isExternal \u003d false;\n        JSDocInfo functionDocumentation \u003d methodType.getJSDocInfo();\n        if (null !\u003d functionDocumentation) {\n            String functionSourceName \u003d functionDocumentation.getSourceName();\n            CompilerInput functionInput \u003d compiler.getInput(functionSourceName);\n            isExternal \u003d functionInput.isExtern();\n        }\n        // Non-native constructors should not be called directly\n        // unless they specify a return type and are defined\n        // in an extern.\n        if (methodType.isConstructor() \u0026\u0026 !methodType.isNativeObjectType() \u0026\u0026 (methodType.getReturnType().isUnknownType() || methodType.getReturnType().isVoidType() || !isExternal)) {\n            report(t, n, CONSTRUCTOR_NOT_CALLABLE, descendantType.toString());\n        }\n        // Functions with explcit \u0027this\u0027 types must be called in a GETPROP\n        // or GETELEM.\n        visitParameterList(t, n, methodType);\n        ensureTyped(t, n, methodType.getReturnType());\n    }\n    // TODO: Add something to check for calls of RegExp objects, which is not\n    // supported by IE.  Either say something about the return type or warn\n    // about the non-portability of the call or both.\n}"
}