{
  "Chart-1": {
    "id": "Chart-1",
    "project": "Chart",
    "number": "1",
    "buggy_function": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset != null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}",
    "fixed_function": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java",
      "first_line": 1790,
      "last_line": 1822
    },
    "javadoc": "/**\n* Returns a (possibly empty) collection of legend items for the series\n* that this renderer is responsible for drawing.\n*\n* @return The legend item collection (never <code>null</code>).\n*\n* @see #getLegendItem(int, int)\n*/",
    "failing_tests": {
      "org.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests::test2947660": {
        "source": "    public void test2947660() {\n\n        AbstractCategoryItemRenderer r = new LineAndShapeRenderer();\n\n        assertNotNull(r.getLegendItems());\n\n        assertEquals(0, r.getLegendItems().getItemCount());\n\n\n\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n        CategoryPlot plot = new CategoryPlot();\n\n        plot.setDataset(dataset);\n\n        plot.setRenderer(r);\n\n        assertEquals(0, r.getLegendItems().getItemCount());\n\n\n\n        dataset.addValue(1.0, \"S1\", \"C1\");\n\n        LegendItemCollection lic = r.getLegendItems();\n\n        assertEquals(1, lic.getItemCount());\n\n        assertEquals(\"S1\", lic.get(0).getLabel());\n\n    }\n"
      }
    }
  },
  "Chart-10": {
    "id": "Chart-10",
    "project": "Chart",
    "number": "10",
    "buggy_function": "public String generateToolTipFragment(String toolTipText) {\n    return \" title=\\\"\" + toolTipText\n        + \"\\\" alt=\\\"\\\"\";\n}",
    "fixed_function": "public String generateToolTipFragment(String toolTipText) {\n    return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n        + \"\\\" alt=\\\"\\\"\";\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java",
      "first_line": 64,
      "last_line": 67
    },
    "javadoc": "/**\n* Generates a tooltip string to go in an HTML image map.\n*\n* @param toolTipText  the tooltip.\n*\n* @return The formatted HTML area tag attribute(s).\n*/",
    "failing_tests": {
      "org.jfree.chart.imagemap.junit.StandardToolTipTagFragmentGeneratorTests::testGenerateURLFragment": {
        "source": "    public void testGenerateURLFragment() {\n\n        StandardToolTipTagFragmentGenerator g\n\n                = new StandardToolTipTagFragmentGenerator();\n\n        assertEquals(\" title=\\\"abc\\\" alt=\\\"\\\"\",\n\n                g.generateToolTipFragment(\"abc\"));\n\n        assertEquals(\" title=\\\"Series &quot;A&quot;, 100.0\\\" alt=\\\"\\\"\",\n\n                g.generateToolTipFragment(\"Series \\\"A\\\", 100.0\"));\n\n    }\n"
      }
    }
  },
  "Chart-11": {
    "id": "Chart-11",
    "project": "Chart",
    "number": "11",
    "buggy_function": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p1.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}",
    "fixed_function": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/util/ShapeUtilities.java",
      "first_line": 264,
      "last_line": 296
    },
    "javadoc": "/**\n* Tests two polygons for equality.  If both are <code>null</code> this\n* method returns <code>true</code>.\n*\n* @param p1  path 1 (<code>null</code> permitted).\n* @param p2  path 2 (<code>null</code> permitted).\n*\n* @return A boolean.\n*/",
    "failing_tests": {
      "org.jfree.chart.util.junit.ShapeUtilitiesTests::testEqualGeneralPaths": {
        "source": "    public void testEqualGeneralPaths() {\n\n        GeneralPath g1 = new GeneralPath();\n\n        g1.moveTo(1.0f, 2.0f);\n\n        g1.lineTo(3.0f, 4.0f);\n\n        g1.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n\n        g1.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n\n        g1.closePath();\n\n        GeneralPath g2 = new GeneralPath();\n\n        g2.moveTo(1.0f, 2.0f);\n\n        g2.lineTo(3.0f, 4.0f);\n\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n\n        g2.closePath();\n\n        assertTrue(ShapeUtilities.equal(g1, g2));\n\n\n\n        g2 = new GeneralPath();\n\n        g2.moveTo(11.0f, 22.0f);\n\n        g2.lineTo(3.0f, 4.0f);\n\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n\n        g2.closePath();\n\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n\n\n        g2 = new GeneralPath();\n\n        g2.moveTo(1.0f, 2.0f);\n\n        g2.lineTo(33.0f, 44.0f);\n\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n\n        g2.closePath();\n\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n\n\n        g2 = new GeneralPath();\n\n        g2.moveTo(1.0f, 2.0f);\n\n        g2.lineTo(3.0f, 4.0f);\n\n        g2.curveTo(55.0f, 66.0f, 77.0f, 88.0f, 99.0f, 100.0f);\n\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n\n        g2.closePath();\n\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n\n\n        g2 = new GeneralPath();\n\n        g2.moveTo(1.0f, 2.0f);\n\n        g2.lineTo(3.0f, 4.0f);\n\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n\n        g2.quadTo(11.0f, 22.0f, 33.0f, 44.0f);\n\n        g2.closePath();\n\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n\n\n        g2 = new GeneralPath();\n\n        g2.moveTo(1.0f, 2.0f);\n\n        g2.lineTo(3.0f, 4.0f);\n\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n\n        g2.lineTo(3.0f, 4.0f);\n\n        g2.closePath();\n\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n    }\n"
      }
    }
  },
  "Chart-12": {
    "id": "Chart-12",
    "project": "Chart",
    "number": "12",
    "buggy_function": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}",
    "fixed_function": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/plot/MultiplePiePlot.java",
      "first_line": 143,
      "last_line": 158
    },
    "javadoc": "/**\n* Creates a new plot.\n*\n* @param dataset  the dataset (<code>null</code> permitted).\n*/",
    "failing_tests": {
      "org.jfree.chart.plot.junit.MultiplePiePlotTests::testConstructor": {
        "source": "    public void testConstructor() {\n\n    \tMultiplePiePlot plot = new MultiplePiePlot();\n\n    \tassertNull(plot.getDataset());\n\n\n\n    \t// the following checks that the plot registers itself as a listener\n\n    \t// with the dataset passed to the constructor - see patch 1943021\n\n    \tDefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n    \tplot = new MultiplePiePlot(dataset);\n\n    \tassertTrue(dataset.hasListener(plot));\n\n    }\n"
      }
    }
  },
  "Chart-13": {
    "id": "Chart-13",
    "project": "Chart",
    "number": "13",
    "buggy_function": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth() - w[2]),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.rightBlock.arrange(g2, c4);\n        w[3] = size.width;\n    }\n    h[4] = h[2];\n    w[4] = constraint.getWidth() - w[3] - w[2];\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n    if (this.centerBlock != null) {\n        this.centerBlock.arrange(g2, c5);\n    }\n\n    if (this.topBlock != null) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                h[0]));\n    }\n    if (this.bottomBlock != null) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                w[1], h[1]));\n    }\n    if (this.leftBlock != null) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                h[2]));\n    }\n    if (this.rightBlock != null) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                w[3], h[3]));\n    }\n    if (this.centerBlock != null) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                h[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}",
    "fixed_function": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.rightBlock.arrange(g2, c4);\n        w[3] = size.width;\n    }\n    h[4] = h[2];\n    w[4] = constraint.getWidth() - w[3] - w[2];\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n    if (this.centerBlock != null) {\n        this.centerBlock.arrange(g2, c5);\n    }\n\n    if (this.topBlock != null) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                h[0]));\n    }\n    if (this.bottomBlock != null) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                w[1], h[1]));\n    }\n    if (this.leftBlock != null) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                h[2]));\n    }\n    if (this.rightBlock != null) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                w[3], h[3]));\n    }\n    if (this.centerBlock != null) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                h[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/block/BorderArrangement.java",
      "first_line": 422,
      "last_line": 489
    },
    "javadoc": "/**\n* Arranges the items within a container.\n*\n* @param container  the container.\n* @param constraint  the constraint.\n* @param g2  the graphics device.\n*\n* @return The container size after the arrangement.\n*/",
    "failing_tests": {
      "org.jfree.chart.block.junit.BorderArrangementTests::testSizingWithWidthConstraint": {
        "source": "    public void testSizingWithWidthConstraint() {\n\n        RectangleConstraint constraint = new RectangleConstraint(\n\n            10.0, new Range(10.0, 10.0), LengthConstraintType.FIXED,\n\n            0.0, new Range(0.0, 0.0), LengthConstraintType.NONE\n\n        );\n\n                \n\n        BlockContainer container = new BlockContainer(new BorderArrangement());\n\n        BufferedImage image = new BufferedImage(\n\n            200, 100, BufferedImage.TYPE_INT_RGB\n\n        );\n\n        Graphics2D g2 = image.createGraphics();\n\n        \n\n        // TBLRC\n\n        // 00001 - center item only\n\n        container.add(new EmptyBlock(5.0, 6.0));\n\n        Size2D size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(6.0, size.height, EPSILON);\n\n        \n\n        container.clear();\n\n        container.add(new EmptyBlock(15.0, 16.0));\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(16.0, size.height, EPSILON);\n\n\n\n        // TBLRC\n\n        // 00010 - right item only\n\n        container.clear();\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.RIGHT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 00011 - right and center items\n\n        container.clear();\n\n        container.add(new EmptyBlock(7.0, 20.0));\n\n        container.add(new EmptyBlock(8.0, 45.6), RectangleEdge.RIGHT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 00100 - left item only\n\n        container.clear();\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 00101 - left and center items\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0));\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 00110 - left and right items\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 00111 - left, right and center items\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0));\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(5.4, 3.2), RectangleEdge.RIGHT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01000 - bottom item only\n\n        container.clear();\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01001 - bottom and center only\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0));\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01010 - bottom and right only\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01011 - bottom, right and center\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3));\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01100\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01101 - bottom, left and center\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3));\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01110 - bottom. left and right\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 01111\n\n        container.clear();\n\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(9.0, 10.0));\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(14.0, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 10000 - top item only\n\n        container.clear();\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(45.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 10001 - top and center only\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0));\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n                \n\n        // TBLRC\n\n        // 10010 - right and top only\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 10011 - top, right and center\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3));\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.RIGHT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n\n\n        // TBLRC\n\n        // 10100 - top and left only\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 10101 - top, left and center\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3));\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 10110 - top, left and right\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 10111\n\n        container.clear();\n\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(9.0, 10.0));\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(12.0, size.height, EPSILON);\n\n\n\n        // TBLRC\n\n        // 11000 - top and bottom only\n\n        container.clear();\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(65.6, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 11001\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3));\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(77.9, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 11010 - top, bottom and right\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(77.9, size.height, EPSILON);\n\n                \n\n        // TBLRC\n\n        // 11011\n\n        container.clear();\n\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(9.0, 10.0));\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(16.0, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 11100\n\n        container.clear();\n\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(77.9, size.height, EPSILON);\n\n\n\n        // TBLRC\n\n        // 11101\n\n        container.clear();\n\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(9.0, 10.0));\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(16.0, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 11110\n\n        container.clear();\n\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(14.0, size.height, EPSILON);\n\n        \n\n        // TBLRC\n\n        // 11111 - all\n\n        container.clear();\n\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n\n        container.add(new EmptyBlock(9.0, 10.0));\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(16.0, size.height, EPSILON);\n\n\n\n        // TBLRC\n\n        // 00000 - no items\n\n        container.clear();\n\n        size = container.arrange(g2, constraint);\n\n        assertEquals(10.0, size.width, EPSILON);\n\n        assertEquals(0.0, size.height, EPSILON);\n\n        \n\n    }\n"
      }
    }
  },
  "Chart-17": {
    "id": "Chart-17",
    "project": "Chart",
    "number": "17",
    "buggy_function": "public Object clone() throws CloneNotSupportedException {\n    Object clone = createCopy(0, getItemCount() - 1);\n    return clone;\n}",
    "fixed_function": "public Object clone() throws CloneNotSupportedException {\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = (List) ObjectUtilities.deepClone(this.data);\n    return clone;\n}",
    "replacement_info": {
      "file": "source/org/jfree/data/time/TimeSeries.java",
      "first_line": 856,
      "last_line": 859
    },
    "javadoc": "/**\n* Returns a clone of the time series.\n* <P>\n* Notes:\n* <ul>\n*   <li>no need to clone the domain and range descriptions, since String\n*     object is immutable;</li>\n*   <li>we pass over to the more general method clone(start, end).</li>\n* </ul>\n*\n* @return A clone of the time series.\n*\n* @throws CloneNotSupportedException not thrown by this class, but\n*         subclasses may differ.\n*/",
    "failing_tests": {
      "org.jfree.data.time.junit.TimeSeriesTests::testBug1832432": {
        "source": "    public void testBug1832432() {\n\n        TimeSeries s1 = new TimeSeries(\"Series\");\n\n        TimeSeries s2 = null;\n\n        try {\n\n            s2 = (TimeSeries) s1.clone();\n\n        }\n\n        catch (CloneNotSupportedException e) {\n\n            e.printStackTrace();\n\n        }\n\n        assertTrue(s1 != s2);\n\n        assertTrue(s1.getClass() == s2.getClass());\n\n        assertTrue(s1.equals(s2));\n\n\n\n        // test independence\n\n        s1.add(new Day(1, 1, 2007), 100.0);\n\n        assertFalse(s1.equals(s2));    \t\n\n    }\n"
      }
    }
  },
  "Chart-20": {
    "id": "Chart-20",
    "project": "Chart",
    "number": "20",
    "buggy_function": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, paint, stroke, alpha);\n    this.value = value;\n}",
    "fixed_function": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, outlinePaint, outlineStroke, alpha);\n    this.value = value;\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/plot/ValueMarker.java",
      "first_line": 93,
      "last_line": 97
    },
    "javadoc": "/**\n* Creates a new value marker.\n*\n* @param value  the value.\n* @param paint  the paint (<code>null</code> not permitted).\n* @param stroke  the stroke (<code>null</code> not permitted).\n* @param outlinePaint  the outline paint (<code>null</code> permitted).\n* @param outlineStroke  the outline stroke (<code>null</code> permitted).\n* @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n*/",
    "failing_tests": {
      "org.jfree.chart.plot.junit.ValueMarkerTests::test1808376": {
        "source": "    public void test1808376() {\n\n        Stroke stroke = new BasicStroke(1.0f);\n\n        Stroke outlineStroke = new BasicStroke(2.0f);\n\n        ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, \n\n                outlineStroke, 0.5f);\n\n        assertEquals(1.0, m.getValue(), EPSILON);\n\n        assertEquals(Color.red, m.getPaint());\n\n        assertEquals(stroke, m.getStroke());\n\n        assertEquals(Color.blue, m.getOutlinePaint());\n\n        assertEquals(outlineStroke, m.getOutlineStroke());\n\n        assertEquals(0.5f, m.getAlpha(), EPSILON);\n\n    }\n"
      }
    }
  },
  "Chart-24": {
    "id": "Chart-24",
    "project": "Chart",
    "number": "24",
    "buggy_function": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound \n            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}",
    "fixed_function": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound \n            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/renderer/GrayPaintScale.java",
      "first_line": 123,
      "last_line": 129
    },
    "javadoc": "/**\n* Returns a paint for the specified value.\n*\n* @param value  the value (must be within the range specified by the\n*         lower and upper bounds for the scale).\n*\n* @return A paint for the specified value.\n*/",
    "failing_tests": {
      "org.jfree.chart.renderer.junit.GrayPaintScaleTests::testGetPaint": {
        "source": "    public void testGetPaint() {\n\n        GrayPaintScale gps = new GrayPaintScale();\n\n        Color c = (Color) gps.getPaint(0.0);\n\n        assertTrue(c.equals(Color.black));\n\n        c = (Color) gps.getPaint(1.0);\n\n        assertTrue(c.equals(Color.white));\n\n        \n\n        // check lookup values that are outside the bounds - see bug report\n\n        // 1767315\n\n        c = (Color) gps.getPaint(-0.5);\n\n        assertTrue(c.equals(Color.black));\n\n        c = (Color) gps.getPaint(1.5);\n\n        assertTrue(c.equals(Color.white));\n\n    }\n"
      }
    }
  },
  "Chart-26": {
    "id": "Chart-26",
    "project": "Chart",
    "number": "26",
    "buggy_function": "protected AxisState drawLabel(String label, Graphics2D g2, \n        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n        AxisState state, PlotRenderingInfo plotState) {\n\n    // it is unlikely that 'state' will be null, but check anyway...\n    if (state == null) {\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    \n    if ((label == null) || (label.equals(\"\"))) {\n        return state;\n    }\n\n    Font font = getLabelFont();\n    RectangleInsets insets = getLabelInsets();\n    g2.setFont(font);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fm = g2.getFontMetrics();\n    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n    Shape hotspot = null;\n    \n    if (edge == RectangleEdge.TOP) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() - insets.getBottom() \n                - h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.BOTTOM) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() + insets.getTop() \n                + h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.LEFT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() - insets.getRight() \n                - w / 2.0);\n        float labely = (float) dataArea.getCenterY();\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    else if (edge == RectangleEdge.RIGHT) {\n\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() + Math.PI / 2.0, \n                labelBounds.getCenterX(), labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() \n                        + insets.getLeft() + w / 2.0);\n        float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n\n    }\n    if (plotState != null && hotspot != null) {\n        ChartRenderingInfo owner = plotState.getOwner();\n            EntityCollection entities = owner.getEntityCollection();\n            if (entities != null) {\n                entities.add(new AxisLabelEntity(this, hotspot, \n                        this.labelToolTip, this.labelURL));\n            }\n    }\n    return state;\n\n}",
    "fixed_function": "protected AxisState drawLabel(String label, Graphics2D g2, \n        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n        AxisState state, PlotRenderingInfo plotState) {\n\n    // it is unlikely that 'state' will be null, but check anyway...\n    if (state == null) {\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    \n    if ((label == null) || (label.equals(\"\"))) {\n        return state;\n    }\n\n    Font font = getLabelFont();\n    RectangleInsets insets = getLabelInsets();\n    g2.setFont(font);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fm = g2.getFontMetrics();\n    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n    Shape hotspot = null;\n    \n    if (edge == RectangleEdge.TOP) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() - insets.getBottom() \n                - h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.BOTTOM) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() + insets.getTop() \n                + h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.LEFT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() - insets.getRight() \n                - w / 2.0);\n        float labely = (float) dataArea.getCenterY();\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    else if (edge == RectangleEdge.RIGHT) {\n\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() + Math.PI / 2.0, \n                labelBounds.getCenterX(), labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() \n                        + insets.getLeft() + w / 2.0);\n        float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n\n    }\n    if (plotState != null && hotspot != null) {\n        ChartRenderingInfo owner = plotState.getOwner();\n        if (owner != null) {\n            EntityCollection entities = owner.getEntityCollection();\n            if (entities != null) {\n                entities.add(new AxisLabelEntity(this, hotspot, \n                        this.labelToolTip, this.labelURL));\n            }\n        }\n    }\n    return state;\n\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/axis/Axis.java",
      "first_line": 1092,
      "last_line": 1200
    },
    "javadoc": "/**\n* Draws the axis label.\n*\n* @param label  the label text.\n* @param g2  the graphics device.\n* @param plotArea  the plot area.\n* @param dataArea  the area inside the axes.\n* @param edge  the location of the axis.\n* @param state  the axis state (<code>null</code> not permitted).\n* @param plotState  the plot state (<code>null</code> permitted).\n*\n* @return Information about the axis.\n*/",
    "failing_tests": {
      "org.jfree.chart.junit.AreaChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.junit.BarChart3DTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.junit.BarChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.GanttChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.junit.GanttChartTests::testDrawWithNullInfo2": {
        "source": "    public void testDrawWithNullInfo2() {\n\n        boolean success = false;\n\n        try {\n\n            JFreeChart chart = createGanttChart();\n\n            CategoryPlot plot = (CategoryPlot) chart.getPlot();\n\n            plot.setDataset(createDataset());\n\n            /* BufferedImage img =*/ chart.createBufferedImage(300, 200, null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.junit.LineChart3DTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.LineChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.StackedAreaChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.StackedBarChart3DTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.StackedBarChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n        }\n\n\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.WaterfallChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            success = false;\n\n        }\n\n\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.plot.junit.CategoryPlotTests::test1654215": {
        "source": "    public void test1654215() {\n\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n        JFreeChart chart = ChartFactory.createLineChart(\"Title\", \"X\", \"Y\",\n\n                dataset, PlotOrientation.VERTICAL, true, false, false);\n\n        CategoryPlot plot = (CategoryPlot) chart.getPlot();\n\n        plot.setRenderer(1, new LineAndShapeRenderer());\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100, \n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.plot.junit.CategoryPlotTests::testSerialization3": {
        "source": "    public void testSerialization3() {\n\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n        JFreeChart chart = ChartFactory.createBarChart(\n\n            \"Test Chart\",\n\n            \"Category Axis\",\n\n            \"Value Axis\",\n\n            dataset,\n\n            PlotOrientation.VERTICAL,\n\n            true,\n\n            true,\n\n            false\n\n        );\n\n        JFreeChart chart2 = null;\n\n        \n\n        // serialize and deserialize the chart....\n\n        try {\n\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\n            ObjectOutput out = new ObjectOutputStream(buffer);\n\n            out.writeObject(chart);\n\n            out.close();\n\n\n\n            ObjectInput in = new ObjectInputStream(\n\n                    new ByteArrayInputStream(buffer.toByteArray()));\n\n            chart2 = (JFreeChart) in.readObject();\n\n            in.close();\n\n        }\n\n        catch (Exception e) {\n\n            fail(e.toString());\n\n        }\n\n\n\n        // now check that the chart is usable...\n\n        boolean passed = true;\n\n        try {\n\n            chart2.createBufferedImage(300, 200);\n\n        }\n\n        catch (Exception e) {\n\n            passed = false;  \n\n            e.printStackTrace();            \n\n        }\n\n        assertTrue(passed);\n\n    }\n"
      },
      "org.jfree.chart.plot.junit.CategoryPlotTests::testSerialization4": {
        "source": "    public void testSerialization4() {\n\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n        JFreeChart chart = ChartFactory.createBarChart(\n\n            \"Test Chart\",\n\n            \"Category Axis\",\n\n            \"Value Axis\",\n\n            dataset,\n\n            PlotOrientation.VERTICAL,\n\n            true,\n\n            true,\n\n            false\n\n        );\n\n        CategoryPlot plot = (CategoryPlot) chart.getPlot();\n\n        plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND);\n\n        plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND);\n\n        JFreeChart chart2 = null;\n\n        \n\n        // serialize and deserialize the chart....\n\n        try {\n\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\n            ObjectOutput out = new ObjectOutputStream(buffer);\n\n            out.writeObject(chart);\n\n            out.close();\n\n\n\n            ObjectInput in = new ObjectInputStream(\n\n                    new ByteArrayInputStream(buffer.toByteArray()));\n\n            chart2 = (JFreeChart) in.readObject();\n\n            in.close();\n\n        }\n\n        catch (Exception e) {\n\n            fail(e.toString());\n\n        }\n\n        assertEquals(chart, chart2);\n\n        \n\n        // now check that the chart is usable...\n\n        boolean passed = true;\n\n        try {\n\n            chart2.createBufferedImage(300, 200);\n\n        }\n\n        catch (Exception e) {\n\n            passed = false;  \n\n            e.printStackTrace();            \n\n        }\n\n        assertTrue(passed);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.BoxAndWhiskerRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultBoxAndWhiskerCategoryDataset dataset \n\n                = new DefaultBoxAndWhiskerCategoryDataset();\n\n            dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0),\n\n                    new Double(0.0), new Double(4.0), new Double(0.5), \n\n                    new Double(4.5), new Double(-0.5), new Double(5.5), \n\n                    null), \"S1\", \"C1\");\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    new BoxAndWhiskerRenderer());\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.GroupedStackedBarRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n            dataset.addValue(1.0, \"S1\", \"C1\");\n\n            dataset.addValue(2.0, \"S1\", \"C2\");\n\n            dataset.addValue(3.0, \"S2\", \"C1\");\n\n            dataset.addValue(4.0, \"S2\", \"C2\");\n\n            GroupedStackedBarRenderer renderer \n\n                = new GroupedStackedBarRenderer();\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    renderer);\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.IntervalBarRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            double[][] starts = new double[][] {{0.1, 0.2, 0.3}, \n\n                    {0.3, 0.4, 0.5}};\n\n            double[][] ends = new double[][] {{0.5, 0.6, 0.7}, {0.7, 0.8, 0.9}};\n\n            DefaultIntervalCategoryDataset dataset \n\n                = new DefaultIntervalCategoryDataset(starts, ends);        \n\n            IntervalBarRenderer renderer = new IntervalBarRenderer();\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    renderer);\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.LayeredBarRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n            dataset.addValue(1.0, \"S1\", \"C1\");\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    new LayeredBarRenderer());\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.LevelRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n            dataset.addValue(1.0, \"S1\", \"C1\");\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    new LevelRenderer());\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.MinMaxCategoryRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n            dataset.addValue(1.0, \"S1\", \"C1\");\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    new MinMaxCategoryRenderer());\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultStatisticalCategoryDataset dataset \n\n                = new DefaultStatisticalCategoryDataset();\n\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n\n            dataset.add(3.0, 4.0, \"S1\", \"C2\");\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    new StatisticalBarRenderer());\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      },
      "org.jfree.chart.renderer.category.junit.StatisticalLineAndShapeRendererTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n\n            DefaultStatisticalCategoryDataset dataset \n\n                = new DefaultStatisticalCategoryDataset();\n\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n\n            dataset.add(3.0, 4.0, \"S1\", \"C2\");\n\n            CategoryPlot plot = new CategoryPlot(dataset, \n\n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n\n                    new StatisticalLineAndShapeRenderer());\n\n            JFreeChart chart = new JFreeChart(plot);\n\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n\n                    null);\n\n            success = true;\n\n        }\n\n        catch (NullPointerException e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      }
    }
  },
  "Chart-3": {
    "id": "Chart-3",
    "project": "Chart",
    "number": "3",
    "buggy_function": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n            try {\n                copy.add(clone);\n            }\n            catch (SeriesException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return copy;\n}",
    "fixed_function": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.minY = Double.NaN;\n    copy.maxY = Double.NaN;\n    copy.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n            try {\n                copy.add(clone);\n            }\n            catch (SeriesException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return copy;\n}",
    "replacement_info": {
      "file": "source/org/jfree/data/time/TimeSeries.java",
      "first_line": 1048,
      "last_line": 1072
    },
    "javadoc": "/**\n* Creates a new timeseries by copying a subset of the data in this time\n* series.\n*\n* @param start  the index of the first time period to copy.\n* @param end  the index of the last time period to copy.\n*\n* @return A series containing a copy of this times series from start until\n*         end.\n*\n* @throws CloneNotSupportedException if there is a cloning problem.\n*/",
    "failing_tests": {
      "org.jfree.data.time.junit.TimeSeriesTests::testCreateCopy3": {
        "source": "    public void testCreateCopy3() throws CloneNotSupportedException {\n\n        TimeSeries s1 = new TimeSeries(\"S1\");\n\n        s1.add(new Year(2009), 100.0);\n\n        s1.add(new Year(2010), 101.0);\n\n        s1.add(new Year(2011), 102.0);\n\n        assertEquals(100.0, s1.getMinY(), EPSILON);\n\n        assertEquals(102.0, s1.getMaxY(), EPSILON);\n\n\n\n        TimeSeries s2 = s1.createCopy(0, 1);\n\n        assertEquals(100.0, s2.getMinY(), EPSILON);\n\n        assertEquals(101.0, s2.getMaxY(), EPSILON);\n\n\n\n        TimeSeries s3 = s1.createCopy(1, 2);\n\n        assertEquals(101.0, s3.getMinY(), EPSILON);\n\n        assertEquals(102.0, s3.getMaxY(), EPSILON);\n\n    }\n"
      }
    }
  },
  "Chart-4": {
    "id": "Chart-4",
    "project": "Chart",
    "number": "4",
    "buggy_function": "public Range getDataRange(ValueAxis axis) {\n\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n\n    // is it a domain axis?\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            // grab the plot's annotations\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (isDomainAxis) {\n                if (r != null) {\n                    result = Range.combine(result, r.findDomainBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findDomainBounds(d));\n                }\n            }\n            else {\n                if (r != null) {\n                    result = Range.combine(result, r.findRangeBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findRangeBounds(d));\n                }\n            }\n            \n                Collection c = r.getAnnotations();\n                Iterator i = c.iterator();\n                while (i.hasNext()) {\n                    XYAnnotation a = (XYAnnotation) i.next();\n                    if (a instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(a);\n                    }\n                }\n        }\n    }\n\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            }\n            else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n\n    return result;\n\n}",
    "fixed_function": "public Range getDataRange(ValueAxis axis) {\n\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n\n    // is it a domain axis?\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            // grab the plot's annotations\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (isDomainAxis) {\n                if (r != null) {\n                    result = Range.combine(result, r.findDomainBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findDomainBounds(d));\n                }\n            }\n            else {\n                if (r != null) {\n                    result = Range.combine(result, r.findRangeBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findRangeBounds(d));\n                }\n            }\n            \n            if (r != null) {\n                Collection c = r.getAnnotations();\n                Iterator i = c.iterator();\n                while (i.hasNext()) {\n                    XYAnnotation a = (XYAnnotation) i.next();\n                    if (a instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(a);\n                    }\n                }\n            }\n        }\n    }\n\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            }\n            else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n\n    return result;\n\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/plot/XYPlot.java",
      "first_line": 4425,
      "last_line": 4519
    },
    "javadoc": "/**\n* Returns the range for the specified axis.\n*\n* @param axis  the axis.\n*\n* @return The range.\n*/",
    "failing_tests": {
      "org.jfree.chart.axis.junit.LogAxisTests::testXYAutoRange1": {
        "source": "    public void testXYAutoRange1() {\n\n        XYSeries series = new XYSeries(\"Series 1\");\n\n        series.add(1.0, 1.0);\n\n        series.add(2.0, 2.0);\n\n        series.add(3.0, 3.0);\n\n        XYSeriesCollection dataset = new XYSeriesCollection();\n\n        dataset.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createScatterPlot(\n\n            \"Test\",\n\n            \"X\",\n\n            \"Y\",\n\n            dataset,\n\n            PlotOrientation.VERTICAL,\n\n            false,\n\n            false,\n\n            false\n\n        );\n\n        XYPlot plot = (XYPlot) chart.getPlot();\n\n        LogAxis axis = new LogAxis(\"Log(Y)\");\n\n        plot.setRangeAxis(axis);\n\n        assertEquals(0.9465508226401592, axis.getLowerBound(), EPSILON);\n\n        assertEquals(3.1694019256486126, axis.getUpperBound(), EPSILON);\n\n    }\n"
      },
      "org.jfree.chart.axis.junit.LogAxisTests::testXYAutoRange2": {
        "source": "    public void testXYAutoRange2() {\n\n        XYSeries series = new XYSeries(\"Series 1\");\n\n        series.add(1.0, 1.0);\n\n        series.add(2.0, 2.0);\n\n        series.add(3.0, 3.0);\n\n        XYSeriesCollection dataset = new XYSeriesCollection();\n\n        dataset.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createScatterPlot(\n\n            \"Test\",\n\n            \"X\",\n\n            \"Y\",\n\n            dataset,\n\n            PlotOrientation.VERTICAL,\n\n            false,\n\n            false,\n\n            false\n\n        );\n\n        XYPlot plot = (XYPlot) chart.getPlot();\n\n        LogAxis axis = new LogAxis(\"Log(Y)\");\n\n        plot.setRangeAxis(axis);\n\n        assertEquals(0.9465508226401592, axis.getLowerBound(), EPSILON);\n\n        assertEquals(3.1694019256486126, axis.getUpperBound(), EPSILON);\n\n    }\n"
      },
      "org.jfree.chart.axis.junit.NumberAxisTests::testXYAutoRange1": {
        "source": "    public void testXYAutoRange1() {\n\n        XYSeries series = new XYSeries(\"Series 1\");\n\n        series.add(1.0, 1.0);\n\n        series.add(2.0, 2.0);\n\n        series.add(3.0, 3.0);\n\n        XYSeriesCollection dataset = new XYSeriesCollection();\n\n        dataset.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createScatterPlot(\n\n            \"Test\",\n\n            \"X\",\n\n            \"Y\",\n\n            dataset,\n\n            PlotOrientation.VERTICAL,\n\n            false,\n\n            false,\n\n            false\n\n        );\n\n        XYPlot plot = (XYPlot) chart.getPlot();\n\n        NumberAxis axis = (NumberAxis) plot.getDomainAxis();\n\n        axis.setAutoRangeIncludesZero(false);\n\n        assertEquals(0.9, axis.getLowerBound(), EPSILON);\n\n        assertEquals(3.1, axis.getUpperBound(), EPSILON);\n\n    }\n"
      },
      "org.jfree.chart.axis.junit.NumberAxisTests::testXYAutoRange2": {
        "source": "    public void testXYAutoRange2() {\n\n        XYSeries series = new XYSeries(\"Series 1\");\n\n        series.add(1.0, 1.0);\n\n        series.add(2.0, 2.0);\n\n        series.add(3.0, 3.0);\n\n        XYSeriesCollection dataset = new XYSeriesCollection();\n\n        dataset.addSeries(series);\n\n        JFreeChart chart = ChartFactory.createScatterPlot(\n\n            \"Test\",\n\n            \"X\",\n\n            \"Y\",\n\n            dataset,\n\n            PlotOrientation.VERTICAL,\n\n            false,\n\n            false,\n\n            false\n\n        );\n\n        XYPlot plot = (XYPlot) chart.getPlot();\n\n        NumberAxis axis = (NumberAxis) plot.getRangeAxis();\n\n        axis.setAutoRangeIncludesZero(false);\n\n        assertEquals(0.9, axis.getLowerBound(), EPSILON);\n\n        assertEquals(3.1, axis.getUpperBound(), EPSILON);\n\n    }\n"
      },
      "org.jfree.chart.axis.junit.ValueAxisTests::testAxisMargins": {
        "source": "    public void testAxisMargins() {\n\n        XYSeries series = new XYSeries(\"S1\");\n\n        series.add(100.0, 1.1);\n\n        series.add(200.0, 2.2);\n\n        XYSeriesCollection dataset = new XYSeriesCollection(series);\n\n        dataset.setIntervalWidth(0.0);\n\n        JFreeChart chart = ChartFactory.createScatterPlot(\n\n            \"Title\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL,\n\n            false, false, false\n\n        );\n\n        ValueAxis domainAxis = ((XYPlot) chart.getPlot()).getDomainAxis();\n\n        Range r = domainAxis.getRange();\n\n        assertEquals(110.0, r.getLength(), EPSILON);\n\n        domainAxis.setLowerMargin(0.10);\n\n        domainAxis.setUpperMargin(0.10);\n\n        r = domainAxis.getRange();\n\n        assertEquals(120.0, r.getLength(), EPSILON);\n\n    }\n"
      },
      "org.jfree.chart.junit.JFreeChartTests::testSerialization4": {
        "source": "    public void testSerialization4() {\n\n\n\n        RegularTimePeriod t = new Day();\n\n        TimeSeries series = new TimeSeries(\"Series 1\");\n\n        series.add(t, 36.4);\n\n        t = t.next();\n\n        series.add(t, 63.5);\n\n        TimeSeriesCollection dataset = new TimeSeriesCollection();\n\n        dataset.addSeries(series);\n\n\n\n        JFreeChart c1 = ChartFactory.createTimeSeriesChart(\"Test\", \"Date\",\n\n                \"Value\", dataset, true, true, true);\n\n        JFreeChart c2 = null;\n\n\n\n        try {\n\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\n            ObjectOutput out = new ObjectOutputStream(buffer);\n\n            out.writeObject(c1);\n\n            out.close();\n\n\n\n            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(\n\n                    buffer.toByteArray()));\n\n            c2 = (JFreeChart) in.readObject();\n\n            in.close();\n\n        }\n\n        catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        assertEquals(c1, c2);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.ScatterPlotTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100,\n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n          e.printStackTrace();\n\n        }\n\n\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.ScatterPlotTests::testSetSeriesToolTipGenerator": {
        "source": "    public void testSetSeriesToolTipGenerator() {\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        XYItemRenderer renderer = plot.getRenderer();\n\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n\n        renderer.setSeriesToolTipGenerator(0, tt);\n\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n\n        assertTrue(tt2 == tt);\n\n    }\n"
      },
      "org.jfree.chart.junit.ScatterPlotTests::testReplaceDataset": {
        "source": "    public void testReplaceDataset() {\n\n\n\n        // create a dataset...\n\n        XYSeries series1 = new XYSeries(\"Series 1\");\n\n        series1.add(10.0, 10.0);\n\n        series1.add(20.0, 20.0);\n\n        series1.add(30.0, 30.0);\n\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n\n\n        LocalListener l = new LocalListener();\n\n        this.chart.addChangeListener(l);\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        plot.setDataset(dataset);\n\n        assertEquals(true, l.flag);\n\n        ValueAxis axis = plot.getRangeAxis();\n\n        Range range = axis.getRange();\n\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.TimeSeriesChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100,\n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n          e.printStackTrace();\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.TimeSeriesChartTests::testSetSeriesToolTipGenerator": {
        "source": "    public void testSetSeriesToolTipGenerator() {\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        XYItemRenderer renderer = plot.getRenderer();\n\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n\n        renderer.setSeriesToolTipGenerator(0, tt);\n\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n\n        assertTrue(tt2 == tt);\n\n    }\n"
      },
      "org.jfree.chart.junit.TimeSeriesChartTests::testReplaceDataset": {
        "source": "    public void testReplaceDataset() {\n\n\n\n        // create a dataset...\n\n        XYSeries series1 = new XYSeries(\"Series 1\");\n\n        series1.add(10.0, 10.0);\n\n        series1.add(20.0, 20.0);\n\n        series1.add(30.0, 30.0);\n\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n\n\n        LocalListener l = new LocalListener();\n\n        this.chart.addChangeListener(l);\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        plot.setDataset(dataset);\n\n        assertEquals(true, l.flag);\n\n        ValueAxis axis = plot.getRangeAxis();\n\n        Range range = axis.getRange();\n\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.XYAreaChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100,\n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n          e.printStackTrace();\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.XYAreaChartTests::testSetSeriesToolTipGenerator": {
        "source": "    public void testSetSeriesToolTipGenerator() {\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        XYItemRenderer renderer = plot.getRenderer();\n\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n\n        renderer.setSeriesToolTipGenerator(0, tt);\n\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0,\n\n                false);\n\n        assertTrue(tt2 == tt);\n\n    }\n"
      },
      "org.jfree.chart.junit.XYAreaChartTests::testReplaceDataset": {
        "source": "    public void testReplaceDataset() {\n\n\n\n        // create a dataset...\n\n        XYSeries series1 = new XYSeries(\"Series 1\");\n\n        series1.add(10.0, 10.0);\n\n        series1.add(20.0, 20.0);\n\n        series1.add(30.0, 30.0);\n\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n\n\n        LocalListener l = new LocalListener();\n\n        this.chart.addChangeListener(l);\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        plot.setDataset(dataset);\n\n        assertEquals(true, l.flag);\n\n        ValueAxis axis = plot.getRangeAxis();\n\n        Range range = axis.getRange();\n\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.XYStepAreaChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100,\n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n          e.printStackTrace();\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.XYStepAreaChartTests::testSetSeriesToolTipGenerator": {
        "source": "    public void testSetSeriesToolTipGenerator() {\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        XYItemRenderer renderer = plot.getRenderer();\n\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n\n        renderer.setSeriesToolTipGenerator(0, tt);\n\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n\n        assertTrue(tt2 == tt);\n\n    }\n"
      },
      "org.jfree.chart.junit.XYStepAreaChartTests::testReplaceDataset": {
        "source": "    public void testReplaceDataset() {\n\n\n\n        // create a dataset...\n\n        XYSeries series1 = new XYSeries(\"Series 1\");\n\n        series1.add(10.0, 10.0);\n\n        series1.add(20.0, 20.0);\n\n        series1.add(30.0, 30.0);\n\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n\n\n        LocalListener l = new LocalListener();\n\n        this.chart.addChangeListener(l);\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        plot.setDataset(dataset);\n\n        assertEquals(true, l.flag);\n\n        ValueAxis axis = plot.getRangeAxis();\n\n        Range range = axis.getRange();\n\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.XYStepChartTests::testDrawWithNullInfo": {
        "source": "    public void testDrawWithNullInfo() {\n\n\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100,\n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n\n                    null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n          success = false;\n\n          e.printStackTrace();\n\n        }\n\n        assertTrue(success);\n\n\n\n    }\n"
      },
      "org.jfree.chart.junit.XYStepChartTests::testSetSeriesToolTipGenerator": {
        "source": "    public void testSetSeriesToolTipGenerator() {\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        XYItemRenderer renderer = plot.getRenderer();\n\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n\n        renderer.setSeriesToolTipGenerator(0, tt);\n\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n\n        assertTrue(tt2 == tt);\n\n    }\n"
      },
      "org.jfree.chart.junit.XYStepChartTests::testReplaceDataset": {
        "source": "    public void testReplaceDataset() {\n\n\n\n        // create a dataset...\n\n        XYSeries series1 = new XYSeries(\"Series 1\");\n\n        series1.add(10.0, 10.0);\n\n        series1.add(20.0, 20.0);\n\n        series1.add(30.0, 30.0);\n\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n\n\n        LocalListener l = new LocalListener();\n\n        this.chart.addChangeListener(l);\n\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n\n        plot.setDataset(dataset);\n\n        assertEquals(true, l.flag);\n\n        ValueAxis axis = plot.getRangeAxis();\n\n        Range range = axis.getRange();\n\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n\n\n    }\n"
      },
      "org.jfree.chart.plot.junit.XYPlotTests::testDrawRangeGridlines": {
        "source": "    public void testDrawRangeGridlines() {\n\n        DefaultXYDataset dataset = new DefaultXYDataset();\n\n        JFreeChart chart = ChartFactory.createXYLineChart(\"Title\", \"X\", \"Y\",\n\n                dataset, PlotOrientation.VERTICAL, true, false, false);\n\n        XYPlot plot = (XYPlot) chart.getPlot();\n\n        plot.setRenderer(null);\n\n        boolean success = false;\n\n        try {\n\n            BufferedImage image = new BufferedImage(200 , 100,\n\n                    BufferedImage.TYPE_INT_RGB);\n\n            Graphics2D g2 = image.createGraphics();\n\n            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n\n            g2.dispose();\n\n            success = true;\n\n        }\n\n        catch (Exception e) {\n\n            e.printStackTrace();\n\n            success = false;\n\n        }\n\n        assertTrue(success);\n\n    }\n"
      }
    }
  },
  "Chart-5": {
    "id": "Chart-5",
    "project": "Chart",
    "number": "5",
    "buggy_function": "public XYDataItem addOrUpdate(Number x, Number y) {\n    if (x == null) {\n        throw new IllegalArgumentException(\"Null 'x' argument.\");\n    }\n\n    // if we get to here, we know that duplicate X values are not permitted\n    XYDataItem overwritten = null;\n    int index = indexOf(x);\n    if (index >= 0 && !this.allowDuplicateXValues) {\n        XYDataItem existing = (XYDataItem) this.data.get(index);\n        try {\n            overwritten = (XYDataItem) existing.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            throw new SeriesException(\"Couldn't clone XYDataItem!\");\n        }\n        existing.setY(y);\n    }\n    else {\n        // if the series is sorted, the negative index is a result from\n        // Collections.binarySearch() and tells us where to insert the\n        // new item...otherwise it will be just -1 and we should just\n        // append the value to the list...\n        if (this.autoSort) {\n            this.data.add(-index - 1, new XYDataItem(x, y));\n        }\n        else {\n            this.data.add(new XYDataItem(x, y));\n        }\n        // check if this addition will exceed the maximum item count...\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0);\n        }\n    }\n    fireSeriesChanged();\n    return overwritten;\n}",
    "fixed_function": "public XYDataItem addOrUpdate(Number x, Number y) {\n    if (x == null) {\n        throw new IllegalArgumentException(\"Null 'x' argument.\");\n    }\n    if (this.allowDuplicateXValues) {\n        add(x, y);\n        return null;\n    }\n\n    // if we get to here, we know that duplicate X values are not permitted\n    XYDataItem overwritten = null;\n    int index = indexOf(x);\n    if (index >= 0) {\n        XYDataItem existing = (XYDataItem) this.data.get(index);\n        try {\n            overwritten = (XYDataItem) existing.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            throw new SeriesException(\"Couldn't clone XYDataItem!\");\n        }\n        existing.setY(y);\n    }\n    else {\n        // if the series is sorted, the negative index is a result from\n        // Collections.binarySearch() and tells us where to insert the\n        // new item...otherwise it will be just -1 and we should just\n        // append the value to the list...\n        if (this.autoSort) {\n            this.data.add(-index - 1, new XYDataItem(x, y));\n        }\n        else {\n            this.data.add(new XYDataItem(x, y));\n        }\n        // check if this addition will exceed the maximum item count...\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0);\n        }\n    }\n    fireSeriesChanged();\n    return overwritten;\n}",
    "replacement_info": {
      "file": "source/org/jfree/data/xy/XYSeries.java",
      "first_line": 540,
      "last_line": 576
    },
    "javadoc": "/**\n* Adds or updates an item in the series and sends a\n* {@link SeriesChangeEvent} to all registered listeners.\n*\n* @param x  the x-value (<code>null</code> not permitted).\n* @param y  the y-value (<code>null</code> permitted).\n*\n* @return A copy of the overwritten data item, or <code>null</code> if no\n*         item was overwritten.\n*/",
    "failing_tests": {
      "org.jfree.data.xy.junit.XYSeriesTests::testBug1955483": {
        "source": "    public void testBug1955483() {\n\n        XYSeries series = new XYSeries(\"Series\", true, true);\n\n        series.addOrUpdate(1.0, 1.0);\n\n        series.addOrUpdate(1.0, 2.0);\n\n        assertEquals(new Double(1.0), series.getY(0));\n\n        assertEquals(new Double(2.0), series.getY(1));\n\n        assertEquals(2, series.getItemCount());\n\n    }\n"
      }
    }
  },
  "Chart-6": {
    "id": "Chart-6",
    "project": "Chart",
    "number": "6",
    "buggy_function": "public boolean equals(Object obj) {\n\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    return super.equals(obj);\n\n}",
    "fixed_function": "public boolean equals(Object obj) {\n\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList that = (ShapeList) obj;\n    int listSize = size();\n    for (int i = 0; i < listSize; i++) {\n       if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n           return false;\n       }\n    }\n    return true;\n\n}",
    "replacement_info": {
      "file": "source/org/jfree/chart/util/ShapeList.java",
      "first_line": 103,
      "last_line": 113
    },
    "javadoc": "/**\n* Tests the list for equality with another object (typically also a list).\n*\n* @param obj  the other object (<code>null</code> permitted).\n*\n* @return A boolean.\n*/",
    "failing_tests": {
      "org.jfree.chart.util.junit.ShapeListTests::testSerialization": {
        "source": "    public void testSerialization() {\n\n\n\n        ShapeList l1 = new ShapeList();\n\n        l1.setShape(0, new Rectangle(1, 2, 3, 4));\n\n        l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\n\n        l1.setShape(2, null);\n\n\n\n        ShapeList l2 = null;\n\n\n\n        try {\n\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\n            ObjectOutput out = new ObjectOutputStream(buffer);\n\n            out.writeObject(l1);\n\n            out.close();\n\n\n\n            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(\n\n            \t\tbuffer.toByteArray()));\n\n            l2 = (ShapeList) in.readObject();\n\n            in.close();\n\n        }\n\n        catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        assertEquals(l1, l2);\n\n\n\n    }\n"
      },
      "org.jfree.chart.util.junit.ShapeListTests::testEquals": {
        "source": "    public void testEquals() {\n\n        ShapeList l1 = new ShapeList();\n\n        l1.setShape(0, new Rectangle(1, 2, 3, 4));\n\n        l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\n\n        l1.setShape(2, null);\n\n\n\n        ShapeList l2 = new ShapeList();\n\n        l2.setShape(0, new Rectangle(1, 2, 3, 4));\n\n        l2.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\n\n        l2.setShape(2, null);\n\n\n\n        assertTrue(l1.equals(l2));\n\n        assertTrue(l2.equals(l2));\n\n    }\n"
      }
    }
  },
  "Chart-7": {
    "id": "Chart-7",
    "project": "Chart",
    "number": "7",
    "buggy_function": "private void updateBounds(TimePeriod period, int index) {\n    \n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + ((end - start) / 2);\n\n    if (this.minStartIndex >= 0) {\n        long minStart = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start < minStart) {\n            this.minStartIndex = index;           \n        }\n    }\n    else {\n        this.minStartIndex = index;\n    }\n    \n    if (this.maxStartIndex >= 0) {\n        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start > maxStart) {\n            this.maxStartIndex = index;           \n        }\n    }\n    else {\n        this.maxStartIndex = index;\n    }\n    \n    if (this.minMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long minMiddle = s + (e - s) / 2;\n        if (middle < minMiddle) {\n            this.minMiddleIndex = index;           \n        }\n    }\n    else {\n        this.minMiddleIndex = index;\n    }\n    \n    if (this.maxMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long maxMiddle = s + (e - s) / 2;\n        if (middle > maxMiddle) {\n            this.maxMiddleIndex = index;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = index;\n    }\n    \n    if (this.minEndIndex >= 0) {\n        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end < minEnd) {\n            this.minEndIndex = index;           \n        }\n    }\n    else {\n        this.minEndIndex = index;\n    }\n   \n    if (this.maxEndIndex >= 0) {\n        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end > maxEnd) {\n            this.maxEndIndex = index;           \n        }\n    }\n    else {\n        this.maxEndIndex = index;\n    }\n    \n}",
    "fixed_function": "private void updateBounds(TimePeriod period, int index) {\n    \n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + ((end - start) / 2);\n\n    if (this.minStartIndex >= 0) {\n        long minStart = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start < minStart) {\n            this.minStartIndex = index;           \n        }\n    }\n    else {\n        this.minStartIndex = index;\n    }\n    \n    if (this.maxStartIndex >= 0) {\n        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start > maxStart) {\n            this.maxStartIndex = index;           \n        }\n    }\n    else {\n        this.maxStartIndex = index;\n    }\n    \n    if (this.minMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long minMiddle = s + (e - s) / 2;\n        if (middle < minMiddle) {\n            this.minMiddleIndex = index;           \n        }\n    }\n    else {\n        this.minMiddleIndex = index;\n    }\n    \n    if (this.maxMiddleIndex >= 0) {\n        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long maxMiddle = s + (e - s) / 2;\n        if (middle > maxMiddle) {\n            this.maxMiddleIndex = index;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = index;\n    }\n    \n    if (this.minEndIndex >= 0) {\n        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end < minEnd) {\n            this.minEndIndex = index;           \n        }\n    }\n    else {\n        this.minEndIndex = index;\n    }\n   \n    if (this.maxEndIndex >= 0) {\n        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end > maxEnd) {\n            this.maxEndIndex = index;           \n        }\n    }\n    else {\n        this.maxEndIndex = index;\n    }\n    \n}",
    "replacement_info": {
      "file": "source/org/jfree/data/time/TimePeriodValues.java",
      "first_line": 257,
      "last_line": 335
    },
    "javadoc": "/**\n* Update the index values for the maximum and minimum bounds.\n*\n* @param period  the time period.\n* @param index  the index of the time period.\n*/",
    "failing_tests": {
      "org.jfree.data.time.junit.TimePeriodValuesTests::testGetMaxMiddleIndex": {
        "source": "    public void testGetMaxMiddleIndex() {\n\n        TimePeriodValues s = new TimePeriodValues(\"Test\");\n\n        assertEquals(-1, s.getMaxMiddleIndex());\n\n        s.add(new SimpleTimePeriod(100L, 200L), 1.0);\n\n        assertEquals(0, s.getMaxMiddleIndex());\n\n        s.add(new SimpleTimePeriod(300L, 400L), 2.0);\n\n        assertEquals(1, s.getMaxMiddleIndex());\n\n        s.add(new SimpleTimePeriod(0L, 50L), 3.0);\n\n        assertEquals(1, s.getMaxMiddleIndex());\n\n        s.add(new SimpleTimePeriod(150L, 200L), 4.0);\n\n        assertEquals(1, s.getMaxMiddleIndex());\n\n    }\n"
      }
    }
  },
  "Chart-8": {
    "id": "Chart-8",
    "project": "Chart",
    "number": "8",
    "buggy_function": "public Week(Date time, TimeZone zone) {\n    // defer argument checking...\n    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n}",
    "fixed_function": "public Week(Date time, TimeZone zone) {\n    // defer argument checking...\n    this(time, zone, Locale.getDefault());\n}",
    "replacement_info": {
      "file": "source/org/jfree/data/time/Week.java",
      "first_line": 173,
      "last_line": 176
    },
    "javadoc": "/**\n* Creates a time period for the week in which the specified date/time\n* falls, calculated relative to the specified time zone.\n*\n* @param time  the date/time (<code>null</code> not permitted).\n* @param zone  the time zone (<code>null</code> not permitted).\n*\n* @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n*/",
    "failing_tests": {
      "org.jfree.data.time.junit.WeekTests::testConstructor": {
        "source": "    public void testConstructor() {\n\n        Locale savedLocale = Locale.getDefault();\n\n        TimeZone savedZone = TimeZone.getDefault();\n\n        Locale.setDefault(new Locale(\"da\", \"DK\"));\n\n        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n\n        GregorianCalendar cal = (GregorianCalendar) Calendar.getInstance(\n\n                TimeZone.getDefault(), Locale.getDefault());\n\n\n\n        // first day of week is monday\n\n        assertEquals(Calendar.MONDAY, cal.getFirstDayOfWeek());\n\n        cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0);\n\n        cal.set(Calendar.MILLISECOND, 0);\n\n        Date t = cal.getTime();\n\n        Week w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n\n        assertEquals(34, w.getWeek());\n\n\n\n        Locale.setDefault(Locale.US);\n\n        TimeZone.setDefault(TimeZone.getTimeZone(\"US/Detroit\"));\n\n        cal = (GregorianCalendar) Calendar.getInstance(TimeZone.getDefault());\n\n        // first day of week is Sunday\n\n        assertEquals(Calendar.SUNDAY, cal.getFirstDayOfWeek());\n\n        cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0);\n\n        cal.set(Calendar.MILLISECOND, 0);\n\n\n\n        t = cal.getTime();\n\n        w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n\n        assertEquals(35, w.getWeek());\n\n        w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"),\n\n                new Locale(\"da\", \"DK\"));\n\n        assertEquals(34, w.getWeek());\n\n\n\n        Locale.setDefault(savedLocale);\n\n        TimeZone.setDefault(savedZone);\n\n    }\n"
      }
    }
  },
  "Chart-9": {
    "id": "Chart-9",
    "project": "Chart",
    "number": "9",
    "buggy_function": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  // start is after last data item\n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             // end period is not in original series\n        endIndex = -(endIndex + 1); // this is first item AFTER end period\n        endIndex = endIndex - 1;    // so this is last item BEFORE end\n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n\n}",
    "fixed_function": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  // start is after last data item\n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             // end period is not in original series\n        endIndex = -(endIndex + 1); // this is first item AFTER end period\n        endIndex = endIndex - 1;    // so this is last item BEFORE end\n    }\n    if ((endIndex < 0)  || (endIndex < startIndex)) {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n\n}",
    "replacement_info": {
      "file": "source/org/jfree/data/time/TimeSeries.java",
      "first_line": 918,
      "last_line": 956
    },
    "javadoc": "/**\n* Creates a new timeseries by copying a subset of the data in this time\n* series.\n*\n* @param start  the first time period to copy (<code>null</code> not\n*         permitted).\n* @param end  the last time period to copy (<code>null</code> not\n*         permitted).\n*\n* @return A time series containing a copy of this time series from start\n*         until end.\n*\n* @throws CloneNotSupportedException if there is a cloning problem.\n*/",
    "failing_tests": {
      "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222": {
        "source": "    public void testBug1864222() {\n\n        TimeSeries s = new TimeSeries(\"S\");\n\n        s.add(new Day(19, 8, 2005), 1);\n\n        s.add(new Day(31, 1, 2006), 1);\n\n        boolean pass = true;\n\n        try {\n\n            s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));\n\n        }\n\n        catch (CloneNotSupportedException e) {\n\n            pass = false;\n\n        }\n\n        assertTrue(pass);\n\n    }\n"
      }
    }
  },
  "Cli-11": {
    "id": "Cli-11",
    "project": "Cli",
    "number": "11",
    "buggy_function": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n\n    // if the Option has a value\n    if (option.hasArg() && (option.getArgName() != null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n\n    // if the Option is not a required option\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
    "fixed_function": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n\n    // if the Option has a value\n    if (option.hasArg() && option.hasArgName())\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n\n    // if the Option is not a required option\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 613,
      "last_line": 642
    },
    "javadoc": "/**\n* Appends the usage clause for an Option to a StringBuffer.\n*\n* @param buff the StringBuffer to append to\n* @param option the Option to append\n* @param required whether the Option is required or not\n*/",
    "failing_tests": {
      "org.apache.commons.cli.HelpFormatterTest::testPrintOptionWithEmptyArgNameUsage": {
        "source": "    public void testPrintOptionWithEmptyArgNameUsage() {\n\n        Option option = new Option(\"f\", true, null);\n\n        option.setArgName(\"\");\n\n        option.setRequired(true);\n\n\n\n        Options options = new Options();\n\n        options.addOption(option);\n\n\n\n        StringWriter out = new StringWriter();\n\n\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n\n    }\n"
      }
    }
  },
  "Cli-12": {
    "id": "Cli-12",
    "project": "Cli",
    "number": "12",
    "buggy_function": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n    List tokens = new ArrayList();\n\n    boolean eatTheRest = false;\n\n    for (int i = 0; i < arguments.length; i++)\n    {\n        String arg = arguments[i];\n\n        if (\"--\".equals(arg))\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n        else if (\"-\".equals(arg))\n        {\n            tokens.add(\"-\");\n        }\n        else if (arg.startsWith(\"-\"))\n        {\n            String opt = Util.stripLeadingHyphens(arg);\n\n            if (options.hasOption(opt))\n            {\n                tokens.add(arg);\n            }\n            else\n            {\n                if (options.hasOption(arg.substring(0, 2)))\n                {\n                    // the format is --foo=value or -foo=value\n                    // the format is a special properties option (-Dproperty=value)\n                    tokens.add(arg.substring(0, 2)); // -D\n                    tokens.add(arg.substring(2)); // property=value\n                }\n                else\n                {\n                    eatTheRest = stopAtNonOption;\n                    tokens.add(arg);\n                }\n            }\n        }\n        else\n        {\n            tokens.add(arg);\n        }\n\n        if (eatTheRest)\n        {\n            for (i++; i < arguments.length; i++)\n            {\n                tokens.add(arguments[i]);\n            }\n        }\n    }\n\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}",
    "fixed_function": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n    List tokens = new ArrayList();\n\n    boolean eatTheRest = false;\n\n    for (int i = 0; i < arguments.length; i++)\n    {\n        String arg = arguments[i];\n\n        if (\"--\".equals(arg))\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n        else if (\"-\".equals(arg))\n        {\n            tokens.add(\"-\");\n        }\n        else if (arg.startsWith(\"-\"))\n        {\n            String opt = Util.stripLeadingHyphens(arg);\n\n            if (options.hasOption(opt))\n            {\n                tokens.add(arg);\n            }\n            else\n            {\n                if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n                {\n                    // the format is --foo=value or -foo=value\n                    tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n                    tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n                }\n                else if (options.hasOption(arg.substring(0, 2)))\n                {\n                    // the format is a special properties option (-Dproperty=value)\n                    tokens.add(arg.substring(0, 2)); // -D\n                    tokens.add(arg.substring(2)); // property=value\n                }\n                else\n                {\n                    eatTheRest = stopAtNonOption;\n                    tokens.add(arg);\n                }\n            }\n        }\n        else\n        {\n            tokens.add(arg);\n        }\n\n        if (eatTheRest)\n        {\n            for (i++; i < arguments.length; i++)\n            {\n                tokens.add(arguments[i]);\n            }\n        }\n    }\n\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/GnuParser.java",
      "first_line": 52,
      "last_line": 110
    },
    "javadoc": "/**\n* <p>This flatten method does so using the following rules:\n* <ol>\n*  <li>If an {@link Option} exists for the first character of\n*  the <code>arguments</code> entry <b>AND</b> an {@link Option}\n*  does not exist for the whole <code>argument</code> then\n*  add the first character as an option to the processed tokens\n*  list e.g. \"-D\" and add the rest of the entry to the also.</li>\n*  <li>Otherwise just add the token to the processed tokens list.\n*  </li>\n* </ol>\n* </p>\n*\n* @param options The Options to parse the arguments by.\n* @param arguments The arguments that have to be flattened.\n* @param stopAtNonOption specifies whether to stop\n* flattening when a non option has been encountered\n* @return a String array of the flattened arguments\n*/",
    "failing_tests": {
      "org.apache.commons.cli.GnuParserTest::testShortWithEqual": {
        "source": "    public void testShortWithEqual() throws Exception\n\n    {\n\n        String[] args = new String[] { \"-f=bar\" };\n\n\n\n        Options options = new Options();\n\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n\n\n        Parser parser = new GnuParser();\n\n        CommandLine cl = parser.parse(options, args);\n\n\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n\n    }\n"
      },
      "org.apache.commons.cli.GnuParserTest::testLongWithEqualSingleDash": {
        "source": "    public void testLongWithEqualSingleDash() throws Exception\n\n    {\n\n        String[] args = new String[] { \"-foo=bar\" };\n\n\n\n        Options options = new Options();\n\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n\n\n        Parser parser = new GnuParser();\n\n        CommandLine cl = parser.parse(options, args);\n\n\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n\n    }\n"
      },
      "org.apache.commons.cli.GnuParserTest::testLongWithEqual": {
        "source": "    public void testLongWithEqual() throws Exception\n\n    {\n\n        String[] args = new String[] { \"--foo=bar\" };\n\n\n\n        Options options = new Options();\n\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n\n\n        Parser parser = new GnuParser();\n\n        CommandLine cl = parser.parse(options, args);\n\n\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n\n    }\n"
      }
    }
  },
  "Cli-14": {
    "id": "Cli-14",
    "project": "Cli",
    "number": "14",
    "buggy_function": "public void validate(final WriteableCommandLine commandLine)\n    throws OptionException {\n    // number of options found\n    int present = 0;\n\n    // reference to first unexpected option\n    Option unexpected = null;\n\n    for (final Iterator i = options.iterator(); i.hasNext();) {\n        final Option option = (Option) i.next();\n\n        // needs validation?\n        boolean validate = option.isRequired() || option instanceof Group;\n        if (validate) {\n            option.validate(commandLine);\n        }\n\n        // if the child option is present then validate it\n        if (commandLine.hasOption(option)) {\n            if (++present > maximum) {\n                unexpected = option;\n\n                break;\n            }\n\n            option.validate(commandLine);\n        }\n    }\n\n    // too many options\n    if (unexpected != null) {\n        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                  unexpected.getPreferredName());\n    }\n\n    // too few option\n    if (present < minimum) {\n        throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n    }\n\n    // validate each anonymous argument\n    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n        final Option option = (Option) i.next();\n        option.validate(commandLine);\n    }\n}",
    "fixed_function": "public void validate(final WriteableCommandLine commandLine)\n    throws OptionException {\n    // number of options found\n    int present = 0;\n\n    // reference to first unexpected option\n    Option unexpected = null;\n\n    for (final Iterator i = options.iterator(); i.hasNext();) {\n        final Option option = (Option) i.next();\n\n        // needs validation?\n        boolean validate = option.isRequired() || option instanceof Group;\n\n        // if the child option is present then validate it\n        if (commandLine.hasOption(option)) {\n            if (++present > maximum) {\n                unexpected = option;\n\n                break;\n            }\n            validate = true;\n        }\n\n        if (validate) {\n            option.validate(commandLine);\n        }\n    }\n\n    // too many options\n    if (unexpected != null) {\n        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                  unexpected.getPreferredName());\n    }\n\n    // too few option\n    if (present < minimum) {\n        throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n    }\n\n    // validate each anonymous argument\n    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n        final Option option = (Option) i.next();\n        option.validate(commandLine);\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli2/option/GroupImpl.java",
      "first_line": 237,
      "last_line": 282
    },
    "javadoc": "// canProcess will always return true?",
    "failing_tests": {
      "org.apache.commons.cli2.bug.BugCLI144Test::testFileValidator": {
        "source": "\tpublic void testFileValidator() {\n\n\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n\n        final GroupBuilder gbuilder = new GroupBuilder();\n\n        DefaultOption fileNameOption = obuilder.withShortName(\"f\")\n\n                .withLongName(\"file-name\").withRequired(true).withDescription(\n\n                        \"name of an existing file\").withArgument(\n\n                        abuilder.withName(\"file-name\").withValidator(\n\n                                FileValidator.getExistingFileInstance())\n\n                                .create()).create();\n\n        Group options = gbuilder.withName(\"options\").withOption(fileNameOption)\n\n                .create();\n\n        Parser parser = new Parser();\n\n        parser.setHelpTrigger(\"--help\");\n\n        parser.setGroup(options);\n\n\n\n        final String fileName = \"src/test/org/apache/commons/cli2/bug/BugCLI144Test.java\";\n\n        CommandLine cl = parser\n\n                .parseAndHelp(new String[] { \"--file-name\", fileName });\n\n        assertNotNull(cl);\n\n        assertEquals(\"Wrong file\", new File(fileName), cl.getValue(fileNameOption));\n\n\t}\n"
      }
    }
  },
  "Cli-15": {
    "id": "Cli-15",
    "project": "Cli",
    "number": "15",
    "buggy_function": "public List getValues(final Option option,\n                      List defaultValues) {\n    // initialize the return list\n    List valueList = (List) values.get(option);\n\n    // grab the correct default values\n    if ((valueList == null) || valueList.isEmpty()) {\n        valueList = defaultValues;\n    }\n\n    // augment the list with the default values\n    if ((valueList == null) || valueList.isEmpty()) {\n        valueList = (List) this.defaultValues.get(option);\n    }\n            // if there are more default values as specified, add them to\n            // the list.\n                // copy the list first\n    \n    return valueList == null ? Collections.EMPTY_LIST : valueList;\n}",
    "fixed_function": "public List getValues(final Option option,\n                      List defaultValues) {\n    // initialize the return list\n    List valueList = (List) values.get(option);\n\n    // grab the correct default values\n    if (defaultValues == null || defaultValues.isEmpty()) {\n        defaultValues = (List) this.defaultValues.get(option);\n    }\n\n    // augment the list with the default values\n    if (defaultValues != null && !defaultValues.isEmpty()) {\n        if (valueList == null || valueList.isEmpty()) {\n            valueList = defaultValues;\n        } else {\n            // if there are more default values as specified, add them to\n            // the list.\n            if (defaultValues.size() > valueList.size()) {\n                // copy the list first\n                valueList = new ArrayList(valueList);\n                for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                    valueList.add(defaultValues.get(i));\n                }\n            }\n        }\n    }\n    \n    return valueList == null ? Collections.EMPTY_LIST : valueList;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java",
      "first_line": 111,
      "last_line": 130
    },
    "javadoc": "/**\n* Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n* hold the parsed arguments.\n*\n* @param rootOption the CommandLine's root Option\n* @param arguments the arguments this CommandLine represents\n*/",
    "failing_tests": {
      "org.apache.commons.cli2.bug.BugCLI158Test::testSingleOptionSingleArgument": {
        "source": "    public void testSingleOptionSingleArgument() throws Exception {\n\n        Parser parser = createDefaultValueParser(new String[]{\"100\", \"1000\"});\n\n        String enteredValue1 = \"1\";\n\n        String[] args = new String[]{\"-b\", enteredValue1};\n\n        CommandLine cl = parser.parse(args);\n\n        CommandLine cmd = cl;\n\n        assertNotNull(cmd);\n\n        List b = cmd.getValues(\"-b\");\n\n        assertEquals(\"[\" + enteredValue1 + \", 1000]\", b + \"\");\n\n    }\n"
      },
      "org.apache.commons.cli2.bug.BugCLI158Test::testSingleOptionMaximumNumberOfArgument": {
        "source": "    public void testSingleOptionMaximumNumberOfArgument() throws Exception {\n\n        String[] args = new String[]{\"-b\", \"1\", \"2\"};\n\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n\n        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n\n        final GroupBuilder gbuilder = new GroupBuilder();\n\n\n\n        DefaultOption bOption = obuilder.withShortName(\"b\")\n\n                .withLongName(\"b\")\n\n                .withArgument(abuilder.withName(\"b\")\n\n                        .withMinimum(2)\n\n                        .withMaximum(4)\n\n                        .withDefault(\"100\")\n\n                        .withDefault(\"1000\")\n\n                        .withDefault(\"10000\")\n\n                        .create())\n\n                .create();\n\n\n\n        Group options = gbuilder\n\n                .withName(\"options\")\n\n                .withOption(bOption)\n\n                .create();\n\n\n\n        Parser parser = new Parser();\n\n        parser.setHelpTrigger(\"--help\");\n\n        parser.setGroup(options);\n\n        CommandLine cl = parser.parse(args);\n\n        CommandLine cmd = cl;\n\n        assertNotNull(cmd);\n\n        List b = cmd.getValues(\"-b\");\n\n        assertEquals(\"[1, 2, 10000]\", b + \"\");\n\n    }\n"
      }
    }
  },
  "Cli-17": {
    "id": "Cli-17",
    "project": "Cli",
    "number": "17",
    "buggy_function": "protected void burstToken(String token, boolean stopAtNonOption)\n{\n    for (int i = 1; i < token.length(); i++)\n    {\n        String ch = String.valueOf(token.charAt(i));\n\n        if (options.hasOption(ch))\n        {\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && (token.length() != (i + 1)))\n            {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n        else if (stopAtNonOption)\n        {\n            process(token.substring(i));\n        }\n        else\n        {\n            tokens.add(token);\n            break;\n        }\n    }\n}",
    "fixed_function": "protected void burstToken(String token, boolean stopAtNonOption)\n{\n    for (int i = 1; i < token.length(); i++)\n    {\n        String ch = String.valueOf(token.charAt(i));\n\n        if (options.hasOption(ch))\n        {\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && (token.length() != (i + 1)))\n            {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n        else if (stopAtNonOption)\n        {\n            process(token.substring(i));\n            break;\n        }\n        else\n        {\n            tokens.add(token);\n            break;\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/PosixParser.java",
      "first_line": 282,
      "last_line": 310
    },
    "javadoc": "/**\n* <p>Breaks <code>token</code> into its constituent parts\n* using the following algorithm.\n* <ul>\n*  <li>ignore the first character (\"<b>-</b>\")</li>\n*  <li>foreach remaining character check if an {@link Option}\n*  exists with that id.</li>\n*  <li>if an {@link Option} does exist then add that character\n*  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n*  <li>if the {@link Option} can have an argument value and there\n*  are remaining characters in the token then add the remaining\n*  characters as a token to the list of processed tokens.</li>\n*  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n*  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n*  \"<b>--</b>\" followed by the remaining characters and also\n*  the remaining tokens directly to the processed tokens list.</li>\n*  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n*  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n*  character prepended with \"<b>-</b>\".</li>\n* </ul>\n* </p>\n*\n* @param token The current token to be <b>burst</b>\n* @param stopAtNonOption Specifies whether to stop processing\n* at the first non-Option encountered.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.PosixParserTest::testStopBursting": {
        "source": "    public void testStopBursting() throws Exception\n\n    {\n\n        String[] args = new String[] { \"-azc\" };\n\n\n\n        CommandLine cl = parser.parse(options, args, true);\n\n        assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n\n        assertFalse( \"Confirm -c is not set\", cl.hasOption(\"c\") );\n\n\n\n        assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n\n        assertTrue(cl.getArgList().contains(\"zc\"));\n\n    }\n"
      }
    }
  },
  "Cli-19": {
    "id": "Cli-19",
    "project": "Cli",
    "number": "19",
    "buggy_function": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\n    if (options.hasOption(token))\n    {\n        currentOption = options.getOption(token);\n        tokens.add(token);\n    }\n    else if (stopAtNonOption)\n    {\n        eatTheRest = true;\n        tokens.add(token);\n    }\n}",
    "fixed_function": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\n    if (options.hasOption(token))\n    {\n        currentOption = options.getOption(token);\n    }\n    else if (stopAtNonOption)\n    {\n        eatTheRest = true;\n    }\n\n    tokens.add(token);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/PosixParser.java",
      "first_line": 227,
      "last_line": 239
    },
    "javadoc": "/**\n* <p>If an {@link Option} exists for <code>token</code> then\n* set the current option and add the token to the processed\n* list.</p>\n*\n* <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n* is set then ignore the current token and add the remaining tokens\n* to the processed tokens list directly.</p>\n*\n* @param token The current option token\n* @param stopAtNonOption Specifies whether flattening should halt\n* at the first non option.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.PosixParserTest::testUnrecognizedOption2": {
        "source": "    public void testUnrecognizedOption2() throws Exception\n\n    {\n\n        String[] args = new String[] { \"-z\", \"-abtoast\", \"foo\", \"bar\" };\n\n\n\n        try\n\n        {\n\n            parser.parse(options, args);\n\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n\n        }\n\n        catch (UnrecognizedOptionException e)\n\n        {\n\n            assertEquals(\"-z\", e.getOption());\n\n        }\n\n    }\n"
      }
    }
  },
  "Cli-20": {
    "id": "Cli-20",
    "project": "Cli",
    "number": "20",
    "buggy_function": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n    init();\n    this.options = options;\n\n    // an iterator for the command line tokens\n    Iterator iter = Arrays.asList(arguments).iterator();\n\n    // process each command line token\n    while (iter.hasNext())\n    {\n        // get the next command line token\n        String token = (String) iter.next();\n\n        // handle long option --foo or --foo=bar\n        if (token.startsWith(\"--\"))\n        {\n            if (token.indexOf('=') != -1)\n            {\n                tokens.add(token.substring(0, token.indexOf('=')));\n                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n            }\n            else\n            {\n                tokens.add(token);\n            }\n        }\n\n        // single hyphen\n        else if (\"-\".equals(token))\n        {\n            tokens.add(token);\n        }\n        else if (token.startsWith(\"-\"))\n        {\n            if (token.length() == 2)\n            {\n                processOptionToken(token, stopAtNonOption);\n            }\n            else if (options.hasOption(token))\n            {\n                tokens.add(token);\n            }\n            // requires bursting\n            else\n            {\n                burstToken(token, stopAtNonOption);\n            }\n        }\n        else if (stopAtNonOption)\n        {\n            process(token);\n        }\n        else\n        {\n            tokens.add(token);\n        }\n\n        gobble(iter);\n    }\n\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}",
    "fixed_function": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n    init();\n    this.options = options;\n\n    // an iterator for the command line tokens\n    Iterator iter = Arrays.asList(arguments).iterator();\n\n    // process each command line token\n    while (iter.hasNext())\n    {\n        // get the next command line token\n        String token = (String) iter.next();\n\n        // handle long option --foo or --foo=bar\n        if (token.startsWith(\"--\"))\n        {\n            int pos = token.indexOf('=');\n            String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n            if (!options.hasOption(opt) && stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(opt);\n                if (pos != -1) {\n                    tokens.add(token.substring(pos + 1));\n                }\n            }\n        }\n\n        // single hyphen\n        else if (\"-\".equals(token))\n        {\n            tokens.add(token);\n        }\n        else if (token.startsWith(\"-\"))\n        {\n            if (token.length() == 2)\n            {\n                processOptionToken(token, stopAtNonOption);\n            }\n            else if (options.hasOption(token))\n            {\n                tokens.add(token);\n            }\n            // requires bursting\n            else\n            {\n                burstToken(token, stopAtNonOption);\n            }\n        }\n        else if (stopAtNonOption)\n        {\n            process(token);\n        }\n        else\n        {\n            tokens.add(token);\n        }\n\n        gobble(iter);\n    }\n\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/PosixParser.java",
      "first_line": 97,
      "last_line": 159
    },
    "javadoc": "/**\n* <p>An implementation of {@link Parser}'s abstract\n* {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n*\n* <p>The following are the rules used by this flatten method.\n* <ol>\n*  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n*  burst anymore of <code>arguments</code> entries, just add each\n*  successive entry without further processing.  Otherwise, ignore\n*  <code>stopAtNonOption</code>.</li>\n*  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n*  just add the entry to the list of processed tokens</li>\n*  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n*  just add the entry to the list of processed tokens</li>\n*  <li>if the current <code>arguments</code> entry is two characters\n*  in length and the first character is \"<b>-</b>\" then check if this\n*  is a valid {@link Option} id.  If it is a valid id, then add the\n*  entry to the list of processed tokens and set the current {@link Option}\n*  member.  If it is not a valid id and <code>stopAtNonOption</code>\n*  is true, then the remaining entries are copied to the list of\n*  processed tokens.  Otherwise, the current entry is ignored.</li>\n*  <li>if the current <code>arguments</code> entry is more than two\n*  characters in length and the first character is \"<b>-</b>\" then\n*  we need to burst the entry to determine its constituents.  For more\n*  information on the bursting algorithm see\n*  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n*  <li>if the current <code>arguments</code> entry is not handled\n*  by any of the previous rules, then the entry is added to the list\n*  of processed tokens.</li>\n* </ol>\n* </p>\n*\n* @param options The command line {@link Options}\n* @param arguments The command line arguments to be parsed\n* @param stopAtNonOption Specifies whether to stop flattening\n* when an non option is found.\n* @return The flattened <code>arguments</code> String array.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.PosixParserTest::testStop3": {
        "source": "    public void testStop3() throws Exception\n\n    {\n\n        String[] args = new String[]{\"--zop==1\",\n\n                                     \"-abtoast\",\n\n                                     \"--b=bar\"};\n\n\n\n        CommandLine cl = parser.parse(options, args, true);\n\n\n\n        assertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\"));\n\n        assertFalse(\"Confirm -b is not set\", cl.hasOption(\"b\"));\n\n        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n\n    }\n"
      }
    }
  },
  "Cli-23": {
    "id": "Cli-23",
    "project": "Cli",
    "number": "23",
    "buggy_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        int lastPos = pos;\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        } else\n        if (pos == lastPos)\n        {\n            throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "fixed_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n        \n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n            sb.append(text);\n\n            return sb;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 805,
      "last_line": 841
    },
    "javadoc": "/**\n* Render the specified text and return the rendered Options\n* in a StringBuffer.\n*\n* @param sb The StringBuffer to place the rendered text into.\n* @param width The number of characters to display per line\n* @param nextLineTabStop The position on the next line for the first tab.\n* @param text The text to be rendered.\n*\n* @return the StringBuffer with the rendered Options contents.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI162Test::testInfiniteLoop": {
        "source": "    public void testInfiniteLoop() {\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        formatter.setWidth(20);\n\n        formatter.printHelp(\"app\", options); // used to hang & crash\n\n    }\n"
      },
      "org.apache.commons.cli.bug.BugCLI162Test::testPrintHelpLongLines": {
        "source": "    public void testPrintHelpLongLines() throws ParseException, IOException {\n\n        // Constants used for options\n\n        final String OPT = \"-\";\n\n\n\n        final String OPT_COLUMN_NAMES = \"l\";\n\n\n\n        final String OPT_CONNECTION = \"c\";\n\n\n\n        final String OPT_DESCRIPTION = \"e\";\n\n\n\n        final String OPT_DRIVER = \"d\";\n\n\n\n        final String OPT_DRIVER_INFO = \"n\";\n\n\n\n        final String OPT_FILE_BINDING = \"b\";\n\n\n\n        final String OPT_FILE_JDBC = \"j\";\n\n\n\n        final String OPT_FILE_SFMD = \"f\";\n\n\n\n        final String OPT_HELP = \"h\";\n\n\n\n        final String OPT_HELP_ = \"help\";\n\n\n\n        final String OPT_INTERACTIVE = \"i\";\n\n\n\n        final String OPT_JDBC_TO_SFMD = \"2\";\n\n\n\n        final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n\n\n        final String OPT_METADATA = \"m\";\n\n\n\n        final String OPT_PARAM_MODES_INT = \"o\";\n\n\n\n        final String OPT_PARAM_MODES_NAME = \"O\";\n\n\n\n        final String OPT_PARAM_NAMES = \"a\";\n\n\n\n        final String OPT_PARAM_TYPES_INT = \"y\";\n\n\n\n        final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n\n\n        final String OPT_PASSWORD = \"p\";\n\n\n\n        final String OPT_PASSWORD_L = \"password\";\n\n\n\n        final String OPT_SQL = \"s\";\n\n\n\n        final String OPT_SQL_L = \"sql\";\n\n\n\n        final String OPT_SQL_SPLIT_DEFAULT = \"###\";\n\n\n\n        final String OPT_SQL_SPLIT_L = \"splitSql\";\n\n\n\n        final String OPT_STACK_TRACE = \"t\";\n\n\n\n        final String OPT_TIMING = \"g\";\n\n\n\n        final String OPT_TRIM_L = \"trim\";\n\n\n\n        final String OPT_USER = \"u\";\n\n\n\n        final String OPT_WRITE_TO_FILE = \"w\";\n\n        \n\n        final String _PMODE_IN = \"IN\";\n\n\n\n        final String _PMODE_INOUT = \"INOUT\";\n\n\n\n        final String _PMODE_OUT = \"OUT\";\n\n        \n\n        final String _PMODE_UNK = \"Unknown\";\n\n        \n\n        final String PMODES = _PMODE_IN + \", \" + _PMODE_INOUT + \", \" + _PMODE_OUT + \", \" + _PMODE_UNK;\n\n        \n\n        // Options build\n\n        Options commandLineOptions;\n\n        commandLineOptions = new Options();\n\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_, false, \"Prints help and quits\");\n\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n\n            + OPT\n\n            + OPT_CONNECTION\n\n            + \" is not specified, all drivers on the classpath are displayed.\");\n\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n\n        commandLineOptions\n\n                .addOption(\n\n                        OPT_PASSWORD,\n\n                        OPT_PASSWORD_L,\n\n                        true,\n\n                        \"The database password for the user specified with the \"\n\n                            + OPT\n\n                            + OPT_USER\n\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password, see http://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n\n                \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n\n                \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n\n            + OPT\n\n            + OPT_COLUMN_NAMES\n\n            + \" \\\"cname1 cname2\\\"\");\n\n        commandLineOptions.addOption(option);\n\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n\n            + OPT\n\n            + OPT_PARAM_NAMES\n\n            + \" \\\"pname1 pname2\\\"\");\n\n        commandLineOptions.addOption(option);\n\n        //\n\n        OptionGroup pOutTypesOptionGroup = new OptionGroup();\n\n        String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n\n        final String typesClassName = Types.class.getName();\n\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n\n            + typesClassName\n\n            + \". \"\n\n            + pOutTypesOptionGroupDoc\n\n            + \" Example: \"\n\n            + OPT\n\n            + OPT_PARAM_TYPES_INT\n\n            + \" \\\"-10 12\\\"\");\n\n        commandLineOptions.addOption(option);\n\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n\n            + typesClassName\n\n            + \" names. \"\n\n            + pOutTypesOptionGroupDoc\n\n            + \" Example: \"\n\n            + OPT\n\n            + OPT_PARAM_TYPES_NAME\n\n            + \" \\\"CURSOR VARCHAR\\\"\");\n\n        commandLineOptions.addOption(option);\n\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n\n        //\n\n        OptionGroup modesOptionGroup = new OptionGroup();\n\n        String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n\n            + ParameterMetaData.parameterModeIn\n\n            + \"=IN, \"\n\n            + ParameterMetaData.parameterModeInOut\n\n            + \"=INOUT, \"\n\n            + ParameterMetaData.parameterModeOut\n\n            + \"=OUT, \"\n\n            + ParameterMetaData.parameterModeUnknown\n\n            + \"=Unknown\"\n\n            + \"). \"\n\n            + modesOptionGroupDoc\n\n            + \" Example for 2 parameters, OUT and IN: \"\n\n            + OPT\n\n            + OPT_PARAM_MODES_INT\n\n            + \" \\\"\"\n\n            + ParameterMetaData.parameterModeOut\n\n            + \" \"\n\n            + ParameterMetaData.parameterModeIn\n\n            + \"\\\"\");\n\n        modesOptionGroup.addOption(option);\n\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n\n            + PMODES\n\n            + \"). \"\n\n            + modesOptionGroupDoc\n\n            + \" Example for 2 parameters, OUT and IN: \"\n\n            + OPT\n\n            + OPT_PARAM_MODES_NAME\n\n            + \" \\\"\"\n\n            + _PMODE_OUT\n\n            + \" \"\n\n            + _PMODE_IN\n\n            + \"\\\"\");\n\n        modesOptionGroup.addOption(option);\n\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n\n        option = new Option(null, OPT_TRIM_L, true,\n\n                \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n\n        option.setOptionalArg(true);\n\n        commandLineOptions.addOption(option);\n\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n\n                \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n\n        option.setArgs(2);\n\n        commandLineOptions.addOption(option);\n\n        this.testPrintHelp(commandLineOptions);\n\n    }\n"
      }
    }
  },
  "Cli-24": {
    "id": "Cli-24",
    "project": "Cli",
    "number": "24",
    "buggy_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width)\n    {\n        // stops infinite loop happening\n        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n                                        \"- no room for the description\");\n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n        \n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "fixed_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width)\n    {\n        // stops infinite loop happening\n        nextLineTabStop = width - 1;\n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n        \n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 809,
      "last_line": 852
    },
    "javadoc": "/**\n* Render the specified text and return the rendered Options\n* in a StringBuffer.\n*\n* @param sb The StringBuffer to place the rendered text into.\n* @param width The number of characters to display per line\n* @param nextLineTabStop The position on the next line for the first tab.\n* @param text The text to be rendered.\n*\n* @return the StringBuffer with the rendered Options contents.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI162Test::testLongLineChunkingIndentIgnored": {
        "source": "    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n\n        Options options = new Options();\n\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        StringWriter sw = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n\n        String expected = \"usage:\\n\" +\n\n                          \"       org.apache.comm\\n\" +\n\n                          \"       ons.cli.bug.Bug\\n\" +\n\n                          \"       CLI162Test\\n\" +\n\n                          \"Header\\n\" +\n\n                          \"-x,--extralongarg\\n\" +\n\n                          \"                     T\\n\" +\n\n                          \"                     h\\n\" +\n\n                          \"                     i\\n\" +\n\n                          \"                     s\\n\" +\n\n                          \"                     d\\n\" +\n\n                          \"                     e\\n\" +\n\n                          \"                     s\\n\" +\n\n                          \"                     c\\n\" +\n\n                          \"                     r\\n\" +\n\n                          \"                     i\\n\" +\n\n                          \"                     p\\n\" +\n\n                          \"                     t\\n\" +\n\n                          \"                     i\\n\" +\n\n                          \"                     o\\n\" +\n\n                          \"                     n\\n\" +\n\n                          \"                     i\\n\" +\n\n                          \"                     s\\n\" +\n\n                          \"                     L\\n\" +\n\n                          \"                     o\\n\" +\n\n                          \"                     n\\n\" +\n\n                          \"                     g\\n\" +\n\n                          \"                     .\\n\" +\n\n                          \"Footer\\n\";\n\n        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n\n    }\n"
      }
    }
  },
  "Cli-25": {
    "id": "Cli-25",
    "project": "Cli",
    "number": "25",
    "buggy_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width)\n    {\n        // stops infinite loop happening\n        nextLineTabStop = width - 1;\n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n        \n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "fixed_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width)\n    {\n        // stops infinite loop happening\n        nextLineTabStop = 1;\n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n        \n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 809,
      "last_line": 851
    },
    "javadoc": "/**\n* Render the specified text and return the rendered Options\n* in a StringBuffer.\n*\n* @param sb The StringBuffer to place the rendered text into.\n* @param width The number of characters to display per line\n* @param nextLineTabStop The position on the next line for the first tab.\n* @param text The text to be rendered.\n*\n* @return the StringBuffer with the rendered Options contents.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI162Test::testLongLineChunkingIndentIgnored": {
        "source": "    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n\n        Options options = new Options();\n\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        StringWriter sw = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n\n        System.err.println(sw.toString());\n\n        String expected = \"usage:\\n\" +\n\n                          \"       org.apache.comm\\n\" +\n\n                          \"       ons.cli.bug.Bug\\n\" +\n\n                          \"       CLI162Test\\n\" +\n\n                          \"Header\\n\" +\n\n                          \"-x,--extralongarg\\n\" +\n\n                          \" This description is\\n\" +\n\n                          \" Long.\\n\" +\n\n                          \"Footer\\n\";\n\n        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n\n    }\n"
      }
    }
  },
  "Cli-26": {
    "id": "Cli-26",
    "project": "Cli",
    "number": "26",
    "buggy_function": "public static Option create(String opt) throws IllegalArgumentException\n{\n        // create the option\n    Option option = new Option(opt, description);\n\n        // set the option properties\n        option.setLongOpt(longopt);\n        option.setRequired(required);\n        option.setOptionalArg(optionalArg);\n        option.setArgs(numberOfArgs);\n        option.setType(type);\n        option.setValueSeparator(valuesep);\n        option.setArgName(argName);\n        // reset the OptionBuilder properties\n        OptionBuilder.reset();\n\n    // return the Option instance\n    return option;\n}",
    "fixed_function": "public static Option create(String opt) throws IllegalArgumentException\n{\n    Option option = null;\n    try {\n        // create the option\n        option = new Option(opt, description);\n\n        // set the option properties\n        option.setLongOpt(longopt);\n        option.setRequired(required);\n        option.setOptionalArg(optionalArg);\n        option.setArgs(numberOfArgs);\n        option.setType(type);\n        option.setValueSeparator(valuesep);\n        option.setArgName(argName);\n    } finally {\n        // reset the OptionBuilder properties\n        OptionBuilder.reset();\n    }\n\n    // return the Option instance\n    return option;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/OptionBuilder.java",
      "first_line": 346,
      "last_line": 364
    },
    "javadoc": "/**\n* Create an Option using the current settings and with\n* the specified Option <code>char</code>.\n*\n* @param opt the <code>java.lang.String</code> representation\n* of the Option\n* @return the Option instance\n* @throws IllegalArgumentException if <code>opt</code> is not\n* a valid character.  See Option.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways": {
        "source": "    public void testBuilderIsResettedAlways() {\n\n        try\n\n        {\n\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n\n            fail(\"IllegalArgumentException expected\");\n\n        }\n\n        catch (IllegalArgumentException e)\n\n        {\n\n            // expected\n\n        }\n\n        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n\n\n\n        try\n\n        {\n\n            OptionBuilder.withDescription(\"JUnit\").create();\n\n            fail(\"IllegalArgumentException expected\");\n\n        }\n\n        catch (IllegalArgumentException e)\n\n        {\n\n            // expected\n\n        }\n\n        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n\n    }\n"
      }
    }
  },
  "Cli-27": {
    "id": "Cli-27",
    "project": "Cli",
    "number": "27",
    "buggy_function": "public void setSelected(Option option) throws AlreadySelectedException\n{\n    if (option == null)\n    {\n        // reset the option previously selected\n        selected = null;\n        return;\n    }\n    \n    // if no option has already been selected or the \n    // same option is being reselected then set the\n    // selected member variable\n    if (selected == null || selected.equals(option.getOpt()))\n    {\n        selected = option.getOpt();\n    }\n    else\n    {\n        throw new AlreadySelectedException(this, option);\n    }\n}",
    "fixed_function": "public void setSelected(Option option) throws AlreadySelectedException\n{\n    if (option == null)\n    {\n        // reset the option previously selected\n        selected = null;\n        return;\n    }\n    \n    // if no option has already been selected or the \n    // same option is being reselected then set the\n    // selected member variable\n    if (selected == null || selected.equals(option.getKey()))\n    {\n        selected = option.getKey();\n    }\n    else\n    {\n        throw new AlreadySelectedException(this, option);\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/OptionGroup.java",
      "first_line": 86,
      "last_line": 106
    },
    "javadoc": "/**\n* Set the selected option of this group to <code>name</code>.\n*\n* @param option the option that is selected\n* @throws AlreadySelectedException if an option from this group has\n* already been selected.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.BasicParserTest::testOptionGroupLong": {
        "source": "    public void testOptionGroupLong() throws Exception\n\n    {\n\n        OptionGroup group = new OptionGroup();\n\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        \n\n        Options options = new Options();\n\n        options.addOptionGroup(group);\n\n        \n\n        CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        \n\n        assertTrue(cl.hasOption(\"bar\"));\n\n        assertEquals(\"selected option\", \"bar\", group.getSelected());\n\n    }\n"
      },
      "org.apache.commons.cli.GnuParserTest::testOptionGroupLong": {
        "source": "    public void testOptionGroupLong() throws Exception\n\n    {\n\n        OptionGroup group = new OptionGroup();\n\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        \n\n        Options options = new Options();\n\n        options.addOptionGroup(group);\n\n        \n\n        CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        \n\n        assertTrue(cl.hasOption(\"bar\"));\n\n        assertEquals(\"selected option\", \"bar\", group.getSelected());\n\n    }\n"
      },
      "org.apache.commons.cli.PosixParserTest::testOptionGroupLong": {
        "source": "    public void testOptionGroupLong() throws Exception\n\n    {\n\n        OptionGroup group = new OptionGroup();\n\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        \n\n        Options options = new Options();\n\n        options.addOptionGroup(group);\n\n        \n\n        CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        \n\n        assertTrue(cl.hasOption(\"bar\"));\n\n        assertEquals(\"selected option\", \"bar\", group.getSelected());\n\n    }\n"
      }
    }
  },
  "Cli-28": {
    "id": "Cli-28",
    "project": "Cli",
    "number": "28",
    "buggy_function": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n\n            // get the value from the properties instance\n            String value = properties.getProperty(option);\n\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                        // if we cannot add the value don't worry about it\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                // if the value is not yes, true or 1 then don't add the\n                // option to the CommandLine\n                break;\n            }\n\n            cmd.addOption(opt);\n        }\n    }\n}",
    "fixed_function": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n\n            // get the value from the properties instance\n            String value = properties.getProperty(option);\n\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                        // if we cannot add the value don't worry about it\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                // if the value is not yes, true or 1 then don't add the\n                // option to the CommandLine\n                continue;\n            }\n\n            cmd.addOption(opt);\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/Parser.java",
      "first_line": 252,
      "last_line": 296
    },
    "javadoc": "/**\n* Sets the values of Options using the values in <code>properties</code>.\n*\n* @param properties The value properties to be processed.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.ValueTest::testPropertyOptionFlags": {
        "source": "    public void testPropertyOptionFlags() throws Exception\n\n    {\n\n        Properties properties = new Properties();\n\n        properties.setProperty( \"a\", \"true\" );\n\n        properties.setProperty( \"c\", \"yes\" );\n\n        properties.setProperty( \"e\", \"1\" );\n\n\n\n        Parser parser = new PosixParser();\n\n\n\n        CommandLine cmd = parser.parse(opts, null, properties);\n\n        assertTrue( cmd.hasOption(\"a\") );\n\n        assertTrue( cmd.hasOption(\"c\") );\n\n        assertTrue( cmd.hasOption(\"e\") );\n\n\n\n\n\n        properties = new Properties();\n\n        properties.setProperty( \"a\", \"false\" );\n\n        properties.setProperty( \"c\", \"no\" );\n\n        properties.setProperty( \"e\", \"0\" );\n\n\n\n        cmd = parser.parse(opts, null, properties);\n\n        assertTrue( !cmd.hasOption(\"a\") );\n\n        assertTrue( !cmd.hasOption(\"c\") );\n\n        assertTrue( cmd.hasOption(\"e\") ); // this option accepts as argument\n\n\n\n\n\n        properties = new Properties();\n\n        properties.setProperty( \"a\", \"TRUE\" );\n\n        properties.setProperty( \"c\", \"nO\" );\n\n        properties.setProperty( \"e\", \"TrUe\" );\n\n\n\n        cmd = parser.parse(opts, null, properties);\n\n        assertTrue( cmd.hasOption(\"a\") );\n\n        assertTrue( !cmd.hasOption(\"c\") );\n\n        assertTrue( cmd.hasOption(\"e\") );\n\n\n\n        \n\n        properties = new Properties();\n\n        properties.setProperty( \"a\", \"just a string\" );\n\n        properties.setProperty( \"e\", \"\" );\n\n\n\n        cmd = parser.parse(opts, null, properties);\n\n        assertTrue( !cmd.hasOption(\"a\") );\n\n        assertTrue( !cmd.hasOption(\"c\") );\n\n        assertTrue( cmd.hasOption(\"e\") );\n\n    } \n"
      }
    }
  },
  "Cli-29": {
    "id": "Cli-29",
    "project": "Cli",
    "number": "29",
    "buggy_function": "static String stripLeadingAndTrailingQuotes(String str)\n{\n    if (str.startsWith(\"\\\"\"))\n    {\n        str = str.substring(1, str.length());\n    }\n    int length = str.length();\n    if (str.endsWith(\"\\\"\"))\n    {\n        str = str.substring(0, length - 1);\n    }\n    \n    return str;\n}",
    "fixed_function": "static String stripLeadingAndTrailingQuotes(String str)\n{\n    int length = str.length();\n    if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n    {\n        str = str.substring(1, length - 1);\n    }\n    \n    return str;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/Util.java",
      "first_line": 63,
      "last_line": 76
    },
    "javadoc": "/**\n* Remove the leading and trailing quotes from <code>str</code>.\n* E.g. if str is '\"one two\"', then 'one two' is returned.\n*\n* @param str The string from which the leading and trailing quotes\n* should be removed.\n*\n* @return The string without the leading and trailing quotes.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes": {
        "source": "    public void testStripLeadingAndTrailingQuotes()\n\n    {\n\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n\n    }\n"
      }
    }
  },
  "Cli-32": {
    "id": "Cli-32",
    "project": "Cli",
    "number": "32",
    "buggy_function": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    \n    // the line ends before the max wrap pos or a new line char found\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n\n\n    // look for the last whitespace character before startPos+width\n    pos = startPos + width;\n\n    char c;\n\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n\n    // if we found it - just return\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    \n    // if we didn't find one, simply chop at startPos+width\n    pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n           && (c != '\\n') && (c != '\\r'))\n    {\n        ++pos;\n    }        \n    return pos == text.length() ? -1 : pos;\n}",
    "fixed_function": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    \n    // the line ends before the max wrap pos or a new line char found\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n\n\n    // look for the last whitespace character before startPos+width\n    pos = startPos + width;\n\n    char c;\n\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n\n    // if we found it - just return\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    \n    // if we didn't find one, simply chop at startPos+width\n    pos = startPos + width;\n    \n    return pos == text.length() ? -1 : pos;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 902,
      "last_line": 943
    },
    "javadoc": "/**\n* Finds the next text wrap position after <code>startPos</code> for the\n* text in <code>text</code> with the column width <code>width</code>.\n* The wrap point is the last position before startPos+width having a\n* whitespace character (space, \\n, \\r). If there is no whitespace character\n* before startPos+width, it will return startPos+width.\n*\n* @param text The text being searched for the wrap position\n* @param width width of the wrapped text\n* @param startPos position from which to start the lookup whitespace\n* character\n* @return postion on which the text must be wrapped or -1 if the wrap\n* position is at the end of the text\n*/",
    "failing_tests": {
      "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut": {
        "source": "    public void testRenderWrappedTextWordCut()\n\n    {\n\n        int width = 7;\n\n        int padding = 0;\n\n        String text = \"Thisisatest.\";\n\n        String expected = \"Thisisa\" + EOL + \n\n                          \"test.\";\n\n        \n\n        StringBuffer sb = new StringBuffer();\n\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n\n        assertEquals(\"cut and wrap\", expected, sb.toString());\n\n    }\n"
      },
      "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos": {
        "source": "    public void testFindWrapPos() throws Exception\n\n    {\n\n        HelpFormatter hf = new HelpFormatter();\n\n\n\n        String text = \"This is a test.\";\n\n        // text width should be max 8; the wrap position is 7\n\n        assertEquals(\"wrap position\", 7, hf.findWrapPos(text, 8, 0));\n\n        \n\n        // starting from 8 must give -1 - the wrap pos is after end\n\n        assertEquals(\"wrap position 2\", -1, hf.findWrapPos(text, 8, 8));\n\n        \n\n        // words longer than the width are cut\n\n        text = \"aaaa aa\";\n\n        assertEquals(\"wrap position 3\", 3, hf.findWrapPos(text, 3, 0));\n\n        \n\n        // last word length is equal to the width\n\n        text = \"aaaaaa aaaaaa\";\n\n        assertEquals(\"wrap position 4\", 6, hf.findWrapPos(text, 6, 0));\n\n        assertEquals(\"wrap position 4\", -1, hf.findWrapPos(text, 6, 7));\n\n    }\n"
      }
    }
  },
  "Cli-35": {
    "id": "Cli-35",
    "project": "Cli",
    "number": "35",
    "buggy_function": "public List<String> getMatchingOptions(String opt)\n{\n    opt = Util.stripLeadingHyphens(opt);\n    \n    List<String> matchingOpts = new ArrayList<String>();\n\n    // for a perfect match return the single option only\n\n    for (String longOpt : longOpts.keySet())\n    {\n        if (longOpt.startsWith(opt))\n        {\n            matchingOpts.add(longOpt);\n        }\n    }\n    \n    return matchingOpts;\n}",
    "fixed_function": "public List<String> getMatchingOptions(String opt)\n{\n    opt = Util.stripLeadingHyphens(opt);\n    \n    List<String> matchingOpts = new ArrayList<String>();\n\n    // for a perfect match return the single option only\n    if(longOpts.keySet().contains(opt)) {\n        return Collections.singletonList(opt);\n    }\n\n    for (String longOpt : longOpts.keySet())\n    {\n        if (longOpt.startsWith(opt))\n        {\n            matchingOpts.add(longOpt);\n        }\n    }\n    \n    return matchingOpts;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/Options.java",
      "first_line": 233,
      "last_line": 250
    },
    "javadoc": "/**\n* Returns the options with a long name starting with the name specified.\n*\n* @param opt the partial name of the option\n* @return the options matching the partial name specified, or an empty list if none matches\n* @since 1.3\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI252Test::testExactOptionNameMatch": {
        "source": "    public void testExactOptionNameMatch() throws ParseException {\n\n        new DefaultParser().parse(getOptions(), new String[]{\"--prefix\"});\n\n    }\n"
      }
    }
  },
  "Cli-37": {
    "id": "Cli-37",
    "project": "Cli",
    "number": "37",
    "buggy_function": "private boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n    // remove leading \"-\" and \"=value\"\n}",
    "fixed_function": "private boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if (!token.startsWith(\"-\") || token.length() == 1)\n    {\n        return false;\n    }\n\n    // remove leading \"-\" and \"=value\"\n    int pos = token.indexOf(\"=\");\n    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n    return options.hasShortOption(optName);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/DefaultParser.java",
      "first_line": 299,
      "last_line": 305
    },
    "javadoc": "/**\n* Tells if the token looks like a short option.\n*\n* @param token\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI265Test::shouldParseShortOptionWithoutValue": {
        "source": "    public void shouldParseShortOptionWithoutValue() throws Exception {\n\n        String[] twoShortOptions = new String[]{\"-t1\", \"-last\"};\n\n\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n\n        assertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\"));\n\n        assertTrue(\"Second option has not been detected\", commandLine.hasOption(\"last\"));\n\n    }\n"
      }
    }
  },
  "Cli-38": {
    "id": "Cli-38",
    "project": "Cli",
    "number": "38",
    "buggy_function": "private boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if (!token.startsWith(\"-\") || token.length() == 1)\n    {\n        return false;\n    }\n\n    // remove leading \"-\" and \"=value\"\n    int pos = token.indexOf(\"=\");\n    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n    return options.hasShortOption(optName);\n    // check for several concatenated short options\n}",
    "fixed_function": "private boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if (!token.startsWith(\"-\") || token.length() == 1)\n    {\n        return false;\n    }\n\n    // remove leading \"-\" and \"=value\"\n    int pos = token.indexOf(\"=\");\n    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n    if (options.hasShortOption(optName))\n    {\n        return true;\n    }\n    // check for several concatenated short options\n    return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/DefaultParser.java",
      "first_line": 299,
      "last_line": 312
    },
    "javadoc": "/**\n* Tells if the token looks like a short option.\n*\n* @param token\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI265Test::shouldParseConcatenatedShortOptions": {
        "source": "    public void shouldParseConcatenatedShortOptions() throws Exception {\n\n        String[] concatenatedShortOptions = new String[] { \"-t1\", \"-ab\" };\n\n\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n\n        assertNull(commandLine.getOptionValue(\"t1\"));\n\n        assertTrue(commandLine.hasOption(\"a\"));\n\n        assertTrue(commandLine.hasOption(\"b\"));\n\n        assertFalse(commandLine.hasOption(\"last\"));\n\n    }\n"
      }
    }
  },
  "Cli-4": {
    "id": "Cli-4",
    "project": "Cli",
    "number": "4",
    "buggy_function": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processsed\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        StringBuffer buff = new StringBuffer();\n\n\n        // loop through the required options\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n        }\n\n        throw new MissingOptionException(buff.toString());\n    }\n}",
    "fixed_function": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processsed\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n\n\n        // loop through the required options\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n        }\n\n        throw new MissingOptionException(buff.toString());\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/Parser.java",
      "first_line": 290,
      "last_line": 309
    },
    "javadoc": "/**\n* <p>Throws a {@link MissingOptionException} if all of the\n* required options are no present.</p>\n*\n* @throws MissingOptionException if any of the required Options\n* are not present.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.OptionsTest::testMissingOptionsException": {
        "source": "    public void testMissingOptionsException() throws ParseException {\n\n        Options options = new Options();\n\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n\n        try {\n\n            new PosixParser().parse(options, new String[0]);\n\n            fail(\"Expected MissingOptionException to be thrown\");\n\n        } catch (MissingOptionException e) {\n\n            assertEquals(\"Missing required options: fx\", e.getMessage());\n\n        }\n\n    }\n"
      },
      "org.apache.commons.cli.OptionsTest::testMissingOptionException": {
        "source": "    public void testMissingOptionException() throws ParseException {\n\n        Options options = new Options();\n\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        try {\n\n            new PosixParser().parse(options, new String[0]);\n\n            fail(\"Expected MissingOptionException to be thrown\");\n\n        } catch (MissingOptionException e) {\n\n            assertEquals(\"Missing required option: f\", e.getMessage());\n\n        }\n\n    }\n"
      }
    }
  },
  "Cli-40": {
    "id": "Cli-40",
    "project": "Cli",
    "number": "40",
    "buggy_function": "public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}",
    "fixed_function": "public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        throw new ParseException(\"Unable to handle the class: \" + clazz);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/TypeHandler.java",
      "first_line": 63,
      "last_line": 105
    },
    "javadoc": "/**\n* Returns the <code>Object</code> of type <code>clazz</code>\n* with the value of <code>str</code>.\n*\n* @param str the command line value\n* @param clazz the type of argument\n* @return The instance of <code>clazz</code> initialised with\n* the value of <code>str</code>.\n* @throws ParseException if the value creation for the given class failed\n*/",
    "failing_tests": {
      "org.apache.commons.cli.TypeHandlerTest::testCreateValueInteger_failure": {
        "source": "    public void testCreateValueInteger_failure()\n\n            throws Exception\n\n    {\n\n        TypeHandler.createValue(\"just-a-string\", Integer.class);\n\n    }\n"
      }
    }
  },
  "Cli-5": {
    "id": "Cli-5",
    "project": "Cli",
    "number": "5",
    "buggy_function": "static String stripLeadingHyphens(String str)\n{\n    if (str.startsWith(\"--\"))\n    {\n        return str.substring(2, str.length());\n    }\n    else if (str.startsWith(\"-\"))\n    {\n        return str.substring(1, str.length());\n    }\n\n    return str;\n}",
    "fixed_function": "static String stripLeadingHyphens(String str)\n{\n    if (str == null) {\n        return null;\n    }\n    if (str.startsWith(\"--\"))\n    {\n        return str.substring(2, str.length());\n    }\n    else if (str.startsWith(\"-\"))\n    {\n        return str.substring(1, str.length());\n    }\n\n    return str;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/Util.java",
      "first_line": 34,
      "last_line": 46
    },
    "javadoc": "/**\n* <p>Remove the hyphens from the begining of <code>str</code> and\n* return the new String.</p>\n*\n* @param str The string from which the hyphens should be removed.\n*\n* @return the new String.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.UtilTest::testStripLeadingHyphens": {
        "source": "    public void testStripLeadingHyphens() {\n\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n\n        assertNull(Util.stripLeadingHyphens(null));\n\n    }\n"
      },
      "org.apache.commons.cli.bug.BugCLI133Test::testOrder": {
        "source": "    public void testOrder() throws ParseException {\n\n        Option optionA = new Option(\"a\", \"first\");\n\n        Options opts = new Options();\n\n        opts.addOption(optionA);\n\n        PosixParser posixParser = new PosixParser();\n\n        CommandLine line = posixParser.parse(opts, null);\n\n        assertFalse(line.hasOption(null));\n\n    }\n"
      }
    }
  },
  "Cli-8": {
    "id": "Cli-8",
    "project": "Cli",
    "number": "8",
    "buggy_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "fixed_function": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 792,
      "last_line": 823
    },
    "javadoc": "/**\n* <p>Render the specified text and return the rendered Options\n* in a StringBuffer.</p>\n*\n* @param sb The StringBuffer to place the rendered text into.\n* @param width The number of characters to display per line\n* @param nextLineTabStop The position on the next line for the first tab.\n* @param text The text to be rendered.\n*\n* @return the StringBuffer with the rendered Options contents.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.HelpFormatterTest::testPrintWrapped": {
        "source": "   public void testPrintWrapped()\n\n      throws Exception\n\n   {\n\n      StringBuffer sb = new StringBuffer();\n\n      HelpFormatter hf = new HelpFormatter();\n\n\n\n      String text = \"This is a test.\";\n\n      String expected;\n\n\n\n      expected = \"This is a\" + hf.getNewLine() + \"test.\";\n\n      hf.renderWrappedText(sb, 12, 0, text);\n\n      assertEquals(\"single line text\", expected, sb.toString());\n\n\n\n      sb.setLength(0);\n\n      expected = \"This is a\" + hf.getNewLine() + \"    test.\";\n\n      hf.renderWrappedText(sb, 12, 4, text);\n\n      assertEquals(\"single line padded text\", expected, sb.toString());\n\n\n\n      text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n\n          \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n\n\n\n      sb.setLength(0);\n\n      expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" +\n\n                 hf.getNewLine() +\n\n                 \"                        form DATE[-DATE] where DATE\" +\n\n                 hf.getNewLine() +\n\n                 \"                        has form YYYY[MM[DD]]\";\n\n      hf.renderWrappedText(sb, 53, 24, text);\n\n      assertEquals(\"single line padded text 2\", expected, sb.toString());\n\n\n\n      text =\n\n         \"aaaa aaaa aaaa\" + hf.getNewLine() +\n\n         \"aaaaaa\" + hf.getNewLine() +\n\n         \"aaaaa\";\n\n\n\n      expected = text;\n\n      sb.setLength(0);\n\n      hf.renderWrappedText(sb, 16, 0, text);\n\n      assertEquals(\"multi line text\", expected, sb.toString());\n\n\n\n      expected =\n\n         \"aaaa aaaa aaaa\" + hf.getNewLine() +\n\n         \"    aaaaaa\" + hf.getNewLine() +\n\n         \"    aaaaa\";\n\n      sb.setLength(0);\n\n      hf.renderWrappedText(sb, 16, 4, text);\n\n      assertEquals(\"multi-line padded text\", expected, sb.toString());\n\n   }\n"
      }
    }
  },
  "Cli-9": {
    "id": "Cli-9",
    "project": "Cli",
    "number": "9",
    "buggy_function": "protected void checkRequiredOptions()\n    throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processsed\n    if (getRequiredOptions().size() > 0)\n    {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n\n\n        // loop through the required options\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n        }\n\n        throw new MissingOptionException(buff.toString());\n    }\n}",
    "fixed_function": "protected void checkRequiredOptions()\n    throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processsed\n    if (getRequiredOptions().size() > 0)\n    {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n\n\n        // loop through the required options\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n            buff.append(\", \");\n        }\n\n        throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/Parser.java",
      "first_line": 303,
      "last_line": 324
    },
    "javadoc": "/**\n* <p>Throws a {@link MissingOptionException} if all of the\n* required options are no present.</p>\n*\n* @throws MissingOptionException if any of the required Options\n* are not present.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.OptionsTest::testMissingOptionsException": {
        "source": "    public void testMissingOptionsException() throws ParseException {\n\n        Options options = new Options();\n\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n\n        try {\n\n            new PosixParser().parse(options, new String[0]);\n\n            fail(\"Expected MissingOptionException to be thrown\");\n\n        } catch (MissingOptionException e) {\n\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n\n        }\n\n    }\n"
      },
      "org.apache.commons.cli.ParseRequiredTest::testMissingRequiredOptions": {
        "source": "    public void testMissingRequiredOptions()\n\n    {\n\n        String[] args = new String[] { \"-a\" };\n\n\n\n        _options.addOption( OptionBuilder.withLongOpt( \"cfile\" )\n\n                                     .hasArg()\n\n                                     .isRequired()\n\n                                     .withDescription( \"set the value of [c]\" )\n\n                                     .create( 'c' ) );\n\n\n\n        try\n\n        {\n\n            CommandLine cl = parser.parse(_options,args);\n\n            fail( \"exception should have been thrown\" );\n\n        }\n\n        catch (MissingOptionException e)\n\n        {\n\n            assertEquals( \"Incorrect exception message\", \"Missing required options: b, c\", e.getMessage() );\n\n        }\n\n        catch (ParseException e)\n\n        {\n\n            fail( \"expected to catch MissingOptionException\" );\n\n        }\n\n    }\n"
      }
    }
  },
  "Closure-1": {
    "id": "Closure-1",
    "project": "Closure",
    "number": "1",
    "buggy_function": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  // Notice that removing unreferenced function args breaks\n  // Function.prototype.length. In advanced mode, we don't really care\n  // about this: we consider \"length\" the equivalent of reflecting on\n  // the function's lexical source.\n  //\n  // Rather than create a new option for this, we assume that if the user\n  // is removing globals, then it's OK to remove unused function args.\n  //\n  // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n  Node function = fnScope.getRootNode();\n\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    // The parameters object literal setters can not be removed.\n    return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n    // Strip unreferenced args off the end of the function declaration.\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      Var var = fnScope.getVar(lastArg.getString());\n      if (!referenced.contains(var)) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n      } else {\n        break;\n      }\n    }\n  } else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}",
    "fixed_function": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  // Notice that removing unreferenced function args breaks\n  // Function.prototype.length. In advanced mode, we don't really care\n  // about this: we consider \"length\" the equivalent of reflecting on\n  // the function's lexical source.\n  //\n  // Rather than create a new option for this, we assume that if the user\n  // is removing globals, then it's OK to remove unused function args.\n  //\n  // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n  if (!removeGlobals) {\n    return;\n  }\n\n  Node function = fnScope.getRootNode();\n\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    // The parameters object literal setters can not be removed.\n    return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n    // Strip unreferenced args off the end of the function declaration.\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      Var var = fnScope.getVar(lastArg.getString());\n      if (!referenced.contains(var)) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n      } else {\n        break;\n      }\n    }\n  } else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "first_line": 369,
      "last_line": 406
    },
    "javadoc": "/**\n* Removes unreferenced arguments from a function declaration and when\n* possible the function's callSites.\n*\n* @param fnScope The scope inside the function\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testSimpleModeLeavesUnusedParams": {
        "source": "  public void testSimpleModeLeavesUnusedParams() {\n\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n\n    testSame(\"window.f = function(a) {};\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.CommandLineRunnerTest::testForwardDeclareDroppedTypes": {
        "source": "  public void testForwardDeclareDroppedTypes() {\n\n    args.add(\"--manage_closure_dependencies=true\");\n\n\n\n    args.add(\"--warning_level=VERBOSE\");\n\n    test(new String[] {\n\n          \"goog.require('beer');\",\n\n          \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\",\n\n          \"goog.provide('Scotch'); var x = 3;\"\n\n         },\n\n         new String[] {\n\n           \"var beer = {}; function f(a) {}\",\n\n           \"\"\n\n         });\n\n\n\n    test(new String[] {\n\n          \"goog.require('beer');\",\n\n          \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\"\n\n         },\n\n         new String[] {\n\n           \"var beer = {}; function f(a) {}\",\n\n           \"\"\n\n         },\n\n         RhinoErrorReporter.TYPE_PARSE_ERROR);\n\n  }\n"
      },
      "com.google.javascript.jscomp.CommandLineRunnerTest::testDebugFlag1": {
        "source": "  public void testDebugFlag1() {\n\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n\n    args.add(\"--debug=false\");\n\n    test(\"function foo(a) {}\",\n\n         \"function foo(a) {}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.IntegrationTest::testIssue787": {
        "source": "  public void testIssue787() {\n\n    CompilerOptions options = createCompilerOptions();\n\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n\n    level.setOptionsForCompilationLevel(options);\n\n    WarningLevel warnings = WarningLevel.DEFAULT;\n\n    warnings.setOptionsForWarningLevel(options);\n\n\n\n    String code = \"\" +\n\n        \"function some_function() {\\n\" +\n\n        \"  var fn1;\\n\" +\n\n        \"  var fn2;\\n\" +\n\n        \"\\n\" +\n\n        \"  if (any_expression) {\\n\" +\n\n        \"    fn2 = external_ref;\\n\" +\n\n        \"    fn1 = function (content) {\\n\" +\n\n        \"      return fn2();\\n\" +\n\n        \"    }\\n\" +\n\n        \"  }\\n\" +\n\n        \"\\n\" +\n\n        \"  return {\\n\" +\n\n        \"    method1: function () {\\n\" +\n\n        \"      if (fn1) fn1();\\n\" +\n\n        \"      return true;\\n\" +\n\n        \"    },\\n\" +\n\n        \"    method2: function () {\\n\" +\n\n        \"      return false;\\n\" +\n\n        \"    }\\n\" +\n\n        \"  }\\n\" +\n\n        \"}\";\n\n\n\n    String result = \"\" +\n\n        \"function some_function() {\\n\" +\n\n        \"  var a, b;\\n\" +\n\n        \"  any_expression && (b = external_ref, a = function(a) {\\n\" +\n\n        \"    return b()\\n\" +\n\n        \"  });\\n\" +\n\n        \"  return{method1:function() {\\n\" +\n\n        \"    a && a();\\n\" +\n\n        \"    return !0\\n\" +\n\n        \"  }, method2:function() {\\n\" +\n\n        \"    return !1\\n\" +\n\n        \"  }}\\n\" +\n\n        \"}\\n\" +\n\n        \"\";\n\n\n\n    test(options, code, result);\n\n  }\n"
      },
      "com.google.javascript.jscomp.RemoveUnusedVarsTest::testRemoveGlobal1": {
        "source": "  public void testRemoveGlobal1() {\n\n    removeGlobal = false;\n\n    testSame(\"var x=1\");\n\n    test(\"var y=function(x){var z;}\", \"var y=function(x){}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.RemoveUnusedVarsTest::testRemoveGlobal2": {
        "source": "  public void testRemoveGlobal2() {\n\n    removeGlobal = false;\n\n    testSame(\"var x=1\");\n\n    test(\"function y(x){var z;}\", \"function y(x){}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.RemoveUnusedVarsTest::testRemoveGlobal3": {
        "source": "  public void testRemoveGlobal3() {\n\n    removeGlobal = false;\n\n    testSame(\"var x=1\");\n\n    test(\"function x(){function y(x){var z;}y()}\",\n\n         \"function x(){function y(x){}y()}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.RemoveUnusedVarsTest::testIssue168b": {
        "source": "  public void testIssue168b() {\n\n    removeGlobal = false;\n\n    test(\"function a(){\" +\n\n         \"  (function(x){ b(); })(1);\" +\n\n         \"}\" +\n\n         \"function b(){\" +\n\n         \"  a();\" +\n\n         \"}\",\n\n         \"function a(){(function(x){b()})(1)}\" +\n\n         \"function b(){a()}\");\n\n  }\n"
      }
    }
  },
  "Closure-10": {
    "id": "Closure-10",
    "project": "Closure",
    "number": "10",
    "buggy_function": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n  } else {\n    return mayBeStringHelper(n);\n  }\n}",
    "fixed_function": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n  } else {\n    return mayBeStringHelper(n);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/NodeUtil.java",
      "first_line": 1415,
      "last_line": 1421
    },
    "javadoc": "/**\n* @returns Whether the results is possibly a string.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testIssue821": {
        "source": "  public void testIssue821() {\n\n    foldSame(\"var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;\");\n\n    foldSame(\"var a = ((Math.random() ? 0 : 1) ||\" +\n\n             \"(Math.random()>0.5? '1' : 2 )) + 3 + 4;\");\n\n  }\n"
      }
    }
  },
  "Closure-101": {
    "id": "Closure-101",
    "project": "Closure",
    "number": "101",
    "buggy_function": "protected CompilerOptions createOptions() {\n  CompilerOptions options = new CompilerOptions();\n  options.setCodingConvention(new ClosureCodingConvention());\n  CompilationLevel level = flags.compilation_level;\n  level.setOptionsForCompilationLevel(options);\n  if (flags.debug) {\n    level.setDebugOptionsForCompilationLevel(options);\n  }\n\n  WarningLevel wLevel = flags.warning_level;\n  wLevel.setOptionsForWarningLevel(options);\n  for (FormattingOption formattingOption : flags.formatting) {\n    formattingOption.applyToOptions(options);\n  }\n  if (flags.process_closure_primitives) {\n    options.closurePass = true;\n  }\n\n  initOptionsFromFlags(options);\n  return options;\n}",
    "fixed_function": "protected CompilerOptions createOptions() {\n  CompilerOptions options = new CompilerOptions();\n  options.setCodingConvention(new ClosureCodingConvention());\n  CompilationLevel level = flags.compilation_level;\n  level.setOptionsForCompilationLevel(options);\n  if (flags.debug) {\n    level.setDebugOptionsForCompilationLevel(options);\n  }\n\n  WarningLevel wLevel = flags.warning_level;\n  wLevel.setOptionsForWarningLevel(options);\n  for (FormattingOption formattingOption : flags.formatting) {\n    formattingOption.applyToOptions(options);\n  }\n\n  options.closurePass = flags.process_closure_primitives;\n  initOptionsFromFlags(options);\n  return options;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CommandLineRunner.java",
      "first_line": 419,
      "last_line": 439
    },
    "javadoc": "// expects.",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives": {
        "source": "  public void testProcessClosurePrimitives() {\n\n    test(\"var goog = {}; goog.provide('goog.dom');\",\n\n         \"var goog = {}; goog.dom = {};\");\n\n    args.add(\"--process_closure_primitives=false\");\n\n    testSame(\"var goog = {}; goog.provide('goog.dom');\");\n\n  }\n"
      }
    }
  },
  "Closure-102": {
    "id": "Closure-102",
    "project": "Closure",
    "number": "102",
    "buggy_function": "public void process(Node externs, Node root) {\n  NodeTraversal.traverse(compiler, root, this);\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n    NodeTraversal t = new NodeTraversal(compiler, renamer);\n    t.traverseRoots(externs, root);\n  }\n  removeDuplicateDeclarations(root);\n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(externs, root);\n}",
    "fixed_function": "public void process(Node externs, Node root) {\n  NodeTraversal.traverse(compiler, root, this);\n  removeDuplicateDeclarations(root);\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n    NodeTraversal t = new NodeTraversal(compiler, renamer);\n    t.traverseRoots(externs, root);\n  }\n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(externs, root);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/Normalize.java",
      "first_line": 87,
      "last_line": 97
    },
    "javadoc": "// public for ReplaceDebugStringsTest",
    "failing_tests": {
      "com.google.javascript.jscomp.CompilerRunnerTest::testIssue115": {
        "source": "  public void testIssue115() {\n\n    CompilerRunner.FLAG_compilation_level.setForTest(\n\n        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n\n    CompilerRunner.FLAG_warning_level.setForTest(\n\n        WarningLevel.VERBOSE);\n\n    test(\"function f() { \" +\n\n         \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n\n         \"  return arguments[0]; \" +\n\n         \"}\",\n\n         \"function f() { \" +\n\n         \"  arguments = Array.prototype.slice.call(arguments, 0);\" +\n\n         \"  return arguments[0]; \" +\n\n         \"}\");\n\n  }\n"
      }
    }
  },
  "Closure-104": {
    "id": "Closure-104",
    "project": "Closure",
    "number": "104",
    "buggy_function": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (result != null) {\n    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}",
    "fixed_function": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (!result.isNoType()) {\n    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/UnionType.java",
      "first_line": 273,
      "last_line": 298
    },
    "javadoc": "/**\n* This predicate determines whether objects of this type can have the\n* {@code null} value, and therefore can appear in contexts where\n* {@code null} is expected.\n*\n* @return {@code true} for everything but {@code Number} and\n*         {@code Boolean} types.\n*/",
    "failing_tests": {
      "com.google.javascript.rhino.jstype.UnionTypeTest::testGreatestSubtypeUnionTypes5": {
        "source": "  public void testGreatestSubtypeUnionTypes5() throws Exception {\n\n    JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n\n    assertEquals(NO_OBJECT_TYPE,\n\n        errUnion.getGreatestSubtype(STRING_OBJECT_TYPE));\n\n  }\n"
      }
    }
  },
  "Closure-105": {
    "id": "Closure-105",
    "project": "Closure",
    "number": "105",
    "buggy_function": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                       Node parent) {\n  if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n    return;\n  }\n\n  Node arrayNode = left.getFirstChild();\n  Node functionName = arrayNode.getNext();\n\n  if ((arrayNode.getType() != Token.ARRAYLIT) ||\n      !functionName.getString().equals(\"join\")) {\n    return;\n  }\n\n  String joinString = NodeUtil.getStringValue(right);\n  List<Node> arrayFoldedChildren = Lists.newLinkedList();\n  StringBuilder sb = new StringBuilder();\n  int foldedSize = 0;\n  Node elem = arrayNode.getFirstChild();\n  // Merges adjacent String nodes.\n  while (elem != null) {\n    if (NodeUtil.isImmutableValue(elem)) {\n      if (sb.length() > 0) {\n        sb.append(joinString);\n      }\n      sb.append(NodeUtil.getStringValue(elem));\n    } else {\n      if (sb.length() > 0) {\n        // + 2 for the quotes.\n        foldedSize += sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()));\n        sb = new StringBuilder();\n      }\n      foldedSize += InlineCostEstimator.getCost(elem);\n      arrayFoldedChildren.add(elem);\n    }\n    elem = elem.getNext();\n  }\n\n  if (sb.length() > 0) {\n    // + 2 for the quotes.\n    foldedSize += sb.length() + 2;\n    arrayFoldedChildren.add(Node.newString(sb.toString()));\n  }\n  // one for each comma.\n  foldedSize += arrayFoldedChildren.size() - 1;\n\n  int originalSize = InlineCostEstimator.getCost(n);\n  switch (arrayFoldedChildren.size()) {\n    case 0:\n      Node emptyStringNode = Node.newString(\"\");\n      parent.replaceChild(n, emptyStringNode);\n      break;\n\n    case 1:\n      Node foldedStringNode = arrayFoldedChildren.remove(0);\n      if (foldedSize > originalSize) {\n        return;\n      }\n      arrayNode.detachChildren();\n      if (foldedStringNode.getType() != Token.STRING) {\n        // If the Node is not a string literal, ensure that\n        // it is coerced to a string.\n        Node replacement = new Node(Token.ADD,\n            Node.newString(\"\"), foldedStringNode);\n        foldedStringNode = replacement;\n      }\n      parent.replaceChild(n, foldedStringNode);\n      break;\n\n    default:\n      // No folding could actually be performed.\n      if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n        return;\n      }\n      int kJoinOverhead = \"[].join()\".length();\n      foldedSize += kJoinOverhead;\n      foldedSize += InlineCostEstimator.getCost(right);\n      if (foldedSize > originalSize) {\n        return;\n      }\n      arrayNode.detachChildren();\n      for (Node node : arrayFoldedChildren) {\n        arrayNode.addChildToBack(node);\n      }\n      break;\n  }\n  t.getCompiler().reportCodeChange();\n}",
    "fixed_function": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                       Node parent) {\n  if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n    return;\n  }\n\n  Node arrayNode = left.getFirstChild();\n  Node functionName = arrayNode.getNext();\n\n  if ((arrayNode.getType() != Token.ARRAYLIT) ||\n      !functionName.getString().equals(\"join\")) {\n    return;\n  }\n\n  String joinString = NodeUtil.getStringValue(right);\n  List<Node> arrayFoldedChildren = Lists.newLinkedList();\n  StringBuilder sb = null;\n  int foldedSize = 0;\n  Node elem = arrayNode.getFirstChild();\n  // Merges adjacent String nodes.\n  while (elem != null) {\n    if (NodeUtil.isImmutableValue(elem)) {\n      if (sb == null) {\n        sb = new StringBuilder();\n      } else {\n        sb.append(joinString);\n      }\n      sb.append(NodeUtil.getStringValue(elem));\n    } else {\n      if (sb != null) {\n        // + 2 for the quotes.\n        foldedSize += sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()));\n        sb = null;\n      }\n      foldedSize += InlineCostEstimator.getCost(elem);\n      arrayFoldedChildren.add(elem);\n    }\n    elem = elem.getNext();\n  }\n\n  if (sb != null) {\n    // + 2 for the quotes.\n    foldedSize += sb.length() + 2;\n    arrayFoldedChildren.add(Node.newString(sb.toString()));\n  }\n  // one for each comma.\n  foldedSize += arrayFoldedChildren.size() - 1;\n\n  int originalSize = InlineCostEstimator.getCost(n);\n  switch (arrayFoldedChildren.size()) {\n    case 0:\n      Node emptyStringNode = Node.newString(\"\");\n      parent.replaceChild(n, emptyStringNode);\n      break;\n\n    case 1:\n      Node foldedStringNode = arrayFoldedChildren.remove(0);\n      if (foldedSize > originalSize) {\n        return;\n      }\n      arrayNode.detachChildren();\n      if (foldedStringNode.getType() != Token.STRING) {\n        // If the Node is not a string literal, ensure that\n        // it is coerced to a string.\n        Node replacement = new Node(Token.ADD,\n            Node.newString(\"\"), foldedStringNode);\n        foldedStringNode = replacement;\n      }\n      parent.replaceChild(n, foldedStringNode);\n      break;\n\n    default:\n      // No folding could actually be performed.\n      if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n        return;\n      }\n      int kJoinOverhead = \"[].join()\".length();\n      foldedSize += kJoinOverhead;\n      foldedSize += InlineCostEstimator.getCost(right);\n      if (foldedSize > originalSize) {\n        return;\n      }\n      arrayNode.detachChildren();\n      for (Node node : arrayFoldedChildren) {\n        arrayNode.addChildToBack(node);\n      }\n      break;\n  }\n  t.getCompiler().reportCodeChange();\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/FoldConstants.java",
      "first_line": 1461,
      "last_line": 1549
    },
    "javadoc": "/**\n* Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.FoldConstantsTest::testStringJoinAdd": {
        "source": "  public void testStringJoinAdd() {\n\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\", \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\", \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\", \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n\n\n\n    // Works with numbers\n\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n\n\n    // Works on boolean\n\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n\n\n    // Only optimize if it's a size win.\n\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n\n    \n\n    // TODO(user): Its possible to fold this better.\n\n    foldSame(\"x = ['', foo].join(',')\");\n\n    foldSame(\"x = ['', foo, ''].join(',')\");\n\n    \n\n    fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n\n    fold(\"x = ['', '', foo, '', ''].join(',')\",\n\n         \"x = [',', foo, ','].join(',')\");\n\n    \n\n    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n\n         \"x = [',', foo, ',', bar].join(',')\");\n\n    \n\n    fold(\"x = [1,2,3].join('abcdef')\",\n\n         \"x = '1abcdef2abcdef3'\");\n\n  }\n"
      }
    }
  },
  "Closure-107": {
    "id": "Closure-107",
    "project": "Closure",
    "number": "107",
    "buggy_function": "protected CompilerOptions createOptions() {\n  CompilerOptions options = new CompilerOptions();\n  if (flags.processJqueryPrimitives) {\n    options.setCodingConvention(new JqueryCodingConvention());\n  } else {\n    options.setCodingConvention(new ClosureCodingConvention());\n  }\n\n  options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n  CompilationLevel level = flags.compilationLevel;\n  level.setOptionsForCompilationLevel(options);\n\n  if (flags.debug) {\n    level.setDebugOptionsForCompilationLevel(options);\n  }\n\n  if (flags.useTypesForOptimization) {\n    level.setTypeBasedOptimizationOptions(options);\n  }\n\n  if (flags.generateExports) {\n    options.setGenerateExports(flags.generateExports);\n  }\n\n  WarningLevel wLevel = flags.warningLevel;\n  wLevel.setOptionsForWarningLevel(options);\n  for (FormattingOption formattingOption : flags.formatting) {\n    formattingOption.applyToOptions(options);\n  }\n\n  options.closurePass = flags.processClosurePrimitives;\n\n  options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n      flags.processJqueryPrimitives;\n\n  options.angularPass = flags.angularPass;\n\n  if (!flags.translationsFile.isEmpty()) {\n    try {\n      options.messageBundle = new XtbMessageBundle(\n          new FileInputStream(flags.translationsFile),\n          flags.translationsProject);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Reading XTB file\", e);\n    }\n  } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n    // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n    // translations file, they might reasonably try to write their own\n    // implementation of goog.getMsg that makes the substitution at\n    // run-time.\n    //\n    // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n    // so we might as well inline it. But shut off the i18n warnings,\n    // because the user didn't really ask for i18n.\n    options.messageBundle = new EmptyMessageBundle();\n  }\n\n  return options;\n}",
    "fixed_function": "protected CompilerOptions createOptions() {\n  CompilerOptions options = new CompilerOptions();\n  if (flags.processJqueryPrimitives) {\n    options.setCodingConvention(new JqueryCodingConvention());\n  } else {\n    options.setCodingConvention(new ClosureCodingConvention());\n  }\n\n  options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n  CompilationLevel level = flags.compilationLevel;\n  level.setOptionsForCompilationLevel(options);\n\n  if (flags.debug) {\n    level.setDebugOptionsForCompilationLevel(options);\n  }\n\n  if (flags.useTypesForOptimization) {\n    level.setTypeBasedOptimizationOptions(options);\n  }\n\n  if (flags.generateExports) {\n    options.setGenerateExports(flags.generateExports);\n  }\n\n  WarningLevel wLevel = flags.warningLevel;\n  wLevel.setOptionsForWarningLevel(options);\n  for (FormattingOption formattingOption : flags.formatting) {\n    formattingOption.applyToOptions(options);\n  }\n\n  options.closurePass = flags.processClosurePrimitives;\n\n  options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n      flags.processJqueryPrimitives;\n\n  options.angularPass = flags.angularPass;\n\n  if (!flags.translationsFile.isEmpty()) {\n    try {\n      options.messageBundle = new XtbMessageBundle(\n          new FileInputStream(flags.translationsFile),\n          flags.translationsProject);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Reading XTB file\", e);\n    }\n  } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n    // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n    // translations file, they might reasonably try to write their own\n    // implementation of goog.getMsg that makes the substitution at\n    // run-time.\n    //\n    // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n    // so we might as well inline it. But shut off the i18n warnings,\n    // because the user didn't really ask for i18n.\n    options.messageBundle = new EmptyMessageBundle();\n    options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n  }\n\n  return options;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CommandLineRunner.java",
      "first_line": 806,
      "last_line": 865
    },
    "javadoc": "// For contains --flagfile flag",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings": {
        "source": "  public void testGetMsgWiringNoWarnings() throws Exception {\n\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n\n    test(\"/** @desc A bad foo. */ var MSG_FOO = 1;\", \"\");\n\n  }\n"
      }
    }
  },
  "Closure-109": {
    "id": "Closure-109",
    "project": "Closure",
    "number": "109",
    "buggy_function": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n}",
    "fixed_function": "private Node parseContextTypeExpression(JsDocToken token) {\n  if (token == JsDocToken.QMARK) {\n    return newNode(Token.QMARK);\n  } else {\n    return parseBasicTypeExpression(token);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "first_line": 1907,
      "last_line": 1909
    },
    "javadoc": "/**\n* ContextTypeExpression := BasicTypeExpression | '?'\n* For expressions on the right hand side of a this: or new:\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testStructuralConstructor2": {
        "source": "  public void testStructuralConstructor2() throws Exception {\n\n    JSType type = testParseType(\n\n        \"function (new:?)\",\n\n        // toString skips unknowns, but isConstructor reveals the truth.\n\n        \"function (): ?\");\n\n    assertTrue(type.isConstructor());\n\n    assertFalse(type.isNominalConstructor());\n\n  }\n"
      },
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testStructuralConstructor3": {
        "source": "  public void testStructuralConstructor3() throws Exception {\n\n    resolve(parse(\"@type {function (new:*)} */\").getType(),\n\n        \"constructed type must be an object type\");\n\n  }\n"
      }
    }
  },
  "Closure-11": {
    "id": "Closure-11",
    "project": "Closure",
    "number": "11",
    "buggy_function": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  // obj.prop or obj.method()\n  // Lots of types can appear on the left, a call to a void function can\n  // never be on the left. getPropertyType will decide what is acceptable\n  // and what isn't.\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (n.getJSType() != null && parent.isAssign()) {\n    return;\n  } else if (validator.expectNotNullOrUndefined(t, n, childType,\n      \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n    checkPropertyAccess(childType, property.getString(), t, n);\n  }\n  ensureTyped(t, n);\n}",
    "fixed_function": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  // obj.prop or obj.method()\n  // Lots of types can appear on the left, a call to a void function can\n  // never be on the left. getPropertyType will decide what is acceptable\n  // and what isn't.\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (validator.expectNotNullOrUndefined(t, n, childType,\n      \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n    checkPropertyAccess(childType, property.getString(), t, n);\n  }\n  ensureTyped(t, n);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeCheck.java",
      "first_line": 1303,
      "last_line": 1321
    },
    "javadoc": "/**\n* Visits a GETPROP node.\n*\n* @param t The node traversal object that supplies context, such as the\n* scope chain to use in name lookups as well as error reporting.\n* @param n The node being visited.\n* @param parent The parent of <code>n</code>\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testGetprop4": {
        "source": "  public void testGetprop4() throws Exception {\n\n    testTypes(\"var x = null; x.prop = 3;\",\n\n        \"No properties on this expression\\n\" +\n\n        \"found   : null\\n\" +\n\n        \"required: Object\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testIssue810": {
        "source": "  public void testIssue810() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */\" +\n\n        \"var Type = function () {\" +\n\n        \"};\" +\n\n        \"Type.prototype.doIt = function(obj) {\" +\n\n        \"  this.prop = obj.unknownProp;\" +\n\n        \"};\",\n\n        \"Property unknownProp never defined on obj\");\n\n  }\n"
      }
    }
  },
  "Closure-111": {
    "id": "Closure-111",
    "project": "Closure",
    "number": "111",
    "buggy_function": "protected JSType caseTopType(JSType topType) {\n  return topType;\n}",
    "fixed_function": "protected JSType caseTopType(JSType topType) {\n  return topType.isAllType() ?\n      getNativeType(ARRAY_TYPE) : topType;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java",
      "first_line": 53,
      "last_line": 55
    },
    "javadoc": "/**\n* For when {@code goog.isArray} returns true.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsArray2": {
        "source": "  public void testGoogIsArray2() throws Exception {\n\n    testClosureFunction(\"goog.isArray\",\n\n        ALL_TYPE,\n\n        ARRAY_TYPE,\n\n        ALL_TYPE);\n\n  }\n"
      }
    }
  },
  "Closure-112": {
    "id": "Closure-112",
    "project": "Closure",
    "number": "112",
    "buggy_function": "private boolean inferTemplatedTypesForCall(\n    Node n, FunctionType fnType) {\n  final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n      .getTemplateKeys();\n  if (keys.isEmpty()) {\n    return false;\n  }\n\n  // Try to infer the template types\n  Map<TemplateType, JSType> inferred = \n      inferTemplateTypesFromParameters(fnType, n);\n\n\n  // Replace all template types. If we couldn't find a replacement, we\n  // replace it with UNKNOWN.\n  TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n      registry, inferred);\n  Node callTarget = n.getFirstChild();\n\n  FunctionType replacementFnType = fnType.visit(replacer)\n      .toMaybeFunctionType();\n  Preconditions.checkNotNull(replacementFnType);\n\n  callTarget.setJSType(replacementFnType);\n  n.setJSType(replacementFnType.getReturnType());\n\n  return replacer.madeChanges;\n}",
    "fixed_function": "private boolean inferTemplatedTypesForCall(\n    Node n, FunctionType fnType) {\n  final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n      .getTemplateKeys();\n  if (keys.isEmpty()) {\n    return false;\n  }\n\n  // Try to infer the template types\n  Map<TemplateType, JSType> inferred = Maps.filterKeys(\n      inferTemplateTypesFromParameters(fnType, n),\n      new Predicate<TemplateType>() {\n\n        @Override\n        public boolean apply(TemplateType key) {\n          return keys.contains(key);\n        }}\n      );\n\n  // Replace all template types. If we couldn't find a replacement, we\n  // replace it with UNKNOWN.\n  TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n      registry, inferred);\n  Node callTarget = n.getFirstChild();\n\n  FunctionType replacementFnType = fnType.visit(replacer)\n      .toMaybeFunctionType();\n  Preconditions.checkNotNull(replacementFnType);\n\n  callTarget.setJSType(replacementFnType);\n  n.setJSType(replacementFnType.getReturnType());\n\n  return replacer.madeChanges;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeInference.java",
      "first_line": 1183,
      "last_line": 1210
    },
    "javadoc": "/**\n* For functions with function(this: T, ...) and T as parameters, type\n* inference will set the type of this on a function literal argument to the\n* the actual type of T.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue1058": {
        "source": "  public void testIssue1058() throws Exception {\n\n    testTypes(\n\n        \"/**\\n\" +\n\n        \"  * @constructor\\n\" +\n\n        \"  * @template CLASS\\n\" +\n\n        \"  */\\n\" +\n\n        \"var Class = function() {};\\n\" +\n\n        \"\\n\" +\n\n        \"/**\\n\" +\n\n        \"  * @param {function(CLASS):CLASS} a\\n\" +\n\n        \"  * @template T\\n\" +\n\n        \"  */\\n\" +\n\n        \"Class.prototype.foo = function(a) {\\n\" +\n\n        \"  return 'string';\\n\" +\n\n        \"};\\n\" +\n\n        \"\\n\" +\n\n        \"/** @param {number} a\\n\" +\n\n        \"  * @return {string} */\\n\" +\n\n        \"var a = function(a) { return '' };\\n\" +\n\n        \"\\n\" +\n\n        \"new Class().foo(a);\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testTemplatized11": {
        "source": "  public void testTemplatized11() throws Exception {\n\n    testTypes(\n\n        \"/** \\n\" +\n\n        \" * @template T\\n\" +\n\n        \" * @constructor\\n\" +\n\n        \" */\\n\" +\n\n        \"function C() {}\\n\" +\n\n        \"\\n\" +\n\n        \"/**\\n\" +\n\n        \" * @param {T|K} a\\n\" +\n\n        \" * @return {T}\\n\" +\n\n        \" * @template K\\n\" +\n\n        \" */\\n\" +\n\n        \"C.prototype.method = function (a) {};\\n\" +\n\n        \"\\n\" +\n\n        // method returns \"?\"\n\n        \"/** @type {void} */ var x = new C().method(1);\");\n\n  }\n"
      }
    }
  },
  "Closure-113": {
    "id": "Closure-113",
    "project": "Closure",
    "number": "113",
    "buggy_function": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n\n      // This must be non-null, because there was an explicit provide.\n      Preconditions.checkNotNull(providedModule);\n\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n\n    // Requires should be removed before further processing.\n    // Some clients run closure pass multiple times, first with\n    // the checks for broken requires turned off. In these cases, we\n    // allow broken requires to be preserved by the first run to\n    // let them be caught in the subsequent run.\n    if (provided != null) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}",
    "fixed_function": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n\n      // This must be non-null, because there was an explicit provide.\n      Preconditions.checkNotNull(providedModule);\n\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n\n    // Requires should be removed before further processing.\n    // Some clients run closure pass multiple times, first with\n    // the checks for broken requires turned off. In these cases, we\n    // allow broken requires to be preserved by the first run to\n    // let them be caught in the subsequent run.\n    if (provided != null || requiresLevel.isOn()) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "first_line": 295,
      "last_line": 334
    },
    "javadoc": "/**\n* Handles a goog.require call.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.VarCheckTest::testNoUndeclaredVarWhenUsingClosurePass": {
        "source": "  public void testNoUndeclaredVarWhenUsingClosurePass() {\n\n    enableClosurePass();\n\n    // We don't want to get goog as an undeclared var here.\n\n    test(\"goog.require('namespace.Class1');\\n\", null,\n\n        ProcessClosurePrimitives.MISSING_PROVIDE_ERROR);\n\n  }\n"
      }
    }
  },
  "Closure-114": {
    "id": "Closure-114",
    "project": "Closure",
    "number": "114",
    "buggy_function": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation\n      // logic.\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      // The rhs of the assignment is the caller, so it's used by the\n      // context. Don't associate it w/ the lhs.\n      // FYI: this fixes only the specific case where the assignment is the\n      // caller expression, but it could be nested deeper in the caller and\n      // we would still get a bug.\n      // See testAssignWithCall2 for an example of this.\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
    "fixed_function": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation\n      // logic.\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n      // The rhs of the assignment is the caller, so it's used by the\n      // context. Don't associate it w/ the lhs.\n      // FYI: this fixes only the specific case where the assignment is the\n      // caller expression, but it could be nested deeper in the caller and\n      // we would still get a bug.\n      // See testAssignWithCall2 for an example of this.\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "first_line": 558,
      "last_line": 588
    },
    "javadoc": "// \"a\" must be falsy, which it must be an immutable, non-Object",
    "failing_tests": {
      "com.google.javascript.jscomp.NameAnalyzerTest::testAssignWithCall": {
        "source": "  public void testAssignWithCall() {\n\n    test(\"var fun, x; (fun = function(){ x; })();\",\n\n        \"var x; (function(){ x; })();\");\n\n  }\n"
      }
    }
  },
  "Closure-115": {
    "id": "Closure-115",
    "project": "Closure",
    "number": "115",
    "buggy_function": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  boolean hasSideEffects = false;\n  if (block.hasChildren()) {\n    Preconditions.checkState(block.hasOneChild());\n    Node stmt = block.getFirstChild();\n    if (stmt.isReturn()) {\n      hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n    }\n  }\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    // For each named parameter check if a mutable argument use more than one.\n    if (fnParam != null) {\n      if (cArg != null) {\n        if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n          return CanInlineResult.NO;\n        }\n        // Check for arguments that are evaluated more than once.\n        // Note: Unlike block inlining, there it is not possible that a\n        // parameter reference will be in a loop.\n        if (NodeUtil.mayEffectMutableState(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      // Move to the next name.\n      fnParam = fnParam.getNext();\n    }\n\n    // For every call argument check for side-effects, even if there\n    // isn't a named parameter to match.\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "fixed_function": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    // For each named parameter check if a mutable argument use more than one.\n    if (fnParam != null) {\n      if (cArg != null) {\n        // Check for arguments that are evaluated more than once.\n        // Note: Unlike block inlining, there it is not possible that a\n        // parameter reference will be in a loop.\n        if (NodeUtil.mayEffectMutableState(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      // Move to the next name.\n      fnParam = fnParam.getNext();\n    }\n\n    // For every call argument check for side-effects, even if there\n    // isn't a named parameter to match.\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "first_line": 689,
      "last_line": 758
    },
    "javadoc": "/**\n* Determines whether a function can be inlined at a particular call site.\n* There are several criteria that the function and reference must hold in\n* order for the functions to be inlined:\n* 1) If a call's arguments have side effects,\n* the corresponding argument in the function must only be referenced once.\n* For instance, this will not be inlined:\n* <pre>\n*     function foo(a) { return a + a }\n*     x = foo(i++);\n* </pre>\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineFunctionsTest::testBug4944818": {
        "source": "  public void testBug4944818() {\n\n    test(\n\n        \"var getDomServices_ = function(self) {\\n\" +\n\n        \"  if (!self.domServices_) {\\n\" +\n\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n\n        \"        self.appContext_);\\n\" +\n\n        \"  }\\n\" +\n\n        \"\\n\" +\n\n        \"  return self.domServices_;\\n\" +\n\n        \"};\\n\" +\n\n        \"\\n\" +\n\n        \"var getOwnerWin_ = function(self) {\\n\" +\n\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n\n        \"};\\n\" +\n\n        \"\\n\" +\n\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n\n        \"  var self = a.b;\\n\" +\n\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n\n        \"};\",\n\n        \"HangoutStarter.prototype.launchHangout = function() { \" +\n\n        \"  var self$$2 = a.b;\" +\n\n        \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n\n        \"  var JSCompiler_inline_result$$1;\" +\n\n        \"  {\" +\n\n        \"  var self$$inline_2 = self$$2;\" +\n\n        \"  if (!self$$inline_2.domServices_) {\" +\n\n        \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n\n        \"        self$$inline_2.appContext_);\" +\n\n        \"  }\" +\n\n        \"  JSCompiler_inline_result$$1=self$$inline_2.domServices_;\" +\n\n        \"  }\" +\n\n        \"  var myUrl = new JSCompiler_temp_const$$0(\" +\n\n        \"      JSCompiler_inline_result$$1.getDomHelper().\" +\n\n        \"          getWindow().location.href)\" +\n\n        \"}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testDoubleInlining1": {
        "source": "  public void testDoubleInlining1() {\n\n    allowBlockInlining = false;\n\n    test(\"var foo = function(a) { return getWindow(a); };\" +\n\n         \"var bar = function(b) { return b; };\" +\n\n         \"foo(bar(x));\",\n\n         \"getWindow(x)\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testNoInlineIfParametersModified8": {
        "source": "  public void testNoInlineIfParametersModified8() {\n\n    // OK, object parameter modified.\n\n    test(\"function f(a){return a.x=2}f(o)\", \"o.x=2\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testNoInlineIfParametersModified9": {
        "source": "  public void testNoInlineIfParametersModified9() {\n\n    // OK, array parameter modified.\n\n    test(\"function f(a){return a[2]=2}f(o)\", \"o[2]=2\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testInlineFunctions6": {
        "source": "  public void testInlineFunctions6() {\n\n    // more complex inlines\n\n    test(\"function BAR_FN(x, y, z) { return z(foo(x + y)) }\" +\n\n         \"alert(BAR_FN(1, 2, baz))\",\n\n\n\n         \"alert(baz(foo(1+2)))\");\n\n  }\n"
      }
    }
  },
  "Closure-116": {
    "id": "Closure-116",
    "project": "Closure",
    "number": "116",
    "buggy_function": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    // For each named parameter check if a mutable argument use more than one.\n    if (fnParam != null) {\n      if (cArg != null) {\n\n        // Check for arguments that are evaluated more than once.\n        // Note: Unlike block inlining, there it is not possible that a\n        // parameter reference will be in a loop.\n        if (NodeUtil.mayEffectMutableState(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      // Move to the next name.\n      fnParam = fnParam.getNext();\n    }\n\n    // For every call argument check for side-effects, even if there\n    // isn't a named parameter to match.\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "fixed_function": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  boolean hasSideEffects = false;  // empty function case\n  if (block.hasChildren()) {\n    Preconditions.checkState(block.hasOneChild());\n    Node stmt = block.getFirstChild();\n    if (stmt.isReturn()) {\n      hasSideEffects = NodeUtil.mayHaveSideEffects(\n          stmt.getFirstChild(), compiler);\n    }\n  }\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    // For each named parameter check if a mutable argument use more than one.\n    if (fnParam != null) {\n      if (cArg != null) {\n        if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n          return CanInlineResult.NO;\n        }\n\n        // Check for arguments that are evaluated more than once.\n        // Note: Unlike block inlining, there it is not possible that a\n        // parameter reference will be in a loop.\n        if (NodeUtil.mayEffectMutableState(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      // Move to the next name.\n      fnParam = fnParam.getNext();\n    }\n\n    // For every call argument check for side-effects, even if there\n    // isn't a named parameter to match.\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "first_line": 689,
      "last_line": 749
    },
    "javadoc": "/**\n* Determines whether a function can be inlined at a particular call site.\n* There are several criteria that the function and reference must hold in\n* order for the functions to be inlined:\n* 1) If a call's arguments have side effects,\n* the corresponding argument in the function must only be referenced once.\n* For instance, this will not be inlined:\n* <pre>\n*     function foo(a) { return a + a }\n*     x = foo(i++);\n* </pre>\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.FunctionInjectorTest::testIssue1101a": {
        "source": "  public void testIssue1101a() {\n\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n\n        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n\n        INLINE_DIRECT);\n\n  }\n"
      },
      "com.google.javascript.jscomp.FunctionInjectorTest::testIssue1101b": {
        "source": "  public void testIssue1101b() {\n\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n\n        \"function foo(a){return (x.prop = 2),a;} foo(x.prop);\", \"foo\",\n\n        INLINE_DIRECT);\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testBug4944818": {
        "source": "  public void testBug4944818() {\n\n    test(\n\n        \"var getDomServices_ = function(self) {\\n\" +\n\n        \"  if (!self.domServices_) {\\n\" +\n\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n\n        \"        self.appContext_);\\n\" +\n\n        \"  }\\n\" +\n\n        \"\\n\" +\n\n        \"  return self.domServices_;\\n\" +\n\n        \"};\\n\" +\n\n        \"\\n\" +\n\n        \"var getOwnerWin_ = function(self) {\\n\" +\n\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n\n        \"};\\n\" +\n\n        \"\\n\" +\n\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n\n        \"  var self = a.b;\\n\" +\n\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n\n        \"};\",\n\n        \"HangoutStarter.prototype.launchHangout=function(){\" +\n\n        \"  var self$$2=a.b;\" +\n\n        \"  var JSCompiler_temp_const$$0=goog.Uri;\" +\n\n        \"  var JSCompiler_inline_result$$1;\" +\n\n        \"  {\" +\n\n        \"    var JSCompiler_inline_result$$0;\" +\n\n        \"    {\" +\n\n        \"      var self$$inline_1=self$$2;\" +\n\n        \"      if(!self$$inline_1.domServices_) {\" +\n\n        \"        self$$inline_1.domServices_=goog$component$DomServices.get(self$$inline_1.appContext_);\" +\n\n        \"      }\" +\n\n        \"      JSCompiler_inline_result$$0=self$$inline_1.domServices_;\" +\n\n        \"    }\" +\n\n        \"    JSCompiler_inline_result$$1=JSCompiler_inline_result$$0.getDomHelper().getWindow();\" +\n\n        \"  }\" +\n\n        \"  var myUrl=new JSCompiler_temp_const$$0(JSCompiler_inline_result$$1.location.href)\" +\n\n        \"}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testDoubleInlining2": {
        "source": "  public void testDoubleInlining2() {\n\n    test(\"var foo = function(a) { return getWindow(a); };\" +\n\n         \"var bar = function(b) { return b; };\" +\n\n         \"foo(bar(x));\",\n\n         \"{getWindow(x)}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testIssue1101": {
        "source": "  public void testIssue1101() {\n\n    test(\n\n        \"var x = (function (saved) {\" +\n\n        \"    return foo(obj) + saved;\" +\n\n        \"  })(obj[\\\"prop\\\"]);\",\n\n        \"var x;\" +\n\n        \"{\" +\n\n        \"  var saved$$inline_0=obj[\\\"prop\\\"];x=foo(obj)+saved$$inline_0\" +\n\n        \"}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testInlineIfParametersModified8": {
        "source": "  public void testInlineIfParametersModified8() {\n\n    // OK, object parameter modified.\n\n    test(\"function f(a){return a.x=2}f(o)\", \"{o.x=2}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testInlineIfParametersModified9": {
        "source": "  public void testInlineIfParametersModified9() {\n\n    // OK, array parameter modified.\n\n    test(\"function f(a){return a[2]=2}f(o)\", \"{o[2]=2}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testInlineFunctions6": {
        "source": "  public void testInlineFunctions6() {\n\n    // more complex inlines\n\n    test(\"function BAR_FN(x, y, z) { return z(nochg(x + y)) }\" +\n\n         \"alert(BAR_FN(1, 2, baz))\",\n\n\n\n         \"var JSCompiler_temp_const$$0=alert;\" +\n\n         \"var JSCompiler_inline_result$$1;\" +\n\n         \"{JSCompiler_inline_result$$1=baz(nochg(1+2));}\" +\n\n         \"JSCompiler_temp_const$$0(JSCompiler_inline_result$$1)\");\n\n  }\n"
      }
    }
  },
  "Closure-117": {
    "id": "Closure-117",
    "project": "Closure",
    "number": "117",
    "buggy_function": "String getReadableJSTypeName(Node n, boolean dereference) {\n\n  // The best type name is the actual type name.\n\n  // If we're analyzing a GETPROP, the property may be inherited by the\n  // prototype chain. So climb the prototype chain and find out where\n  // the property was originally defined.\n  if (n.isGetProp()) {\n    ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n    if (objectType != null) {\n      String propName = n.getLastChild().getString();\n      if (objectType.getConstructor() != null &&\n          objectType.getConstructor().isInterface()) {\n        objectType = FunctionType.getTopDefiningInterface(\n            objectType, propName);\n      } else {\n        // classes\n        while (objectType != null && !objectType.hasOwnProperty(propName)) {\n          objectType = objectType.getImplicitPrototype();\n        }\n      }\n\n      // Don't show complex function names or anonymous types.\n      // Instead, try to get a human-readable type name.\n      if (objectType != null &&\n          (objectType.getConstructor() != null ||\n           objectType.isFunctionPrototypeType())) {\n        return objectType.toString() + \".\" + propName;\n      }\n    }\n  }\n\n  JSType type = getJSType(n);\n  if (dereference) {\n    ObjectType dereferenced = type.dereference();\n    if (dereferenced != null) {\n      type = dereferenced;\n    }\n  }\n  if (type.isFunctionPrototypeType() ||\n      (type.toObjectType() != null &&\n       type.toObjectType().getConstructor() != null)) {\n    return type.toString();\n  }\n  String qualifiedName = n.getQualifiedName();\n  if (qualifiedName != null) {\n    return qualifiedName;\n  } else if (type.isFunctionType()) {\n    // Don't show complex function names.\n    return \"function\";\n  } else {\n    return type.toString();\n  }\n}",
    "fixed_function": "String getReadableJSTypeName(Node n, boolean dereference) {\n  JSType type = getJSType(n);\n  if (dereference) {\n    ObjectType dereferenced = type.dereference();\n    if (dereferenced != null) {\n      type = dereferenced;\n    }\n  }\n\n  // The best type name is the actual type name.\n  if (type.isFunctionPrototypeType() ||\n      (type.toObjectType() != null &&\n       type.toObjectType().getConstructor() != null)) {\n    return type.toString();\n  }\n\n  // If we're analyzing a GETPROP, the property may be inherited by the\n  // prototype chain. So climb the prototype chain and find out where\n  // the property was originally defined.\n  if (n.isGetProp()) {\n    ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n    if (objectType != null) {\n      String propName = n.getLastChild().getString();\n      if (objectType.getConstructor() != null &&\n          objectType.getConstructor().isInterface()) {\n        objectType = FunctionType.getTopDefiningInterface(\n            objectType, propName);\n      } else {\n        // classes\n        while (objectType != null && !objectType.hasOwnProperty(propName)) {\n          objectType = objectType.getImplicitPrototype();\n        }\n      }\n\n      // Don't show complex function names or anonymous types.\n      // Instead, try to get a human-readable type name.\n      if (objectType != null &&\n          (objectType.getConstructor() != null ||\n           objectType.isFunctionPrototypeType())) {\n        return objectType.toString() + \".\" + propName;\n      }\n    }\n  }\n\n  String qualifiedName = n.getQualifiedName();\n  if (qualifiedName != null) {\n    return qualifiedName;\n  } else if (type.isFunctionType()) {\n    // Don't show complex function names.\n    return \"function\";\n  } else {\n    return type.toString();\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeValidator.java",
      "first_line": 724,
      "last_line": 777
    },
    "javadoc": "/**\n* Given a node, get a human-readable name for the type of that node so\n* that will be easy for the programmer to find the original declaration.\n*\n* For example, if SubFoo's property \"bar\" might have the human-readable\n* name \"Foo.prototype.bar\".\n*\n* @param n The node.\n* @param dereference If true, the type of the node will be dereferenced\n*     to an Object type, if possible.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue1047": {
        "source": "  public void testIssue1047() throws Exception {\n\n    testTypes(\n\n        \"/**\\n\" +\n\n        \" * @constructor\\n\" +\n\n        \" */\\n\" +\n\n        \"function C2() {}\\n\" +\n\n        \"\\n\" +\n\n        \"/**\\n\" +\n\n        \" * @constructor\\n\" +\n\n        \" */\\n\" +\n\n        \"function C3(c2) {\\n\" +\n\n        \"  /**\\n\" +\n\n        \"   * @type {C2} \\n\" +\n\n        \"   * @private\\n\" +\n\n        \"   */\\n\" +\n\n        \"  this.c2_;\\n\" +\n\n        \"\\n\" +\n\n        \"  var x = this.c2_.prop;\\n\" +\n\n        \"}\",\n\n        \"Property prop never defined on C2\");\n\n  }\n"
      }
    }
  },
  "Closure-118": {
    "id": "Closure-118",
    "project": "Closure",
    "number": "118",
    "buggy_function": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n\n    // We should never see a mix of numbers and strings.\n    String name = child.getString();\n    T type = typeSystem.getType(getScope(), n, name);\n\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(child,\n                               processProperty(t, prop, type, null))) {\n      // TODO(user): It doesn't look like the user can do much in this\n      // case right now.\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(JSError.make(\n            t.getSourceName(), child, propertiesToErrorFor.get(name),\n            Warnings.INVALIDATION, name,\n            (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n      }\n    }\n  }\n}",
    "fixed_function": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isQuotedString()) {\n      continue;\n    }\n\n    // We should never see a mix of numbers and strings.\n    String name = child.getString();\n    T type = typeSystem.getType(getScope(), n, name);\n\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(child,\n                               processProperty(t, prop, type, null))) {\n      // TODO(user): It doesn't look like the user can do much in this\n      // case right now.\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(JSError.make(\n            t.getSourceName(), child, propertiesToErrorFor.get(name),\n            Warnings.INVALIDATION, name,\n            (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
      "first_line": 490,
      "last_line": 513
    },
    "javadoc": "/**\n* Processes a OBJECTLIT node.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.DisambiguatePropertiesTest::testOneType4": {
        "source": "  public void testOneType4() {\n\n    String js = \"\"\n\n        + \"/** @constructor */ function Foo() {}\\n\"\n\n        + \"Foo.prototype = {'a': 0};\\n\"\n\n        + \"/** @type Foo */\\n\"\n\n        + \"var F = new Foo;\\n\"\n\n        + \"F['a'] = 0;\";\n\n    String expected = \"{}\";\n\n    testSets(false, js, js, expected);\n\n    testSets(true, js, js, expected);\n\n  }\n"
      },
      "com.google.javascript.jscomp.DisambiguatePropertiesTest::testTwoTypes4": {
        "source": "  public void testTwoTypes4() {\n\n    String js = \"\"\n\n        + \"/** @constructor */ function Foo() {}\\n\"\n\n        + \"Foo.prototype = {a: 0};\"\n\n        + \"/** @type Foo */\\n\"\n\n        + \"var F = new Foo;\\n\"\n\n        + \"F.a = 0;\"\n\n        + \"/** @constructor */ function Bar() {}\\n\"\n\n        + \"Bar.prototype = {'a': 0};\"\n\n        + \"/** @type Bar */\\n\"\n\n        + \"var B = new Bar;\\n\"\n\n        + \"B['a'] = 0;\";\n\n\n\n    String output = \"\"\n\n        + \"function Foo(){}\"\n\n        + \"Foo.prototype = {a: 0};\"\n\n        + \"var F=new Foo;\"\n\n        + \"F.a=0;\"\n\n        + \"function Bar(){}\"\n\n        + \"Bar.prototype = {'a': 0};\"\n\n        + \"var B=new Bar;\"\n\n        + \"B['a']=0\";\n\n\n\n    testSets(false, js, output, \"{a=[[Foo.prototype]]}\");\n\n    testSets(true, js, output, \"{a=[[Foo.prototype]]}\");\n\n  }\n"
      }
    }
  },
  "Closure-119": {
    "id": "Closure-119",
    "project": "Closure",
    "number": "119",
    "buggy_function": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      // This may be a key in an object literal declaration.\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      // This may be a variable get or set.\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getString();\n      break;\n    case Token.GETPROP:\n      // This may be a namespaced name get or set.\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n              isPropAssign = true;\n            }\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          case Token.GETPROP:\n            return;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getQualifiedName();\n      if (name == null) {\n        return;\n      }\n      break;\n    default:\n      return;\n  }\n\n  // We are only interested in global names.\n  if (!isGlobalNameReference(name, scope)) {\n    return;\n  }\n\n  if (isSet) {\n    if (isGlobalScope(scope)) {\n      handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n    } else {\n      handleSetFromLocal(module, scope, n, parent, name);\n    }\n  } else {\n    handleGet(module, scope, n, parent, name);\n  }\n}",
    "fixed_function": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      // This may be a key in an object literal declaration.\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      // This may be a variable get or set.\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.CATCH:\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getString();\n      break;\n    case Token.GETPROP:\n      // This may be a namespaced name get or set.\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n              isPropAssign = true;\n            }\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          case Token.GETPROP:\n            return;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getQualifiedName();\n      if (name == null) {\n        return;\n      }\n      break;\n    default:\n      return;\n  }\n\n  // We are only interested in global names.\n  if (!isGlobalNameReference(name, scope)) {\n    return;\n  }\n\n  if (isSet) {\n    if (isGlobalScope(scope)) {\n      handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n    } else {\n      handleSetFromLocal(module, scope, n, parent, name);\n    }\n  } else {\n    handleGet(module, scope, n, parent, name);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/GlobalNamespace.java",
      "first_line": 306,
      "last_line": 430
    },
    "javadoc": "// generated by them, so that we can do lookups in it later.",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckGlobalNamesTest::testGlobalCatch": {
        "source": "  public void testGlobalCatch() throws Exception {\n\n    testSame(\n\n        \"try {\" +\n\n        \"  throw Error();\" +\n\n        \"} catch (e) {\" +\n\n        \"  console.log(e.name)\" +\n\n        \"}\");\n\n  }\n"
      }
    }
  },
  "Closure-12": {
    "id": "Closure-12",
    "project": "Closure",
    "number": "12",
    "buggy_function": "private boolean hasExceptionHandler(Node cfgNode) {\n  return false;\n}",
    "fixed_function": "private boolean hasExceptionHandler(Node cfgNode) {\n  List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n  for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n    if (edge.getValue() == Branch.ON_EX) {\n      return true;\n    }\n  }\n  return false;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
      "first_line": 159,
      "last_line": 161
    },
    "javadoc": "// a conditional.",
    "failing_tests": {
      "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testIssue794b": {
        "source": "  public void testIssue794b() {\n\n    noInline(\n\n        \"var x = 1; \" +\n\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n\n        \"x = x + 1;\" +\n\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n\n        \"return x;\");\n\n  }\n"
      }
    }
  },
  "Closure-120": {
    "id": "Closure-120",
    "project": "Closure",
    "number": "120",
    "buggy_function": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n\n  // Make sure this assignment is not in a loop.\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n      break;\n    } else if (block.isLoop) {\n      return false;\n    }\n  }\n\n  return true;\n}",
    "fixed_function": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n\n  // Make sure this assignment is not in a loop.\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n      if (ref.getSymbol().getScope() != ref.scope) {\n        return false;\n      }\n      break;\n    } else if (block.isLoop) {\n      return false;\n    }\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
      "first_line": 421,
      "last_line": 438
    },
    "javadoc": "/**\n* @return Whether the variable is only assigned a value once for its\n*     lifetime.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineVariablesTest::testExternalIssue1053": {
        "source": "  public void testExternalIssue1053() {\n\n    testSame(\n\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n\n  }\n"
      }
    }
  },
  "Closure-121": {
    "id": "Closure-121",
    "project": "Closure",
    "number": "121",
    "buggy_function": "private void inlineNonConstants(\n    Var v, ReferenceCollection referenceInfo,\n    boolean maybeModifiedArguments) {\n  int refCount = referenceInfo.references.size();\n  Reference declaration = referenceInfo.references.get(0);\n  Reference init = referenceInfo.getInitializingReference();\n  int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n  if (refCount > 1 &&\n      isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n    // if the variable is referenced more than once, we can only\n    // inline it if it's immutable and never defined before referenced.\n    Node value;\n    if (init != null) {\n      value = init.getAssignedValue();\n    } else {\n      // Create a new node for variable that is never initialized.\n      Node srcLocation = declaration.getNode();\n      value = NodeUtil.newUndefinedNode(srcLocation);\n    }\n    Preconditions.checkNotNull(value);\n    inlineWellDefinedVariable(v, value, referenceInfo.references);\n    staleVars.add(v);\n  } else if (refCount == firstRefAfterInit) {\n    // The variable likely only read once, try some more\n    // complex inlining heuristics.\n    Reference reference = referenceInfo.references.get(\n        firstRefAfterInit - 1);\n    if (canInline(declaration, init, reference)) {\n      inline(v, declaration, init, reference);\n      staleVars.add(v);\n    }\n  } else if (declaration != init && refCount == 2) {\n    if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n      // The only reference is the initialization, remove the assignment and\n      // the variable declaration.\n      Node value = init.getAssignedValue();\n      Preconditions.checkNotNull(value);\n      inlineWellDefinedVariable(v, value, referenceInfo.references);\n      staleVars.add(v);\n    }\n  }\n\n  // If this variable was not inlined normally, check if we can\n  // inline an alias of it. (If the variable was inlined, then the\n  // reference data is out of sync. We're better off just waiting for\n  // the next pass.)\n  if (!maybeModifiedArguments &&\n      !staleVars.contains(v) &&\n      referenceInfo.isWellDefined() &&\n      referenceInfo.isAssignedOnceInLifetime()) {\n      // Inlining the variable based solely on well-defined and assigned\n      // once is *NOT* correct. We relax the correctness requirement if\n      // the variable is declared constant.\n    List<Reference> refs = referenceInfo.references;\n    for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n      Node nameNode = refs.get(i).getNode();\n      if (aliasCandidates.containsKey(nameNode)) {\n        AliasCandidate candidate = aliasCandidates.get(nameNode);\n        if (!staleVars.contains(candidate.alias) &&\n            !isVarInlineForbidden(candidate.alias)) {\n          Reference aliasInit;\n          aliasInit = candidate.refInfo.getInitializingReference();\n          Node value = aliasInit.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(candidate.alias,\n              value,\n              candidate.refInfo.references);\n          staleVars.add(candidate.alias);\n        }\n      }\n    }\n  }\n}",
    "fixed_function": "private void inlineNonConstants(\n    Var v, ReferenceCollection referenceInfo,\n    boolean maybeModifiedArguments) {\n  int refCount = referenceInfo.references.size();\n  Reference declaration = referenceInfo.references.get(0);\n  Reference init = referenceInfo.getInitializingReference();\n  int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n  if (refCount > 1 &&\n      isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n    // if the variable is referenced more than once, we can only\n    // inline it if it's immutable and never defined before referenced.\n    Node value;\n    if (init != null) {\n      value = init.getAssignedValue();\n    } else {\n      // Create a new node for variable that is never initialized.\n      Node srcLocation = declaration.getNode();\n      value = NodeUtil.newUndefinedNode(srcLocation);\n    }\n    Preconditions.checkNotNull(value);\n    inlineWellDefinedVariable(v, value, referenceInfo.references);\n    staleVars.add(v);\n  } else if (refCount == firstRefAfterInit) {\n    // The variable likely only read once, try some more\n    // complex inlining heuristics.\n    Reference reference = referenceInfo.references.get(\n        firstRefAfterInit - 1);\n    if (canInline(declaration, init, reference)) {\n      inline(v, declaration, init, reference);\n      staleVars.add(v);\n    }\n  } else if (declaration != init && refCount == 2) {\n    if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n      // The only reference is the initialization, remove the assignment and\n      // the variable declaration.\n      Node value = init.getAssignedValue();\n      Preconditions.checkNotNull(value);\n      inlineWellDefinedVariable(v, value, referenceInfo.references);\n      staleVars.add(v);\n    }\n  }\n\n  // If this variable was not inlined normally, check if we can\n  // inline an alias of it. (If the variable was inlined, then the\n  // reference data is out of sync. We're better off just waiting for\n  // the next pass.)\n  if (!maybeModifiedArguments &&\n      !staleVars.contains(v) &&\n      referenceInfo.isWellDefined() &&\n      referenceInfo.isAssignedOnceInLifetime() &&\n      // Inlining the variable based solely on well-defined and assigned\n      // once is *NOT* correct. We relax the correctness requirement if\n      // the variable is declared constant.\n      (isInlineableDeclaredConstant(v, referenceInfo) ||\n       referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n    List<Reference> refs = referenceInfo.references;\n    for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n      Node nameNode = refs.get(i).getNode();\n      if (aliasCandidates.containsKey(nameNode)) {\n        AliasCandidate candidate = aliasCandidates.get(nameNode);\n        if (!staleVars.contains(candidate.alias) &&\n            !isVarInlineForbidden(candidate.alias)) {\n          Reference aliasInit;\n          aliasInit = candidate.refInfo.getInitializingReference();\n          Node value = aliasInit.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(candidate.alias,\n              value,\n              candidate.refInfo.references);\n          staleVars.add(candidate.alias);\n        }\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/InlineVariables.java",
      "first_line": 254,
      "last_line": 327
    },
    "javadoc": "// consider a escape of the arguments object.",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineVariablesTest::testExternalIssue1053": {
        "source": "  public void testExternalIssue1053() {\n\n    testSame(\n\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n\n  }\n"
      }
    }
  },
  "Closure-122": {
    "id": "Closure-122",
    "project": "Closure",
    "number": "122",
    "buggy_function": "private void handleBlockComment(Comment comment) {\n  if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n    errorReporter.warning(\n        SUSPICIOUS_COMMENT_WARNING,\n        sourceName,\n        comment.getLineno(), \"\", 0);\n  }\n}",
    "fixed_function": "private void handleBlockComment(Comment comment) {\n  Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n  if (p.matcher(comment.getValue()).find()) {\n    errorReporter.warning(\n        SUSPICIOUS_COMMENT_WARNING,\n        sourceName,\n        comment.getLineno(), \"\", 0);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
      "first_line": 251,
      "last_line": 258
    },
    "javadoc": "/**\n* Check to see if the given block comment looks like it should be JSDoc.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3": {
        "source": "  public void testSuspiciousBlockCommentWarning3() {\n\n    parse(\"/* \\n *@type {number} */ var x = 3;\", SUSPICIOUS_COMMENT_WARNING);\n\n  }\n"
      },
      "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4": {
        "source": "  public void testSuspiciousBlockCommentWarning4() {\n\n    parse(\n\n        \"  /*\\n\" +\n\n        \"   * @type {number}\\n\" +\n\n        \"   */\\n\" +\n\n        \"  var x = 3;\",\n\n        SUSPICIOUS_COMMENT_WARNING);\n\n  }\n"
      },
      "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5": {
        "source": "  public void testSuspiciousBlockCommentWarning5() {\n\n    parse(\n\n        \"  /*\\n\" +\n\n        \"   * some random text here\\n\" +\n\n        \"   * @type {number}\\n\" +\n\n        \"   */\\n\" +\n\n        \"  var x = 3;\",\n\n        SUSPICIOUS_COMMENT_WARNING);\n\n  }\n"
      }
    }
  },
  "Closure-123": {
    "id": "Closure-123",
    "project": "Closure",
    "number": "123",
    "buggy_function": "void add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}",
    "fixed_function": "void add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = getContextForNoInOperator(context);\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 107,
      "last_line": 771
    },
    "javadoc": "/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testPrintInOperatorInForLoop": {
        "source": "  public void testPrintInOperatorInForLoop() {\n\n    // Check for in expression in for's init expression.\n\n    // Check alone, with + (higher precedence), with ?: (lower precedence),\n\n    // and with conditional.\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a); i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a);i;);\");\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) ? 0 : 1; i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)?0:1;i;);\");\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) + 1; i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)+1;i;);\");\n\n    assertPrint(\"var a={};for (var i = (\\\"length\\\" in a|| \\\"size\\\" in a);;);\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)||(\\\"size\\\"in a);;);\");\n\n    assertPrint(\"var a={};for (var i = a || a || (\\\"size\\\" in a);;);\",\n\n        \"var a={};for(var i=a||a||(\\\"size\\\"in a);;);\");\n\n\n\n    // Test works with unary operators and calls.\n\n    assertPrint(\"var a={}; for (var i = -(\\\"length\\\" in a); i;) {}\",\n\n        \"var a={};for(var i=-(\\\"length\\\"in a);i;);\");\n\n    assertPrint(\"var a={};function b_(p){ return p;};\" +\n\n        \"for(var i=1,j=b_(\\\"length\\\" in a);;) {}\",\n\n        \"var a={};function b_(p){return p}\" +\n\n            \"for(var i=1,j=b_(\\\"length\\\"in a);;);\");\n\n\n\n    // Test we correctly handle an in operator in the test clause.\n\n    assertPrint(\"var a={}; for (;(\\\"length\\\" in a);) {}\",\n\n        \"var a={};for(;\\\"length\\\"in a;);\");\n\n\n\n    // Test we correctly handle an in operator inside a comma.\n\n    assertPrintSame(\"for(x,(y in z);;)foo()\");\n\n    assertPrintSame(\"for(var x,w=(y in z);;)foo()\");\n\n\n\n    // And in operator inside a hook.\n\n    assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n\n  }\n"
      }
    }
  },
  "Closure-124": {
    "id": "Closure-124",
    "project": "Closure",
    "number": "124",
    "buggy_function": "private boolean isSafeReplacement(Node node, Node replacement) {\n  // No checks are needed for simple names.\n  if (node.isName()) {\n    return true;\n  }\n  Preconditions.checkArgument(node.isGetProp());\n\n    node = node.getFirstChild();\n  if (node.isName()\n      && isNameAssignedTo(node.getString(), replacement)) {\n    return false;\n  }\n\n  return true;\n}",
    "fixed_function": "private boolean isSafeReplacement(Node node, Node replacement) {\n  // No checks are needed for simple names.\n  if (node.isName()) {\n    return true;\n  }\n  Preconditions.checkArgument(node.isGetProp());\n\n  while (node.isGetProp()) {\n    node = node.getFirstChild();\n  }\n  if (node.isName()\n      && isNameAssignedTo(node.getString(), replacement)) {\n    return false;\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ExploitAssigns.java",
      "first_line": 206,
      "last_line": 220
    },
    "javadoc": "/**\n* Checks name referenced in node to determine if it might have\n* changed.\n* @return Whether the replacement can be made.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.ExploitAssignsTest::testIssue1017": {
        "source": "  public void testIssue1017() {\n\n    testSame(\"x = x.parentNode.parentNode; x = x.parentNode.parentNode;\");\n\n  }\n"
      }
    }
  },
  "Closure-125": {
    "id": "Closure-125",
    "project": "Closure",
    "number": "125",
    "buggy_function": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}",
    "fixed_function": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeCheck.java",
      "first_line": 1656,
      "last_line": 1671
    },
    "javadoc": "/**\n* Visits a NEW node.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue1002": {
        "source": "  public void testIssue1002() throws Exception {\n\n    testTypes(\n\n        \"/** @interface */\" +\n\n        \"var I = function() {};\" +\n\n        \"/** @constructor @implements {I} */\" +\n\n        \"var A = function() {};\" +\n\n        \"/** @constructor @implements {I} */\" +\n\n        \"var B = function() {};\" +\n\n        \"var f = function() {\" +\n\n        \"  if (A === B) {\" +\n\n        \"    new B();\" +\n\n        \"  }\" +\n\n        \"};\");\n\n  }\n"
      }
    }
  },
  "Closure-126": {
    "id": "Closure-126",
    "project": "Closure",
    "number": "126",
    "buggy_function": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n  // Just an 'exit'.\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n\n  // Just an 'if'.\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n\n  // Just a 'try/catch/finally'.\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    /* Don't try to minimize the exits of finally blocks, as this\n     * can cause problems if it changes the completion type of the finally\n     * block. See ECMA 262 Sections 8.9 & 12.14\n     */\n    if (NodeUtil.hasFinally(n)) {\n      Node finallyBlock = n.getLastChild();\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n  }\n\n  // Just a 'label'.\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n  }\n\n  // TODO(johnlenz): The last case of SWITCH statement?\n\n  // The rest assumes a block with at least one child, bail on anything else.\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n\n  // Multiple if-exits can be converted in a single pass.\n  // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n  // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n  // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n  for (Node c : n.children()) {\n\n    // An 'if' block to process below.\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock, falseBlock;\n\n      // First, the true condition block.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n          ifTree, exitType, labelName);\n\n      // Now the else block.\n      // The if blocks may have changed, get them again.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n            ifTree, exitType, labelName);\n      }\n    }\n\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n\n  // Now try to minimize the exits of the last child, if it is removed\n  // look at what has become the last child.\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    // If the node is still the last child, we are done.\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
    "fixed_function": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n  // Just an 'exit'.\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n\n  // Just an 'if'.\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n\n  // Just a 'try/catch/finally'.\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    /* Don't try to minimize the exits of finally blocks, as this\n     * can cause problems if it changes the completion type of the finally\n     * block. See ECMA 262 Sections 8.9 & 12.14\n     */\n  }\n\n  // Just a 'label'.\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n  }\n\n  // TODO(johnlenz): The last case of SWITCH statement?\n\n  // The rest assumes a block with at least one child, bail on anything else.\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n\n  // Multiple if-exits can be converted in a single pass.\n  // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n  // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n  // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n  for (Node c : n.children()) {\n\n    // An 'if' block to process below.\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock, falseBlock;\n\n      // First, the true condition block.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n          ifTree, exitType, labelName);\n\n      // Now the else block.\n      // The if blocks may have changed, get them again.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n            ifTree, exitType, labelName);\n      }\n    }\n\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n\n  // Now try to minimize the exits of the last child, if it is removed\n  // look at what has become the last child.\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    // If the node is still the last child, we are done.\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
      "first_line": 106,
      "last_line": 201
    },
    "javadoc": "/**\n* Attempts to minimize the number of explicit exit points in a control\n* structure to take advantage of the implied exit at the end of the\n* structure.  This is accomplished by removing redundant statements, and\n* moving statements following a qualifying IF node into that node.\n* For example:\n*\n* function () {\n*   if (x) return;\n*   else blah();\n*   foo();\n* }\n*\n* becomes:\n*\n* function () {\n*  if (x) ;\n*  else {\n*    blah();\n*    foo();\n*  }\n*\n* @param n The execution node of a parent to inspect.\n* @param exitType The type of exit to look for.\n* @param labelName If parent is a label the name of the label to look for,\n*   null otherwise.\n* @nullable labelName non-null only for breaks within labels.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.MinimizeExitPointsTest::testDontRemoveBreakInTryFinally": {
        "source": "  public void testDontRemoveBreakInTryFinally() throws Exception {\n\n    foldSame(\"function f() {b:try{throw 9} finally {break b} return 1;}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.MinimizeExitPointsTest::testFunctionReturnOptimization": {
        "source": "  public void testFunctionReturnOptimization() throws Exception {\n\n    fold(\"function f(){if(a()){b();if(c())return;}}\",\n\n         \"function f(){if(a()){b();if(c());}}\");\n\n    fold(\"function f(){if(x)return; x=3; return; }\",\n\n         \"function f(){if(x); else x=3}\");\n\n    fold(\"function f(){if(true){a();return;}else;b();}\",\n\n         \"function f(){if(true){a();}else{b();}}\");\n\n    fold(\"function f(){if(false){a();return;}else;b();return;}\",\n\n         \"function f(){if(false){a();}else{b();}}\");\n\n    fold(\"function f(){if(a()){b();return;}else;c();}\",\n\n         \"function f(){if(a()){b();}else{c();}}\");\n\n    fold(\"function f(){if(a()){b()}else{c();return;}}\",\n\n         \"function f(){if(a()){b()}else{c();}}\");\n\n    fold(\"function f(){if(a()){b();return;}else;}\",\n\n         \"function f(){if(a()){b();}else;}\");\n\n    fold(\"function f(){if(a()){return;}else{return;} return;}\",\n\n         \"function f(){if(a()){}else{}}\");\n\n    fold(\"function f(){if(a()){return;}else{return;} b();}\",\n\n         \"function f(){if(a()){}else{return;b()}}\");\n\n    fold(\"function f(){ if (x) return; if (y) return; if (z) return; w(); }\",\n\n        \" function f() {\" +\n\n        \"   if (x) {} else { if (y) {} else { if (z) {} else w(); }}\" +\n\n        \" }\");\n\n\n\n    fold(\"function f(){while(a())return;}\",\n\n         \"function f(){while(a())return}\");\n\n    foldSame(\"function f(){for(x in a())return}\");\n\n\n\n    fold(\"function f(){while(a())break;}\",\n\n         \"function f(){while(a())break}\");\n\n    foldSame(\"function f(){for(x in a())break}\");\n\n\n\n    fold(\"function f(){try{return;}catch(e){throw 9;}finally{return}}\",\n\n         \"function f(){try{}catch(e){throw 9;}finally{return}}\");\n\n    foldSame(\"function f(){try{throw 9;}finally{return;}}\");\n\n\n\n    fold(\"function f(){try{return;}catch(e){return;}}\",\n\n         \"function f(){try{}catch(e){}}\");\n\n    fold(\"function f(){try{if(a()){return;}else{return;} return;}catch(e){}}\",\n\n         \"function f(){try{if(a()){}else{}}catch(e){}}\");\n\n\n\n    fold(\"function f(){g:return}\",\n\n         \"function f(){}\");\n\n    fold(\"function f(){g:if(a()){return;}else{return;} return;}\",\n\n         \"function f(){g:if(a()){}else{}}\");\n\n    fold(\"function f(){try{g:if(a()){throw 9;} return;}finally{return}}\",\n\n         \"function f(){try{g:if(a()){throw 9;}}finally{return}}\");\n\n  }\n"
      }
    }
  },
  "Closure-128": {
    "id": "Closure-128",
    "project": "Closure",
    "number": "128",
    "buggy_function": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0 && s.charAt(0) != '0';\n}",
    "fixed_function": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  if (len == 0) {\n    return false;\n  }\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len == 1 || s.charAt(0) != '0';\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 783,
      "last_line": 792
    },
    "javadoc": "/**\n* We could use addList recursively here, but sometimes we produce\n* very deeply nested operators and run out of stack space, so we\n* just unroll the recursion when possible.\n*\n* We assume nodes are left-recursive.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testIssue942": {
        "source": "  public void testIssue942() {\n\n    assertPrint(\"var x = {0: 1};\", \"var x={0:1}\");\n\n  }\n"
      }
    }
  },
  "Closure-129": {
    "id": "Closure-129",
    "project": "Closure",
    "number": "129",
    "buggy_function": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n\n  // Keep track of of the \"this\" context of a call.  A call without an\n  // explicit \"this\" is a free call.\n  Node first = n.getFirstChild();\n\n  // ignore cast nodes.\n\n  if (!NodeUtil.isGet(first)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n\n  // Keep track of the context in which eval is called. It is important\n  // to distinguish between \"(0, eval)()\" and \"eval()\".\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}",
    "fixed_function": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n\n  // Keep track of of the \"this\" context of a call.  A call without an\n  // explicit \"this\" is a free call.\n  Node first = n.getFirstChild();\n\n  // ignore cast nodes.\n  while (first.isCast()) {\n    first = first.getFirstChild();\n  }\n\n  if (!NodeUtil.isGet(first)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n\n  // Keep track of the context in which eval is called. It is important\n  // to distinguish between \"(0, eval)()\" and \"eval()\".\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PrepareAst.java",
      "first_line": 158,
      "last_line": 177
    },
    "javadoc": "/**\n* There are two types of calls we are interested in calls without explicit\n* \"this\" values (what we are call \"free\" calls) and direct call to eval.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.IntegrationTest::testIssue937": {
        "source": "  public void testIssue937() {\n\n    CompilerOptions options = createCompilerOptions();\n\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n\n    level.setOptionsForCompilationLevel(options);\n\n    WarningLevel warnings = WarningLevel.DEFAULT;\n\n    warnings.setOptionsForWarningLevel(options);\n\n\n\n    String code = \"\" +\n\n        \"console.log(\" +\n\n            \"/** @type {function():!string} */ ((new x())['abc'])() );\";\n\n    String result = \"\" +\n\n        \"console.log((new x()).abc());\";\n\n    test(options, code, result);\n\n  }\n"
      }
    }
  },
  "Closure-13": {
    "id": "Closure-13",
    "project": "Closure",
    "number": "13",
    "buggy_function": "private void traverse(Node node) {\n  // The goal here is to avoid retraversing\n  // the entire AST to catch newly created opportunities.\n  // So we track whether a \"unit of code\" has changed,\n  // and revisit immediately.\n  if (!shouldVisit(node)) {\n    return;\n  }\n\n  int visits = 0;\n  do {\n    Node c = node.getFirstChild();\n    while(c != null) {\n      traverse(c);\n      Node next = c.getNext();\n      c = next;\n    }\n\n    visit(node);\n    visits++;\n\n    Preconditions.checkState(visits < 10000, \"too many interations\");\n  } while (shouldRetraverse(node));\n\n  exitNode(node);\n}",
    "fixed_function": "private void traverse(Node node) {\n  // The goal here is to avoid retraversing\n  // the entire AST to catch newly created opportunities.\n  // So we track whether a \"unit of code\" has changed,\n  // and revisit immediately.\n  if (!shouldVisit(node)) {\n    return;\n  }\n\n  int visits = 0;\n  do {\n    Node c = node.getFirstChild();\n    while(c != null) {\n      Node next = c.getNext();\n      traverse(c);\n      c = next;\n    }\n\n    visit(node);\n    visits++;\n\n    Preconditions.checkState(visits < 10000, \"too many interations\");\n  } while (shouldRetraverse(node));\n\n  exitNode(node);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
      "first_line": 113,
      "last_line": 138
    },
    "javadoc": "/**\n* Creates a peephole optimization pass that runs the given\n* optimizations.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.IntegrationTest::testIssue787": {
        "source": "  public void testIssue787() {\n\n    CompilerOptions options = createCompilerOptions();\n\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n\n    level.setOptionsForCompilationLevel(options);\n\n    WarningLevel warnings = WarningLevel.DEFAULT;\n\n    warnings.setOptionsForWarningLevel(options);\n\n\n\n    String code = \"\" +\n\n        \"function some_function() {\\n\" +\n\n        \"  var fn1;\\n\" +\n\n        \"  var fn2;\\n\" +\n\n        \"\\n\" +\n\n        \"  if (any_expression) {\\n\" +\n\n        \"    fn2 = external_ref;\\n\" +\n\n        \"    fn1 = function (content) {\\n\" +\n\n        \"      return fn2();\\n\" +\n\n        \"    }\\n\" +\n\n        \"  }\\n\" +\n\n        \"\\n\" +\n\n        \"  return {\\n\" +\n\n        \"    method1: function () {\\n\" +\n\n        \"      if (fn1) fn1();\\n\" +\n\n        \"      return true;\\n\" +\n\n        \"    },\\n\" +\n\n        \"    method2: function () {\\n\" +\n\n        \"      return false;\\n\" +\n\n        \"    }\\n\" +\n\n        \"  }\\n\" +\n\n        \"}\";\n\n\n\n    String result = \"\" +\n\n        \"function some_function() {\\n\" +\n\n        \"  var a, b;\\n\" +\n\n        \"  any_expression && (b = external_ref, a = function() {\\n\" +\n\n        \"    return b()\\n\" +\n\n        \"  });\\n\" +\n\n        \"  return{method1:function() {\\n\" +\n\n        \"    a && a();\\n\" +\n\n        \"    return !0\\n\" +\n\n        \"  }, method2:function() {\\n\" +\n\n        \"    return !1\\n\" +\n\n        \"  }}\\n\" +\n\n        \"}\\n\" +\n\n        \"\";\n\n\n\n    test(options, code, result);\n\n  }\n"
      }
    }
  },
  "Closure-130": {
    "id": "Closure-130",
    "project": "Closure",
    "number": "130",
    "buggy_function": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n\n    // Don't attempt to inline a getter or setter property as a variable.\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n\n    if (name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets > 0) {\n      // {@code name} meets condition (b). Find all of its local aliases\n      // and try to inline them.\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          // {@code name} meets condition (c). Try to inline it.\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n\n    // Check if {@code name} has any aliases left after the\n    // local-alias-inlining above.\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      // All of {@code name}'s children meet condition (a), so they can be\n      // added to the worklist.\n      workList.addAll(name.props);\n    }\n  }\n}",
    "fixed_function": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n\n    // Don't attempt to inline a getter or setter property as a variable.\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n\n    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets > 0) {\n      // {@code name} meets condition (b). Find all of its local aliases\n      // and try to inline them.\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          // {@code name} meets condition (c). Try to inline it.\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n\n    // Check if {@code name} has any aliases left after the\n    // local-alias-inlining above.\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      // All of {@code name}'s children meet condition (a), so they can be\n      // added to the worklist.\n      workList.addAll(name.props);\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CollapseProperties.java",
      "first_line": 161,
      "last_line": 197
    },
    "javadoc": "/**\n* For each qualified name N in the global scope, we check if:\n* (a) No ancestor of N is ever aliased or assigned an unknown value type.\n*     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n* (b) N has exactly one write, and it lives in the global scope.\n* (c) N is aliased in a local scope.\n*\n* If (a) is true, then GlobalNamespace must know all the writes to N.\n* If (a) and (b) are true, then N cannot change during the execution of\n*    a local scope.\n* If (a) and (b) and (c) are true, then the alias can be inlined if the\n*    alias obeys the usual rules for how we decide whether a variable is\n*    inlineable.\n* @see InlineVariables\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CollapsePropertiesTest::testIssue931": {
        "source": "  public void testIssue931() {\n\n    collapsePropertiesOnExternTypes = true;\n\n    testSame(\n\n      \"function f() {\\n\" +\n\n      \"  return function () {\\n\" +\n\n      \"    var args = arguments;\\n\" +\n\n      \"    setTimeout(function() { alert(args); }, 0);\\n\" +\n\n      \"  }\\n\" +\n\n      \"};\\n\");\n\n  }\n"
      }
    }
  },
  "Closure-131": {
    "id": "Closure-131",
    "project": "Closure",
    "number": "131",
    "buggy_function": "public static boolean isJSIdentifier(String s) {\n  int length = s.length();\n\n  if (length == 0 ||\n      !Character.isJavaIdentifierStart(s.charAt(0))) {\n    return false;\n  }\n\n  for (int i = 1; i < length; i++) {\n    if (\n        !Character.isJavaIdentifierPart(s.charAt(i))) {\n      return false;\n    }\n  }\n\n  return true;\n}",
    "fixed_function": "public static boolean isJSIdentifier(String s) {\n  int length = s.length();\n\n  if (length == 0 ||\n      Character.isIdentifierIgnorable(s.charAt(0)) ||\n      !Character.isJavaIdentifierStart(s.charAt(0))) {\n    return false;\n  }\n\n  for (int i = 1; i < length; i++) {\n    if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n        !Character.isJavaIdentifierPart(s.charAt(i))) {\n      return false;\n    }\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/TokenStream.java",
      "first_line": 190,
      "last_line": 206
    },
    "javadoc": "// partial match validate the entire string the one possibility",
    "failing_tests": {
      "com.google.javascript.jscomp.ConvertToDottedPropertiesTest::testQuotedProps": {
        "source": "  public void testQuotedProps() {\n\n    testSame(\"({'':0})\");\n\n    testSame(\"({'1.0':0})\");\n\n    testSame(\"({'\\u1d17A':0})\");\n\n    testSame(\"({'a\\u0004b':0})\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.ConvertToDottedPropertiesTest::testDoNotConvert": {
        "source": "  public void testDoNotConvert() {\n\n    testSame(\"a[0]\");\n\n    testSame(\"a['']\");\n\n    testSame(\"a[' ']\");\n\n    testSame(\"a[',']\");\n\n    testSame(\"a[';']\");\n\n    testSame(\"a[':']\");\n\n    testSame(\"a['.']\");\n\n    testSame(\"a['0']\");\n\n    testSame(\"a['p ']\");\n\n    testSame(\"a['p' + '']\");\n\n    testSame(\"a[p]\");\n\n    testSame(\"a[P]\");\n\n    testSame(\"a[$]\");\n\n    testSame(\"a[p()]\");\n\n    testSame(\"a['default']\");\n\n    // Ignorable control characters are ok in Java identifiers, but not in JS.\n\n    testSame(\"a['A\\u0004']\");\n\n    // upper case lower half of o from phonetic extensions set.\n\n    // valid in Safari, not in Firefox, IE.\n\n    test(\"a['\\u1d17A']\", \"a['\\u1d17A']\");\n\n    // Latin capital N with tilde - nice if we handled it, but for now let's\n\n    // only allow simple Latin (aka ASCII) to be converted.\n\n    test(\"a['\\u00d1StuffAfter']\", \"a['\\u00d1StuffAfter']\");\n\n  }\n"
      }
    }
  },
  "Closure-132": {
    "id": "Closure-132",
    "project": "Closure",
    "number": "132",
    "buggy_function": "private Node tryMinimizeIf(Node n) {\n\n  Node parent = n.getParent();\n\n  Node cond = n.getFirstChild();\n\n  /* If the condition is a literal, we'll let other\n   * optimizations try to remove useless code.\n   */\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        // Keep opportunities for CollapseProperties such as\n        // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n        // until CollapseProperties has been run.\n        return n;\n      }\n\n      if (cond.isNot()) {\n        // if(!x)bar(); -> x||bar();\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                OR_PRECEDENCE)) {\n          // It's not okay to add two sets of parentheses.\n          return n;\n        }\n\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      }\n\n      // if(x)foo(); -> x&&foo();\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n          isLowerPrecedenceInExpression(expr.getFirstChild(),\n              AND_PRECEDENCE)) {\n        // One additional set of parentheses is worth the change even if\n        // there is no immediate code size win. However, two extra pair of\n        // {}, we would have to think twice. (unless we know for sure the\n        // we can further optimize its parent.\n        return n;\n      }\n\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n\n      return newExpr;\n    } else {\n\n      // Try to combine two IF-ELSE\n      if (NodeUtil.isStatementBlock(thenBranch) &&\n          thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThenBranch = innerCond.getNext();\n          Node innerElseBranch = innerThenBranch.getNext();\n\n          if (innerElseBranch == null &&\n               !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                 isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(\n                    cond,\n                    innerCond.detachFromParent())\n                    .srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            // Not worth trying to fold the current IF-ELSE into && because\n            // the inner IF-ELSE wasn't able to be folded into && anyways.\n            return n;\n          }\n        }\n      }\n    }\n\n    return n;\n  }\n\n  /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n   * peephole optimization. This should probably get moved to another pass.\n   */\n  tryRemoveRepeatedStatements(n);\n\n  // if(!x)foo();else bar(); -> if(x)bar();else foo();\n  // An additional set of curly braces isn't worth it.\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  // if(x)return 1;else return 2; -> return x?1:2;\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n\n    // note - we ignore any cases with \"return;\", technically this\n    // can be converted to \"return undefined;\" or some variant, but\n    // that does not help code size.\n    Node returnNode = IR.returnNode(\n                          IR.hook(cond, thenExpr, elseExpr)\n                              .srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      // if(x)a=1;else a=2; -> a=x?1:2;\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            // if LHS has side effects, don't proceed [since the optimization\n            // evaluates LHS before cond]\n            // NOTE - there are some circumstances where we can\n            // proceed even if there are side effects...\n            !mayEffectMutableState(lhs)) {\n\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                            .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n\n          return expr;\n        }\n      }\n    }\n    // if(x)foo();else bar(); -> x?foo():bar()\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(\n        IR.hook(cond, thenOp, elseOp).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n\n  boolean thenBranchIsVar = isVarBlock(thenBranch);\n  boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n  // if(x)var y=1;else y=2  ->  var y=x?1:2\n  if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n      getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n    Node var = getBlockVar(thenBranch);\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n    Node name1 = var.getFirstChild();\n    Node maybeName2 = elseAssign.getFirstChild();\n\n    if (name1.hasChildren()\n        && maybeName2.isName()\n        && name1.getString().equals(maybeName2.getString())) {\n      Node thenExpr = name1.removeChildren();\n      Node elseExpr = elseAssign.getLastChild().detachFromParent();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name1.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n\n  // if(x)y=1;else var y=2  ->  var y=x?1:2\n  } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n      getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n    Node var = getBlockVar(elseBranch);\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n    Node maybeName1 = thenAssign.getFirstChild();\n    Node name2 = var.getFirstChild();\n\n    if (name2.hasChildren()\n        && maybeName1.isName()\n        && maybeName1.getString().equals(name2.getString())) {\n      Node thenExpr = thenAssign.getLastChild().detachFromParent();\n      Node elseExpr = name2.removeChildren();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name2.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n\n      return var;\n    }\n  }\n\n  return n;\n}",
    "fixed_function": "private Node tryMinimizeIf(Node n) {\n\n  Node parent = n.getParent();\n\n  Node cond = n.getFirstChild();\n\n  /* If the condition is a literal, we'll let other\n   * optimizations try to remove useless code.\n   */\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        // Keep opportunities for CollapseProperties such as\n        // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n        // until CollapseProperties has been run.\n        return n;\n      }\n\n      if (cond.isNot()) {\n        // if(!x)bar(); -> x||bar();\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                OR_PRECEDENCE)) {\n          // It's not okay to add two sets of parentheses.\n          return n;\n        }\n\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      }\n\n      // if(x)foo(); -> x&&foo();\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n          isLowerPrecedenceInExpression(expr.getFirstChild(),\n              AND_PRECEDENCE)) {\n        // One additional set of parentheses is worth the change even if\n        // there is no immediate code size win. However, two extra pair of\n        // {}, we would have to think twice. (unless we know for sure the\n        // we can further optimize its parent.\n        return n;\n      }\n\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n\n      return newExpr;\n    } else {\n\n      // Try to combine two IF-ELSE\n      if (NodeUtil.isStatementBlock(thenBranch) &&\n          thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThenBranch = innerCond.getNext();\n          Node innerElseBranch = innerThenBranch.getNext();\n\n          if (innerElseBranch == null &&\n               !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                 isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(\n                    cond,\n                    innerCond.detachFromParent())\n                    .srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            // Not worth trying to fold the current IF-ELSE into && because\n            // the inner IF-ELSE wasn't able to be folded into && anyways.\n            return n;\n          }\n        }\n      }\n    }\n\n    return n;\n  }\n\n  /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n   * peephole optimization. This should probably get moved to another pass.\n   */\n  tryRemoveRepeatedStatements(n);\n\n  // if(!x)foo();else bar(); -> if(x)bar();else foo();\n  // An additional set of curly braces isn't worth it.\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  // if(x)return 1;else return 2; -> return x?1:2;\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n\n    // note - we ignore any cases with \"return;\", technically this\n    // can be converted to \"return undefined;\" or some variant, but\n    // that does not help code size.\n    Node returnNode = IR.returnNode(\n                          IR.hook(cond, thenExpr, elseExpr)\n                              .srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      // if(x)a=1;else a=2; -> a=x?1:2;\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            // if LHS has side effects, don't proceed [since the optimization\n            // evaluates LHS before cond]\n            // NOTE - there are some circumstances where we can\n            // proceed even if there are side effects...\n            !mayEffectMutableState(lhs) &&\n            (!mayHaveSideEffects(cond) ||\n                (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                            .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n\n          return expr;\n        }\n      }\n    }\n    // if(x)foo();else bar(); -> x?foo():bar()\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(\n        IR.hook(cond, thenOp, elseOp).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n\n  boolean thenBranchIsVar = isVarBlock(thenBranch);\n  boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n  // if(x)var y=1;else y=2  ->  var y=x?1:2\n  if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n      getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n    Node var = getBlockVar(thenBranch);\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n    Node name1 = var.getFirstChild();\n    Node maybeName2 = elseAssign.getFirstChild();\n\n    if (name1.hasChildren()\n        && maybeName2.isName()\n        && name1.getString().equals(maybeName2.getString())) {\n      Node thenExpr = name1.removeChildren();\n      Node elseExpr = elseAssign.getLastChild().detachFromParent();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name1.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n\n  // if(x)y=1;else var y=2  ->  var y=x?1:2\n  } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n      getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n    Node var = getBlockVar(elseBranch);\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n    Node maybeName1 = thenAssign.getFirstChild();\n    Node name2 = var.getFirstChild();\n\n    if (name2.hasChildren()\n        && maybeName1.isName()\n        && maybeName1.getString().equals(name2.getString())) {\n      Node thenExpr = thenAssign.getLastChild().detachFromParent();\n      Node elseExpr = name2.removeChildren();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name2.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n\n      return var;\n    }\n  }\n\n  return n;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "first_line": 636,
      "last_line": 868
    },
    "javadoc": "/**\n* Try turning IF nodes into smaller HOOKs\n*\n* Returns the replacement for n or the original if no replacement was\n* necessary.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testIssue925": {
        "source": "  public void testIssue925() {\n\n    test(\n\n        \"if (x[--y] === 1) {\\n\" +\n\n        \"    x[y] = 0;\\n\" +\n\n        \"} else {\\n\" +\n\n        \"    x[y] = 1;\\n\" +\n\n        \"}\",\n\n        \"(x[--y] === 1) ? x[y] = 0 : x[y] = 1;\");\n\n\n\n    test(\n\n        \"if (x[--y]) {\\n\" +\n\n        \"    a = 0;\\n\" +\n\n        \"} else {\\n\" +\n\n        \"    a = 1;\\n\" +\n\n        \"}\",\n\n        \"a = (x[--y]) ? 0 : 1;\");\n\n\n\n    test(\"if (x++) { x += 2 } else { x += 3 }\",\n\n         \"x++ ? x += 2 : x += 3\");\n\n\n\n    test(\"if (x++) { x = x + 2 } else { x = x + 3 }\",\n\n        \"x = x++ ? x + 2 : x + 3\");\n\n  }\n"
      }
    }
  },
  "Closure-133": {
    "id": "Closure-133",
    "project": "Closure",
    "number": "133",
    "buggy_function": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  return result;\n}",
    "fixed_function": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  unreadToken = NO_UNREAD_TOKEN;\n  return result;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "first_line": 2399,
      "last_line": 2402
    },
    "javadoc": "/**\n* Returns the remainder of the line.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testTextExtents": {
        "source": "  public void testTextExtents() {\n\n    parse(\"@return {@code foo} bar \\n *    baz. */\",\n\n        true, \"Bad type annotation. type not recognized due to syntax error\");\n\n  }\n"
      }
    }
  },
  "Closure-14": {
    "id": "Closure-14",
    "project": "Closure",
    "number": "14",
    "buggy_function": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  // If we are just before a IF/WHILE/DO/FOR:\n  switch (parent.getType()) {\n    // The follow() of any of the path from IF would be what follows IF.\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      // After the body of a CASE, the control goes to the body of the next\n      // case, without having to go to the case condition.\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      // If we are coming out of the TRY block...\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(parent.getLastChild());\n        } else { // and have no FINALLY.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // CATCH block.\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // If we are coming out of the FINALLY block...\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  // Now that we are done with the special cases follow should be its\n  // immediate sibling, unless its sibling is a function\n  Node nextSibling = node.getNext();\n\n  // Skip function declarations because control doesn't get pass into it.\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    // If there are no more siblings, control is transferred up the AST.\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
    "fixed_function": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  // If we are just before a IF/WHILE/DO/FOR:\n  switch (parent.getType()) {\n    // The follow() of any of the path from IF would be what follows IF.\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      // After the body of a CASE, the control goes to the body of the next\n      // case, without having to go to the case condition.\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      // If we are coming out of the TRY block...\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(parent.getLastChild());\n        } else { // and have no FINALLY.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // CATCH block.\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // If we are coming out of the FINALLY block...\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  // Now that we are done with the special cases follow should be its\n  // immediate sibling, unless its sibling is a function\n  Node nextSibling = node.getNext();\n\n  // Skip function declarations because control doesn't get pass into it.\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    // If there are no more siblings, control is transferred up the AST.\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
      "first_line": 692,
      "last_line": 789
    },
    "javadoc": "/**\n* Computes the follow() node of a given node and its parent. There is a side\n* effect when calling this function. If this function computed an edge that\n* exists a FINALLY, it'll attempt to connect the fromNode to the outer\n* FINALLY according to the finallyMap.\n*\n* @param fromNode The original source node since {@code node} is changed\n*        during recursion.\n* @param node The node that follow() should compute.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckMissingReturnTest::testIssue779": {
        "source": "  public void testIssue779() {\n\n    testNotMissing(\n\n        \"var a = f(); try { alert(); if (a > 0) return 1; }\" +\n\n        \"finally { a = 5; } return 2;\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.ControlFlowAnalysisTest::testDeepNestedFinally": {
        "source": "  public void testDeepNestedFinally() {\n\n    String src = \"try{try{try{throw 1}\" +\n\n        \"finally{1;var a}}finally{2;if(a);}}finally{3;a()}\";\n\n    ControlFlowGraph<Node> cfg = createCfg(src);\n\n    assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX);\n\n    assertCrossEdge(cfg, Token.VAR, Token.BLOCK, Branch.UNCOND);\n\n    assertCrossEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_EX);\n\n  }\n"
      },
      "com.google.javascript.jscomp.ControlFlowAnalysisTest::testDeepNestedBreakwithFinally": {
        "source": "  public void testDeepNestedBreakwithFinally() {\n\n    String src = \"X:while(1){try{while(2){try{var a;break X;}\" +\n\n        \"finally{}}}finally{}}\";\n\n    ControlFlowGraph<Node> cfg = createCfg(src);\n\n    assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE);\n\n    assertDownEdge(cfg, Token.BLOCK, Token.TRY, Branch.UNCOND);\n\n    assertDownEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND);\n\n    // BREAK to FINALLY.\n\n    assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND);\n\n    // FINALLY to FINALLY.\n\n    assertCrossEdge(cfg, Token.BLOCK, Token.BLOCK, Branch.ON_EX);\n\n    assertCrossEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_FALSE);\n\n    assertReturnEdge(cfg, Token.BLOCK);\n\n  }\n"
      }
    }
  },
  "Closure-145": {
    "id": "Closure-145",
    "project": "Closure",
    "number": "145",
    "buggy_function": "private boolean isOneExactlyFunctionOrDo(Node n) {\n      // For labels with block children, we need to ensure that a\n      // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n      // are skipped. \n        // Either a empty statement or an block with more than one child,\n        // way it isn't a FUNCTION or DO.\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}",
    "fixed_function": "private boolean isOneExactlyFunctionOrDo(Node n) {\n  if (n.getType() == Token.LABEL) {\n    Node labeledStatement = n.getLastChild();\n    if (labeledStatement.getType() != Token.BLOCK) {\n      return isOneExactlyFunctionOrDo(labeledStatement);\n    } else {\n      // For labels with block children, we need to ensure that a\n      // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n      // are skipped. \n      if (getNonEmptyChildCount(n, 2) == 1) { \n        return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n      } else {\n        // Either a empty statement or an block with more than one child,\n        // way it isn't a FUNCTION or DO.\n        return false;\n      }\n    }\n  } else {\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 708,
      "last_line": 715
    },
    "javadoc": "/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testFunctionSafariCompatiblity": {
        "source": "  public void testFunctionSafariCompatiblity() {\n\n    // Functions within IFs cause syntax errors on Safari.\n\n    assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n\n\n    assertPrint(\"function(){if(e1)function goo(){return true}else foo()}\",\n\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n\n\n    assertPrint(\"if(e1){function goo(){return true}}\",\n\n        \"if(e1){function goo(){return true}}\");\n\n\n\n    assertPrint(\"if(e1)function goo(){return true}\",\n\n        \"if(e1){function goo(){return true}}\");\n\n\n\n    assertPrint(\"if(e1)A:function goo(){return true}\",\n\n        \"if(e1){A:function goo(){return true}}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testDoLoopIECompatiblity": {
        "source": "  public void testDoLoopIECompatiblity() {\n\n    // Do loops within IFs cause syntax errors in IE6 and IE7.\n\n    assertPrint(\"function(){if(e1){do foo();while(e2)}else foo()}\",\n\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n\n\n    assertPrint(\"function(){if(e1)do foo();while(e2)else foo()}\",\n\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n\n\n    assertPrint(\"if(x){do{foo()}while(y)}else bar()\",\n\n        \"if(x){do foo();while(y)}else bar()\");\n\n\n\n    assertPrint(\"if(x)do{foo()}while(y);else bar()\",\n\n        \"if(x){do foo();while(y)}else bar()\");\n\n\n\n    assertPrint(\"if(x){do{foo()}while(y)}\",\n\n        \"if(x){do foo();while(y)}\");\n\n\n\n    assertPrint(\"if(x)do{foo()}while(y);\",\n\n        \"if(x){do foo();while(y)}\");\n\n\n\n    assertPrint(\"if(x)A:do{foo()}while(y);\",\n\n        \"if(x){A:do foo();while(y)}\");\n\n    \n\n    assertPrint(\"var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);\",\n\n        \"var i=0;a:do{b:do{i++;break b}while(0)}while(0)\");\n\n  }\n"
      }
    }
  },
  "Closure-146": {
    "id": "Closure-146",
    "project": "Closure",
    "number": "146",
    "buggy_function": "public TypePair getTypesUnderInequality(JSType that) {\n  // unions types\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n\n  // other types\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(this, that);\n  }\n\n  // switch case is exhaustive\n  throw new IllegalStateException();\n}",
    "fixed_function": "public TypePair getTypesUnderInequality(JSType that) {\n  // unions types\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n\n  // other types\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n      return new TypePair(noType, noType);\n\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(this, that);\n  }\n\n  // switch case is exhaustive\n  throw new IllegalStateException();\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/JSType.java",
      "first_line": 696,
      "last_line": 715
    },
    "javadoc": "/**\n* Computes the subset of {@code this} and {@code that} types if inequality\n* is observed. If a value {@code v1} of type {@code number} is not equal to a\n* value {@code v2} of type {@code (undefined,number)}, we can infer that the\n* type of {@code v1} is {@code number} and the type of {@code v2} is\n* {@code number} as well.\n*\n* @return a pair containing the restricted type of {@code this} as the first\n*         component and the restricted type of {@code that} as the second\n*         element. The returned pair is never {@code null} even though its\n*         components may be {@code null}\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.SemanticReverseAbstractInterpreterTest::testEqCondition4": {
        "source": "  public void testEqCondition4() throws Exception {\n\n    FlowScope blind = newScope();\n\n    testBinop(blind,\n\n        Token.EQ,\n\n        createVar(blind, \"a\", VOID_TYPE),\n\n        createVar(blind, \"b\", VOID_TYPE),\n\n        Sets.newHashSet(\n\n            new TypedName(\"a\", VOID_TYPE),\n\n            new TypedName(\"b\", VOID_TYPE)),\n\n        Sets.newHashSet(\n\n            new TypedName(\"a\", NO_TYPE),\n\n            new TypedName(\"b\", NO_TYPE)));\n\n  }\n"
      }
    }
  },
  "Closure-15": {
    "id": "Closure-15",
    "project": "Closure",
    "number": "15",
    "buggy_function": "public boolean apply(Node n) {\n  // When the node is null it means, we reached the implicit return\n  // where the function returns (possibly without an return statement)\n  if (n == null) {\n    return false;\n  }\n\n  // TODO(user): We only care about calls to functions that\n  // passes one of the dependent variable to a non-side-effect free\n  // function.\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n\n\n  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "fixed_function": "public boolean apply(Node n) {\n  // When the node is null it means, we reached the implicit return\n  // where the function returns (possibly without an return statement)\n  if (n == null) {\n    return false;\n  }\n\n  // TODO(user): We only care about calls to functions that\n  // passes one of the dependent variable to a non-side-effect free\n  // function.\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n\n  if (n.isDelProp()) {\n    return true;\n  }\n\n  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
      "first_line": 84,
      "last_line": 109
    },
    "javadoc": "// scope.",
    "failing_tests": {
      "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testSimpleForIn": {
        "source": "  public void testSimpleForIn() {\n\n    inline(\"var a,b,x = a in b; x\",\n\n           \"var a,b,x; a in b\");\n\n    noInline(\"var a, b; var x = a in b; print(1); x\");\n\n    noInline(\"var a,b,x = a in b; delete a[b]; x\");\n\n  }\n"
      }
    }
  },
  "Closure-150": {
    "id": "Closure-150",
    "project": "Closure",
    "number": "150",
    "buggy_function": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n}",
    "fixed_function": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  super.visit(t, n, parent);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 1443,
      "last_line": 1466
    },
    "javadoc": "/**\n* Visit a node in a local scope, and add any local variables or catch\n* parameters into the local symbol table.\n*\n* @param t The node traversal.\n* @param n The node being visited.\n* @param parent The parent of n\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testNamespacedFunctionStubLocal": {
        "source": "  public void testNamespacedFunctionStubLocal() {\n\n    testSame(\n\n        \"(function() {\" +\n\n        \"var goog = {};\" +\n\n        \"/** @param {number} x */ goog.foo;\" +\n\n        \"});\");\n\n\n\n    ObjectType goog = (ObjectType) findNameType(\"goog\", lastLocalScope);\n\n    assertTrue(goog.hasProperty(\"foo\"));\n\n    assertEquals(\"function (number): ?\",\n\n        goog.getPropertyType(\"foo\").toString());\n\n    assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n\n\n\n    assertEquals(lastLocalScope.getVar(\"goog.foo\").getType(),\n\n        goog.getPropertyType(\"foo\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testCollectedFunctionStubLocal": {
        "source": "  public void testCollectedFunctionStubLocal() {\n\n    testSame(\n\n        \"(function() {\" +\n\n        \"/** @constructor */ function f() { \" +\n\n        \"  /** @return {number} */ this.foo;\" +\n\n        \"}\" +\n\n        \"var x = new f();\" +\n\n        \"});\");\n\n    ObjectType x = (ObjectType) findNameType(\"x\", lastLocalScope);\n\n    assertEquals(\"f\", x.toString());\n\n    assertTrue(x.hasProperty(\"foo\"));\n\n    assertEquals(\"function (this:f): number\",\n\n        x.getPropertyType(\"foo\").toString());\n\n    assertFalse(x.isPropertyTypeInferred(\"foo\"));\n\n  }\n"
      }
    }
  },
  "Closure-152": {
    "id": "Closure-152",
    "project": "Closure",
    "number": "152",
    "buggy_function": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  // Warning about typeOfThis if it doesn't resolve to an ObjectType\n  // is handled further upstream.\n  // TODO(nicksantos): Handle this correctly if we have a UnionType.\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}",
    "fixed_function": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  // Warning about typeOfThis if it doesn't resolve to an ObjectType\n  // is handled further upstream.\n  // TODO(nicksantos): Handle this correctly if we have a UnionType.\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis instanceof ObjectType) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/FunctionType.java",
      "first_line": 862,
      "last_line": 892
    },
    "javadoc": "/**\n* Gets the template type name.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse1": {
        "source": "  public void testBackwardsTypedefUse1() throws Exception {\n\n    testTypes(\n\n        \"/** @this {MyTypedef} */ function f() {}\" +\n\n        \"/** @typedef {string} */ var MyTypedef;\",\n\n        \"@this type of a function must be an object\\n\" +\n\n        \"Actual type: string\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse2": {
        "source": "  public void testBackwardsTypedefUse2() throws Exception {\n\n    testTypes(\n\n        \"/** @this {MyTypedef} */ function f() {}\" +\n\n        \"/** @typedef {!(Date|Array)} */ var MyTypedef;\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse3": {
        "source": "  public void testBackwardsTypedefUse3() throws Exception {\n\n    testTypes(\n\n        \"/** @this {MyTypedef} */ function f() {}\" +\n\n        \"/** @typedef {(Date|Array)} */ var MyTypedef;\",\n\n        \"@this type of a function must be an object\\n\" +\n\n        \"Actual type: (Array|Date|null)\");\n\n  }\n"
      }
    }
  },
  "Closure-159": {
    "id": "Closure-159",
    "project": "Closure",
    "number": "159",
    "buggy_function": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n  // For each referenced function, add a new reference\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n\n  for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
    "fixed_function": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n  // For each referenced function, add a new reference\n  if (node.getType() == Token.NAME) {\n    if (isCandidateUsage(node)) {\n      changed.add(node.getString());\n    }\n  }\n\n  for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "first_line": 773,
      "last_line": 787
    },
    "javadoc": "/**\n* @see #findCalledFunctions(Node)\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineFunctionsTest::testIssue423": {
        "source": "  public void testIssue423() {\n\n    test(\n\n        \"(function($) {\\n\" +\n\n        \"  $.fn.multicheck = function(options) {\\n\" +\n\n        \"    initialize.call(this, options);\\n\" +\n\n        \"  };\\n\" +\n\n        \"\\n\" +\n\n        \"  function initialize(options) {\\n\" +\n\n        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n\n        \"    preload_check_all.call(this);\\n\" +\n\n        \"  }\\n\" +\n\n        \"\\n\" +\n\n        \"  function preload_check_all() {\\n\" +\n\n        \"    $(this).data('checkboxes');\\n\" +\n\n        \"  }\\n\" +\n\n        \"})(jQuery)\",\n\n        \"(function($){\" +\n\n        \"  $.fn.multicheck=function(options$$1){\" +\n\n        \"    {\" +\n\n        \"     options$$1.checkboxes=$(this).siblings(\\\":checkbox\\\");\" +\n\n        \"     {\" +\n\n        \"       $(this).data(\\\"checkboxes\\\")\" +\n\n        \"     }\" +\n\n        \"    }\" +\n\n        \"  }\" +\n\n        \"})(jQuery)\");\n\n  }\n"
      }
    }
  },
  "Closure-160": {
    "id": "Closure-160",
    "project": "Closure",
    "number": "160",
    "buggy_function": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n\n\n  // All passes must run the variable check. This synthesizes\n  // variables later so that the compiler doesn't crash. It also\n  // checks the externs file for validity. If you don't want to warn\n  // about missing variable declarations, we shut that specific\n  // error off.\n  if (!options.checkSymbols &&\n      (warningsGuard == null || !warningsGuard.disables(\n          DiagnosticGroups.CHECK_VARIABLES))) {\n    guards.add(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n\n  this.warningsGuard = new ComposeWarningsGuard(guards);\n}",
    "fixed_function": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n\n  ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n  // All passes must run the variable check. This synthesizes\n  // variables later so that the compiler doesn't crash. It also\n  // checks the externs file for validity. If you don't want to warn\n  // about missing variable declarations, we shut that specific\n  // error off.\n  if (!options.checkSymbols &&\n      !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n    composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n\n  this.warningsGuard = composedGuards;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/Compiler.java",
      "first_line": 226,
      "last_line": 282
    },
    "javadoc": "/**\n* Initialize the compiler options. Only necessary if you're not doing\n* a normal compile() job.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testCheckSymbolsOverrideForQuiet": {
        "source": "  public void testCheckSymbolsOverrideForQuiet() {\n\n    args.add(\"--warning_level=QUIET\");\n\n    args.add(\"--jscomp_error=undefinedVars\");\n\n    test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n\n  }\n"
      }
    }
  },
  "Closure-161": {
    "id": "Closure-161",
    "project": "Closure",
    "number": "161",
    "buggy_function": "private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n  Node parent = n.getParent();\n  // If GETPROP/GETELEM is used as assignment target the array literal is\n  // acting as a temporary we can't fold it here:\n  //    \"[][0] += 1\"\n\n  if (right.getType() != Token.NUMBER) {\n    // Sometimes people like to use complex expressions to index into\n    // arrays, or strings to index into array methods.\n    return n;\n  }\n\n  double index = right.getDouble();\n  int intIndex = (int) index;\n  if (intIndex != index) {\n    error(INVALID_GETELEM_INDEX_ERROR, right);\n    return n;\n  }\n\n  if (intIndex < 0) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  Node elem = left.getFirstChild();\n  for (int i = 0; elem != null && i < intIndex; i++) {\n    elem = elem.getNext();\n  }\n\n  if (elem == null) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  if (elem.getType() == Token.EMPTY) {\n    elem = NodeUtil.newUndefinedNode(elem);\n  } else {\n    left.removeChild(elem);\n  }\n\n  // Replace the entire GETELEM with the value\n  n.getParent().replaceChild(n, elem);\n  reportCodeChange();\n  return elem;\n}",
    "fixed_function": "private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n  Node parent = n.getParent();\n  // If GETPROP/GETELEM is used as assignment target the array literal is\n  // acting as a temporary we can't fold it here:\n  //    \"[][0] += 1\"\n  if (isAssignmentTarget(n)) {\n    return n;\n  }\n\n  if (right.getType() != Token.NUMBER) {\n    // Sometimes people like to use complex expressions to index into\n    // arrays, or strings to index into array methods.\n    return n;\n  }\n\n  double index = right.getDouble();\n  int intIndex = (int) index;\n  if (intIndex != index) {\n    error(INVALID_GETELEM_INDEX_ERROR, right);\n    return n;\n  }\n\n  if (intIndex < 0) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  Node elem = left.getFirstChild();\n  for (int i = 0; elem != null && i < intIndex; i++) {\n    elem = elem.getNext();\n  }\n\n  if (elem == null) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  if (elem.getType() == Token.EMPTY) {\n    elem = NodeUtil.newUndefinedNode(elem);\n  } else {\n    left.removeChild(elem);\n  }\n\n  // Replace the entire GETELEM with the value\n  n.getParent().replaceChild(n, elem);\n  reportCodeChange();\n  return elem;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "first_line": 1278,
      "last_line": 1322
    },
    "javadoc": "//    \"{a:x}.a += 1\" is not \"x += 1\"",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testIssue522": {
        "source": "  public void testIssue522() {\n\n    testSame(\"[][1] = 1;\");\n\n  }\n"
      }
    }
  },
  "Closure-164": {
    "id": "Closure-164",
    "project": "Closure",
    "number": "164",
    "buggy_function": "public boolean isSubtype(JSType other) {\n  if (!(other instanceof ArrowType)) {\n    return false;\n  }\n\n  ArrowType that = (ArrowType) other;\n\n  // This is described in Draft 2 of the ES4 spec,\n  // Section 3.4.7: Subtyping Function Types.\n\n  // this.returnType <: that.returnType (covariant)\n  if (!this.returnType.isSubtype(that.returnType)) {\n    return false;\n  }\n\n  // that.paramType[i] <: this.paramType[i] (contravariant)\n  //\n  // If this.paramType[i] is required,\n  // then that.paramType[i] is required.\n  //\n  // In theory, the \"required-ness\" should work in the other direction as\n  // well. In other words, if we have\n  //\n  // function f(number, number) {}\n  // function g(number) {}\n  //\n  // Then f *should* not be a subtype of g, and g *should* not be\n  // a subtype of f. But in practice, we do not implement it this way.\n  // We want to support the use case where you can pass g where f is\n  // expected, and pretend that g ignores the second argument.\n  // That way, you can have a single \"no-op\" function, and you don't have\n  // to create a new no-op function for every possible type signature.\n  //\n  // So, in this case, g < f, but f !< g\n  Node thisParam = parameters.getFirstChild();\n  Node thatParam = that.parameters.getFirstChild();\n  while (thisParam != null && thatParam != null) {\n    JSType thisParamType = thisParam.getJSType();\n    JSType thatParamType = thatParam.getJSType();\n    if (thisParamType != null) {\n      if (thatParamType == null ||\n          !thatParamType.isSubtype(thisParamType)) {\n        return false;\n      }\n    }\n\n    boolean thisIsVarArgs = thisParam.isVarArgs();\n    boolean thatIsVarArgs = thatParam.isVarArgs();\n\n    // \"that\" can't be a supertype, because it's missing a required argument.\n      // NOTE(nicksantos): In our type system, we use {function(...?)} and\n      // {function(...NoType)} to to indicate that arity should not be\n      // checked. Strictly speaking, this is not a correct formulation,\n      // because now a sub-function can required arguments that are var_args\n      // in the super-function. So we special-case this.\n\n    // don't advance if we have variable arguments\n    if (!thisIsVarArgs) {\n      thisParam = thisParam.getNext();\n    }\n    if (!thatIsVarArgs) {\n      thatParam = thatParam.getNext();\n    }\n\n    // both var_args indicates the end\n    if (thisIsVarArgs && thatIsVarArgs) {\n      thisParam = null;\n      thatParam = null;\n    }\n  }\n\n  // \"that\" can't be a supertype, because it's missing a required arguement.\n\n  return true;\n}",
    "fixed_function": "public boolean isSubtype(JSType other) {\n  if (!(other instanceof ArrowType)) {\n    return false;\n  }\n\n  ArrowType that = (ArrowType) other;\n\n  // This is described in Draft 2 of the ES4 spec,\n  // Section 3.4.7: Subtyping Function Types.\n\n  // this.returnType <: that.returnType (covariant)\n  if (!this.returnType.isSubtype(that.returnType)) {\n    return false;\n  }\n\n  // that.paramType[i] <: this.paramType[i] (contravariant)\n  //\n  // If this.paramType[i] is required,\n  // then that.paramType[i] is required.\n  //\n  // In theory, the \"required-ness\" should work in the other direction as\n  // well. In other words, if we have\n  //\n  // function f(number, number) {}\n  // function g(number) {}\n  //\n  // Then f *should* not be a subtype of g, and g *should* not be\n  // a subtype of f. But in practice, we do not implement it this way.\n  // We want to support the use case where you can pass g where f is\n  // expected, and pretend that g ignores the second argument.\n  // That way, you can have a single \"no-op\" function, and you don't have\n  // to create a new no-op function for every possible type signature.\n  //\n  // So, in this case, g < f, but f !< g\n  Node thisParam = parameters.getFirstChild();\n  Node thatParam = that.parameters.getFirstChild();\n  while (thisParam != null && thatParam != null) {\n    JSType thisParamType = thisParam.getJSType();\n    JSType thatParamType = thatParam.getJSType();\n    if (thisParamType != null) {\n      if (thatParamType == null ||\n          !thatParamType.isSubtype(thisParamType)) {\n        return false;\n      }\n    }\n\n    boolean thisIsVarArgs = thisParam.isVarArgs();\n    boolean thatIsVarArgs = thatParam.isVarArgs();\n    boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n    boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n\n    // \"that\" can't be a supertype, because it's missing a required argument.\n    if (!thisIsOptional && thatIsOptional) {\n      // NOTE(nicksantos): In our type system, we use {function(...?)} and\n      // {function(...NoType)} to to indicate that arity should not be\n      // checked. Strictly speaking, this is not a correct formulation,\n      // because now a sub-function can required arguments that are var_args\n      // in the super-function. So we special-case this.\n      boolean isTopFunction =\n          thatIsVarArgs &&\n          (thatParamType == null ||\n           thatParamType.isUnknownType() ||\n           thatParamType.isNoType());\n      if (!isTopFunction) {\n        return false;\n      }\n    }\n\n    // don't advance if we have variable arguments\n    if (!thisIsVarArgs) {\n      thisParam = thisParam.getNext();\n    }\n    if (!thatIsVarArgs) {\n      thatParam = thatParam.getNext();\n    }\n\n    // both var_args indicates the end\n    if (thisIsVarArgs && thatIsVarArgs) {\n      thisParam = null;\n      thatParam = null;\n    }\n  }\n\n  // \"that\" can't be a supertype, because it's missing a required arguement.\n  if (thisParam != null\n      && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n      && thatParam == null) {\n    return false;\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/ArrowType.java",
      "first_line": 80,
      "last_line": 154
    },
    "javadoc": "// Whether the return type is inferred.",
    "failing_tests": {
      "com.google.javascript.jscomp.LooseTypeCheckTest::testMethodInference7": {
        "source": "  public void testMethodInference7() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function F() {}\" +\n\n        \"F.prototype.foo = function() { };\" +\n\n        \"/** @constructor \\n * @extends {F} */ \" +\n\n        \"function G() {}\" +\n\n        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n\n        \"mismatch of the foo property type and the type of the property \" +\n\n        \"it overrides from superclass F\\n\" +\n\n        \"original: function (this:F): undefined\\n\" +\n\n        \"override: function (this:G, ?, ?): undefined\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testMethodInference7": {
        "source": "  public void testMethodInference7() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function F() {}\" +\n\n        \"F.prototype.foo = function() { };\" +\n\n        \"/** @constructor \\n * @extends {F} */ \" +\n\n        \"function G() {}\" +\n\n        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n\n        \"mismatch of the foo property type and the type of the property \" +\n\n        \"it overrides from superclass F\\n\" +\n\n        \"original: function (this:F): undefined\\n\" +\n\n        \"override: function (this:G, ?, ?): undefined\");\n\n  }\n"
      },
      "com.google.javascript.rhino.jstype.FunctionTypeTest::testSupAndInfOfReturnTypesWithNumOfParams": {
        "source": "  public void testSupAndInfOfReturnTypesWithNumOfParams() {\n\n    FunctionType twoNumbers = new FunctionBuilder(registry)\n\n        .withParamsNode(registry.createParameters(NUMBER_TYPE, NUMBER_TYPE))\n\n        .withReturnType(BOOLEAN_TYPE).build();\n\n    FunctionType oneNumber = new FunctionBuilder(registry)\n\n        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n\n        .withReturnType(BOOLEAN_TYPE).build();\n\n\n\n    assertLeastSupertype(\n\n        \"function (number, number): boolean\", twoNumbers, oneNumber);\n\n    assertGreatestSubtype(\n\n        \"function (number): boolean\", twoNumbers, oneNumber);\n\n  }\n"
      }
    }
  },
  "Closure-166": {
    "id": "Closure-166",
    "project": "Closure",
    "number": "166",
    "buggy_function": "public void matchConstraint(JSType constraint) {\n  // We only want to match constraints on anonymous types.\n  if (hasReferenceName()) {\n    return;\n  }\n\n  // Handle the case where the constraint object is a record type.\n  //\n  // param constraint {{prop: (number|undefined)}}\n  // function f(constraint) {}\n  // f({});\n  //\n  // We want to modify the object literal to match the constraint, by\n  // taking any each property on the record and trying to match\n  // properties on this object.\n  if (constraint.isRecordType()) {\n    matchRecordTypeConstraint(constraint.toObjectType());\n  }\n}",
    "fixed_function": "public void matchConstraint(JSType constraint) {\n  // We only want to match constraints on anonymous types.\n  if (hasReferenceName()) {\n    return;\n  }\n\n  // Handle the case where the constraint object is a record type.\n  //\n  // param constraint {{prop: (number|undefined)}}\n  // function f(constraint) {}\n  // f({});\n  //\n  // We want to modify the object literal to match the constraint, by\n  // taking any each property on the record and trying to match\n  // properties on this object.\n  if (constraint.isRecordType()) {\n    matchRecordTypeConstraint(constraint.toObjectType());\n  } else if (constraint.isUnionType()) {\n    for (JSType alt : constraint.toMaybeUnionType().getAlternates()) {\n      if (alt.isRecordType()) {\n        matchRecordTypeConstraint(alt.toObjectType());\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
      "first_line": 556,
      "last_line": 574
    },
    "javadoc": "// to avoid guessing.",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeInferenceTest::testRecordInference": {
        "source": "  public void testRecordInference() {\n\n    inFunction(\n\n        \"/** @param {{a: (boolean|undefined)}|{b: (string|undefined)}} x */\" +\n\n        \"function f(x) {}\" +\n\n        \"var out = {};\" +\n\n        \"f(out);\");\n\n    assertEquals(\"{a: (boolean|undefined), b: (string|undefined)}\",\n\n        getType(\"out\").toString());\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeInferenceTest::testIssue785": {
        "source": "  public void testIssue785() {\n\n    inFunction(\"/** @param {string|{prop: (string|undefined)}} x */\" +\n\n               \"function f(x) {}\" +\n\n               \"var out = {};\" +\n\n               \"f(out);\");\n\n    assertEquals(\"{prop: (string|undefined)}\", getType(\"out\").toString());\n\n  }\n"
      }
    }
  },
  "Closure-168": {
    "id": "Closure-168",
    "project": "Closure",
    "number": "168",
    "buggy_function": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  if (t.getScopeDepth() <= 2) {\n    // The first-order function analyzer looks at two types of variables:\n    //\n    // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n    //\n    // 2) Local variables that are assigned more than once.\n    //\n    // We treat all global variables as escaped by default, so there's\n    // no reason to do this extra computation for them.\n    return;\n  }\n\n  if (n.isName() && NodeUtil.isLValue(n) &&\n      // Be careful of bleeding functions, which create variables\n      // in the inner scope, not the scope where the name appears.\n      !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n      }\n\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}",
    "fixed_function": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  if (t.getScopeDepth() <= 1) {\n    // The first-order function analyzer looks at two types of variables:\n    //\n    // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n    //\n    // 2) Local variables that are assigned more than once.\n    //\n    // We treat all global variables as escaped by default, so there's\n    // no reason to do this extra computation for them.\n    return;\n  }\n\n  if (n.isName() && NodeUtil.isLValue(n) &&\n      // Be careful of bleeding functions, which create variables\n      // in the inner scope, not the scope where the name appears.\n      !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n      }\n\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 1987,
      "last_line": 2038
    },
    "javadoc": "/**\n* Does a first-order function analysis that just looks at simple things\n* like what variables are escaped, and whether 'this' is used.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue726": {
        "source": "  public void testIssue726() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function Foo() {}\" +\n\n        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n\n        \"/** @return {!Function} */ \" +\n\n        \"Foo.prototype.getDeferredBar = function() { \" +\n\n        \"  var self = this;\" +\n\n        \"  return function() {\" +\n\n        \"    self.bar(true);\" +\n\n        \"  };\" +\n\n        \"};\",\n\n        \"actual parameter 1 of Foo.prototype.bar does not match formal parameter\\n\" +\n\n        \"found   : boolean\\n\" +\n\n        \"required: number\");\n\n  }\n"
      }
    }
  },
  "Closure-17": {
    "id": "Closure-17",
    "project": "Closure",
    "number": "17",
    "buggy_function": "private JSType getDeclaredType(String sourceName, JSDocInfo info,\n    Node lValue, @Nullable Node rValue) {\n  if (info != null && info.hasType()) {\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n  } else if (rValue != null && rValue.isFunction() &&\n      shouldUseFunctionLiteralType(\n          JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n    return rValue.getJSType();\n  } else if (info != null) {\n    if (info.hasEnumParameterType()) {\n      if (rValue != null && rValue.isObjectLit()) {\n        return rValue.getJSType();\n      } else {\n        return createEnumTypeFromNodes(\n            rValue, lValue.getQualifiedName(), info, lValue);\n      }\n    } else if (info.isConstructor() || info.isInterface()) {\n      return createFunctionTypeFromNodes(\n          rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n      // Check if this is constant, and if it has a known type.\n      if (info.isConstant()) {\n        JSType knownType = null;\n        if (rValue != null) {\n          if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n            // If rValue has a type-cast, we use the type in the type-cast.\n            // If rValue's type was already computed during scope creation,\n            // then we can safely use that.\n            return rValue.getJSType();\n          } else if (rValue.isOr()) {\n            // Check for a very specific JS idiom:\n            // var x = x || TYPE;\n            // This is used by Closure's base namespace for esoteric\n            // reasons.\n            Node firstClause = rValue.getFirstChild();\n            Node secondClause = firstClause.getNext();\n            boolean namesMatch = firstClause.isName()\n                && lValue.isName()\n                && firstClause.getString().equals(lValue.getString());\n            if (namesMatch && secondClause.getJSType() != null\n                && !secondClause.getJSType().isUnknownType()) {\n              return secondClause.getJSType();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
    "fixed_function": "private JSType getDeclaredType(String sourceName, JSDocInfo info,\n    Node lValue, @Nullable Node rValue) {\n  if (info != null && info.hasType()) {\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n  } else if (rValue != null && rValue.isFunction() &&\n      shouldUseFunctionLiteralType(\n          JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n    return rValue.getJSType();\n  } else if (info != null) {\n    if (info.hasEnumParameterType()) {\n      if (rValue != null && rValue.isObjectLit()) {\n        return rValue.getJSType();\n      } else {\n        return createEnumTypeFromNodes(\n            rValue, lValue.getQualifiedName(), info, lValue);\n      }\n    } else if (info.isConstructor() || info.isInterface()) {\n      return createFunctionTypeFromNodes(\n          rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n      // Check if this is constant, and if it has a known type.\n      if (info.isConstant()) {\n        JSType knownType = null;\n        if (rValue != null) {\n          JSDocInfo rValueInfo = rValue.getJSDocInfo();\n          if (rValueInfo != null && rValueInfo.hasType()) {\n            // If rValue has a type-cast, we use the type in the type-cast.\n            return rValueInfo.getType().evaluate(scope, typeRegistry);\n          } else if (rValue.getJSType() != null\n              && !rValue.getJSType().isUnknownType()) {\n            // If rValue's type was already computed during scope creation,\n            // then we can safely use that.\n            return rValue.getJSType();\n          } else if (rValue.isOr()) {\n            // Check for a very specific JS idiom:\n            // var x = x || TYPE;\n            // This is used by Closure's base namespace for esoteric\n            // reasons.\n            Node firstClause = rValue.getFirstChild();\n            Node secondClause = firstClause.getNext();\n            boolean namesMatch = firstClause.isName()\n                && lValue.isName()\n                && firstClause.getString().equals(lValue.getString());\n            if (namesMatch && secondClause.getJSType() != null\n                && !secondClause.getJSType().isUnknownType()) {\n              return secondClause.getJSType();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 1267,
      "last_line": 1317
    },
    "javadoc": "/**\n* Look for a type declaration on a property assignment\n* (in an ASSIGN or an object literal key).\n*\n* @param info The doc info for this property.\n* @param lValue The l-value node.\n* @param rValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue688": {
        "source": "  public void testIssue688() throws Exception {\n\n    testTypes(\n\n        \"/** @const */ var SOME_DEFAULT =\\n\" +\n\n        \"    /** @type {TwoNumbers} */ ({first: 1, second: 2});\\n\" +\n\n        \"/**\\n\" +\n\n        \"* Class defining an interface with two numbers.\\n\" +\n\n        \"* @interface\\n\" +\n\n        \"*/\\n\" +\n\n        \"function TwoNumbers() {}\\n\" +\n\n        \"/** @type number */\\n\" +\n\n        \"TwoNumbers.prototype.first;\\n\" +\n\n        \"/** @type number */\\n\" +\n\n        \"TwoNumbers.prototype.second;\\n\" +\n\n        \"/** @return {number} */ function f() { return SOME_DEFAULT; }\",\n\n        \"inconsistent return type\\n\" +\n\n        \"found   : (TwoNumbers|null)\\n\" +\n\n        \"required: number\");\n\n  }\n"
      }
    }
  },
  "Closure-172": {
    "id": "Closure-172",
    "project": "Closure",
    "number": "172",
    "buggy_function": "private boolean isQualifiedNameInferred(\n    String qName, Node n, JSDocInfo info,\n    Node rhsValue, JSType valueType) {\n  if (valueType == null) {\n    return true;\n  }\n\n  // Prototypes of constructors and interfaces are always declared.\n  if (qName != null && qName.endsWith(\".prototype\")) {\n      return false;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (isConstantSymbol(info, n) && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    if (info != null) {\n      return false;\n    } else if (!scope.isDeclared(qName, false) &&\n        n.isUnscopedQualifiedName()) {\n\n      // Check if this is in a conditional block.\n      // Functions assigned in conditional blocks are inferred.\n      for (Node current = n.getParent();\n           !(current.isScript() || current.isFunction());\n           current = current.getParent()) {\n        if (NodeUtil.isControlStructure(current)) {\n          return true;\n        }\n      }\n\n      // Check if this is assigned in an inner scope.\n      // Functions assigned in inner scopes are inferred.\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents == null ||\n          !contents.getEscapedQualifiedNames().contains(qName)) {\n        return false;\n      }\n    }\n  }\n  return inferred;\n}",
    "fixed_function": "private boolean isQualifiedNameInferred(\n    String qName, Node n, JSDocInfo info,\n    Node rhsValue, JSType valueType) {\n  if (valueType == null) {\n    return true;\n  }\n\n  // Prototypes of constructors and interfaces are always declared.\n  if (qName != null && qName.endsWith(\".prototype\")) {\n    String className = qName.substring(0, qName.lastIndexOf(\".prototype\"));\n    Var slot = scope.getSlot(className);\n    JSType classType = slot == null ? null : slot.getType();\n    if (classType != null\n        && (classType.isConstructor() || classType.isInterface())) {\n      return false;\n    }\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (isConstantSymbol(info, n) && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    if (info != null) {\n      return false;\n    } else if (!scope.isDeclared(qName, false) &&\n        n.isUnscopedQualifiedName()) {\n\n      // Check if this is in a conditional block.\n      // Functions assigned in conditional blocks are inferred.\n      for (Node current = n.getParent();\n           !(current.isScript() || current.isFunction());\n           current = current.getParent()) {\n        if (NodeUtil.isControlStructure(current)) {\n          return true;\n        }\n      }\n\n      // Check if this is assigned in an inner scope.\n      // Functions assigned in inner scopes are inferred.\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents == null ||\n          !contents.getEscapedQualifiedNames().contains(qName)) {\n        return false;\n      }\n    }\n  }\n  return inferred;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 1661,
      "last_line": 1709
    },
    "javadoc": "/**\n* Determines whether a qualified name is inferred.\n* NOTE(nicksantos): Determining whether a property is declared or not\n* is really really obnoxious.\n*\n* The problem is that there are two (equally valid) coding styles:\n*\n* (function() {\n*   /* The authoritative definition of goog.bar. /\n*   goog.bar = function() {};\n* })();\n*\n* function f() {\n*   goog.bar();\n*   /* Reset goog.bar to a no-op. /\n*   goog.bar = function() {};\n* }\n*\n* In a dynamic language with first-class functions, it's very difficult\n* to know which one the user intended without looking at lots of\n* contextual information (the second example demonstrates a small case\n* of this, but there are some really pathological cases as well).\n*\n* The current algorithm checks if either the declaration has\n* JsDoc type information, or @const with a known type,\n* or a function literal with a name we haven't seen before.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue1024": {
        "source": "  public void testIssue1024() throws Exception {\n\n     testTypes(\n\n        \"/** @param {Object} a */\\n\" +\n\n        \"function f(a) {\\n\" +\n\n        \"  a.prototype = '__proto'\\n\" +\n\n        \"}\\n\" +\n\n        \"/** @param {Object} b\\n\" +\n\n        \" *  @return {!Object}\\n\" +\n\n        \" */\\n\" +\n\n        \"function g(b) {\\n\" +\n\n        \"  return b.prototype\\n\" +\n\n        \"}\\n\");\n\n     /* TODO(blickly): Make this warning go away.\n\n      * This is old behavior, but it doesn't make sense to warn about since\n\n      * both assignments are inferred.\n\n      */\n\n     testTypes(\n\n        \"/** @param {Object} a */\\n\" +\n\n        \"function f(a) {\\n\" +\n\n        \"  a.prototype = {foo:3};\\n\" +\n\n        \"}\\n\" +\n\n        \"/** @param {Object} b\\n\" +\n\n        \" */\\n\" +\n\n        \"function g(b) {\\n\" +\n\n        \"  b.prototype = function(){};\\n\" +\n\n        \"}\\n\",\n\n        \"assignment to property prototype of Object\\n\" +\n\n        \"found   : {foo: number}\\n\" +\n\n        \"required: function (): undefined\");\n\n  }\n"
      }
    }
  },
  "Closure-176": {
    "id": "Closure-176",
    "project": "Closure",
    "number": "176",
    "buggy_function": "private void updateScopeForTypeChange(\n    FlowScope scope, Node left, JSType leftType, JSType resultType) {\n  Preconditions.checkNotNull(resultType);\n  switch (left.getType()) {\n    case Token.NAME:\n      String varName = left.getString();\n      Var var = syntacticScope.getVar(varName);\n      boolean isVarDeclaration = left.hasChildren();\n\n      // When looking at VAR initializers for declared VARs, we tend\n      // to use the declared type over the type it's being\n      // initialized to in the global scope.\n      //\n      // For example,\n      // /** @param {number} */ var f = goog.abstractMethod;\n      // it's obvious that the programmer wants you to use\n      // the declared function signature, not the inferred signature.\n      //\n      // Or,\n      // /** @type {Object.<string>} */ var x = {};\n      // the one-time anonymous object on the right side\n      // is as narrow as it can possibly be, but we need to make\n      // sure we back-infer the <string> element constraint on\n      // the left hand side, so we use the left hand side.\n\n      boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n          // Makes it easier to check for NPEs.\n\n      // TODO(nicksantos): This might be a better check once we have\n      // back-inference of object/array constraints.  It will probably\n      // introduce more type warnings.  It uses the result type iff it's\n      // strictly narrower than the declared var type.\n      //\n      //boolean isVarTypeBetter = isVarDeclaration &&\n      //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n      //     || !resultType.isSubtype(varType));\n\n\n      if (isVarTypeBetter) {\n        redeclareSimpleVar(scope, left, resultType);\n      }\n      left.setJSType(isVarDeclaration || leftType == null ?\n          resultType : null);\n\n      if (var != null && var.isTypeInferred()) {\n        JSType oldType = var.getType();\n        var.setType(oldType == null ?\n            resultType : oldType.getLeastSupertype(resultType));\n      }\n      break;\n    case Token.GETPROP:\n      String qualifiedName = left.getQualifiedName();\n      if (qualifiedName != null) {\n        scope.inferQualifiedSlot(left, qualifiedName,\n            leftType == null ? unknownType : leftType,\n            resultType);\n      }\n\n      left.setJSType(resultType);\n      ensurePropertyDefined(left, resultType);\n      break;\n  }\n}",
    "fixed_function": "private void updateScopeForTypeChange(\n    FlowScope scope, Node left, JSType leftType, JSType resultType) {\n  Preconditions.checkNotNull(resultType);\n  switch (left.getType()) {\n    case Token.NAME:\n      String varName = left.getString();\n      Var var = syntacticScope.getVar(varName);\n      JSType varType = var == null ? null : var.getType();\n      boolean isVarDeclaration = left.hasChildren()\n          && varType != null && !var.isTypeInferred();\n\n      // When looking at VAR initializers for declared VARs, we tend\n      // to use the declared type over the type it's being\n      // initialized to in the global scope.\n      //\n      // For example,\n      // /** @param {number} */ var f = goog.abstractMethod;\n      // it's obvious that the programmer wants you to use\n      // the declared function signature, not the inferred signature.\n      //\n      // Or,\n      // /** @type {Object.<string>} */ var x = {};\n      // the one-time anonymous object on the right side\n      // is as narrow as it can possibly be, but we need to make\n      // sure we back-infer the <string> element constraint on\n      // the left hand side, so we use the left hand side.\n\n      boolean isVarTypeBetter = isVarDeclaration &&\n          // Makes it easier to check for NPEs.\n          !resultType.isNullType() && !resultType.isVoidType();\n\n      // TODO(nicksantos): This might be a better check once we have\n      // back-inference of object/array constraints.  It will probably\n      // introduce more type warnings.  It uses the result type iff it's\n      // strictly narrower than the declared var type.\n      //\n      //boolean isVarTypeBetter = isVarDeclaration &&\n      //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n      //     || !resultType.isSubtype(varType));\n\n\n      if (isVarTypeBetter) {\n        redeclareSimpleVar(scope, left, varType);\n      } else {\n        redeclareSimpleVar(scope, left, resultType);\n      }\n      left.setJSType(resultType);\n\n      if (var != null && var.isTypeInferred()) {\n        JSType oldType = var.getType();\n        var.setType(oldType == null ?\n            resultType : oldType.getLeastSupertype(resultType));\n      }\n      break;\n    case Token.GETPROP:\n      String qualifiedName = left.getQualifiedName();\n      if (qualifiedName != null) {\n        scope.inferQualifiedSlot(left, qualifiedName,\n            leftType == null ? unknownType : leftType,\n            resultType);\n      }\n\n      left.setJSType(resultType);\n      ensurePropertyDefined(left, resultType);\n      break;\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeInference.java",
      "first_line": 523,
      "last_line": 585
    },
    "javadoc": "/**\n* Updates the scope according to the result of a type change, like\n* an assignment or a type cast.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue1056": {
        "source": "  public void testIssue1056() throws Exception {\n\n    testTypes(\n\n        \"/** @type {Array} */ var x = null;\" +\n\n        \"x.push('hi');\",\n\n        \"No properties on this expression\\n\" +\n\n        \"found   : null\\n\" +\n\n        \"required: Object\");\n\n  }\n"
      }
    }
  },
  "Closure-18": {
    "id": "Closure-18",
    "project": "Closure",
    "number": "18",
    "buggy_function": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main JS sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    hoistExterns(externsRoot);\n\n    // Check if the sources need to be re-ordered.\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    hoistNoCompileFiles();\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
    "fixed_function": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main JS sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    hoistExterns(externsRoot);\n\n    // Check if the sources need to be re-ordered.\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement()) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    hoistNoCompileFiles();\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/Compiler.java",
      "first_line": 1240,
      "last_line": 1362
    },
    "javadoc": "/**\n* Parses the externs and main inputs.\n*\n* @return A synthetic root node whose two children are the externs root\n*     and the main root\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.IntegrationTest::testDependencySorting": {
        "source": "  public void testDependencySorting() throws Exception {\n\n    CompilerOptions options = createCompilerOptions();\n\n    options.setDependencyOptions(\n\n        new DependencyOptions()\n\n        .setDependencySorting(true));\n\n    test(\n\n        options,\n\n        new String[] {\n\n          \"goog.require('x');\",\n\n          \"goog.provide('x');\",\n\n        },\n\n        new String[] {\n\n          \"goog.provide('x');\",\n\n          \"goog.require('x');\",\n\n\n\n          // For complicated reasons involving modules,\n\n          // the compiler creates a synthetic source file.\n\n          \"\",\n\n        });\n\n  }\n"
      }
    }
  },
  "Closure-19": {
    "id": "Closure-19",
    "project": "Closure",
    "number": "19",
    "buggy_function": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n\n      // \"this\" references aren't currently modeled in the CFG.\n\n    default:\n      throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n          node.toStringTree());\n  }\n}",
    "fixed_function": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n\n    case Token.THIS:\n      // \"this\" references aren't currently modeled in the CFG.\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n          node.toStringTree());\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
      "first_line": 157,
      "last_line": 178
    },
    "javadoc": "/**\n* Declares a refined type in {@code scope} for the name represented by\n* {@code node}. It must be possible to refine the type of the given node in\n* the given scope, as determined by {@link #getTypeIfRefinable}.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeInferenceTest::testNoThisInference": {
        "source": "  public void testNoThisInference() {\n\n    JSType thisType = createNullableType(OBJECT_TYPE);\n\n    assumingThisType(thisType);\n\n    inFunction(\"var out = 3; if (goog.isNull(this)) out = this;\");\n\n    verify(\"out\", createUnionType(OBJECT_TYPE, NUMBER_TYPE));\n\n  }\n"
      }
    }
  },
  "Closure-2": {
    "id": "Closure-2",
    "project": "Closure",
    "number": "2",
    "buggy_function": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n    String functionName, HashMap<String, ObjectType> properties,\n    HashMap<String, ObjectType> currentProperties,\n    ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  Set<String> currentPropertyNames;\n    // This can be the case if interfaceType is proxy to a non-existent\n    // object (which is a bad type annotation, but shouldn't crash).\n    currentPropertyNames = implicitProto.getOwnPropertyNames();\n  for (String name : currentPropertyNames) {\n    ObjectType oType = properties.get(name);\n    if (oType != null) {\n      if (!interfaceType.getPropertyType(name).isEquivalentTo(\n          oType.getPropertyType(name))) {\n        compiler.report(\n            t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                functionName, name, oType.toString(),\n                interfaceType.toString()));\n      }\n    }\n    currentProperties.put(name, interfaceType);\n  }\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n    checkInterfaceConflictProperties(t, n, functionName, properties,\n        currentProperties, iType);\n  }\n}",
    "fixed_function": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n    String functionName, HashMap<String, ObjectType> properties,\n    HashMap<String, ObjectType> currentProperties,\n    ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  Set<String> currentPropertyNames;\n  if (implicitProto == null) {\n    // This can be the case if interfaceType is proxy to a non-existent\n    // object (which is a bad type annotation, but shouldn't crash).\n    currentPropertyNames = ImmutableSet.of();\n  } else {\n    currentPropertyNames = implicitProto.getOwnPropertyNames();\n  }\n  for (String name : currentPropertyNames) {\n    ObjectType oType = properties.get(name);\n    if (oType != null) {\n      if (!interfaceType.getPropertyType(name).isEquivalentTo(\n          oType.getPropertyType(name))) {\n        compiler.report(\n            t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                functionName, name, oType.toString(),\n                interfaceType.toString()));\n      }\n    }\n    currentProperties.put(name, interfaceType);\n  }\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n    checkInterfaceConflictProperties(t, n, functionName, properties,\n        currentProperties, iType);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeCheck.java",
      "first_line": 1566,
      "last_line": 1592
    },
    "javadoc": "/**\n* Check whether there's any property conflict for for a particular super\n* interface\n* @param t The node traversal object that supplies context\n* @param n The node being visited\n* @param functionName The function name being checked\n* @param properties The property names in the super interfaces that have\n* been visited\n* @param currentProperties The property names in the super interface\n* that have been visited\n* @param interfaceType The super interface that is being visited\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces": {
        "source": "  public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception {\n\n    String js = \"/** @interface \\n\" +\n\n        \" * @extends {nonExistent1} \\n\" +\n\n        \" * @extends {nonExistent2} \\n\" +\n\n        \" */function A() {}\";\n\n    String[] expectedWarnings = {\n\n      \"Bad type annotation. Unknown type nonExistent1\",\n\n      \"Bad type annotation. Unknown type nonExistent2\"\n\n    };\n\n    testTypes(js, expectedWarnings);\n\n  }\n"
      }
    }
  },
  "Closure-20": {
    "id": "Closure-20",
    "project": "Closure",
    "number": "20",
    "buggy_function": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    // Fold String(a) to '' + (a) on immutable literals,\n    // which allows further optimizations\n    //\n    // We can't do this in the general case, because String(a) has\n    // slightly different semantics than '' + (a). See\n    // http://code.google.com/p/closure-compiler/issues/detail?id=759\n    Node value = callTarget.getNext();\n    if (value != null) {\n      Node addition = IR.add(\n          IR.string(\"\").srcref(callTarget),\n          value.detachFromParent());\n      n.getParent().replaceChild(n, addition);\n      reportCodeChange();\n      return addition;\n    }\n  }\n  return n;\n}",
    "fixed_function": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    // Fold String(a) to '' + (a) on immutable literals,\n    // which allows further optimizations\n    //\n    // We can't do this in the general case, because String(a) has\n    // slightly different semantics than '' + (a). See\n    // http://code.google.com/p/closure-compiler/issues/detail?id=759\n    Node value = callTarget.getNext();\n    if (value != null && value.getNext() == null &&\n        NodeUtil.isImmutableValue(value)) {\n      Node addition = IR.add(\n          IR.string(\"\").srcref(callTarget),\n          value.detachFromParent());\n      n.getParent().replaceChild(n, addition);\n      reportCodeChange();\n      return addition;\n    }\n  }\n  return n;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "first_line": 208,
      "last_line": 230
    },
    "javadoc": "// OK, join the IF expression with the FOR expression",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testSimpleFunctionCall": {
        "source": "  public void testSimpleFunctionCall() {\n\n    test(\"var a = String(23)\", \"var a = '' + 23\");\n\n    test(\"var a = String('hello')\", \"var a = '' + 'hello'\");\n\n    testSame(\"var a = String('hello', bar());\");\n\n    testSame(\"var a = String({valueOf: function() { return 1; }});\");\n\n  }\n"
      }
    }
  },
  "Closure-21": {
    "id": "Closure-21",
    "project": "Closure",
    "number": "21",
    "buggy_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (n.isEmpty() ||\n      n.isComma()) {\n    return;\n  }\n\n  if (parent == null) {\n    return;\n  }\n\n  // Do not try to remove a block or an expr result. We already handle\n  // these cases when we visit the child, and the peephole passes will\n  // fix up the tree in more clever ways when these are removed.\n  if (n.isExprResult()) {\n    return;\n  }\n\n  // This no-op statement was there so that JSDoc information could\n  // be attached to the name. This check should not complain about it.\n  if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n    return;\n  }\n\n  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n  if (parent.getType() == Token.COMMA) {\n    if (isResultUsed) {\n      return;\n    }\n    if (n == parent.getLastChild()) {\n      for (Node an : parent.getAncestors()) {\n        int ancestorType = an.getType();\n        if (ancestorType == Token.COMMA) continue;\n        if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n        else break;\n      }\n    }\n  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n    if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n      return;\n    }\n  }\n  if (\n      (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    t.getCompiler().report(\n        t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "fixed_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (n.isEmpty() ||\n      n.isComma()) {\n    return;\n  }\n\n  if (parent == null) {\n    return;\n  }\n\n  // Do not try to remove a block or an expr result. We already handle\n  // these cases when we visit the child, and the peephole passes will\n  // fix up the tree in more clever ways when these are removed.\n  if (n.isExprResult() || n.isBlock()) {\n    return;\n  }\n\n  // This no-op statement was there so that JSDoc information could\n  // be attached to the name. This check should not complain about it.\n  if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n    return;\n  }\n\n  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n  if (!isResultUsed &&\n      (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    t.getCompiler().report(\n        t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "first_line": 84,
      "last_line": 148
    },
    "javadoc": "//",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode": {
        "source": "  public void testUselessCode() {\n\n    test(\"function f(x) { if(x) return; }\", ok);\n\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n\n\n    test(\"if(x) x = y;\", ok);\n\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n\n\n    test(\"x = 3;\", ok);\n\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n\n\n    test(\"var x = 'test'\", ok);\n\n    test(\"var x = 'test'\\n'str'\",\n\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n\n\n    test(\"\", ok);\n\n    test(\"foo();;;;bar();;;;\", ok);\n\n\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n\n    test(\"var a, b; a = 5, b == 6\",\n\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n\n    test(\"var a, b; a = (5, 6)\",\n\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n\n    test(\"var a, b; a = (bar(), 6, 7)\",\n\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n\n  }\n"
      }
    }
  },
  "Closure-22": {
    "id": "Closure-22",
    "project": "Closure",
    "number": "22",
    "buggy_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (n.isEmpty() ||\n      n.isComma()) {\n    return;\n  }\n\n  if (parent == null) {\n    return;\n  }\n\n  // Do not try to remove a block or an expr result. We already handle\n  // these cases when we visit the child, and the peephole passes will\n  // fix up the tree in more clever ways when these are removed.\n  if (parent.getType() == Token.COMMA) {\n    Node gramps = parent.getParent();\n    if (gramps.isCall() && parent == gramps.getFirstChild()) {\n      if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n      }\n  }\n\n  // This no-op statement was there so that JSDoc information could\n  // be attached to the name. This check should not complain about it.\n    if (n == parent.getLastChild()) {\n      for (Node an : parent.getAncestors()) {\n        int ancestorType = an.getType();\n        if (ancestorType == Token.COMMA)\n          continue;\n        if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n          return;\n        else\n          break;\n      }\n    }\n  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n    if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n         n == parent.getFirstChild().getNext().getNext())) {\n    } else {\n    return;\n    }\n  }\n\n  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n  if (!isResultUsed &&\n      (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    } else if (n.isExprResult()) {\n      return;\n    }\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    t.getCompiler().report(\n        t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "fixed_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (n.isEmpty() ||\n      n.isComma()) {\n    return;\n  }\n\n  if (parent == null) {\n    return;\n  }\n\n  // Do not try to remove a block or an expr result. We already handle\n  // these cases when we visit the child, and the peephole passes will\n  // fix up the tree in more clever ways when these are removed.\n  if (n.isExprResult() || n.isBlock()) {\n    return;\n  }\n\n  // This no-op statement was there so that JSDoc information could\n  // be attached to the name. This check should not complain about it.\n  if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n    return;\n  }\n\n  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n  if (!isResultUsed &&\n      (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    t.getCompiler().report(\n        t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "first_line": 84,
      "last_line": 155
    },
    "javadoc": "//",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode": {
        "source": "  public void testUselessCode() {\n\n    test(\"function f(x) { if(x) return; }\", ok);\n\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n\n\n    test(\"if(x) x = y;\", ok);\n\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n\n\n    test(\"x = 3;\", ok);\n\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n\n\n    test(\"var x = 'test'\", ok);\n\n    test(\"var x = 'test'\\n'str'\",\n\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n\n\n    test(\"\", ok);\n\n    test(\"foo();;;;bar();;;;\", ok);\n\n\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n\n    test(\"var a, b; a = 5, b == 6\",\n\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n\n    test(\"var a, b; a = (5, 6)\",\n\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n\n    test(\"var a, b; a = (bar(), 6, 7)\",\n\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n\n  }\n"
      }
    }
  },
  "Closure-23": {
    "id": "Closure-23",
    "project": "Closure",
    "number": "23",
    "buggy_function": "private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n  Node parent = n.getParent();\n  // If GETPROP/GETELEM is used as assignment target the array literal is\n  // acting as a temporary we can't fold it here:\n  //    \"[][0] += 1\"\n  if (isAssignmentTarget(n)) {\n    return n;\n  }\n\n  if (!right.isNumber()) {\n    // Sometimes people like to use complex expressions to index into\n    // arrays, or strings to index into array methods.\n    return n;\n  }\n\n  double index = right.getDouble();\n  int intIndex = (int) index;\n  if (intIndex != index) {\n    error(INVALID_GETELEM_INDEX_ERROR, right);\n    return n;\n  }\n\n  if (intIndex < 0) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  Node current = left.getFirstChild();\n  Node elem = null;\n  for (int i = 0; current != null && i < intIndex; i++) {\n      elem = current;\n\n    current = current.getNext();\n  }\n\n  if (elem == null) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  if (elem.isEmpty()) {\n    elem = NodeUtil.newUndefinedNode(elem);\n  } else {\n    left.removeChild(elem);\n  }\n\n  // Replace the entire GETELEM with the value\n  n.getParent().replaceChild(n, elem);\n  reportCodeChange();\n  return elem;\n}",
    "fixed_function": "private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n  Node parent = n.getParent();\n  // If GETPROP/GETELEM is used as assignment target the array literal is\n  // acting as a temporary we can't fold it here:\n  //    \"[][0] += 1\"\n  if (isAssignmentTarget(n)) {\n    return n;\n  }\n\n  if (!right.isNumber()) {\n    // Sometimes people like to use complex expressions to index into\n    // arrays, or strings to index into array methods.\n    return n;\n  }\n\n  double index = right.getDouble();\n  int intIndex = (int) index;\n  if (intIndex != index) {\n    error(INVALID_GETELEM_INDEX_ERROR, right);\n    return n;\n  }\n\n  if (intIndex < 0) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  Node current = left.getFirstChild();\n  Node elem = null;\n  for (int i = 0; current != null; i++) {\n    if (i != intIndex) {\n      if (mayHaveSideEffects(current)) {\n        return n;\n      }\n    } else {\n      elem = current;\n    }\n\n    current = current.getNext();\n  }\n\n  if (elem == null) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n    return n;\n  }\n\n  if (elem.isEmpty()) {\n    elem = NodeUtil.newUndefinedNode(elem);\n  } else {\n    left.removeChild(elem);\n  }\n\n  // Replace the entire GETELEM with the value\n  n.getParent().replaceChild(n, elem);\n  reportCodeChange();\n  return elem;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "first_line": 1422,
      "last_line": 1472
    },
    "javadoc": "//    \"{a:x}.a += 1\" is not \"x += 1\"",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldGetElem": {
        "source": "  public void testFoldGetElem() {\n\n    fold(\"x = [,10][0]\", \"x = void 0\");\n\n    fold(\"x = [10, 20][0]\", \"x = 10\");\n\n    fold(\"x = [10, 20][1]\", \"x = 20\");\n\n    fold(\"x = [10, 20][0.5]\", \"\",\n\n        PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR);\n\n    fold(\"x = [10, 20][-1]\",    \"\",\n\n        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n\n    fold(\"x = [10, 20][2]\",     \"\",\n\n        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n\n\n\n    foldSame(\"x = [foo(), 0][1]\");\n\n    fold(\"x = [0, foo()][1]\", \"x = foo()\");\n\n    foldSame(\"x = [0, foo()][0]\");\n\n  }\n"
      }
    }
  },
  "Closure-24": {
    "id": "Closure-24",
    "project": "Closure",
    "number": "24",
    "buggy_function": "private void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n      String name = n.getString();\n      Var aliasVar = scope.getVar(name);\n      aliases.put(name, aliasVar);\n\n      String qualifiedName =\n          aliasVar.getInitialValue().getQualifiedName();\n      transformation.addAlias(name, qualifiedName);\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else {\n      // TODO(robbyw): Support using locals for private variables.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n    }\n  }\n}",
    "fixed_function": "private void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar() &&\n        n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n      String name = n.getString();\n      Var aliasVar = scope.getVar(name);\n      aliases.put(name, aliasVar);\n\n      String qualifiedName =\n          aliasVar.getInitialValue().getQualifiedName();\n      transformation.addAlias(name, qualifiedName);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else {\n      // TODO(robbyw): Support using locals for private variables.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ScopedAliases.java",
      "first_line": 272,
      "last_line": 297
    },
    "javadoc": "// Do not traverse in to functions except for goog.scope functions.",
    "failing_tests": {
      "com.google.javascript.jscomp.ScopedAliasesTest::testNonAliasLocal": {
        "source": "  public void testNonAliasLocal() {\n\n    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog.dom + 10\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog['dom']\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog.dom, y = 10\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"function f() {}\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n  }\n"
      }
    }
  },
  "Closure-25": {
    "id": "Closure-25",
    "project": "Closure",
    "number": "25",
    "buggy_function": "private FlowScope traverseNew(Node n, FlowScope scope) {\n\n  Node constructor = n.getFirstChild();\n  scope = traverse(constructor, scope);\n  JSType constructorType = constructor.getJSType();\n  JSType type = null;\n  if (constructorType != null) {\n    constructorType = constructorType.restrictByNotNullOrUndefined();\n    if (constructorType.isUnknownType()) {\n      type = getNativeType(UNKNOWN_TYPE);\n    } else {\n      FunctionType ct = constructorType.toMaybeFunctionType();\n      if (ct == null && constructorType instanceof FunctionType) {\n        // If constructorType is a NoObjectType, then toMaybeFunctionType will\n        // return null. But NoObjectType implements the FunctionType\n        // interface, precisely because it can validly construct objects.\n        ct = (FunctionType) constructorType;\n      }\n      if (ct != null && ct.isConstructor()) {\n        type = ct.getInstanceType();\n      }\n    }\n  }\n  n.setJSType(type);\n  for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n    scope = traverse(arg, scope);\n  }\n  return scope;\n}",
    "fixed_function": "private FlowScope traverseNew(Node n, FlowScope scope) {\n  scope = traverseChildren(n, scope);\n\n  Node constructor = n.getFirstChild();\n  JSType constructorType = constructor.getJSType();\n  JSType type = null;\n  if (constructorType != null) {\n    constructorType = constructorType.restrictByNotNullOrUndefined();\n    if (constructorType.isUnknownType()) {\n      type = getNativeType(UNKNOWN_TYPE);\n    } else {\n      FunctionType ct = constructorType.toMaybeFunctionType();\n      if (ct == null && constructorType instanceof FunctionType) {\n        // If constructorType is a NoObjectType, then toMaybeFunctionType will\n        // return null. But NoObjectType implements the FunctionType\n        // interface, precisely because it can validly construct objects.\n        ct = (FunctionType) constructorType;\n      }\n      if (ct != null && ct.isConstructor()) {\n        type = ct.getInstanceType();\n        backwardsInferenceFromCallSite(n, ct);\n      }\n    }\n  }\n  n.setJSType(type);\n  return scope;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeInference.java",
      "first_line": 1035,
      "last_line": 1063
    },
    "javadoc": "// types of the arguments match.",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeInferenceTest::testBackwardsInferenceNew": {
        "source": "  public void testBackwardsInferenceNew() {\n\n    inFunction(\n\n        \"/**\\n\" +\n\n        \" * @constructor\\n\" +\n\n        \" * @param {{foo: (number|undefined)}} x\\n\" +\n\n        \" */\" +\n\n        \"function F(x) {}\" +\n\n        \"var y = {};\" +\n\n        \"new F(y);\");\n\n\n\n    assertEquals(\"{foo: (number|undefined)}\", getType(\"y\").toString());\n\n  }\n"
      }
    }
  },
  "Closure-29": {
    "id": "Closure-29",
    "project": "Closure",
    "number": "29",
    "buggy_function": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Ignore indirect references, like x.y (except x.y(), since\n    // the function referenced by y might reference 'this').\n    //\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target maybe using the object as a 'this' value.\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // NOTE(nicksantos): This pass's object-splitting algorithm has\n      // a blind spot. It assumes that if a property isn't defined on an\n      // object, then the value is undefined. This is not true, because\n      // Object.prototype can have arbitrary properties on it.\n      //\n      // We short-circuit this problem by bailing out if we see a reference\n      // to a property that isn't defined on the object literal. This\n      // isn't a perfect algorithm, but it should catch most cases.\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Make sure that the value is not self-refential. IOW,\n    // disallow things like x = {b: x.a}.\n    //\n    // TODO: Only exclude unorderable self-referential\n    // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n    // but x = {a: 1, b: x.a} is.\n    //\n    // Also, ES5 getters/setters aren't handled by this pass.\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        // ES5 get/set not supported.\n        return false;\n      }\n\n\n      Node childVal = child.getFirstChild();\n      // Check if childVal is the parent of any of the passed in\n      // references, as that is how self-referential assignments\n      // will happen.\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // There's a self-referential assignment\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n\n\n    // We have found an acceptable object literal assignment. As\n    // long as there are no other assignments that mess things up,\n    // we can inline.\n    ret = true;\n  }\n  return ret;\n}",
    "fixed_function": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Ignore indirect references, like x.y (except x.y(), since\n    // the function referenced by y might reference 'this').\n    //\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target maybe using the object as a 'this' value.\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // NOTE(nicksantos): This pass's object-splitting algorithm has\n      // a blind spot. It assumes that if a property isn't defined on an\n      // object, then the value is undefined. This is not true, because\n      // Object.prototype can have arbitrary properties on it.\n      //\n      // We short-circuit this problem by bailing out if we see a reference\n      // to a property that isn't defined on the object literal. This\n      // isn't a perfect algorithm, but it should catch most cases.\n      String propName = parent.getLastChild().getString();\n      if (!validProperties.contains(propName)) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n          validProperties.add(propName);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Make sure that the value is not self-refential. IOW,\n    // disallow things like x = {b: x.a}.\n    //\n    // TODO: Only exclude unorderable self-referential\n    // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n    // but x = {a: 1, b: x.a} is.\n    //\n    // Also, ES5 getters/setters aren't handled by this pass.\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        // ES5 get/set not supported.\n        return false;\n      }\n\n      validProperties.add(child.getString());\n\n      Node childVal = child.getFirstChild();\n      // Check if childVal is the parent of any of the passed in\n      // references, as that is how self-referential assignments\n      // will happen.\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // There's a self-referential assignment\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n\n\n    // We have found an acceptable object literal assignment. As\n    // long as there are no other assignments that mess things up,\n    // we can inline.\n    ret = true;\n  }\n  return ret;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
      "first_line": 155,
      "last_line": 240
    },
    "javadoc": "/**\n* Counts the number of direct (full) references to an object.\n* Specifically we check for references of the following type:\n* <pre>\n*   x;\n*   x.fn();\n* </pre>\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineObjectLiteralsTest::testObject10": {
        "source": "  public void testObject10() {\n\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b);\",\n\n         \"var JSCompiler_object_inline_a_0;\" +\n\n         \"var JSCompiler_object_inline_b_1;\" +\n\n         \"var b = f();\" +\n\n         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;\" +\n\n         \"if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)\");\n\n    testLocal(\"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\",\n\n         \"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\");\n\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; x.c = c; if(x.a) g(x.b) + x.c\",\n\n         \"var JSCompiler_object_inline_a_0;\" +\n\n         \"var JSCompiler_object_inline_b_1;\" +\n\n         \"var JSCompiler_object_inline_c_2;\" +\n\n         \"var b = f();\" +\n\n         \"JSCompiler_object_inline_a_0 = a,JSCompiler_object_inline_b_1 = b, \" +\n\n         \"  JSCompiler_object_inline_c_2=void 0,true;\" +\n\n         \"JSCompiler_object_inline_c_2 = c;\" +\n\n         \"if (JSCompiler_object_inline_a_0)\" +\n\n         \"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2;\");\n\n    testLocal(\"var x = {a:a}; if (b) x={b:b}; f(x.a||x.b);\",\n\n         \"var JSCompiler_object_inline_a_0 = a;\" +\n\n         \"var JSCompiler_object_inline_b_1;\" +\n\n         \"if(b) JSCompiler_object_inline_b_1 = b,\" +\n\n         \"      JSCompiler_object_inline_a_0 = void 0,\" +\n\n         \"      true;\" +\n\n         \"f(JSCompiler_object_inline_a_0 || JSCompiler_object_inline_b_1)\");\n\n    testLocal(\"var x; var y = 5; x = {a:a, b:b, c:c}; if (b) x={b:b}; f(x.a||x.b);\",\n\n         \"var JSCompiler_object_inline_a_0;\" +\n\n         \"var JSCompiler_object_inline_b_1;\" +\n\n         \"var JSCompiler_object_inline_c_2;\" +\n\n         \"var y=5;\" +\n\n         \"JSCompiler_object_inline_a_0=a,\" +\n\n         \"JSCompiler_object_inline_b_1=b,\" +\n\n         \"JSCompiler_object_inline_c_2=c,\" +\n\n         \"true;\" +\n\n         \"if (b) JSCompiler_object_inline_b_1=b,\" +\n\n         \"       JSCompiler_object_inline_a_0=void 0,\" +\n\n         \"       JSCompiler_object_inline_c_2=void 0,\" +\n\n         \"       true;\" +\n\n         \"f(JSCompiler_object_inline_a_0||JSCompiler_object_inline_b_1)\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineObjectLiteralsTest::testObject12": {
        "source": "  public void testObject12() {\n\n    testLocal(\"var a; a = {x:1, y:2}; f(a.x, a.y2);\",\n\n        \"var a; a = {x:1, y:2}; f(a.x, a.y2);\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineObjectLiteralsTest::testObject22": {
        "source": "  public void testObject22() {\n\n    testLocal(\"while(1) { var a = {y:1}; if (b) a.x = 2; f(a.y, a.x);}\",\n\n      \"for(;1;){\" +\n\n      \" var JSCompiler_object_inline_y_0=1;\" +\n\n      \" var JSCompiler_object_inline_x_1;\" +\n\n      \" if(b) JSCompiler_object_inline_x_1=2;\" +\n\n      \" f(JSCompiler_object_inline_y_0,JSCompiler_object_inline_x_1)\" +\n\n      \"}\");\n\n\n\n    testLocal(\"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\",\n\n        \"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.InlineObjectLiteralsTest::testIssue724": {
        "source": "  public void testIssue724() {\n\n    testSameLocal(\n\n        \"var getType; getType = {};\" +\n\n        \"return functionToCheck && \" +\n\n        \"   getType.toString.apply(functionToCheck) === \" +\n\n        \"   '[object Function]';\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.IntegrationTest::testIssue724": {
        "source": "  public void testIssue724() {\n\n    CompilerOptions options = createCompilerOptions();\n\n    CompilationLevel.ADVANCED_OPTIMIZATIONS\n\n        .setOptionsForCompilationLevel(options);\n\n    String code =\n\n        \"isFunction = function(functionToCheck) {\" +\n\n        \"  var getType = {};\" +\n\n        \"  return functionToCheck && \" +\n\n        \"      getType.toString.apply(functionToCheck) === \" +\n\n        \"     '[object Function]';\" +\n\n        \"};\";\n\n    String result =\n\n        \"isFunction=function(a){var b={};\" +\n\n        \"return a&&\\\"[object Function]\\\"===b.b.a(a)}\";\n\n\n\n    test(options, code, result);\n\n  }\n"
      }
    }
  },
  "Closure-31": {
    "id": "Closure-31",
    "project": "Closure",
    "number": "31",
    "buggy_function": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
    "fixed_function": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/Compiler.java",
      "first_line": 1236,
      "last_line": 1387
    },
    "javadoc": "/**\n* Parses the externs and main inputs.\n*\n* @return A synthetic root node whose two children are the externs root\n*     and the main root\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testDependencySortingWhitespaceMode": {
        "source": "  public void testDependencySortingWhitespaceMode() {\n\n    args.add(\"--manage_closure_dependencies\");\n\n    args.add(\"--compilation_level=WHITESPACE_ONLY\");\n\n    test(new String[] {\n\n          \"goog.require('beer');\",\n\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n\n          \"goog.provide('hops');\",\n\n         },\n\n         new String[] {\n\n          \"goog.provide('hops');\",\n\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n\n          \"goog.require('beer');\"\n\n         });\n\n  }\n"
      }
    }
  },
  "Closure-32": {
    "id": "Closure-32",
    "project": "Closure",
    "number": "32",
    "buggy_function": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n            // All tokens must be separated by a space.\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        if (builder.length() > 0) {\n          builder.append(' ');\n        }\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}",
    "fixed_function": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n  int lineStartChar = -1;\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n          lineStartChar = stream.getCharno() + 1;\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        lineStartChar = 0;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n        boolean isEOC = token == JsDocToken.EOC;\n        if (!isEOC) {\n          if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n            int numSpaces = stream.getCharno() - lineStartChar;\n            for (int i = 0; i < numSpaces; i++) {\n              builder.append(' ');\n            }\n            lineStartChar = -1;\n          } else if (builder.length() > 0) {\n            // All tokens must be separated by a space.\n            builder.append(' ');\n          }\n        }\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "first_line": 1329,
      "last_line": 1429
    },
    "javadoc": "/**\n* Extracts the text found on the current line and all subsequent\n* until either an annotation, end of comment or end of file is reached.\n* Note that if this method detects an end of line as the first token, it\n* will quit immediately (indicating that there is no text where it was\n* expected).  Note that token = info.token; should be called after this\n* method is used to update the token properly in the parser.\n*\n* @param token The start token.\n* @param option How to handle whitespace.\n*\n* @return The extraction information.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.IntegrationTest::testIssue701": {
        "source": "  public void testIssue701() {\n\n    // Check ASCII art in license comments.\n\n    String ascii = \"/**\\n\" +\n\n        \" * @preserve\\n\" +\n\n        \"   This\\n\" +\n\n        \"     is\\n\" +\n\n        \"       ASCII    ART\\n\" +\n\n        \"*/\";\n\n    String result = \"/*\\n\\n\" +\n\n        \"   This\\n\" +\n\n        \"     is\\n\" +\n\n        \"       ASCII    ART\\n\" +\n\n        \"*/\\n\";\n\n    testSame(createCompilerOptions(), ascii);\n\n    assertEquals(result, lastCompiler.toSource());\n\n  }\n"
      },
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicense": {
        "source": "  public void testParseLicense() throws Exception {\n\n    Node node = new Node(1);\n\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n\n    String comment = \"@license Foo\\nBar\\n\\nBaz*/\";\n\n    parse(comment);\n\n    assertEquals(\" Foo\\nBar\\n\\nBaz\", node.getJSDocInfo().getLicense());\n\n  }\n"
      },
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParsePreserve": {
        "source": "  public void testParsePreserve() throws Exception {\n\n    Node node = new Node(1);\n\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n\n    String comment = \"@preserve Foo\\nBar\\n\\nBaz*/\";\n\n    parse(comment);\n\n    assertEquals(\" Foo\\nBar\\n\\nBaz\", node.getJSDocInfo().getLicense());\n\n  }\n"
      },
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicenseAscii": {
        "source": "  public void testParseLicenseAscii() throws Exception {\n\n    Node node = new Node(1);\n\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n\n    String comment = \"@license Foo\\n *   Bar\\n\\n  Baz*/\";\n\n    parse(comment);\n\n    assertEquals(\" Foo\\n   Bar\\n\\n  Baz\", node.getJSDocInfo().getLicense());\n\n  }\n"
      }
    }
  },
  "Closure-33": {
    "id": "Closure-33",
    "project": "Closure",
    "number": "33",
    "buggy_function": "public void matchConstraint(ObjectType constraintObj) {\n  // We only want to match contraints on anonymous types.\n\n  // Handle the case where the constraint object is a record type.\n  //\n  // param constraintObj {{prop: (number|undefined)}}\n  // function f(constraintObj) {}\n  // f({});\n  //\n  // We want to modify the object literal to match the constraint, by\n  // taking any each property on the record and trying to match\n  // properties on this object.\n  if (constraintObj.isRecordType()) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!isPropertyTypeDeclared(prop)) {\n        JSType typeToInfer = propType;\n        if (!hasProperty(prop)) {\n          typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(propType);\n        }\n        defineInferredProperty(prop, typeToInfer, null);\n      }\n    }\n  }\n}",
    "fixed_function": "public void matchConstraint(ObjectType constraintObj) {\n  // We only want to match contraints on anonymous types.\n  if (hasReferenceName()) {\n    return;\n  }\n\n  // Handle the case where the constraint object is a record type.\n  //\n  // param constraintObj {{prop: (number|undefined)}}\n  // function f(constraintObj) {}\n  // f({});\n  //\n  // We want to modify the object literal to match the constraint, by\n  // taking any each property on the record and trying to match\n  // properties on this object.\n  if (constraintObj.isRecordType()) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!isPropertyTypeDeclared(prop)) {\n        JSType typeToInfer = propType;\n        if (!hasProperty(prop)) {\n          typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(propType);\n        }\n        defineInferredProperty(prop, typeToInfer, null);\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
      "first_line": 555,
      "last_line": 580
    },
    "javadoc": "// to avoid guessing.",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue700": {
        "source": "  public void testIssue700() throws Exception {\n\n    testTypes(\n\n        \"/**\\n\" +\n\n        \" * @param {{text: string}} opt_data\\n\" +\n\n        \" * @return {string}\\n\" +\n\n        \" */\\n\" +\n\n        \"function temp1(opt_data) {\\n\" +\n\n        \"  return opt_data.text;\\n\" +\n\n        \"}\\n\" +\n\n        \"\\n\" +\n\n        \"/**\\n\" +\n\n        \" * @param {{activity: (boolean|number|string|null|Object)}} opt_data\\n\" +\n\n        \" * @return {string}\\n\" +\n\n        \" */\\n\" +\n\n        \"function temp2(opt_data) {\\n\" +\n\n        \"  /** @notypecheck */\\n\" +\n\n        \"  function __inner() {\\n\" +\n\n        \"    return temp1(opt_data.activity);\\n\" +\n\n        \"  }\\n\" +\n\n        \"  return __inner();\\n\" +\n\n        \"}\\n\" +\n\n        \"\\n\" +\n\n        \"/**\\n\" +\n\n        \" * @param {{n: number, text: string, b: boolean}} opt_data\\n\" +\n\n        \" * @return {string}\\n\" +\n\n        \" */\\n\" +\n\n        \"function temp3(opt_data) {\\n\" +\n\n        \"  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\\n\" +\n\n        \"}\\n\" +\n\n        \"\\n\" +\n\n        \"function callee() {\\n\" +\n\n        \"  var output = temp3({\\n\" +\n\n        \"    n: 0,\\n\" +\n\n        \"    text: 'a string',\\n\" +\n\n        \"    b: true\\n\" +\n\n        \"  })\\n\" +\n\n        \"  alert(output);\\n\" +\n\n        \"}\\n\" +\n\n        \"\\n\" +\n\n        \"callee();\");\n\n  }\n"
      }
    }
  },
  "Closure-35": {
    "id": "Closure-35",
    "project": "Closure",
    "number": "35",
    "buggy_function": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj != null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType != null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}",
    "fixed_function": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj != null) {\n    type.matchConstraint(constraintObj);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeInference.java",
      "first_line": 1113,
      "last_line": 1137
    },
    "javadoc": "/**\n* Suppose X is an object with inferred properties.\n* Suppose also that X is used in a way where it would only type-check\n* correctly if some of those properties are widened.\n* Then we should be polite and automatically widen X's properties for him.\n*\n* For a concrete example, consider:\n* param x {{prop: (number|undefined)}}\n* function f(x) {}\n* f({});\n*\n* If we give the anonymous object an inferred property of (number|undefined),\n* then this code will type-check appropriately.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue669": {
        "source": "  public void testIssue669() throws Exception {\n\n    testTypes(\n\n        \"/** @return {{prop1: (Object|undefined)}} */\" +\n\n         \"function f(a) {\" +\n\n         \"  var results;\" +\n\n         \"  if (a) {\" +\n\n         \"    results = {};\" +\n\n         \"    results.prop1 = {a: 3};\" +\n\n         \"  } else {\" +\n\n         \"    results = {prop2: 3};\" +\n\n         \"  }\" +\n\n         \"  return results;\" +\n\n         \"}\");\n\n  }\n"
      }
    }
  },
  "Closure-36": {
    "id": "Closure-36",
    "project": "Closure",
    "number": "36",
    "buggy_function": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n\n  // If the value is read more than once, skip it.\n  // VAR declarations and EXPR_RESULT don't need the value, but other\n  // ASSIGN expressions parents do.\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n\n  // Be very conservative and do no cross control structures or\n  // scope boundaries\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n\n  // Do not inline into a call node. This would change\n  // the context in which it was being called. For example,\n  //   var a = b.c;\n  //   a();\n  // should not be inlined, because it calls a in the context of b\n  // rather than the context of the window.\n  //   var a = b.c;\n  //   f(a)\n  // is ok.\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      // Bug 2388531: Don't inline subclass definitions into class defining\n      // calls as this confused class removing logic.\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n\n      // issue 668: Don't inline singleton getter methods\n      // calls as this confused class removing logic.\n    }\n  }\n\n  return canMoveAggressively(value) ||\n      canMoveModerately(initialization, reference);\n}",
    "fixed_function": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n\n  // If the value is read more than once, skip it.\n  // VAR declarations and EXPR_RESULT don't need the value, but other\n  // ASSIGN expressions parents do.\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n\n  // Be very conservative and do no cross control structures or\n  // scope boundaries\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n\n  // Do not inline into a call node. This would change\n  // the context in which it was being called. For example,\n  //   var a = b.c;\n  //   a();\n  // should not be inlined, because it calls a in the context of b\n  // rather than the context of the window.\n  //   var a = b.c;\n  //   f(a)\n  // is ok.\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      // Bug 2388531: Don't inline subclass definitions into class defining\n      // calls as this confused class removing logic.\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n\n      // issue 668: Don't inline singleton getter methods\n      // calls as this confused class removing logic.\n      if (convention.getSingletonGetterClassName(callNode) != null) {\n        return false;\n      }\n    }\n  }\n\n  return canMoveAggressively(value) ||\n      canMoveModerately(initialization, reference);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/InlineVariables.java",
      "first_line": 519,
      "last_line": 580
    },
    "javadoc": "/**\n* @return true if the provided reference and declaration can be safely\n*         inlined according to our criteria\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.IntegrationTest::testSingletonGetter1": {
        "source": "  public void testSingletonGetter1() {\n\n    CompilerOptions options = createCompilerOptions();\n\n    CompilationLevel.ADVANCED_OPTIMIZATIONS\n\n        .setOptionsForCompilationLevel(options);\n\n    options.setCodingConvention(new ClosureCodingConvention());\n\n    test(options,\n\n        \"/** @const */\\n\" +\n\n        \"var goog = goog || {};\\n\" +\n\n        \"goog.addSingletonGetter = function(ctor) {\\n\" +\n\n        \"  ctor.getInstance = function() {\\n\" +\n\n        \"    return ctor.instance_ || (ctor.instance_ = new ctor());\\n\" +\n\n        \"  };\\n\" +\n\n        \"};\" +\n\n        \"function Foo() {}\\n\" +\n\n        \"goog.addSingletonGetter(Foo);\" +\n\n        \"Foo.prototype.bar = 1;\" +\n\n        \"function Bar() {}\\n\" +\n\n        \"goog.addSingletonGetter(Bar);\" +\n\n        \"Bar.prototype.bar = 1;\",\n\n        \"\");\n\n  }\n"
      }
    }
  },
  "Closure-38": {
    "id": "Closure-38",
    "project": "Closure",
    "number": "38",
    "buggy_function": "void addNumber(double x) {\n  // This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (x < 0 && prev == '-') {\n    add(\" \");\n  }\n\n  if ((long) x == x && !negativeZero) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}",
    "fixed_function": "void addNumber(double x) {\n  // This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if ((x < 0 || negativeZero) && prev == '-') {\n    add(\" \");\n  }\n\n  if ((long) x == x && !negativeZero) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeConsumer.java",
      "first_line": 240,
      "last_line": 267
    },
    "javadoc": "// because it looks strange.",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testMinusNegativeZero": {
        "source": "  public void testMinusNegativeZero() {\n\n    // Negative zero is weird, because we have to be able to distinguish\n\n    // it from positive zero (there are some subtle differences in behavior).\n\n    assertPrint(\"x- -0\", \"x- -0.0\");\n\n  }\n"
      }
    }
  },
  "Closure-39": {
    "id": "Closure-39",
    "project": "Closure",
    "number": "39",
    "buggy_function": "String toStringHelper(boolean forAnnotations) {\n  if (hasReferenceName()) {\n    return getReferenceName();\n  } else if (prettyPrint) {\n    // Don't pretty print recursively.\n    prettyPrint = false;\n\n    // Use a tree set so that the properties are sorted.\n    Set<String> propertyNames = Sets.newTreeSet();\n    for (ObjectType current = this;\n         current != null && !current.isNativeObjectType() &&\n             propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n         current = current.getImplicitPrototype()) {\n      propertyNames.addAll(current.getOwnPropertyNames());\n    }\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"{\");\n\n    int i = 0;\n    for (String property : propertyNames) {\n      if (i > 0) {\n        sb.append(\", \");\n      }\n\n      sb.append(property);\n      sb.append(\": \");\n      sb.append(getPropertyType(property).toString());\n\n      ++i;\n      if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n        sb.append(\", ...\");\n        break;\n      }\n    }\n\n    sb.append(\"}\");\n\n    prettyPrint = true;\n    return sb.toString();\n  } else {\n    return \"{...}\";\n  }\n}",
    "fixed_function": "String toStringHelper(boolean forAnnotations) {\n  if (hasReferenceName()) {\n    return getReferenceName();\n  } else if (prettyPrint) {\n    // Don't pretty print recursively.\n    prettyPrint = false;\n\n    // Use a tree set so that the properties are sorted.\n    Set<String> propertyNames = Sets.newTreeSet();\n    for (ObjectType current = this;\n         current != null && !current.isNativeObjectType() &&\n             propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n         current = current.getImplicitPrototype()) {\n      propertyNames.addAll(current.getOwnPropertyNames());\n    }\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"{\");\n\n    int i = 0;\n    for (String property : propertyNames) {\n      if (i > 0) {\n        sb.append(\", \");\n      }\n\n      sb.append(property);\n      sb.append(\": \");\n      sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n\n      ++i;\n      if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n        sb.append(\", ...\");\n        break;\n      }\n    }\n\n    sb.append(\"}\");\n\n    prettyPrint = true;\n    return sb.toString();\n  } else {\n    return forAnnotations ? \"?\" : \"{...}\";\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
      "first_line": 353,
      "last_line": 396
    },
    "javadoc": "/**\n* Given the name of a native object property, checks whether the property is\n* present on the object and different from the native one.\n*/",
    "failing_tests": {
      "com.google.javascript.rhino.jstype.RecordTypeTest::testRecursiveRecord": {
        "source": "  public void testRecursiveRecord() {\n\n    ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE);\n\n    JSType record = new RecordTypeBuilder(registry)\n\n        .addProperty(\"loop\", loop, null)\n\n        .addProperty(\"number\", NUMBER_TYPE, null)\n\n        .addProperty(\"string\", STRING_TYPE, null)\n\n        .build();\n\n    assertEquals(\"{loop: number, number: number, string: string}\",\n\n        record.toString());\n\n\n\n    loop.setReferencedType(record);\n\n    assertEquals(\"{loop: {...}, number: number, string: string}\",\n\n        record.toString());\n\n    assertEquals(\"{loop: ?, number: number, string: string}\",\n\n        record.toAnnotationString());\n\n\n\n    Asserts.assertEquivalenceOperations(record, loop);\n\n  }\n"
      },
      "com.google.javascript.rhino.jstype.RecordTypeTest::testLongToString": {
        "source": "  public void testLongToString() {\n\n    JSType record = new RecordTypeBuilder(registry)\n\n        .addProperty(\"a1\", NUMBER_TYPE, null)\n\n        .addProperty(\"a2\", NUMBER_TYPE, null)\n\n        .addProperty(\"a3\", NUMBER_TYPE, null)\n\n        .addProperty(\"a4\", NUMBER_TYPE, null)\n\n        .addProperty(\"a5\", NUMBER_TYPE, null)\n\n        .addProperty(\"a6\", NUMBER_TYPE, null)\n\n        .build();\n\n    assertEquals(\"{a1: number, a2: number, a3: number, a4: number, ...}\",\n\n        record.toString());\n\n    assertEquals(\n\n        \"{a1: number, a2: number, a3: number, a4: number,\" +\n\n        \" a5: number, a6: number}\",\n\n        record.toAnnotationString());\n\n  }\n"
      }
    }
  },
  "Closure-4": {
    "id": "Closure-4",
    "project": "Closure",
    "number": "4",
    "buggy_function": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n  // TODO(user): Investigate whether it is really necessary to keep two\n  // different mechanisms for resolving named types, and if so, which order\n  // makes more sense. Now, resolution via registry is first in order to\n  // avoid triggering the warnings built into the resolution via properties.\n  boolean resolved = resolveViaRegistry(t, enclosing);\n  if (detectImplicitPrototypeCycle()) {\n    handleTypeCycle(t);\n  }\n\n  if (resolved) {\n    super.resolveInternal(t, enclosing);\n    finishPropertyContinuations();\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n\n  resolveViaProperties(t, enclosing);\n  if (detectImplicitPrototypeCycle()) {\n    handleTypeCycle(t);\n  }\n\n  super.resolveInternal(t, enclosing);\n  if (isResolved()) {\n    finishPropertyContinuations();\n  }\n  return registry.isLastGeneration() ?\n      getReferencedType() : this;\n}",
    "fixed_function": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n  // TODO(user): Investigate whether it is really necessary to keep two\n  // different mechanisms for resolving named types, and if so, which order\n  // makes more sense. Now, resolution via registry is first in order to\n  // avoid triggering the warnings built into the resolution via properties.\n  boolean resolved = resolveViaRegistry(t, enclosing);\n  if (detectInheritanceCycle()) {\n    handleTypeCycle(t);\n  }\n\n  if (resolved) {\n    super.resolveInternal(t, enclosing);\n    finishPropertyContinuations();\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n\n  resolveViaProperties(t, enclosing);\n  if (detectInheritanceCycle()) {\n    handleTypeCycle(t);\n  }\n\n  super.resolveInternal(t, enclosing);\n  if (isResolved()) {\n    finishPropertyContinuations();\n  }\n  return registry.isLastGeneration() ?\n      getReferencedType() : this;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/NamedType.java",
      "first_line": 184,
      "last_line": 212
    },
    "javadoc": "/**\n* Resolve the referenced type within the enclosing scope.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testImplementsExtendsLoop": {
        "source": "  public void testImplementsExtendsLoop() throws Exception {\n\n    testClosureTypesMultipleWarnings(\n\n        suppressMissingProperty(\"foo\") +\n\n            \"/** @constructor \\n * @implements {F} */var G = function() {};\" +\n\n            \"/** @constructor \\n * @extends {G} */var F = function() {};\" +\n\n        \"alert((new F).foo);\",\n\n        Lists.newArrayList(\n\n            \"Parse error. Cycle detected in inheritance chain of type F\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testImplementsLoop": {
        "source": "  public void testImplementsLoop() throws Exception {\n\n    testClosureTypesMultipleWarnings(\n\n        suppressMissingProperty(\"foo\") +\n\n        \"/** @constructor \\n * @implements {T} */var T = function() {};\" +\n\n        \"alert((new T).foo);\",\n\n        Lists.newArrayList(\n\n            \"Parse error. Cycle detected in inheritance chain of type T\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testConversionFromInterfaceToRecursiveConstructor": {
        "source": "  public void testConversionFromInterfaceToRecursiveConstructor()\n\n      throws Exception {\n\n    testClosureTypesMultipleWarnings(\n\n        suppressMissingProperty(\"foo\") +\n\n            \"/** @interface */ var OtherType = function() {}\\n\" +\n\n            \"/** @implements {MyType} \\n * @constructor */\\n\" +\n\n            \"var MyType = function() {}\\n\" +\n\n            \"/** @type {MyType} */\\n\" +\n\n            \"var x = /** @type {!OtherType} */ (new Object());\",\n\n        Lists.newArrayList(\n\n            \"Parse error. Cycle detected in inheritance chain of type MyType\",\n\n            \"initializing variable\\n\" +\n\n            \"found   : OtherType\\n\" +\n\n            \"required: (MyType|null)\"));\n\n  }\n"
      }
    }
  },
  "Closure-40": {
    "id": "Closure-40",
    "project": "Closure",
    "number": "40",
    "buggy_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n\n  // Record global variable and function declarations\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n\n  // Record assignments and call sites\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name != null) {\n      refNodes.add(new ClassDefiningFunctionNode(\n          name, n, parent, parent.getParent()));\n      }\n    }\n  }\n}",
    "fixed_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n\n  // Record global variable and function declarations\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n\n  // Record assignments and call sites\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      refNodes.add(new ClassDefiningFunctionNode(\n          name, n, parent, parent.getParent()));\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "first_line": 596,
      "last_line": 642
    },
    "javadoc": "/**\n* Identifies all declarations of global names and setter statements\n* affecting global symbols (assignments to global names).\n*\n* All declarations and setters must be gathered in a single\n* traversal and stored in traversal order so \"removeUnreferenced\"\n* can perform modifications in traversal order.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.IntegrationTest::testIssue284": {
        "source": "  public void testIssue284() {\n\n    CompilerOptions options = createCompilerOptions();\n\n    options.smartNameRemoval = true;\n\n    test(options,\n\n        \"var goog = {};\" +\n\n        \"goog.inherits = function(x, y) {};\" +\n\n        \"var ns = {};\" +\n\n        \"/** @constructor */\" +\n\n        \"ns.PageSelectionModel = function() {};\" +\n\n        \"/** @constructor */\" +\n\n        \"ns.PageSelectionModel.FooEvent = function() {};\" +\n\n        \"/** @constructor */\" +\n\n        \"ns.PageSelectionModel.SelectEvent = function() {};\" +\n\n        \"goog.inherits(ns.PageSelectionModel.ChangeEvent,\" +\n\n        \"    ns.PageSelectionModel.FooEvent);\",\n\n        \"\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.NameAnalyzerTest::testIssue284": {
        "source": "  public void testIssue284() {\n\n    test(\n\n        \"var goog = {};\" +\n\n        \"goog.inherits = function(x, y) {};\" +\n\n        \"var ns = {};\" +\n\n        \"/** @constructor */\" +\n\n        \"ns.PageSelectionModel = function() {};\" +\n\n        \"/** @constructor */\" +\n\n        \"ns.PageSelectionModel.FooEvent = function() {};\" +\n\n        \"/** @constructor */\" +\n\n        \"ns.PageSelectionModel.SelectEvent = function() {};\" +\n\n        \"goog.inherits(ns.PageSelectionModel.ChangeEvent,\" +\n\n        \"    ns.PageSelectionModel.FooEvent);\",\n\n        \"\");\n\n  }\n"
      }
    }
  },
  "Closure-42": {
    "id": "Closure-42",
    "project": "Closure",
    "number": "42",
    "buggy_function": "Node processForInLoop(ForInLoop loopNode) {\n\n    // Return the bare minimum to put the AST in a valid state.\n  return newNode(\n      Token.FOR,\n      transform(loopNode.getIterator()),\n      transform(loopNode.getIteratedObject()),\n      transformBlock(loopNode.getBody()));\n}",
    "fixed_function": "Node processForInLoop(ForInLoop loopNode) {\n  if (loopNode.isForEach()) {\n    errorReporter.error(\n        \"unsupported language extension: for each\",\n        sourceName,\n        loopNode.getLineno(), \"\", 0);\n\n    // Return the bare minimum to put the AST in a valid state.\n    return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n  }\n  return newNode(\n      Token.FOR,\n      transform(loopNode.getIterator()),\n      transform(loopNode.getIteratedObject()),\n      transformBlock(loopNode.getBody()));\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
      "first_line": 567,
      "last_line": 575
    },
    "javadoc": "// Change the NAME to LABEL_NAME",
    "failing_tests": {
      "com.google.javascript.jscomp.parsing.ParserTest::testForEach": {
        "source": "  public void testForEach() {\n\n    parseError(\n\n        \"function f(stamp, status) {\\n\" +\n\n        \"  for each ( var curTiming in this.timeLog.timings ) {\\n\" +\n\n        \"    if ( curTiming.callId == stamp ) {\\n\" +\n\n        \"      curTiming.flag = status;\\n\" +\n\n        \"      break;\\n\" +\n\n        \"    }\\n\" +\n\n        \"  }\\n\" +\n\n        \"};\",\n\n        \"unsupported language extension: for each\");\n\n  }\n"
      }
    }
  },
  "Closure-44": {
    "id": "Closure-44",
    "project": "Closure",
    "number": "44",
    "buggy_function": "void add(String newcode) {\n  maybeEndStatement();\n\n  if (newcode.length() == 0) {\n    return;\n  }\n\n  char c = newcode.charAt(0);\n  if ((isWordChar(c) || c == '\\\\') &&\n      isWordChar(getLastChar())) {\n    // need space to separate. This is not pretty printing.\n    // For example: \"return foo;\"\n    append(\" \");\n    // Do not allow a forward slash to appear after a DIV.\n    // For example,\n    // REGEXP DIV REGEXP\n    // is valid and should print like\n    // / // / /\n  }\n\n  append(newcode);\n}",
    "fixed_function": "void add(String newcode) {\n  maybeEndStatement();\n\n  if (newcode.length() == 0) {\n    return;\n  }\n\n  char c = newcode.charAt(0);\n  if ((isWordChar(c) || c == '\\\\') &&\n      isWordChar(getLastChar())) {\n    // need space to separate. This is not pretty printing.\n    // For example: \"return foo;\"\n    append(\" \");\n  } else if (c == '/' && getLastChar() == '/') {\n    // Do not allow a forward slash to appear after a DIV.\n    // For example,\n    // REGEXP DIV REGEXP\n    // is valid and should print like\n    // / // / /\n    append(\" \");\n  }\n\n  append(newcode);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeConsumer.java",
      "first_line": 181,
      "last_line": 202
    },
    "javadoc": "// Add a ';' if we need to.",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testIssue620": {
        "source": "  public void testIssue620() {\n\n    assertPrint(\"alert(/ / / / /);\", \"alert(/ // / /)\");\n\n    assertPrint(\"alert(/ // / /);\", \"alert(/ // / /)\");\n\n  }\n"
      }
    }
  },
  "Closure-48": {
    "id": "Closure-48",
    "project": "Closure",
    "number": "48",
    "buggy_function": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}",
    "fixed_function": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    // Determining declaration for #2\n    if (info != null) {\n      inferred = false;\n    } else if (!scope.isDeclared(qName, false) &&\n               n.isUnscopedQualifiedName()) {\n      inferred = false;\n    }\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 1416,
      "last_line": 1561
    },
    "javadoc": "/**\n* Declare the symbol for a qualified name in the global scope.\n*\n* @param info The doc info for this property.\n* @param n A top-level GETPROP node (it should not be contained inside\n*     another GETPROP).\n* @param parent The parent of {@code n}.\n* @param rhsValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue586": {
        "source": "  public void testIssue586() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */\" +\n\n        \"var MyClass = function() {};\" +\n\n        \"/** @param {boolean} success */\" +\n\n        \"MyClass.prototype.fn = function(success) {};\" +\n\n        \"MyClass.prototype.test = function() {\" +\n\n        \"  this.fn();\" +\n\n        \"  this.fn = function() {};\" +\n\n        \"};\",\n\n        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n\n        \"Function requires at least 1 argument(s) \" +\n\n        \"and no more than 1 argument(s).\");\n\n  }\n"
      }
    }
  },
  "Closure-5": {
    "id": "Closure-5",
    "project": "Closure",
    "number": "5",
    "buggy_function": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Ignore most indirect references, like x.y (but not x.y(),\n    // since the function referenced by y might reference 'this').\n    //\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target may be using the object as a 'this' value.\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // Deleting a property has different semantics from deleting\n      // a variable, so deleted properties should not be inlined.\n\n      // NOTE(nicksantos): This pass's object-splitting algorithm has\n      // a blind spot. It assumes that if a property isn't defined on an\n      // object, then the value is undefined. This is not true, because\n      // Object.prototype can have arbitrary properties on it.\n      //\n      // We short-circuit this problem by bailing out if we see a reference\n      // to a property that isn't defined on the object literal. This\n      // isn't a perfect algorithm, but it should catch most cases.\n      String propName = parent.getLastChild().getString();\n      if (!validProperties.contains(propName)) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n          validProperties.add(propName);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Make sure that the value is not self-referential. IOW,\n    // disallow things like x = {b: x.a}.\n    //\n    // TODO: Only exclude unorderable self-referential\n    // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n    // but x = {a: 1, b: x.a} is.\n    //\n    // Also, ES5 getters/setters aren't handled by this pass.\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        // ES5 get/set not supported.\n        return false;\n      }\n\n      validProperties.add(child.getString());\n\n      Node childVal = child.getFirstChild();\n      // Check if childVal is the parent of any of the passed in\n      // references, as that is how self-referential assignments\n      // will happen.\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // There's a self-referential assignment\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n\n\n    // We have found an acceptable object literal assignment. As\n    // long as there are no other assignments that mess things up,\n    // we can inline.\n    ret = true;\n  }\n  return ret;\n}",
    "fixed_function": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Ignore most indirect references, like x.y (but not x.y(),\n    // since the function referenced by y might reference 'this').\n    //\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target may be using the object as a 'this' value.\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // Deleting a property has different semantics from deleting\n      // a variable, so deleted properties should not be inlined.\n      if (gramps.isDelProp()) {\n        return false;\n      }\n\n      // NOTE(nicksantos): This pass's object-splitting algorithm has\n      // a blind spot. It assumes that if a property isn't defined on an\n      // object, then the value is undefined. This is not true, because\n      // Object.prototype can have arbitrary properties on it.\n      //\n      // We short-circuit this problem by bailing out if we see a reference\n      // to a property that isn't defined on the object literal. This\n      // isn't a perfect algorithm, but it should catch most cases.\n      String propName = parent.getLastChild().getString();\n      if (!validProperties.contains(propName)) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n          validProperties.add(propName);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Make sure that the value is not self-referential. IOW,\n    // disallow things like x = {b: x.a}.\n    //\n    // TODO: Only exclude unorderable self-referential\n    // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n    // but x = {a: 1, b: x.a} is.\n    //\n    // Also, ES5 getters/setters aren't handled by this pass.\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        // ES5 get/set not supported.\n        return false;\n      }\n\n      validProperties.add(child.getString());\n\n      Node childVal = child.getFirstChild();\n      // Check if childVal is the parent of any of the passed in\n      // references, as that is how self-referential assignments\n      // will happen.\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // There's a self-referential assignment\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n\n\n    // We have found an acceptable object literal assignment. As\n    // long as there are no other assignments that mess things up,\n    // we can inline.\n    ret = true;\n  }\n  return ret;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
      "first_line": 155,
      "last_line": 253
    },
    "javadoc": "/**\n* Counts the number of direct (full) references to an object.\n* Specifically, we check for references of the following type:\n* <pre>\n*   x;\n*   x.fn();\n* </pre>\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineObjectLiteralsTest::testNoInlineDeletedProperties": {
        "source": "  public void testNoInlineDeletedProperties() {\n\n    testSameLocal(\n\n        \"var foo = {bar:1};\" +\n\n        \"delete foo.bar;\" +\n\n        \"return foo.bar;\");\n\n  }\n"
      }
    }
  },
  "Closure-50": {
    "id": "Closure-50",
    "project": "Closure",
    "number": "50",
    "buggy_function": "private Node tryFoldArrayJoin(Node n) {\n  Node callTarget = n.getFirstChild();\n\n  if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n    return n;\n  }\n\n  Node right = callTarget.getNext();\n  if (right != null) {\n    if (!NodeUtil.isImmutableValue(right)) {\n      return n;\n    }\n  }\n\n  Node arrayNode = callTarget.getFirstChild();\n  Node functionName = arrayNode.getNext();\n\n  if ((arrayNode.getType() != Token.ARRAYLIT) ||\n      !functionName.getString().equals(\"join\")) {\n    return n;\n  }\n\n    // \",\" is the default, it doesn't need to be explicit\n\n  String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n  List<Node> arrayFoldedChildren = Lists.newLinkedList();\n  StringBuilder sb = null;\n  int foldedSize = 0;\n  Node prev = null;\n  Node elem = arrayNode.getFirstChild();\n  // Merges adjacent String nodes.\n  while (elem != null) {\n    if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n      if (sb == null) {\n        sb = new StringBuilder();\n      } else {\n        sb.append(joinString);\n      }\n      sb.append(NodeUtil.getArrayElementStringValue(elem));\n    } else {\n      if (sb != null) {\n        Preconditions.checkNotNull(prev);\n        // + 2 for the quotes.\n        foldedSize += sb.length() + 2;\n        arrayFoldedChildren.add(\n            Node.newString(sb.toString()).copyInformationFrom(prev));\n        sb = null;\n      }\n      foldedSize += InlineCostEstimator.getCost(elem);\n      arrayFoldedChildren.add(elem);\n    }\n    prev = elem;\n    elem = elem.getNext();\n  }\n\n  if (sb != null) {\n    Preconditions.checkNotNull(prev);\n    // + 2 for the quotes.\n    foldedSize += sb.length() + 2;\n    arrayFoldedChildren.add(\n        Node.newString(sb.toString()).copyInformationFrom(prev));\n  }\n  // one for each comma.\n  foldedSize += arrayFoldedChildren.size() - 1;\n\n  int originalSize = InlineCostEstimator.getCost(n);\n  switch (arrayFoldedChildren.size()) {\n    case 0:\n      Node emptyStringNode = Node.newString(\"\");\n      n.getParent().replaceChild(n, emptyStringNode);\n      reportCodeChange();\n      return emptyStringNode;\n    case 1:\n      Node foldedStringNode = arrayFoldedChildren.remove(0);\n      if (foldedSize > originalSize) {\n        return n;\n      }\n      arrayNode.detachChildren();\n      if (foldedStringNode.getType() != Token.STRING) {\n        // If the Node is not a string literal, ensure that\n        // it is coerced to a string.\n        Node replacement = new Node(Token.ADD,\n            Node.newString(\"\").copyInformationFrom(n),\n            foldedStringNode);\n        foldedStringNode = replacement;\n      }\n      n.getParent().replaceChild(n, foldedStringNode);\n      reportCodeChange();\n      return foldedStringNode;\n    default:\n      // No folding could actually be performed.\n      if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n        return n;\n      }\n      int kJoinOverhead = \"[].join()\".length();\n      foldedSize += kJoinOverhead;\n      foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n      if (foldedSize > originalSize) {\n        return n;\n      }\n      arrayNode.detachChildren();\n      for (Node node : arrayFoldedChildren) {\n        arrayNode.addChildToBack(node);\n      }\n      reportCodeChange();\n      break;\n  }\n\n  return n;\n}",
    "fixed_function": "private Node tryFoldArrayJoin(Node n) {\n  Node callTarget = n.getFirstChild();\n\n  if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n    return n;\n  }\n\n  Node right = callTarget.getNext();\n  if (right != null) {\n    if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n      return n;\n    }\n  }\n\n  Node arrayNode = callTarget.getFirstChild();\n  Node functionName = arrayNode.getNext();\n\n  if ((arrayNode.getType() != Token.ARRAYLIT) ||\n      !functionName.getString().equals(\"join\")) {\n    return n;\n  }\n\n  if (right != null && right.getType() == Token.STRING\n      && \",\".equals(right.getString())) {\n    // \",\" is the default, it doesn't need to be explicit\n    n.removeChild(right);\n    reportCodeChange();\n  }\n\n  String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n  List<Node> arrayFoldedChildren = Lists.newLinkedList();\n  StringBuilder sb = null;\n  int foldedSize = 0;\n  Node prev = null;\n  Node elem = arrayNode.getFirstChild();\n  // Merges adjacent String nodes.\n  while (elem != null) {\n    if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n      if (sb == null) {\n        sb = new StringBuilder();\n      } else {\n        sb.append(joinString);\n      }\n      sb.append(NodeUtil.getArrayElementStringValue(elem));\n    } else {\n      if (sb != null) {\n        Preconditions.checkNotNull(prev);\n        // + 2 for the quotes.\n        foldedSize += sb.length() + 2;\n        arrayFoldedChildren.add(\n            Node.newString(sb.toString()).copyInformationFrom(prev));\n        sb = null;\n      }\n      foldedSize += InlineCostEstimator.getCost(elem);\n      arrayFoldedChildren.add(elem);\n    }\n    prev = elem;\n    elem = elem.getNext();\n  }\n\n  if (sb != null) {\n    Preconditions.checkNotNull(prev);\n    // + 2 for the quotes.\n    foldedSize += sb.length() + 2;\n    arrayFoldedChildren.add(\n        Node.newString(sb.toString()).copyInformationFrom(prev));\n  }\n  // one for each comma.\n  foldedSize += arrayFoldedChildren.size() - 1;\n\n  int originalSize = InlineCostEstimator.getCost(n);\n  switch (arrayFoldedChildren.size()) {\n    case 0:\n      Node emptyStringNode = Node.newString(\"\");\n      n.getParent().replaceChild(n, emptyStringNode);\n      reportCodeChange();\n      return emptyStringNode;\n    case 1:\n      Node foldedStringNode = arrayFoldedChildren.remove(0);\n      if (foldedSize > originalSize) {\n        return n;\n      }\n      arrayNode.detachChildren();\n      if (foldedStringNode.getType() != Token.STRING) {\n        // If the Node is not a string literal, ensure that\n        // it is coerced to a string.\n        Node replacement = new Node(Token.ADD,\n            Node.newString(\"\").copyInformationFrom(n),\n            foldedStringNode);\n        foldedStringNode = replacement;\n      }\n      n.getParent().replaceChild(n, foldedStringNode);\n      reportCodeChange();\n      return foldedStringNode;\n    default:\n      // No folding could actually be performed.\n      if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n        return n;\n      }\n      int kJoinOverhead = \"[].join()\".length();\n      foldedSize += kJoinOverhead;\n      foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n      if (foldedSize > originalSize) {\n        return n;\n      }\n      arrayNode.detachChildren();\n      for (Node node : arrayFoldedChildren) {\n        arrayNode.addChildToBack(node);\n      }\n      reportCodeChange();\n      break;\n  }\n\n  return n;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
      "first_line": 367,
      "last_line": 476
    },
    "javadoc": "/**\n* Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeReplaceKnownMethodsTest::testStringJoinAdd": {
        "source": "  public void testStringJoinAdd() {\n\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n\n        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join()\");\n\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\",\n\n        \"x = [foo,\\\"a,b,c\\\"].join()\");\n\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\",\n\n        \"x = [\\\"a,b,c\\\",foo].join()\");\n\n\n\n    // Works with numbers\n\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n\n\n    // Works on boolean\n\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n\n\n    // Only optimize if it's a size win.\n\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n\n\n\n    // TODO(user): Its possible to fold this better.\n\n    foldSame(\"x = ['', foo].join('-')\");\n\n    foldSame(\"x = ['', foo, ''].join()\");\n\n\n\n    fold(\"x = ['', '', foo, ''].join(',')\",\n\n         \"x = [',', foo, ''].join()\");\n\n    fold(\"x = ['', '', foo, '', ''].join(',')\",\n\n         \"x = [',', foo, ','].join()\");\n\n\n\n    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n\n         \"x = [',', foo, ',', bar].join()\");\n\n\n\n    fold(\"x = [1,2,3].join('abcdef')\",\n\n         \"x = '1abcdef2abcdef3'\");\n\n\n\n    fold(\"x = [1,2].join()\", \"x = '1,2'\");\n\n    fold(\"x = [null,undefined,''].join(',')\", \"x = ',,'\");\n\n    fold(\"x = [null,undefined,0].join(',')\", \"x = ',,0'\");\n\n    // This can be folded but we don't currently.\n\n    foldSame(\"x = [[1,2],[3,4]].join()\"); // would like: \"x = '1,2,3,4'\"\n\n  }\n"
      },
      "com.google.javascript.jscomp.PeepholeReplaceKnownMethodsTest::testNoStringJoin": {
        "source": "  public void testNoStringJoin() {\n\n    foldSame(\"x = [].join(',',2)\");\n\n    foldSame(\"x = [].join(f)\");\n\n  }\n"
      }
    }
  },
  "Closure-51": {
    "id": "Closure-51",
    "project": "Closure",
    "number": "51",
    "buggy_function": "void addNumber(double x) {\n  // This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char prev = getLastChar();\n  if (x < 0 && prev == '-') {\n    add(\" \");\n  }\n\n  if ((long) x == x) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n\n}",
    "fixed_function": "void addNumber(double x) {\n  // This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char prev = getLastChar();\n  if (x < 0 && prev == '-') {\n    add(\" \");\n  }\n\n  if ((long) x == x && !isNegativeZero(x)) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeConsumer.java",
      "first_line": 233,
      "last_line": 260
    },
    "javadoc": "// because it looks strange.",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testIssue582": {
        "source": "  public void testIssue582() {\n\n    assertPrint(\"var x = -0.0;\", \"var x=-0.0\");\n\n  }\n"
      }
    }
  },
  "Closure-52": {
    "id": "Closure-52",
    "project": "Closure",
    "number": "52",
    "buggy_function": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0;\n}",
    "fixed_function": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0 && s.charAt(0) != '0';\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 737,
      "last_line": 746
    },
    "javadoc": "// ignored for our purposes.",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testNumericKeys": {
        "source": "  public void testNumericKeys() {\n\n    assertPrint(\"var x = {010: 1};\", \"var x={8:1}\");\n\n    assertPrint(\"var x = {'010': 1};\", \"var x={\\\"010\\\":1}\");\n\n\n\n    assertPrint(\"var x = {0x10: 1};\", \"var x={16:1}\");\n\n    assertPrint(\"var x = {'0x10': 1};\", \"var x={\\\"0x10\\\":1}\");\n\n\n\n    // I was surprised at this result too.\n\n    assertPrint(\"var x = {.2: 1};\", \"var x={\\\"0.2\\\":1}\");\n\n    assertPrint(\"var x = {'.2': 1};\", \"var x={\\\".2\\\":1}\");\n\n\n\n    assertPrint(\"var x = {0.2: 1};\", \"var x={\\\"0.2\\\":1}\");\n\n    assertPrint(\"var x = {'0.2': 1};\", \"var x={\\\"0.2\\\":1}\");\n\n  }\n"
      }
    }
  },
  "Closure-53": {
    "id": "Closure-53",
    "project": "Closure",
    "number": "53",
    "buggy_function": "private void replaceAssignmentExpression(Var v, Reference ref,\n                                         Map<String, String> varmap) {\n  // Compute all of the assignments necessary\n  List<Node> nodes = Lists.newArrayList();\n  Node val = ref.getAssignedValue();\n  blacklistVarReferencesInTree(val, v.scope);\n  Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n  Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n  for (Node key = val.getFirstChild(); key != null;\n       key = key.getNext()) {\n    String var = key.getString();\n    Node value = key.removeFirstChild();\n    // TODO(user): Copy type information.\n    nodes.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, varmap.get(var)), value));\n    all.remove(var);\n  }\n\n  // TODO(user): Better source information.\n  for (String var : all) {\n    nodes.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, varmap.get(var)),\n               NodeUtil.newUndefinedNode(null)));\n  }\n\n  Node replacement;\n    // All assignments evaluate to true, so make sure that the\n    // expr statement evaluates to true in case it matters.\n    nodes.add(new Node(Token.TRUE));\n\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    nodes = Lists.reverse(nodes);\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n      cur.addChildToFront(nodes.get(i));\n      Node t = new Node(Token.COMMA);\n      cur.addChildToFront(t);\n      cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n\n  Node replace = ref.getParent();\n  replacement.copyInformationFromForTree(replace);\n\n  if (replace.getType() == Token.VAR) {\n    replace.getParent().replaceChild(\n        replace, NodeUtil.newExpr(replacement));\n  } else {\n    replace.getParent().replaceChild(replace, replacement);\n  }\n}",
    "fixed_function": "private void replaceAssignmentExpression(Var v, Reference ref,\n                                         Map<String, String> varmap) {\n  // Compute all of the assignments necessary\n  List<Node> nodes = Lists.newArrayList();\n  Node val = ref.getAssignedValue();\n  blacklistVarReferencesInTree(val, v.scope);\n  Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n  Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n  for (Node key = val.getFirstChild(); key != null;\n       key = key.getNext()) {\n    String var = key.getString();\n    Node value = key.removeFirstChild();\n    // TODO(user): Copy type information.\n    nodes.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, varmap.get(var)), value));\n    all.remove(var);\n  }\n\n  // TODO(user): Better source information.\n  for (String var : all) {\n    nodes.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, varmap.get(var)),\n               NodeUtil.newUndefinedNode(null)));\n  }\n\n  Node replacement;\n  if (nodes.isEmpty()) {\n    replacement = new Node(Token.TRUE);\n  } else {\n    // All assignments evaluate to true, so make sure that the\n    // expr statement evaluates to true in case it matters.\n    nodes.add(new Node(Token.TRUE));\n\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    nodes = Lists.reverse(nodes);\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n      cur.addChildToFront(nodes.get(i));\n      Node t = new Node(Token.COMMA);\n      cur.addChildToFront(t);\n      cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n  }\n\n  Node replace = ref.getParent();\n  replacement.copyInformationFromForTree(replace);\n\n  if (replace.getType() == Token.VAR) {\n    replace.getParent().replaceChild(\n        replace, NodeUtil.newExpr(replacement));\n  } else {\n    replace.getParent().replaceChild(replace, replacement);\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
      "first_line": 303,
      "last_line": 360
    },
    "javadoc": "/**\n* Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n* Note that the resulting expression will always evaluate to\n* true, as would the x = {...} expression.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.InlineObjectLiteralsTest::testBug545": {
        "source": "  public void testBug545() {\n\n    testLocal(\"var a = {}\", \"\");\n\n    testLocal(\"var a; a = {}\", \"true\");\n\n  }\n"
      }
    }
  },
  "Closure-55": {
    "id": "Closure-55",
    "project": "Closure",
    "number": "55",
    "buggy_function": "private static boolean isReduceableFunctionExpression(Node n) {\n  return NodeUtil.isFunctionExpression(n);\n}",
    "fixed_function": "private static boolean isReduceableFunctionExpression(Node n) {\n  return NodeUtil.isFunctionExpression(n)\n      && !NodeUtil.isGetOrSetKey(n.getParent());\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/FunctionRewriter.java",
      "first_line": 116,
      "last_line": 118
    },
    "javadoc": "/**\n* Parse helper code needed by a reducer.\n*\n* @return Helper code root.  If parse fails, return null.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.FunctionRewriterTest::testIssue538": {
        "source": "  public void testIssue538() {\n\n    checkCompilesToSame(      \"/** @constructor */\\n\" +\n\n        \"WebInspector.Setting = function() {}\\n\" +\n\n        \"WebInspector.Setting.prototype = {\\n\" +\n\n        \"    get name0(){return this._name;},\\n\" +\n\n        \"    get name1(){return this._name;},\\n\" +\n\n        \"    get name2(){return this._name;},\\n\" +\n\n        \"    get name3(){return this._name;},\\n\" +\n\n        \"    get name4(){return this._name;},\\n\" +\n\n        \"    get name5(){return this._name;},\\n\" +\n\n        \"    get name6(){return this._name;},\\n\" +\n\n        \"    get name7(){return this._name;},\\n\" +\n\n        \"    get name8(){return this._name;},\\n\" +\n\n        \"    get name9(){return this._name;},\\n\" +\n\n        \"}\", 1);\n\n  }\n"
      }
    }
  },
  "Closure-56": {
    "id": "Closure-56",
    "project": "Closure",
    "number": "56",
    "buggy_function": "public String getLine(int lineNumber) {\n  String js = \"\";\n  try {\n    // NOTE(nicksantos): Right now, this is optimized for few warnings.\n    // This is probably the right trade-off, but will be slow if there\n    // are lots of warnings in one file.\n    js = getCode();\n  } catch (IOException e) {\n    return null;\n  }\n\n  int pos = 0;\n  int startLine = 1;\n\n  // If we've saved a previous offset and it's for a line less than the\n  // one we're searching for, then start at that point.\n  if (lineNumber >= lastLine) {\n    pos = lastOffset;\n    startLine = lastLine;\n  }\n\n  for (int n = startLine; n < lineNumber; n++) {\n    int nextpos = js.indexOf('\\n', pos);\n    if (nextpos == -1) {\n      return null;\n    }\n    pos = nextpos + 1;\n  }\n\n  // Remember this offset for the next search we do.\n  lastOffset = pos;\n  lastLine = lineNumber;\n\n  if (js.indexOf('\\n', pos) == -1) {\n    // If next new line cannot be found, there are two cases\n    // 1. pos already reaches the end of file, then null should be returned\n    // 2. otherwise, return the contents between pos and the end of file.\n      return null;\n  } else {\n    return js.substring(pos, js.indexOf('\\n', pos));\n  }\n}",
    "fixed_function": "public String getLine(int lineNumber) {\n  String js = \"\";\n  try {\n    // NOTE(nicksantos): Right now, this is optimized for few warnings.\n    // This is probably the right trade-off, but will be slow if there\n    // are lots of warnings in one file.\n    js = getCode();\n  } catch (IOException e) {\n    return null;\n  }\n\n  int pos = 0;\n  int startLine = 1;\n\n  // If we've saved a previous offset and it's for a line less than the\n  // one we're searching for, then start at that point.\n  if (lineNumber >= lastLine) {\n    pos = lastOffset;\n    startLine = lastLine;\n  }\n\n  for (int n = startLine; n < lineNumber; n++) {\n    int nextpos = js.indexOf('\\n', pos);\n    if (nextpos == -1) {\n      return null;\n    }\n    pos = nextpos + 1;\n  }\n\n  // Remember this offset for the next search we do.\n  lastOffset = pos;\n  lastLine = lineNumber;\n\n  if (js.indexOf('\\n', pos) == -1) {\n    // If next new line cannot be found, there are two cases\n    // 1. pos already reaches the end of file, then null should be returned\n    // 2. otherwise, return the contents between pos and the end of file.\n    if (pos >= js.length()) {\n      return null;\n    } else {\n      return js.substring(pos, js.length());\n    }\n  } else {\n    return js.substring(pos, js.indexOf('\\n', pos));\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/SourceFile.java",
      "first_line": 205,
      "last_line": 246
    },
    "javadoc": "/**\n* Gets the source line for the indicated line number.\n*\n* @param lineNumber the line number, 1 being the first line of the file.\n* @return The line indicated. Does not include the newline at the end\n*     of the file. Returns {@code null} if it does not exist,\n*     or if there was an IO exception.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.JSCompilerSourceExcerptProviderTest::testExceptNoNewLine": {
        "source": "  public void testExceptNoNewLine() throws Exception {\n\n    assertEquals(\"foo2:first line\", provider.getSourceLine(\"foo2\", 1));\n\n    assertEquals(\"foo2:second line\", provider.getSourceLine(\"foo2\", 2));\n\n    assertEquals(\"foo2:third line\", provider.getSourceLine(\"foo2\", 3));\n\n    assertEquals(null, provider.getSourceLine(\"foo2\", 4));\n\n  }\n"
      },
      "com.google.javascript.jscomp.JsMessageExtractorTest::testSyntaxError1": {
        "source": "  public void testSyntaxError1() {\n\n    try {\n\n      extractMessage(\"if (true) {}}\");\n\n      fail(\"Expected exception\");\n\n    } catch (RuntimeException e) {\n\n      assertTrue(e.getMessage().contains(\"JSCompiler errors\\n\"));\n\n      assertTrue(e.getMessage().contains(\n\n          \"testcode:1: ERROR - Parse error. syntax error\\n\"));\n\n      assertTrue(e.getMessage().contains(\"if (true) {}}\\n\"));\n"
      },
      "com.google.javascript.jscomp.JsMessageExtractorTest::testSyntaxError2": {
        "source": "  public void testSyntaxError2() {\n\n    try {\n\n      extractMessage(\"\", \"if (true) {}}\");\n\n      fail(\"Expected exception\");\n\n    } catch (RuntimeException e) {\n\n      assertTrue(e.getMessage().contains(\"JSCompiler errors\\n\"));\n\n      assertTrue(e.getMessage().contains(\n\n          \"testcode:2: ERROR - Parse error. syntax error\\n\"));\n\n      assertTrue(e.getMessage().contains(\"if (true) {}}\\n\"));\n"
      }
    }
  },
  "Closure-57": {
    "id": "Closure-57",
    "project": "Closure",
    "number": "57",
    "buggy_function": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target != null) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
    "fixed_function": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target != null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
      "first_line": 188,
      "last_line": 204
    },
    "javadoc": "/**\n* Exctracts X from goog.require('X'), if the applied Node is goog.\n*\n* @return The extracted class name, or null.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.ClosureCodingConventionTest::testRequire": {
        "source": "  public void testRequire() {\n\n    assertRequire(\"goog.require('foo')\");\n\n    assertNotRequire(\"goog.require(foo)\");\n\n    assertNotRequire(\"goog.require()\");\n\n    assertNotRequire(\"foo()\");\n\n  }\n"
      }
    }
  },
  "Closure-58": {
    "id": "Closure-58",
    "project": "Closure",
    "number": "58",
    "buggy_function": "private void computeGenKill(Node n, BitSet gen, BitSet kill,\n    boolean conditional) {\n\n  switch (n.getType()) {\n    case Token.SCRIPT:\n    case Token.BLOCK:\n    case Token.FUNCTION:\n      return;\n\n    case Token.WHILE:\n    case Token.DO:\n    case Token.IF:\n      computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n          conditional);\n      return;\n\n    case Token.FOR:\n      if (!NodeUtil.isForIn(n)) {\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n      } else {\n        // for(x in y) {...}\n        Node lhs = n.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (NodeUtil.isVar(lhs)) {\n          // for(var x in y) {...}\n          lhs = lhs.getLastChild();\n        }\n          addToSetIfLocal(lhs, kill);\n          addToSetIfLocal(lhs, gen);\n        computeGenKill(rhs, gen, kill, conditional);\n      }\n      return;\n\n    case Token.VAR:\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (c.hasChildren()) {\n          computeGenKill(c.getFirstChild(), gen, kill, conditional);\n          if (!conditional) {\n            addToSetIfLocal(c, kill);\n          }\n        }\n      }\n      return;\n\n    case Token.AND:\n    case Token.OR:\n      computeGenKill(n.getFirstChild(), gen, kill, conditional);\n      // May short circuit.\n      computeGenKill(n.getLastChild(), gen, kill, true);\n      return;\n\n    case Token.HOOK:\n      computeGenKill(n.getFirstChild(), gen, kill, conditional);\n      // Assume both sides are conditional.\n      computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n      computeGenKill(n.getLastChild(), gen, kill, true);\n      return;\n\n    case Token.NAME:\n      if (isArgumentsName(n)) {\n        markAllParametersEscaped();\n      } else {\n        addToSetIfLocal(n, gen);\n      }\n      return;\n\n    default:\n      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n        Node lhs = n.getFirstChild();\n        if (!conditional) {\n          addToSetIfLocal(lhs, kill);\n        }\n        if (!NodeUtil.isAssign(n)) {\n          // assignments such as a += 1 reads a.\n          addToSetIfLocal(lhs, gen);\n        }\n        computeGenKill(lhs.getNext(), gen, kill, conditional);\n      } else {\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeGenKill(c, gen, kill, conditional);\n        }\n      }\n      return;\n  }\n}",
    "fixed_function": "private void computeGenKill(Node n, BitSet gen, BitSet kill,\n    boolean conditional) {\n\n  switch (n.getType()) {\n    case Token.SCRIPT:\n    case Token.BLOCK:\n    case Token.FUNCTION:\n      return;\n\n    case Token.WHILE:\n    case Token.DO:\n    case Token.IF:\n      computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n          conditional);\n      return;\n\n    case Token.FOR:\n      if (!NodeUtil.isForIn(n)) {\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n      } else {\n        // for(x in y) {...}\n        Node lhs = n.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (NodeUtil.isVar(lhs)) {\n          // for(var x in y) {...}\n          lhs = lhs.getLastChild();\n        }\n        if (NodeUtil.isName(lhs)) {\n          addToSetIfLocal(lhs, kill);\n          addToSetIfLocal(lhs, gen);\n        } else {\n          computeGenKill(lhs, gen, kill, conditional);\n        }\n        computeGenKill(rhs, gen, kill, conditional);\n      }\n      return;\n\n    case Token.VAR:\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (c.hasChildren()) {\n          computeGenKill(c.getFirstChild(), gen, kill, conditional);\n          if (!conditional) {\n            addToSetIfLocal(c, kill);\n          }\n        }\n      }\n      return;\n\n    case Token.AND:\n    case Token.OR:\n      computeGenKill(n.getFirstChild(), gen, kill, conditional);\n      // May short circuit.\n      computeGenKill(n.getLastChild(), gen, kill, true);\n      return;\n\n    case Token.HOOK:\n      computeGenKill(n.getFirstChild(), gen, kill, conditional);\n      // Assume both sides are conditional.\n      computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n      computeGenKill(n.getLastChild(), gen, kill, true);\n      return;\n\n    case Token.NAME:\n      if (isArgumentsName(n)) {\n        markAllParametersEscaped();\n      } else {\n        addToSetIfLocal(n, gen);\n      }\n      return;\n\n    default:\n      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n        Node lhs = n.getFirstChild();\n        if (!conditional) {\n          addToSetIfLocal(lhs, kill);\n        }\n        if (!NodeUtil.isAssign(n)) {\n          // assignments such as a += 1 reads a.\n          addToSetIfLocal(lhs, gen);\n        }\n        computeGenKill(lhs.getNext(), gen, kill, conditional);\n      } else {\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeGenKill(c, gen, kill, conditional);\n        }\n      }\n      return;\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
      "first_line": 178,
      "last_line": 263
    },
    "javadoc": "/**\n* Computes the GEN and KILL set.\n*\n* @param n Root node.\n* @param gen Local variables that are live because of the instruction at\n*        {@code n} will be added to this set.\n* @param kill Local variables that are killed because of the instruction at\n*        {@code n} will be added to this set.\n* @param conditional {@code true} if any assignments encountered are\n*        conditionally executed. These assignments might not kill a variable.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.LiveVariableAnalysisTest::testExpressionInForIn": {
        "source": "  public void testExpressionInForIn() {\n\n    assertLiveBeforeX(\"var a = [0]; X:for (a[1] in foo) { }\", \"a\");\n\n  }\n"
      }
    }
  },
  "Closure-59": {
    "id": "Closure-59",
    "project": "Closure",
    "number": "59",
    "buggy_function": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n\n  ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n  // All passes must run the variable check. This synthesizes\n  // variables later so that the compiler doesn't crash. It also\n  // checks the externs file for validity. If you don't want to warn\n  // about missing variable declarations, we shut that specific\n  // error off.\n  if (!options.checkSymbols &&\n      !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n    composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n\n  this.warningsGuard = composedGuards;\n}",
    "fixed_function": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn() &&\n      !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n\n  ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n  // All passes must run the variable check. This synthesizes\n  // variables later so that the compiler doesn't crash. It also\n  // checks the externs file for validity. If you don't want to warn\n  // about missing variable declarations, we shut that specific\n  // error off.\n  if (!options.checkSymbols &&\n      !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n    composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n\n  this.warningsGuard = composedGuards;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/Compiler.java",
      "first_line": 226,
      "last_line": 288
    },
    "javadoc": "/**\n* Initialize the compiler options. Only necessary if you're not doing\n* a normal compile() job.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testCheckGlobalThisOff": {
        "source": "  public void testCheckGlobalThisOff() {\n\n    args.add(\"--warning_level=VERBOSE\");\n\n    args.add(\"--jscomp_off=globalThis\");\n\n    testSame(\"function f() { this.a = 3; }\");\n\n  }\n"
      }
    }
  },
  "Closure-61": {
    "id": "Closure-61",
    "project": "Closure",
    "number": "61",
    "buggy_function": "static boolean functionCallHasSideEffects(\n    Node callNode, @Nullable AbstractCompiler compiler) {\n  if (callNode.getType() != Token.CALL) {\n    throw new IllegalStateException(\n        \"Expected CALL node, got \" + Token.name(callNode.getType()));\n  }\n\n  if (callNode.isNoSideEffectsCall()) {\n    return false;\n  }\n\n  Node nameNode = callNode.getFirstChild();\n\n  // Built-in functions with no side effects.\n  if (nameNode.getType() == Token.NAME) {\n    String name = nameNode.getString();\n    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n      return false;\n    }\n  } else if (nameNode.getType() == Token.GETPROP) {\n    if (callNode.hasOneChild()\n        && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n              nameNode.getLastChild().getString())) {\n      return false;\n    }\n\n    if (callNode.isOnlyModifiesThisCall()\n        && evaluatesToLocalValue(nameNode.getFirstChild())) {\n      return false;\n    }\n\n    // Functions in the \"Math\" namespace have no side effects.\n\n    if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n      if (nameNode.getFirstChild().getType() == Token.REGEXP\n          && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      } else if (nameNode.getFirstChild().getType() == Token.STRING\n          && STRING_REGEXP_METHODS.contains(\n              nameNode.getLastChild().getString())) {\n        Node param = nameNode.getNext();\n        if (param != null &&\n            (param.getType() == Token.STRING\n                || param.getType() == Token.REGEXP))\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
    "fixed_function": "static boolean functionCallHasSideEffects(\n    Node callNode, @Nullable AbstractCompiler compiler) {\n  if (callNode.getType() != Token.CALL) {\n    throw new IllegalStateException(\n        \"Expected CALL node, got \" + Token.name(callNode.getType()));\n  }\n\n  if (callNode.isNoSideEffectsCall()) {\n    return false;\n  }\n\n  Node nameNode = callNode.getFirstChild();\n\n  // Built-in functions with no side effects.\n  if (nameNode.getType() == Token.NAME) {\n    String name = nameNode.getString();\n    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n      return false;\n    }\n  } else if (nameNode.getType() == Token.GETPROP) {\n    if (callNode.hasOneChild()\n        && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n              nameNode.getLastChild().getString())) {\n      return false;\n    }\n\n    if (callNode.isOnlyModifiesThisCall()\n        && evaluatesToLocalValue(nameNode.getFirstChild())) {\n      return false;\n    }\n\n    // Functions in the \"Math\" namespace have no side effects.\n    if (nameNode.getFirstChild().getType() == Token.NAME) {\n      String namespaceName = nameNode.getFirstChild().getString();\n      if (namespaceName.equals(\"Math\")) {\n        return false;\n      }\n    }\n\n    if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n      if (nameNode.getFirstChild().getType() == Token.REGEXP\n          && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      } else if (nameNode.getFirstChild().getType() == Token.STRING\n          && STRING_REGEXP_METHODS.contains(\n              nameNode.getLastChild().getString())) {\n        Node param = nameNode.getNext();\n        if (param != null &&\n            (param.getType() == Token.STRING\n                || param.getType() == Token.REGEXP))\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/NodeUtil.java",
      "first_line": 926,
      "last_line": 976
    },
    "javadoc": "/**\n* Returns true if calls to this function have side effects.\n*\n* @param callNode The call node to inspected.\n* @param compiler A compiler object to provide program state changing\n*     context information. Can be null.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeRemoveDeadCodeTest::testCall1": {
        "source": "  public void testCall1() {\n\n    test(\"Math.sin(0);\", \"\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.PeepholeRemoveDeadCodeTest::testCall2": {
        "source": "  public void testCall2() {\n\n    test(\"1 + Math.sin(0);\", \"\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.PeepholeRemoveDeadCodeTest::testRemoveUselessOps": {
        "source": "  public void testRemoveUselessOps() {\n\n    // There are four place where expression results are discarded:\n\n    //  - a top level expression EXPR_RESULT\n\n    //  - the LHS of a COMMA\n\n    //  - the FOR init expression\n\n    //  - the FOR increment expression\n\n\n\n\n\n    // Known side-effect free functions calls are removed.\n\n    fold(\"Math.random()\", \"\");\n\n    fold(\"Math.random(f() + g())\", \"f(),g();\");\n\n    fold(\"Math.random(f(),g(),h())\", \"f(),g(),h();\");\n\n\n\n    // Calls to functions with unknown side-effects are are left.\n\n    foldSame(\"f();\");\n\n    foldSame(\"(function () {})();\");\n\n\n\n    // Uncalled function expressions are removed\n\n    fold(\"(function () {});\", \"\");\n\n    fold(\"(function f() {});\", \"\");\n\n    // ... including any code they contain.\n\n    fold(\"(function () {foo();});\", \"\");\n\n\n\n    // Useless operators are removed.\n\n    fold(\"+f()\", \"f()\");\n\n    fold(\"a=(+f(),g())\", \"a=(f(),g())\");\n\n    fold(\"a=(true,g())\", \"a=g()\");\n\n    fold(\"f(),true\", \"f()\");\n\n    fold(\"f() + g()\", \"f(),g()\");\n\n\n\n    fold(\"for(;;+f()){}\", \"for(;;f()){}\");\n\n    fold(\"for(+f();;g()){}\", \"for(f();;g()){}\");\n\n    fold(\"for(;;Math.random(f(),g(),h())){}\", \"for(;;f(),g(),h()){}\");\n\n\n\n    // The optimization cascades into conditional expressions:\n\n    fold(\"g() && +f()\", \"g() && f()\");\n\n    fold(\"g() || +f()\", \"g() || f()\");\n\n    fold(\"x ? g() : +f()\", \"x ? g() : f()\");\n\n\n\n    fold(\"+x()\", \"x()\");\n\n    fold(\"+x() * 2\", \"x()\");\n\n    fold(\"-(+x() * 2)\", \"x()\");\n\n    fold(\"2 -(+x() * 2)\", \"x()\");\n\n    fold(\"x().foo\", \"x()\");\n\n    foldSame(\"x().foo()\");\n\n\n\n    foldSame(\"x++\");\n\n    foldSame(\"++x\");\n\n    foldSame(\"x--\");\n\n    foldSame(\"--x\");\n\n    foldSame(\"x = 2\");\n\n    foldSame(\"x *= 2\");\n\n\n\n    // Sanity check, other expression are left alone.\n\n    foldSame(\"function f() {}\");\n\n    foldSame(\"var x;\");\n\n  }\n"
      }
    }
  },
  "Closure-62": {
    "id": "Closure-62",
    "project": "Closure",
    "number": "62",
    "buggy_function": "private String format(JSError error, boolean warning) {\n  // extract source excerpt\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n\n  // formatting the message\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n\n    // padding equal to the excerpt and arrow at the end\n    // charno == sourceExpert.length() means something is missing\n    // at the end of the line\n    if (excerpt.equals(LINE)\n        && 0 <= charno && charno < sourceExcerpt.length()) {\n      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}",
    "fixed_function": "private String format(JSError error, boolean warning) {\n  // extract source excerpt\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n\n  // formatting the message\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n\n    // padding equal to the excerpt and arrow at the end\n    // charno == sourceExpert.length() means something is missing\n    // at the end of the line\n    if (excerpt.equals(LINE)\n        && 0 <= charno && charno <= sourceExcerpt.length()) {\n      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java",
      "first_line": 66,
      "last_line": 111
    },
    "javadoc": "/**\n* A constructor for when the client doesn't care about source information.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.LightweightMessageFormatterTest::testFormatErrorSpaceEndOfLine1": {
        "source": "  public void testFormatErrorSpaceEndOfLine1() throws Exception {\n\n    JSError error = JSError.make(\"javascript/complex.js\",\n\n        1, 10, FOO_TYPE);\n\n    LightweightMessageFormatter formatter = formatter(\"assert (1;\");\n\n    assertEquals(\"javascript/complex.js:1: ERROR - error description here\\n\" +\n\n        \"assert (1;\\n\" +\n\n        \"          ^\\n\", formatter.formatError(error));\n\n  }\n"
      },
      "com.google.javascript.jscomp.LightweightMessageFormatterTest::testFormatErrorSpaceEndOfLine2": {
        "source": "  public void testFormatErrorSpaceEndOfLine2() throws Exception {\n\n    JSError error = JSError.make(\"javascript/complex.js\",\n\n        6, 7, FOO_TYPE);\n\n    LightweightMessageFormatter formatter = formatter(\"if (foo\");\n\n    assertEquals(\"javascript/complex.js:6: ERROR - error description here\\n\" +\n\n        \"if (foo\\n\" +\n\n        \"       ^\\n\", formatter.formatError(error));\n\n  }\n"
      }
    }
  },
  "Closure-65": {
    "id": "Closure-65",
    "project": "Closure",
    "number": "65",
    "buggy_function": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
    "fixed_function": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 1005,
      "last_line": 1075
    },
    "javadoc": "/**\n* Escapes the given string to a double quoted (\") JavaScript/JSON string\n*/\nstatic String escapeToDoubleQuotedJsString(String s) {\nreturn strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n}\n\n/* If the user doesn't want to specify an output charset encoder, assume\nthey want Latin/ASCII characters only.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testZero": {
        "source": "  public void testZero() {\n\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\000\\\"\");\n\n    assertPrint(\"var x ='\\\\x00';\", \"var x=\\\"\\\\000\\\"\");\n\n    assertPrint(\"var x ='\\\\u0000';\", \"var x=\\\"\\\\000\\\"\");\n\n    assertPrint(\"var x ='\\\\u00003';\", \"var x=\\\"\\\\0003\\\"\");\n\n  }\n"
      }
    }
  },
  "Closure-66": {
    "id": "Closure-66",
    "project": "Closure",
    "number": "66",
    "buggy_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n  JSType childType;\n  JSType leftType, rightType;\n  Node left, right;\n  // To be explicitly set to false if the node is not typeable.\n  boolean typeable = true;\n\n  switch (n.getType()) {\n    case Token.NAME:\n      typeable = visitName(t, n, parent);\n      break;\n\n    case Token.LP:\n      // If this is under a FUNCTION node, it is a parameter list and can be\n      // ignored here.\n      if (parent.getType() != Token.FUNCTION) {\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n      } else {\n        typeable = false;\n      }\n      break;\n\n    case Token.COMMA:\n      ensureTyped(t, n, getJSType(n.getLastChild()));\n      break;\n\n    case Token.TRUE:\n    case Token.FALSE:\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.THIS:\n      ensureTyped(t, n, t.getScope().getTypeOfThis());\n      break;\n\n    case Token.REF_SPECIAL:\n      ensureTyped(t, n);\n      break;\n\n    case Token.GET_REF:\n      ensureTyped(t, n, getJSType(n.getFirstChild()));\n      break;\n\n    case Token.NULL:\n      ensureTyped(t, n, NULL_TYPE);\n      break;\n\n    case Token.NUMBER:\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.STRING:\n      // Object literal keys are handled with OBJECTLIT\n      if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n        ensureTyped(t, n, STRING_TYPE);\n        // Object literal keys are not typeable\n      }\n      break;\n\n    case Token.GET:\n    case Token.SET:\n      // Object literal keys are handled with OBJECTLIT\n      break;\n\n    case Token.ARRAYLIT:\n      ensureTyped(t, n, ARRAY_TYPE);\n      break;\n\n    case Token.REGEXP:\n      ensureTyped(t, n, REGEXP_TYPE);\n      break;\n\n    case Token.GETPROP:\n      visitGetProp(t, n, parent);\n      typeable = !(parent.getType() == Token.ASSIGN &&\n                   parent.getFirstChild() == n);\n      break;\n\n    case Token.GETELEM:\n      visitGetElem(t, n);\n      // The type of GETELEM is always unknown, so no point counting that.\n      // If that unknown leaks elsewhere (say by an assignment to another\n      // variable), then it will be counted.\n      typeable = false;\n      break;\n\n    case Token.VAR:\n      visitVar(t, n);\n      typeable = false;\n      break;\n\n    case Token.NEW:\n      visitNew(t, n);\n      typeable = true;\n      break;\n\n    case Token.CALL:\n      visitCall(t, n);\n      typeable = !NodeUtil.isExpressionNode(parent);\n      break;\n\n    case Token.RETURN:\n      visitReturn(t, n);\n      typeable = false;\n      break;\n\n    case Token.DEC:\n    case Token.INC:\n      left = n.getFirstChild();\n      validator.expectNumber(\n          t, left, getJSType(left), \"increment/decrement\");\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.NOT:\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.VOID:\n      ensureTyped(t, n, VOID_TYPE);\n      break;\n\n    case Token.TYPEOF:\n      ensureTyped(t, n, STRING_TYPE);\n      break;\n\n    case Token.BITNOT:\n      childType = getJSType(n.getFirstChild());\n      if (!childType.matchesInt32Context()) {\n        report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n            childType.toString());\n      }\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.POS:\n    case Token.NEG:\n      left = n.getFirstChild();\n      validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.EQ:\n    case Token.NE: {\n      leftType = getJSType(n.getFirstChild());\n      rightType = getJSType(n.getLastChild());\n\n      JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n      JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n      TernaryValue result =\n          leftTypeRestricted.testForEquality(rightTypeRestricted);\n      if (result != TernaryValue.UNKNOWN) {\n        if (n.getType() == Token.NE) {\n          result = result.not();\n        }\n        report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n            rightType.toString(), result.toString());\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n    }\n\n    case Token.SHEQ:\n    case Token.SHNE: {\n      leftType = getJSType(n.getFirstChild());\n      rightType = getJSType(n.getLastChild());\n\n      JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n      JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n      if (!leftTypeRestricted.canTestForShallowEqualityWith(\n              rightTypeRestricted)) {\n        report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n            rightType.toString());\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n    }\n\n    case Token.LT:\n    case Token.LE:\n    case Token.GT:\n    case Token.GE:\n      leftType = getJSType(n.getFirstChild());\n      rightType = getJSType(n.getLastChild());\n      if (rightType.isNumber()) {\n        validator.expectNumber(\n            t, n, leftType, \"left side of numeric comparison\");\n      } else if (leftType.isNumber()) {\n        validator.expectNumber(\n            t, n, rightType, \"right side of numeric comparison\");\n      } else if (leftType.matchesNumberContext() &&\n                 rightType.matchesNumberContext()) {\n        // OK.\n      } else {\n        // Whether the comparison is numeric will be determined at runtime\n        // each time the expression is evaluated. Regardless, both operands\n        // should match a string context.\n        String message = \"left side of comparison\";\n        validator.expectString(t, n, leftType, message);\n        validator.expectNotNullOrUndefined(\n            t, n, leftType, message, getNativeType(STRING_TYPE));\n        message = \"right side of comparison\";\n        validator.expectString(t, n, rightType, message);\n        validator.expectNotNullOrUndefined(\n            t, n, rightType, message, getNativeType(STRING_TYPE));\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.IN:\n      left = n.getFirstChild();\n      right = n.getLastChild();\n      leftType = getJSType(left);\n      rightType = getJSType(right);\n      validator.expectObject(t, n, rightType, \"'in' requires an object\");\n      validator.expectString(t, left, leftType, \"left side of 'in'\");\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.INSTANCEOF:\n      left = n.getFirstChild();\n      right = n.getLastChild();\n      leftType = getJSType(left);\n      rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n      validator.expectAnyObject(\n          t, left, leftType, \"deterministic instanceof yields false\");\n      validator.expectActualObject(\n          t, right, rightType, \"instanceof requires an object\");\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.ASSIGN:\n      visitAssign(t, n);\n      typeable = false;\n      break;\n\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_MOD:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_MUL:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n    case Token.SUB:\n    case Token.ADD:\n    case Token.MUL:\n      visitBinaryOperator(n.getType(), t, n);\n      break;\n\n    case Token.DELPROP:\n      if (!isReference(n.getFirstChild())) {\n        report(t, n, BAD_DELETE);\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.CASE:\n      JSType switchType = getJSType(parent.getFirstChild());\n      JSType caseType = getJSType(n.getFirstChild());\n      validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n      typeable = false;\n      break;\n\n    case Token.WITH: {\n      Node child = n.getFirstChild();\n      childType = getJSType(child);\n      validator.expectObject(\n          t, child, childType, \"with requires an object\");\n      typeable = false;\n      break;\n    }\n\n    case Token.FUNCTION:\n      visitFunction(t, n);\n      break;\n\n    // These nodes have no interesting type behavior.\n    case Token.LABEL:\n    case Token.LABEL_NAME:\n    case Token.SWITCH:\n    case Token.BREAK:\n    case Token.CATCH:\n    case Token.TRY:\n    case Token.SCRIPT:\n    case Token.EXPR_RESULT:\n    case Token.BLOCK:\n    case Token.EMPTY:\n    case Token.DEFAULT:\n    case Token.CONTINUE:\n    case Token.DEBUGGER:\n    case Token.THROW:\n      typeable = false;\n      break;\n\n    // These nodes require data flow analysis.\n    case Token.DO:\n    case Token.FOR:\n    case Token.IF:\n    case Token.WHILE:\n      typeable = false;\n      break;\n\n    // These nodes are typed during the type inference.\n    case Token.AND:\n    case Token.HOOK:\n    case Token.OBJECTLIT:\n    case Token.OR:\n      if (n.getJSType() != null) { // If we didn't run type inference.\n        ensureTyped(t, n);\n      } else {\n        // If this is an enum, then give that type to the objectlit as well.\n        if ((n.getType() == Token.OBJECTLIT)\n            && (parent.getJSType() instanceof EnumType)) {\n          ensureTyped(t, n, parent.getJSType());\n        } else {\n          ensureTyped(t, n);\n        }\n      }\n      if (n.getType() == Token.OBJECTLIT) {\n        for (Node key : n.children()) {\n          visitObjLitKey(t, key, n);\n        }\n      }\n      break;\n\n    default:\n      report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n      ensureTyped(t, n);\n      break;\n  }\n\n  // Don't count externs since the user's code may not even use that part.\n  typeable = typeable && !inExterns;\n\n  if (typeable) {\n    doPercentTypedAccounting(t, n);\n  }\n\n  checkNoTypeCheckSection(n, false);\n}",
    "fixed_function": "public void visit(NodeTraversal t, Node n, Node parent) {\n  JSType childType;\n  JSType leftType, rightType;\n  Node left, right;\n  // To be explicitly set to false if the node is not typeable.\n  boolean typeable = true;\n\n  switch (n.getType()) {\n    case Token.NAME:\n      typeable = visitName(t, n, parent);\n      break;\n\n    case Token.LP:\n      // If this is under a FUNCTION node, it is a parameter list and can be\n      // ignored here.\n      if (parent.getType() != Token.FUNCTION) {\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n      } else {\n        typeable = false;\n      }\n      break;\n\n    case Token.COMMA:\n      ensureTyped(t, n, getJSType(n.getLastChild()));\n      break;\n\n    case Token.TRUE:\n    case Token.FALSE:\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.THIS:\n      ensureTyped(t, n, t.getScope().getTypeOfThis());\n      break;\n\n    case Token.REF_SPECIAL:\n      ensureTyped(t, n);\n      break;\n\n    case Token.GET_REF:\n      ensureTyped(t, n, getJSType(n.getFirstChild()));\n      break;\n\n    case Token.NULL:\n      ensureTyped(t, n, NULL_TYPE);\n      break;\n\n    case Token.NUMBER:\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.STRING:\n      // Object literal keys are handled with OBJECTLIT\n      if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n        ensureTyped(t, n, STRING_TYPE);\n      } else {\n        // Object literal keys are not typeable\n        typeable = false;\n      }\n      break;\n\n    case Token.GET:\n    case Token.SET:\n      // Object literal keys are handled with OBJECTLIT\n      break;\n\n    case Token.ARRAYLIT:\n      ensureTyped(t, n, ARRAY_TYPE);\n      break;\n\n    case Token.REGEXP:\n      ensureTyped(t, n, REGEXP_TYPE);\n      break;\n\n    case Token.GETPROP:\n      visitGetProp(t, n, parent);\n      typeable = !(parent.getType() == Token.ASSIGN &&\n                   parent.getFirstChild() == n);\n      break;\n\n    case Token.GETELEM:\n      visitGetElem(t, n);\n      // The type of GETELEM is always unknown, so no point counting that.\n      // If that unknown leaks elsewhere (say by an assignment to another\n      // variable), then it will be counted.\n      typeable = false;\n      break;\n\n    case Token.VAR:\n      visitVar(t, n);\n      typeable = false;\n      break;\n\n    case Token.NEW:\n      visitNew(t, n);\n      typeable = true;\n      break;\n\n    case Token.CALL:\n      visitCall(t, n);\n      typeable = !NodeUtil.isExpressionNode(parent);\n      break;\n\n    case Token.RETURN:\n      visitReturn(t, n);\n      typeable = false;\n      break;\n\n    case Token.DEC:\n    case Token.INC:\n      left = n.getFirstChild();\n      validator.expectNumber(\n          t, left, getJSType(left), \"increment/decrement\");\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.NOT:\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.VOID:\n      ensureTyped(t, n, VOID_TYPE);\n      break;\n\n    case Token.TYPEOF:\n      ensureTyped(t, n, STRING_TYPE);\n      break;\n\n    case Token.BITNOT:\n      childType = getJSType(n.getFirstChild());\n      if (!childType.matchesInt32Context()) {\n        report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n            childType.toString());\n      }\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.POS:\n    case Token.NEG:\n      left = n.getFirstChild();\n      validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n      ensureTyped(t, n, NUMBER_TYPE);\n      break;\n\n    case Token.EQ:\n    case Token.NE: {\n      leftType = getJSType(n.getFirstChild());\n      rightType = getJSType(n.getLastChild());\n\n      JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n      JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n      TernaryValue result =\n          leftTypeRestricted.testForEquality(rightTypeRestricted);\n      if (result != TernaryValue.UNKNOWN) {\n        if (n.getType() == Token.NE) {\n          result = result.not();\n        }\n        report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n            rightType.toString(), result.toString());\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n    }\n\n    case Token.SHEQ:\n    case Token.SHNE: {\n      leftType = getJSType(n.getFirstChild());\n      rightType = getJSType(n.getLastChild());\n\n      JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n      JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n      if (!leftTypeRestricted.canTestForShallowEqualityWith(\n              rightTypeRestricted)) {\n        report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n            rightType.toString());\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n    }\n\n    case Token.LT:\n    case Token.LE:\n    case Token.GT:\n    case Token.GE:\n      leftType = getJSType(n.getFirstChild());\n      rightType = getJSType(n.getLastChild());\n      if (rightType.isNumber()) {\n        validator.expectNumber(\n            t, n, leftType, \"left side of numeric comparison\");\n      } else if (leftType.isNumber()) {\n        validator.expectNumber(\n            t, n, rightType, \"right side of numeric comparison\");\n      } else if (leftType.matchesNumberContext() &&\n                 rightType.matchesNumberContext()) {\n        // OK.\n      } else {\n        // Whether the comparison is numeric will be determined at runtime\n        // each time the expression is evaluated. Regardless, both operands\n        // should match a string context.\n        String message = \"left side of comparison\";\n        validator.expectString(t, n, leftType, message);\n        validator.expectNotNullOrUndefined(\n            t, n, leftType, message, getNativeType(STRING_TYPE));\n        message = \"right side of comparison\";\n        validator.expectString(t, n, rightType, message);\n        validator.expectNotNullOrUndefined(\n            t, n, rightType, message, getNativeType(STRING_TYPE));\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.IN:\n      left = n.getFirstChild();\n      right = n.getLastChild();\n      leftType = getJSType(left);\n      rightType = getJSType(right);\n      validator.expectObject(t, n, rightType, \"'in' requires an object\");\n      validator.expectString(t, left, leftType, \"left side of 'in'\");\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.INSTANCEOF:\n      left = n.getFirstChild();\n      right = n.getLastChild();\n      leftType = getJSType(left);\n      rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n      validator.expectAnyObject(\n          t, left, leftType, \"deterministic instanceof yields false\");\n      validator.expectActualObject(\n          t, right, rightType, \"instanceof requires an object\");\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.ASSIGN:\n      visitAssign(t, n);\n      typeable = false;\n      break;\n\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_MOD:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_MUL:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n    case Token.SUB:\n    case Token.ADD:\n    case Token.MUL:\n      visitBinaryOperator(n.getType(), t, n);\n      break;\n\n    case Token.DELPROP:\n      if (!isReference(n.getFirstChild())) {\n        report(t, n, BAD_DELETE);\n      }\n      ensureTyped(t, n, BOOLEAN_TYPE);\n      break;\n\n    case Token.CASE:\n      JSType switchType = getJSType(parent.getFirstChild());\n      JSType caseType = getJSType(n.getFirstChild());\n      validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n      typeable = false;\n      break;\n\n    case Token.WITH: {\n      Node child = n.getFirstChild();\n      childType = getJSType(child);\n      validator.expectObject(\n          t, child, childType, \"with requires an object\");\n      typeable = false;\n      break;\n    }\n\n    case Token.FUNCTION:\n      visitFunction(t, n);\n      break;\n\n    // These nodes have no interesting type behavior.\n    case Token.LABEL:\n    case Token.LABEL_NAME:\n    case Token.SWITCH:\n    case Token.BREAK:\n    case Token.CATCH:\n    case Token.TRY:\n    case Token.SCRIPT:\n    case Token.EXPR_RESULT:\n    case Token.BLOCK:\n    case Token.EMPTY:\n    case Token.DEFAULT:\n    case Token.CONTINUE:\n    case Token.DEBUGGER:\n    case Token.THROW:\n      typeable = false;\n      break;\n\n    // These nodes require data flow analysis.\n    case Token.DO:\n    case Token.FOR:\n    case Token.IF:\n    case Token.WHILE:\n      typeable = false;\n      break;\n\n    // These nodes are typed during the type inference.\n    case Token.AND:\n    case Token.HOOK:\n    case Token.OBJECTLIT:\n    case Token.OR:\n      if (n.getJSType() != null) { // If we didn't run type inference.\n        ensureTyped(t, n);\n      } else {\n        // If this is an enum, then give that type to the objectlit as well.\n        if ((n.getType() == Token.OBJECTLIT)\n            && (parent.getJSType() instanceof EnumType)) {\n          ensureTyped(t, n, parent.getJSType());\n        } else {\n          ensureTyped(t, n);\n        }\n      }\n      if (n.getType() == Token.OBJECTLIT) {\n        for (Node key : n.children()) {\n          visitObjLitKey(t, key, n);\n        }\n      }\n      break;\n\n    default:\n      report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n      ensureTyped(t, n);\n      break;\n  }\n\n  // Don't count externs since the user's code may not even use that part.\n  typeable = typeable && !inExterns;\n\n  if (typeable) {\n    doPercentTypedAccounting(t, n);\n  }\n\n  checkNoTypeCheckSection(n, false);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeCheck.java",
      "first_line": 461,
      "last_line": 813
    },
    "javadoc": "/**\n* This is the meat of the type checking.  It is basically one big switch,\n* with each case representing one type of parse tree node.  The individual\n* cases are usually pretty straightforward.\n*\n* @param t The node traversal object that supplies context, such as the\n* scope chain to use in name lookups as well as error reporting.\n* @param n The node being visited.\n* @param parent The parent of the node n.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testGetTypedPercent5": {
        "source": "  public void testGetTypedPercent5() throws Exception {\n\n    String js = \"/** @enum {number} */ keys = {A: 1,B: 2,C: 3};\";\n\n    assertEquals(100.0, getTypedPercent(js), 0.1);\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testGetTypedPercent6": {
        "source": "  public void testGetTypedPercent6() throws Exception {\n\n    String js = \"a = {TRUE: 1, FALSE: 0};\";\n\n    assertEquals(100.0, getTypedPercent(js), 0.1);\n\n  }\n"
      }
    }
  },
  "Closure-67": {
    "id": "Closure-67",
    "project": "Closure",
    "number": "67",
    "buggy_function": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      ) {\n    // We want to exclude the assignment itself from the usage list\n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
    "fixed_function": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && assign.getParent().getType() == Token.EXPR_RESULT) {\n    // We want to exclude the assignment itself from the usage list\n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
      "first_line": 314,
      "last_line": 334
    },
    "javadoc": "/**\n* Determines whether {@code n} is the FUNCTION node in a global function\n* declaration.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.RemoveUnusedPrototypePropertiesTest::testAliasing7": {
        "source": "  public void testAliasing7() {\n\n    // An exported alias must preserved any referenced values in the\n\n    // referenced function.\n\n    testSame(\"function e(){}\" +\n\n           \"e.prototype['alias1'] = e.prototype.method1 = \" +\n\n               \"function(){this.method2()};\" +\n\n           \"e.prototype.method2 = function(){};\");\n\n  }\n"
      }
    }
  },
  "Closure-69": {
    "id": "Closure-69",
    "project": "Closure",
    "number": "69",
    "buggy_function": "private void visitCall(NodeTraversal t, Node n) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType instanceof FunctionType) {\n    FunctionType functionType = (FunctionType) childType;\n\n    boolean isExtern = false;\n    JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n    if(functionJSDocInfo != null) {\n      String sourceName = functionJSDocInfo.getSourceName();\n      CompilerInput functionSource = compiler.getInput(sourceName);\n      isExtern = functionSource.isExtern();\n    }\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type and are defined\n    // in an extern.\n    if (functionType.isConstructor() &&\n        !functionType.isNativeObjectType() &&\n        (functionType.getReturnType().isUnknownType() ||\n         functionType.getReturnType().isVoidType() ||\n         !isExtern)) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n    }\n\n    // Functions with explcit 'this' types must be called in a GETPROP\n    // or GETELEM.\n\n    visitParameterList(t, n, functionType);\n    ensureTyped(t, n, functionType.getReturnType());\n  } else {\n    ensureTyped(t, n);\n  }\n\n  // TODO: Add something to check for calls of RegExp objects, which is not\n  // supported by IE.  Either say something about the return type or warn\n  // about the non-portability of the call or both.\n}",
    "fixed_function": "private void visitCall(NodeTraversal t, Node n) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType instanceof FunctionType) {\n    FunctionType functionType = (FunctionType) childType;\n\n    boolean isExtern = false;\n    JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n    if(functionJSDocInfo != null) {\n      String sourceName = functionJSDocInfo.getSourceName();\n      CompilerInput functionSource = compiler.getInput(sourceName);\n      isExtern = functionSource.isExtern();\n    }\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type and are defined\n    // in an extern.\n    if (functionType.isConstructor() &&\n        !functionType.isNativeObjectType() &&\n        (functionType.getReturnType().isUnknownType() ||\n         functionType.getReturnType().isVoidType() ||\n         !isExtern)) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n    }\n\n    // Functions with explcit 'this' types must be called in a GETPROP\n    // or GETELEM.\n    if (functionType.isOrdinaryFunction() &&\n        !functionType.getTypeOfThis().isUnknownType() &&\n        !functionType.getTypeOfThis().isNativeObjectType() &&\n        !(child.getType() == Token.GETELEM ||\n          child.getType() == Token.GETPROP)) {\n      report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n    }\n\n    visitParameterList(t, n, functionType);\n    ensureTyped(t, n, functionType.getReturnType());\n  } else {\n    ensureTyped(t, n);\n  }\n\n  // TODO: Add something to check for calls of RegExp objects, which is not\n  // supported by IE.  Either say something about the return type or warn\n  // about the non-portability of the call or both.\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeCheck.java",
      "first_line": 1544,
      "last_line": 1590
    },
    "javadoc": "/**\n* Visits a CALL node.\n*\n* @param t The node traversal object that supplies context, such as the\n* scope chain to use in name lookups as well as error reporting.\n* @param n The node being visited.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testThisTypeOfFunction2": {
        "source": "  public void testThisTypeOfFunction2() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function F() {}\" +\n\n        \"/** @type {function(this:F)} */ function f() {}\" +\n\n        \"f();\",\n\n        \"\\\"function (this:F): ?\\\" must be called with a \\\"this\\\" type\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testThisTypeOfFunction3": {
        "source": "  public void testThisTypeOfFunction3() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function F() {}\" +\n\n        \"F.prototype.bar = function() {};\" +\n\n        \"var f = (new F()).bar; f();\",\n\n        \"\\\"function (this:F): undefined\\\" must be called with a \\\"this\\\" type\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testThisTypeOfFunction4": {
        "source": "  public void testThisTypeOfFunction4() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function F() {}\" +\n\n        \"F.prototype.moveTo = function(x, y) {};\" +\n\n        \"F.prototype.lineTo = function(x, y) {};\" +\n\n        \"function demo() {\" +\n\n        \"  var path = new F();\" +\n\n        \"  var points = [[1,1], [2,2]];\" +\n\n        \"  for (var i = 0; i < points.length; i++) {\" +\n\n        \"    (i == 0 ? path.moveTo : path.lineTo)(\" +\n\n        \"       points[i][0], points[i][1]);\" +\n\n        \"  }\" +\n\n        \"}\",\n\n        \"\\\"function (this:F, ?, ?): undefined\\\" \" +\n\n        \"must be called with a \\\"this\\\" type\");\n\n  }\n"
      }
    }
  },
  "Closure-7": {
    "id": "Closure-7",
    "project": "Closure",
    "number": "7",
    "buggy_function": "public JSType caseObjectType(ObjectType type) {\n  if (value.equals(\"function\")) {\n    JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n    return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n      // Objects are restricted to \"Function\", subtypes are left\n      // Only filter out subtypes of \"function\"\n  }\n  return matchesExpectation(\"object\") ? type : null;\n}",
    "fixed_function": "public JSType caseObjectType(ObjectType type) {\n  if (value.equals(\"function\")) {\n    JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n    if (resultEqualsValue) {\n      // Objects are restricted to \"Function\", subtypes are left\n      return ctorType.getGreatestSubtype(type);\n    } else {\n      // Only filter out subtypes of \"function\"\n      return type.isSubtype(ctorType) ? null : type;\n    }\n  }\n  return matchesExpectation(\"object\") ? type : null;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
      "first_line": 610,
      "last_line": 618
    },
    "javadoc": "/**\n* Computes whether the given result of a {@code typeof} operator matches\n* expectations, i.e. whether a type that gives such a result should be\n* kept.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsFunction2": {
        "source": "  public void testGoogIsFunction2() throws Exception {\n\n    testClosureFunction(\"goog.isFunction\",\n\n        OBJECT_NUMBER_STRING_BOOLEAN,\n\n        U2U_CONSTRUCTOR_TYPE,\n\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n  }\n"
      },
      "com.google.javascript.jscomp.SemanticReverseAbstractInterpreterTest::testTypeof3": {
        "source": "  public void testTypeof3() {\n\n    FlowScope blind = newScope();\n\n    testBinop(blind,\n\n        Token.EQ,\n\n        new Node(Token.TYPEOF, createVar(\n\n            blind, \"a\", OBJECT_NUMBER_STRING_BOOLEAN)),\n\n        Node.newString(\"function\"),\n\n        Sets.newHashSet(\n\n            new TypedName(\"a\", U2U_CONSTRUCTOR_TYPE)),\n\n        Sets.newHashSet(\n\n            new TypedName(\"a\", OBJECT_NUMBER_STRING_BOOLEAN)));\n\n  }\n"
      }
    }
  },
  "Closure-70": {
    "id": "Closure-70",
    "project": "Closure",
    "number": "70",
    "buggy_function": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n} // end declareArguments",
    "fixed_function": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSType(), false);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n} // end declareArguments",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 1734,
      "last_line": 1753
    },
    "javadoc": "/**\n* Declares all of a function's arguments.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateLocalVarDecl": {
        "source": "  public void testDuplicateLocalVarDecl() throws Exception {\n\n    testClosureTypesMultipleWarnings(\n\n        \"/** @param {number} x */\\n\" +\n\n        \"function f(x) { /** @type {string} */ var x = ''; }\",\n\n        Lists.newArrayList(\n\n            \"variable x redefined with type string, original definition\" +\n\n            \" at  [testcode] :2 with type number\",\n\n            \"initializing variable\\n\" +\n\n            \"found   : string\\n\" +\n\n            \"required: number\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionArguments13": {
        "source": "  public void testFunctionArguments13() throws Exception {\n\n    // verifying that the argument type have non-inferrable types\n\n    testTypes(\n\n        \"/** @return {boolean} */ function u() { return true; }\" +\n\n        \"/** @param {boolean} b\\n@return {?boolean} */\" +\n\n        \"function f(b) { if (u()) { b = null; } return b; }\",\n\n        \"assignment\\n\" +\n\n        \"found   : null\\n\" +\n\n        \"required: boolean\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testScoping12": {
        "source": "  public void testScoping12() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */ function F() {}\" +\n\n        \"/** @type {number} */ F.prototype.bar = 3;\" +\n\n        \"/** @param {!F} f */ function g(f) {\" +\n\n        \"  /** @return {string} */\" +\n\n        \"  function h() {\" +\n\n        \"    return f.bar;\" +\n\n        \"  }\" +\n\n        \"}\",\n\n        \"inconsistent return type\\n\" +\n\n        \"found   : number\\n\" +\n\n        \"required: string\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testDuplicateLocalVarDecl": {
        "source": "  public void testDuplicateLocalVarDecl() throws Exception {\n\n    testClosureTypesMultipleWarnings(\n\n        \"/** @param {number} x */\\n\" +\n\n        \"function f(x) { /** @type {string} */ var x = ''; }\",\n\n        Lists.newArrayList(\n\n            \"variable x redefined with type string, original definition\" +\n\n            \" at  [testcode] :2 with type number\",\n\n            \"initializing variable\\n\" +\n\n            \"found   : string\\n\" +\n\n            \"required: number\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionArguments13": {
        "source": "  public void testFunctionArguments13() throws Exception {\n\n    // verifying that the argument type have non-inferrable types\n\n    testTypes(\n\n        \"/** @return {boolean} */ function u() { return true; }\" +\n\n        \"/** @param {boolean} b\\n@return {?boolean} */\" +\n\n        \"function f(b) { if (u()) { b = null; } return b; }\",\n\n        \"assignment\\n\" +\n\n        \"found   : null\\n\" +\n\n        \"required: boolean\");\n\n  }\n"
      }
    }
  },
  "Closure-71": {
    "id": "Closure-71",
    "project": "Closure",
    "number": "71",
    "buggy_function": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
    "fixed_function": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = parent.getJSDocInfo() != null &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CheckAccessControls.java",
      "first_line": 407,
      "last_line": 500
    },
    "javadoc": "/**\n* Determines whether the given property is visible in the current context.\n* @param t The current traversal.\n* @param getprop The getprop node.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckAccessControlsTest::testNoPrivateAccessForProperties6": {
        "source": "  public void testNoPrivateAccessForProperties6() {\n\n    // Overriding a private property with a non-private property\n\n    // in a different file causes problems.\n\n    test(new String[] {\n\n      \"/** @constructor */ function Foo() {} \" +\n\n      \"/** @private */ Foo.prototype.bar_ = function() {};\",\n\n      \"/** @constructor \\n * @extends {Foo} */ \" +\n\n      \"function SubFoo() {};\" +\n\n      \"SubFoo.prototype.bar_ = function() {};\"\n\n    }, null, BAD_PRIVATE_PROPERTY_ACCESS);\n\n  }\n"
      },
      "com.google.javascript.jscomp.CheckAccessControlsTest::testNoPrivateAccessForProperties8": {
        "source": "  public void testNoPrivateAccessForProperties8() {\n\n    test(new String[] {\n\n      \"/** @constructor */ function Foo() { /** @private */ this.bar_ = 3; }\",\n\n      \"/** @constructor \\n * @extends {Foo} */ \" +\n\n      \"function SubFoo() { /** @private */ this.bar_ = 3; };\"\n\n    }, null, PRIVATE_OVERRIDE);\n\n  }\n"
      }
    }
  },
  "Closure-73": {
    "id": "Closure-73",
    "project": "Closure",
    "number": "73",
    "buggy_function": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
    "fixed_function": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 988,
      "last_line": 1058
    },
    "javadoc": "/**\n* Escapes the given string to a double quoted (\") JavaScript/JSON string\n*/\nstatic String escapeToDoubleQuotedJsString(String s) {\nreturn strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n}\n\n/* If the user doesn't want to specify an output charset encoder, assume\nthey want Latin/ASCII characters only.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testUnicode": {
        "source": "  public void testUnicode() {\n\n    assertPrint(\"var x ='\\\\x0f';\", \"var x=\\\"\\\\u000f\\\"\");\n\n    assertPrint(\"var x ='\\\\x68';\", \"var x=\\\"h\\\"\");\n\n    assertPrint(\"var x ='\\\\x7f';\", \"var x=\\\"\\\\u007f\\\"\");\n\n  }\n"
      }
    }
  },
  "Closure-77": {
    "id": "Closure-77",
    "project": "Closure",
    "number": "77",
    "buggy_function": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
    "fixed_function": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "first_line": 956,
      "last_line": 1025
    },
    "javadoc": "/**\n* Escapes the given string to a double quoted (\") JavaScript/JSON string\n*/\nstatic String escapeToDoubleQuotedJsString(String s) {\nreturn strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n}\n\n/* If the user doesn't want to specify an output charset encoder, assume\nthey want Latin/ASCII characters only.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CodePrinterTest::testZero": {
        "source": "  public void testZero() {\n\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\0\\\"\");\n\n    assertPrint(\"var x ='\\\\x00';\", \"var x=\\\"\\\\0\\\"\");\n\n    assertPrint(\"var x ='\\\\u0000';\", \"var x=\\\"\\\\0\\\"\");\n\n  }\n"
      }
    }
  },
  "Closure-78": {
    "id": "Closure-78",
    "project": "Closure",
    "number": "78",
    "buggy_function": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD\n      && (NodeUtil.mayBeString(left, false)\n          || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  double result;\n\n  // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n  // to zero so this is a little akward here.\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  switch (opType) {\n    case Token.BITAND:\n      result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITOR:\n      result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITXOR:\n      result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n      break;\n    case Token.ADD:\n      result = lval + rval;\n      break;\n    case Token.SUB:\n      result = lval - rval;\n      break;\n    case Token.MUL:\n      result = lval * rval;\n      break;\n    case Token.MOD:\n      if (rval == 0) {\n        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n        return null;\n      }\n      result = lval % rval;\n      break;\n    case Token.DIV:\n      if (rval == 0) {\n        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n        return null;\n      }\n      result = lval / rval;\n      break;\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n\n  // TODO(johnlenz): consider removing the result length check.\n  // length of the left and right value plus 1 byte for the operator.\n  if (String.valueOf(result).length() <=\n      String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n      // Do not try to fold arithmetic for numbers > 2^53. After that\n      // point, fixed-point math starts to break down and become inaccurate.\n      Math.abs(result) <= MAX_FOLD_NUMBER) {\n    Node newNumber = Node.newNumber(result);\n    return newNumber;\n  } else if (Double.isNaN(result)) {\n    return Node.newString(Token.NAME, \"NaN\");\n  } else if (result == Double.POSITIVE_INFINITY) {\n    return Node.newString(Token.NAME, \"Infinity\");\n  } else if (result == Double.NEGATIVE_INFINITY) {\n    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n  }\n\n  return null;\n}",
    "fixed_function": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD\n      && (NodeUtil.mayBeString(left, false)\n          || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  double result;\n\n  // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n  // to zero so this is a little akward here.\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  switch (opType) {\n    case Token.BITAND:\n      result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITOR:\n      result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITXOR:\n      result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n      break;\n    case Token.ADD:\n      result = lval + rval;\n      break;\n    case Token.SUB:\n      result = lval - rval;\n      break;\n    case Token.MUL:\n      result = lval * rval;\n      break;\n    case Token.MOD:\n      if (rval == 0) {\n        return null;\n      }\n      result = lval % rval;\n      break;\n    case Token.DIV:\n      if (rval == 0) {\n        return null;\n      }\n      result = lval / rval;\n      break;\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n\n  // TODO(johnlenz): consider removing the result length check.\n  // length of the left and right value plus 1 byte for the operator.\n  if (String.valueOf(result).length() <=\n      String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n      // Do not try to fold arithmetic for numbers > 2^53. After that\n      // point, fixed-point math starts to break down and become inaccurate.\n      Math.abs(result) <= MAX_FOLD_NUMBER) {\n    Node newNumber = Node.newNumber(result);\n    return newNumber;\n  } else if (Double.isNaN(result)) {\n    return Node.newString(Token.NAME, \"NaN\");\n  } else if (result == Double.POSITIVE_INFINITY) {\n    return Node.newString(Token.NAME, \"Infinity\");\n  } else if (result == Double.NEGATIVE_INFINITY) {\n    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n  }\n\n  return null;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "first_line": 664,
      "last_line": 746
    },
    "javadoc": "/**\n* Try to fold arithmetic binary operators\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldArithmetic": {
        "source": "  public void testFoldArithmetic() {\n\n    fold(\"x = 10 + 20\", \"x = 30\");\n\n    fold(\"x = 2 / 4\", \"x = 0.5\");\n\n    fold(\"x = 2.25 * 3\", \"x = 6.75\");\n\n    fold(\"z = x * y\", \"z = x * y\");\n\n    fold(\"x = y * 5\", \"x = y * 5\");\n\n    fold(\"x = 1 / 0\", \"x = 1 / 0\");\n\n    fold(\"x = 3 % 2\", \"x = 1\");\n\n    fold(\"x = 3 % -2\", \"x = 1\");\n\n    fold(\"x = -1 % 3\", \"x = -1\");\n\n    fold(\"x = 1 % 0\", \"x = 1 % 0\");\n\n  }\n"
      }
    }
  },
  "Closure-81": {
    "id": "Closure-81",
    "project": "Closure",
    "number": "81",
    "buggy_function": "Node processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.LP);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n return node;\n}",
    "fixed_function": "Node processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.LP);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n return node;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
      "first_line": 513,
      "last_line": 562
    },
    "javadoc": "// Change the NAME to LABEL_NAME",
    "failing_tests": {
      "com.google.javascript.jscomp.parsing.ParserTest::testUnnamedFunctionStatement": {
        "source": "  public void testUnnamedFunctionStatement() {\n\n    // Statements\n\n    parseError(\"function() {};\", \"unnamed function statement\");\n\n    parseError(\"if (true) { function() {}; }\", \"unnamed function statement\");\n\n    parse(\"function f() {};\");\n\n    // Expressions\n\n    parse(\"(function f() {});\");\n\n    parse(\"(function () {});\");\n\n  }\n"
      }
    }
  },
  "Closure-82": {
    "id": "Closure-82",
    "project": "Closure",
    "number": "82",
    "buggy_function": "public final boolean isEmptyType() {\n  return isNoType() || isNoObjectType() || isNoResolvedType();\n}",
    "fixed_function": "public final boolean isEmptyType() {\n  return isNoType() || isNoObjectType() || isNoResolvedType() ||\n      (registry.getNativeFunctionType(\n           JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/rhino/jstype/JSType.java",
      "first_line": 162,
      "last_line": 164
    },
    "javadoc": "/**\n* If we see a type name without braces, it might be legacy jsdoc.\n* So we shouldn't emit warnings about it. This method is how we skip\n* those warnings.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue301": {
        "source": "  public void testIssue301() throws Exception {\n\n    testTypes(\n\n        \"Array.indexOf = function() {};\" +\n\n        \"var s = 'hello';\" +\n\n        \"alert(s.toLowerCase.indexOf('1'));\",\n\n        \"Property indexOf never defined on String.prototype.toLowerCase\");\n\n  }\n"
      },
      "com.google.javascript.rhino.jstype.FunctionTypeTest::testEmptyFunctionTypes": {
        "source": "  public void testEmptyFunctionTypes() {\n\n    assertTrue(LEAST_FUNCTION_TYPE.isEmptyType());\n\n    assertFalse(GREATEST_FUNCTION_TYPE.isEmptyType());\n\n  }\n"
      }
    }
  },
  "Closure-83": {
    "id": "Closure-83",
    "project": "Closure",
    "number": "83",
    "buggy_function": "public int parseArguments(Parameters params) throws CmdLineException {\n  String param = params.getParameter(0);\n\n  if (param == null) {\n    setter.addValue(true);\n    return 0;\n  } else {\n    String lowerParam = param.toLowerCase();\n    if (TRUES.contains(lowerParam)) {\n      setter.addValue(true);\n    } else if (FALSES.contains(lowerParam)) {\n      setter.addValue(false);\n    } else {\n      setter.addValue(true);\n      return 0;\n    }\n    return 1;\n  }\n}",
    "fixed_function": "public int parseArguments(Parameters params) throws CmdLineException {\n  String param = null;\n  try {\n    param = params.getParameter(0);\n  } catch (CmdLineException e) {}\n\n  if (param == null) {\n    setter.addValue(true);\n    return 0;\n  } else {\n    String lowerParam = param.toLowerCase();\n    if (TRUES.contains(lowerParam)) {\n      setter.addValue(true);\n    } else if (FALSES.contains(lowerParam)) {\n      setter.addValue(false);\n    } else {\n      setter.addValue(true);\n      return 0;\n    }\n    return 1;\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CommandLineRunner.java",
      "first_line": 333,
      "last_line": 351
    },
    "javadoc": "// It needs to be public because of the crazy reflection that args4j does.",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testVersionFlag2": {
        "source": "  public void testVersionFlag2() {\n\n    lastArg = \"--version\";\n\n    testSame(\"\");\n\n    assertEquals(\n\n        0,\n\n        new String(errReader.toByteArray()).indexOf(\n\n            \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n\n            \"Version: \"));\n\n  }\n"
      }
    }
  },
  "Closure-86": {
    "id": "Closure-86",
    "project": "Closure",
    "number": "86",
    "buggy_function": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // There is no information about the locality of object properties.\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      // TODO(nicksantos): This needs to be changed so that it\n      // returns true iff we're sure the value was never aliased from inside\n      // the constructor (similar to callHasLocalResult)\n      return true;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
    "fixed_function": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // There is no information about the locality of object properties.\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      // TODO(nicksantos): This needs to be changed so that it\n      // returns true iff we're sure the value was never aliased from inside\n      // the constructor (similar to callHasLocalResult)\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/NodeUtil.java",
      "first_line": 2424,
      "last_line": 2489
    },
    "javadoc": "/**\n* @param locals A predicate to apply to unknown local values.\n* @return Whether the node is known to be a value that is not a reference\n*     outside the expression scope.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.NodeUtilTest::testLocalValue1": {
        "source": "  public void testLocalValue1() throws Exception {\n\n    // Names are not known to be local.\n\n    assertFalse(testLocalValue(\"x\"));\n\n    assertFalse(testLocalValue(\"x()\"));\n\n    assertFalse(testLocalValue(\"this\"));\n\n    assertFalse(testLocalValue(\"arguments\"));\n\n\n\n    // We can't know if new objects are local unless we know\n\n    // that they don't alias themselves.\n\n    assertFalse(testLocalValue(\"new x()\"));\n\n\n\n    // property references are assume to be non-local\n\n    assertFalse(testLocalValue(\"(new x()).y\"));\n\n    assertFalse(testLocalValue(\"(new x())['y']\"));\n\n\n\n    // Primitive values are local\n\n    assertTrue(testLocalValue(\"null\"));\n\n    assertTrue(testLocalValue(\"undefined\"));\n\n    assertTrue(testLocalValue(\"Infinity\"));\n\n    assertTrue(testLocalValue(\"NaN\"));\n\n    assertTrue(testLocalValue(\"1\"));\n\n    assertTrue(testLocalValue(\"'a'\"));\n\n    assertTrue(testLocalValue(\"true\"));\n\n    assertTrue(testLocalValue(\"false\"));\n\n    assertTrue(testLocalValue(\"[]\"));\n\n    assertTrue(testLocalValue(\"{}\"));\n\n\n\n    // The contents of arrays and objects don't matter\n\n    assertTrue(testLocalValue(\"[x]\"));\n\n    assertTrue(testLocalValue(\"{'a':x}\"));\n\n\n\n    // Pre-increment results in primitive number\n\n    assertTrue(testLocalValue(\"++x\"));\n\n    assertTrue(testLocalValue(\"--x\"));\n\n\n\n    // Post-increment, the previous value matters.\n\n    assertFalse(testLocalValue(\"x++\"));\n\n    assertFalse(testLocalValue(\"x--\"));\n\n\n\n    // The left side of an only assign matters if it is an alias or mutable.\n\n    assertTrue(testLocalValue(\"x=1\"));\n\n    assertFalse(testLocalValue(\"x=[]\"));\n\n    assertFalse(testLocalValue(\"x=y\"));\n\n    // The right hand side of assignment opts don't matter, as they force\n\n    // a local result.\n\n    assertTrue(testLocalValue(\"x+=y\"));\n\n    assertTrue(testLocalValue(\"x*=y\"));\n\n    // Comparisons always result in locals, as they force a local boolean\n\n    // result.\n\n    assertTrue(testLocalValue(\"x==y\"));\n\n    assertTrue(testLocalValue(\"x!=y\"));\n\n    assertTrue(testLocalValue(\"x>y\"));\n\n    // Only the right side of a comma matters\n\n    assertTrue(testLocalValue(\"(1,2)\"));\n\n    assertTrue(testLocalValue(\"(x,1)\"));\n\n    assertFalse(testLocalValue(\"(x,y)\"));\n\n\n\n    // Both the operands of OR matter\n\n    assertTrue(testLocalValue(\"1||2\"));\n\n    assertFalse(testLocalValue(\"x||1\"));\n\n    assertFalse(testLocalValue(\"x||y\"));\n\n    assertFalse(testLocalValue(\"1||y\"));\n\n\n\n    // Both the operands of AND matter\n\n    assertTrue(testLocalValue(\"1&&2\"));\n\n    assertFalse(testLocalValue(\"x&&1\"));\n\n    assertFalse(testLocalValue(\"x&&y\"));\n\n    assertFalse(testLocalValue(\"1&&y\"));\n\n\n\n    // Only the results of HOOK matter\n\n    assertTrue(testLocalValue(\"x?1:2\"));\n\n    assertFalse(testLocalValue(\"x?x:2\"));\n\n    assertFalse(testLocalValue(\"x?1:x\"));\n\n    assertFalse(testLocalValue(\"x?x:y\"));\n\n\n\n    // Results of ops are local values\n\n    assertTrue(testLocalValue(\"!y\"));\n\n    assertTrue(testLocalValue(\"~y\"));\n\n    assertTrue(testLocalValue(\"y + 1\"));\n\n    assertTrue(testLocalValue(\"y + z\"));\n\n    assertTrue(testLocalValue(\"y * z\"));\n\n\n\n    assertTrue(testLocalValue(\"'a' in x\"));\n\n    assertTrue(testLocalValue(\"typeof x\"));\n\n    assertTrue(testLocalValue(\"x instanceof y\"));\n\n\n\n    assertTrue(testLocalValue(\"void x\"));\n\n    assertTrue(testLocalValue(\"void 0\"));\n\n\n\n    assertFalse(testLocalValue(\"{}.x\"));\n\n\n\n    assertTrue(testLocalValue(\"{}.toString()\"));\n\n    assertTrue(testLocalValue(\"o.toString()\"));\n\n\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testLocalizedSideEffects8": {
        "source": "  public void testLocalizedSideEffects8() throws Exception {\n\n    // Returning a local object that has been modified\n\n    // is not a global side-effect.\n\n    checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n\n                     \"function f() {\" +\n\n                     \"  var a = new A; a.foo = 1; return a;\" +\n\n                     \"}\" +\n\n                     \"f()\",\n\n                     BROKEN_NEW ?\n\n                         ImmutableList.<String>of(\"A\") :\n\n                         ImmutableList.<String>of(\"A\", \"f\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testLocalizedSideEffects9": {
        "source": "  public void testLocalizedSideEffects9() throws Exception {\n\n    // Returning a local object that has been modified\n\n    // is not a global side-effect.\n\n    checkMarkedCalls(\"/** @constructor A */ function A() {this.x = 1};\" +\n\n                     \"function f() {\" +\n\n                     \"  var a = new A; a.foo = 1; return a;\" +\n\n                     \"}\" +\n\n                     \"f()\",\n\n                     BROKEN_NEW ?\n\n                         ImmutableList.<String>of(\"A\") :\n\n                         ImmutableList.<String>of(\"A\", \"f\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testAnnotationInExterns_new4": {
        "source": "  public void testAnnotationInExterns_new4() throws Exception {\n\n    // The entire expression containing \"externObjSEThisMethod\" is considered\n\n    // side-effect free in this context.\n\n\n\n    checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",\n\n        BROKEN_NEW ?\n\n            ImmutableList.<String>of(\n\n               \"externObjSEThis\") :\n\n            ImmutableList.<String>of(\n\n               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testAnnotationInExterns_new6": {
        "source": "  public void testAnnotationInExterns_new6() throws Exception {\n\n    // While \"externObjSEThisMethod\" has modifies \"this\"\n\n    // it does not have global side-effects with \"this\" is\n\n    // a known local value.\n\n    checkMarkedCalls(\n\n        \"function f() {\" +\n\n        \"  new externObjSEThis().externObjSEThisMethod('') \" +\n\n        \"};\" +\n\n        \"f();\",\n\n        BROKEN_NEW ?\n\n            ImmutableList.<String>of(\n\n                \"externObjSEThis\") :\n\n           ImmutableList.<String>of(\n\n               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\", \"f\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testIssue303b": {
        "source": "  public void testIssue303b() throws Exception {\n\n    checkMarkedCalls(\n\n        \"/** @constructor */ function F() {\" +\n\n        \"  var self = this;\" +\n\n        \"  window.setTimeout(function() {\" +\n\n        \"    window.location = self.location;\" +\n\n        \"  }, 0);\" +\n\n        \"}\" +\n\n        \"F.prototype.setLocation = function(x) {\" +\n\n        \"  this.location = x;\" +\n\n        \"};\" +\n\n        \"function x() {\" +\n\n        \"  (new F()).setLocation('http://www.google.com/');\" +\n\n        \"} window['x'] = x;\",\n\n        ImmutableList.<String>of());\n\n  }\n"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testIssue303": {
        "source": "  public void testIssue303() throws Exception {\n\n    checkMarkedCalls(\n\n        \"/** @constructor */ function F() {\" +\n\n        \"  var self = this;\" +\n\n        \"  window.setTimeout(function() {\" +\n\n        \"    window.location = self.location;\" +\n\n        \"  }, 0);\" +\n\n        \"}\" +\n\n        \"F.prototype.setLocation = function(x) {\" +\n\n        \"  this.location = x;\" +\n\n        \"};\" +\n\n        \"(new F()).setLocation('http://www.google.com/');\",\n\n        ImmutableList.<String>of());\n\n  }\n"
      }
    }
  },
  "Closure-87": {
    "id": "Closure-87",
    "project": "Closure",
    "number": "87",
    "buggy_function": "private boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK) {\n    if (n.hasOneChild()) {\n      Node maybeExpr = n.getFirstChild();\n        // IE has a bug where event handlers behave differently when\n        // their return value is used vs. when their return value is in\n        // an EXPR_RESULT. It's pretty freaking weird. See:\n        // http://code.google.com/p/closure-compiler/issues/detail?id=291\n        // We try to detect this case, and not fold EXPR_RESULTs\n        // into other expressions.\n\n          // We only have to worry about methods with an implicit 'this'\n          // param, or this doesn't happen.\n\n        return NodeUtil.isExpressionNode(maybeExpr);\n    }\n  }\n\n  return false;\n}",
    "fixed_function": "private boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK) {\n    if (n.hasOneChild()) {\n      Node maybeExpr = n.getFirstChild();\n      if (maybeExpr.getType() == Token.EXPR_RESULT) {\n        // IE has a bug where event handlers behave differently when\n        // their return value is used vs. when their return value is in\n        // an EXPR_RESULT. It's pretty freaking weird. See:\n        // http://code.google.com/p/closure-compiler/issues/detail?id=291\n        // We try to detect this case, and not fold EXPR_RESULTs\n        // into other expressions.\n        if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n          Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n\n          // We only have to worry about methods with an implicit 'this'\n          // param, or this doesn't happen.\n          if (calledFn.getType() == Token.GETELEM) {\n            return false;\n          } else if (calledFn.getType() == Token.GETPROP &&\n                     calledFn.getLastChild().getString().startsWith(\"on\")) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      return false;\n    }\n  }\n\n  return false;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "first_line": 519,
      "last_line": 538
    },
    "javadoc": "/**\n* @return Whether the node is a block with a single statement that is\n*     an expression.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testIssue291": {
        "source": "  public void testIssue291() {\n\n    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n\n    foldSame(\"if (f) { f.onchange(); }\");\n\n    foldSame(\"if (f) { f.bar(); } else { f.onchange(); }\");\n\n    fold(\"if (f) { f.bonchange(); }\", \"f && f.bonchange();\");\n\n    foldSame(\"if (f) { f['x'](); }\");\n\n  }\n"
      }
    }
  },
  "Closure-88": {
    "id": "Closure-88",
    "project": "Closure",
    "number": "88",
    "buggy_function": "private VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      // The expression to which the assignment is made is evaluated before\n      // the RHS is evaluated (normal left to right evaluation) but the KILL\n      // occurs after the RHS is evaluated.\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  // Expressions are evaluated left-right, depth first.\n  for (Node child = n.getFirstChild();\n      child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "fixed_function": "private VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      // The expression to which the assignment is made is evaluated before\n      // the RHS is evaluated (normal left to right evaluation) but the KILL\n      // occurs after the RHS is evaluated.\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  // Expressions are evaluated left-right, depth first.\n  for (Node child = n.getFirstChild();\n      child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
      "first_line": 323,
      "last_line": 347
    },
    "javadoc": "/**\n* Give an expression and a variable. It returns READ, if the first\n* reference of that variable is a read. It returns KILL, if the first\n* reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testIssue297": {
        "source": "  public void testIssue297() {\n\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n\n    test(\"function f(p) {\" +\n\n         \" var x;\" +\n\n         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n\n         \"}\",\n\n         \"function f(b) {\" +\n\n         \" var a;\" +\n\n         \" return ((a=b.id) && (a=parseInt(a.substr(1))) && a>0);\" +\n\n         \"}\");\n\n  }  \n"
      },
      "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue297a": {
        "source": "  public void testIssue297a() {\n\n    testSame(\"function f(p) {\" +\n\n         \" var x;\" +\n\n         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n\n         \"}; f('');\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue297b": {
        "source": "  public void testIssue297b() {\n\n    test(\"function f() {\" +\n\n         \" var x;\" +\n\n         \" return (x='') && (x = x.substr(1));\" +\n\n         \"};\",\n\n         \"function f() {\" +\n\n         \" var x;\" +\n\n         \" return (x='') && (x.substr(1));\" +\n\n         \"};\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue297c": {
        "source": "  public void testIssue297c() {\n\n    test(\"function f() {\" +\n\n         \" var x;\" +\n\n         \" return (x=1) && (x = f(x));\" +\n\n         \"};\",\n\n         \"function f() {\" +\n\n         \" var x;\" +\n\n         \" return (x=1) && f(x);\" +\n\n         \"};\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue297d": {
        "source": "  public void testIssue297d() {\n\n    test(\"function f(a) {\" +\n\n         \" return (a=1) && (a = f(a));\" +\n\n         \"};\",\n\n         \"function f(a) {\" +\n\n         \" return (a=1) && (f(a));\" +\n\n         \"};\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue297e": {
        "source": "  public void testIssue297e() {\n\n    test(\"function f(a) {\" +\n\n         \" return (a=1) - (a = g(a));\" +\n\n         \"};\",\n\n         \"function f(a) {\" +\n\n         \" return (a=1) - (g(a));\" +\n\n         \"};\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue297f": {
        "source": "  public void testIssue297f() {\n\n    test(\"function f(a) {\" +\n\n         \" h((a=1) - (a = g(a)));\" +\n\n         \"};\",\n\n         \"function f(a) {\" +\n\n         \" h((a=1) - (g(a)));\" +\n\n         \"};\");\n\n  }\n"
      }
    }
  },
  "Closure-91": {
    "id": "Closure-91",
    "project": "Closure",
    "number": "91",
    "buggy_function": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}",
    "fixed_function": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n    Node gramps = parent.getParent();\n    if (NodeUtil.isObjectLitKey(parent, gramps)) {\n      JSDocInfo maybeLends = gramps.getJSDocInfo();\n      if (maybeLends != null &&\n          maybeLends.getLendsName() != null &&\n          maybeLends.getLendsName().endsWith(\".prototype\")) {\n        return false;\n      }\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
      "first_line": 82,
      "last_line": 146
    },
    "javadoc": "/**\n* Since this pass reports errors only when a global {@code this} keyword\n* is encountered, there is no reason to traverse non global contexts.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckGlobalThisTest::testLendsAnnotation3": {
        "source": "  public void testLendsAnnotation3() {\n\n    testSame(\"/** @constructor */ function F() {}\" +\n\n        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +\n\n        \"    {foo: function() { return this.foo; }}));\");\n\n  }\n"
      }
    }
  },
  "Closure-92": {
    "id": "Closure-92",
    "project": "Closure",
    "number": "92",
    "buggy_function": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int indexOfDot = namespace.indexOf('.');\n      if (indexOfDot == -1) {\n        // Any old place is fine.\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
    "fixed_function": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int indexOfDot = namespace.lastIndexOf('.');\n      if (indexOfDot == -1) {\n        // Any old place is fine.\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "first_line": 747,
      "last_line": 809
    },
    "javadoc": "/**\n* Replace the provide statement.\n*\n* If we're providing a name with no definition, then create one.\n* If we're providing a name with a duplicate definition, then make sure\n* that definition becomes a declaration.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.ProcessClosurePrimitivesTest::testProvideInIndependentModules4": {
        "source": "  public void testProvideInIndependentModules4() {\n\n    // Regression test for bug 261:\n\n    // http://code.google.com/p/closure-compiler/issues/detail?id=261\n\n    test(\n\n        createModuleStar(\n\n            \"goog.provide('apps');\",\n\n            \"goog.provide('apps.foo.bar.B');\",\n\n            \"goog.provide('apps.foo.bar.C');\"),\n\n        new String[] {\n\n            \"var apps = {};apps.foo = {};apps.foo.bar = {}\",\n\n            \"apps.foo.bar.B = {};\",\n\n            \"apps.foo.bar.C = {};\",\n\n        });\n\n  }\n"
      }
    }
  },
  "Closure-94": {
    "id": "Closure-94",
    "project": "Closure",
    "number": "94",
    "buggy_function": "static boolean isValidDefineValue(Node val, Set<String> defines) {\n  switch (val.getType()) {\n    case Token.STRING:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n\n    // Binary operators are only valid if both children are valid.\n    case Token.BITAND:\n    case Token.BITNOT:\n    case Token.BITOR:\n    case Token.BITXOR:\n\n    // Uniary operators are valid if the child is valid.\n    case Token.NOT:\n    case Token.NEG:\n      return isValidDefineValue(val.getFirstChild(), defines);\n\n    // Names are valid if and only if they are defines themselves.\n    case Token.NAME:\n    case Token.GETPROP:\n      if (val.isQualifiedName()) {\n        return defines.contains(val.getQualifiedName());\n      }\n  }\n  return false;\n}",
    "fixed_function": "static boolean isValidDefineValue(Node val, Set<String> defines) {\n  switch (val.getType()) {\n    case Token.STRING:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n\n    // Binary operators are only valid if both children are valid.\n    case Token.ADD:\n    case Token.BITAND:\n    case Token.BITNOT:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.DIV:\n    case Token.EQ:\n    case Token.GE:\n    case Token.GT:\n    case Token.LE:\n    case Token.LSH:\n    case Token.LT:\n    case Token.MOD:\n    case Token.MUL:\n    case Token.NE:\n    case Token.RSH:\n    case Token.SHEQ:\n    case Token.SHNE:\n    case Token.SUB:\n    case Token.URSH:\n      return isValidDefineValue(val.getFirstChild(), defines)\n          && isValidDefineValue(val.getLastChild(), defines);\n\n    // Uniary operators are valid if the child is valid.\n    case Token.NOT:\n    case Token.NEG:\n    case Token.POS:\n      return isValidDefineValue(val.getFirstChild(), defines);\n\n    // Names are valid if and only if they are defines themselves.\n    case Token.NAME:\n    case Token.GETPROP:\n      if (val.isQualifiedName()) {\n        return defines.contains(val.getQualifiedName());\n      }\n  }\n  return false;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/NodeUtil.java",
      "first_line": 320,
      "last_line": 347
    },
    "javadoc": "/**\n* Determines whether the given value may be assigned to a define.\n*\n* @param val The value being assigned.\n* @param defines The list of names of existing defines.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.NodeUtilTest::testValidDefine": {
        "source": "  public void testValidDefine() {\n\n    assertTrue(testValidDefineValue(\"1\"));\n\n    assertTrue(testValidDefineValue(\"-3\"));\n\n    assertTrue(testValidDefineValue(\"true\"));\n\n    assertTrue(testValidDefineValue(\"false\"));\n\n    assertTrue(testValidDefineValue(\"'foo'\"));\n\n    \n\n    assertFalse(testValidDefineValue(\"x\"));\n\n    assertFalse(testValidDefineValue(\"null\"));\n\n    assertFalse(testValidDefineValue(\"undefined\"));\n\n    assertFalse(testValidDefineValue(\"NaN\"));\n\n    \n\n    assertTrue(testValidDefineValue(\"!true\"));\n\n    assertTrue(testValidDefineValue(\"-true\"));\n\n    assertTrue(testValidDefineValue(\"1 & 8\"));\n\n    assertTrue(testValidDefineValue(\"1 + 8\"));\n\n    assertTrue(testValidDefineValue(\"'a' + 'b'\"));\n\n\n\n    assertFalse(testValidDefineValue(\"1 & foo\"));\n\n  }\n"
      },
      "com.google.javascript.jscomp.ProcessDefinesTest::testOverridingString1": {
        "source": "  public void testOverridingString1() {\n\n    test(\n\n        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';\",\n\n        \"var DEF_OVERRIDE_STRING=\\\"x\\\" + \\\"y\\\"\");\n\n  }  \n"
      },
      "com.google.javascript.jscomp.ProcessDefinesTest::testOverridingString3": {
        "source": "  public void testOverridingString3() {\n\n    overrides.put(\"DEF_OVERRIDE_STRING\", Node.newString(\"foo\"));\n\n    test(\n\n        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';\",\n\n        \"var DEF_OVERRIDE_STRING=\\\"foo\\\"\");\n\n  }\n"
      }
    }
  },
  "Closure-95": {
    "id": "Closure-95",
    "project": "Closure",
    "number": "95",
    "buggy_function": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n  Preconditions.checkArgument(inferred || type != null);\n\n  // Only allow declarations of NAMEs and qualfied names.\n  boolean shouldDeclareOnGlobalThis = false;\n  if (n.getType() == Token.NAME) {\n    Preconditions.checkArgument(\n        parent.getType() == Token.FUNCTION ||\n        parent.getType() == Token.VAR ||\n        parent.getType() == Token.LP ||\n        parent.getType() == Token.CATCH);\n    shouldDeclareOnGlobalThis = scope.isGlobal() &&\n        (parent.getType() == Token.VAR ||\n         parent.getType() == Token.FUNCTION);\n  } else {\n    Preconditions.checkArgument(\n        n.getType() == Token.GETPROP &&\n        (parent.getType() == Token.ASSIGN ||\n         parent.getType() == Token.EXPR_RESULT));\n  }\n  String variableName = n.getQualifiedName();\n  Preconditions.checkArgument(!variableName.isEmpty());\n\n  // If n is a property, then we should really declare it in the\n  // scope where the root object appears. This helps out people\n  // who declare \"global\" names in an anonymous namespace.\n  Scope scopeToDeclareIn = scope;\n\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n\n  // declared in closest scope?\n  if (scopeToDeclareIn.isDeclared(variableName, false)) {\n    Var oldVar = scopeToDeclareIn.getVar(variableName);\n    validator.expectUndeclaredVariable(\n        sourceName, n, parent, oldVar, variableName, type);\n  } else {\n    if (!inferred) {\n      setDeferredType(n, type);\n    }\n    CompilerInput input = compiler.getInput(sourceName);\n    scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n    if (shouldDeclareOnGlobalThis) {\n      ObjectType globalThis =\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n      boolean isExtern = input.isExtern();\n      if (inferred) {\n        globalThis.defineInferredProperty(variableName,\n            type == null ?\n                getNativeType(JSTypeNative.NO_TYPE) :\n                type,\n            isExtern);\n      } else {\n        globalThis.defineDeclaredProperty(variableName, type, isExtern);\n      }\n    }\n\n    // If we're in the global scope, also declare var.prototype\n    // in the scope chain.\n    if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n      FunctionType fnType = (FunctionType) type;\n      if (fnType.isConstructor() || fnType.isInterface()) {\n        FunctionType superClassCtor = fnType.getSuperClassConstructor();\n        scopeToDeclareIn.declare(variableName + \".prototype\", n,\n            fnType.getPrototype(), compiler.getInput(sourceName),\n            /* declared iff there's an explicit supertype */\n            superClassCtor == null ||\n            superClassCtor.getInstanceType().equals(\n                getNativeType(OBJECT_TYPE)));\n      }\n    }\n  }\n}",
    "fixed_function": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n  Preconditions.checkArgument(inferred || type != null);\n\n  // Only allow declarations of NAMEs and qualfied names.\n  boolean shouldDeclareOnGlobalThis = false;\n  if (n.getType() == Token.NAME) {\n    Preconditions.checkArgument(\n        parent.getType() == Token.FUNCTION ||\n        parent.getType() == Token.VAR ||\n        parent.getType() == Token.LP ||\n        parent.getType() == Token.CATCH);\n    shouldDeclareOnGlobalThis = scope.isGlobal() &&\n        (parent.getType() == Token.VAR ||\n         parent.getType() == Token.FUNCTION);\n  } else {\n    Preconditions.checkArgument(\n        n.getType() == Token.GETPROP &&\n        (parent.getType() == Token.ASSIGN ||\n         parent.getType() == Token.EXPR_RESULT));\n  }\n  String variableName = n.getQualifiedName();\n  Preconditions.checkArgument(!variableName.isEmpty());\n\n  // If n is a property, then we should really declare it in the\n  // scope where the root object appears. This helps out people\n  // who declare \"global\" names in an anonymous namespace.\n  Scope scopeToDeclareIn = scope;\n  if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n      isQnameRootedInGlobalScope(n)) {\n    Scope globalScope = scope.getGlobalScope();\n\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    if (!globalScope.isDeclared(variableName, false)) {\n      scopeToDeclareIn = scope.getGlobalScope();\n    }\n  }\n\n  // declared in closest scope?\n  if (scopeToDeclareIn.isDeclared(variableName, false)) {\n    Var oldVar = scopeToDeclareIn.getVar(variableName);\n    validator.expectUndeclaredVariable(\n        sourceName, n, parent, oldVar, variableName, type);\n  } else {\n    if (!inferred) {\n      setDeferredType(n, type);\n    }\n    CompilerInput input = compiler.getInput(sourceName);\n    scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n    if (shouldDeclareOnGlobalThis) {\n      ObjectType globalThis =\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n      boolean isExtern = input.isExtern();\n      if (inferred) {\n        globalThis.defineInferredProperty(variableName,\n            type == null ?\n                getNativeType(JSTypeNative.NO_TYPE) :\n                type,\n            isExtern);\n      } else {\n        globalThis.defineDeclaredProperty(variableName, type, isExtern);\n      }\n    }\n\n    // If we're in the global scope, also declare var.prototype\n    // in the scope chain.\n    if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n      FunctionType fnType = (FunctionType) type;\n      if (fnType.isConstructor() || fnType.isInterface()) {\n        FunctionType superClassCtor = fnType.getSuperClassConstructor();\n        scopeToDeclareIn.declare(variableName + \".prototype\", n,\n            fnType.getPrototype(), compiler.getInput(sourceName),\n            /* declared iff there's an explicit supertype */\n            superClassCtor == null ||\n            superClassCtor.getInstanceType().equals(\n                getNativeType(OBJECT_TYPE)));\n      }\n    }\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "first_line": 872,
      "last_line": 945
    },
    "javadoc": "/**\n* Defines a typed variable. The defining node will be annotated with the\n* variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n* inferred.\n*\n* Slots may be any variable or any qualified name in the global scope.\n*\n* @param n the defining NAME or GETPROP node.\n* @param parent the {@code n}'s parent.\n* @param type the variable's type. It may be {@code null} if\n*     {@code inferred} is {@code true}.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testQualifiedNameInference5": {
        "source": "  public void testQualifiedNameInference5() throws Exception {\n\n    testTypes(\n\n        \"var ns = {}; \" +\n\n        \"(function() { \" +\n\n        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n\n        \"(function() { ns.foo(true); })();\",\n\n        \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n\n        \"found   : boolean\\n\" +\n\n        \"required: number\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testGlobalQualifiedNameInLocalScope": {
        "source": "  public void testGlobalQualifiedNameInLocalScope() {\n\n    testSame(\n\n        \"var ns = {}; \" +\n\n        \"(function() { \" +\n\n        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n\n        \"(function() { ns.foo(3); })();\");\n\n    assertNotNull(globalScope.getVar(\"ns.foo\"));\n\n    assertEquals(\n\n        \"function (number): undefined\",\n\n        globalScope.getVar(\"ns.foo\").getType().toString());\n\n  }\n"
      }
    }
  },
  "Closure-96": {
    "id": "Closure-96",
    "project": "Closure",
    "number": "96",
    "buggy_function": "private void visitParameterList(NodeTraversal t, Node call,\n    FunctionType functionType) {\n  Iterator<Node> arguments = call.children().iterator();\n  arguments.next(); // skip the function name\n\n  Iterator<Node> parameters = functionType.getParameters().iterator();\n  int ordinal = 0;\n  Node parameter = null;\n  Node argument = null;\n  while (arguments.hasNext() &&\n         parameters.hasNext()) {\n    // If there are no parameters left in the list, then the while loop\n    // above implies that this must be a var_args function.\n      parameter = parameters.next();\n    argument = arguments.next();\n    ordinal++;\n\n    validator.expectArgumentMatchesParameter(t, argument,\n        getJSType(argument), getJSType(parameter), call, ordinal);\n  }\n\n  int numArgs = call.getChildCount() - 1;\n  int minArgs = functionType.getMinArguments();\n  int maxArgs = functionType.getMaxArguments();\n  if (minArgs > numArgs || maxArgs < numArgs) {\n    report(t, call, WRONG_ARGUMENT_COUNT,\n            validator.getReadableJSTypeName(call.getFirstChild(), false),\n            String.valueOf(numArgs), String.valueOf(minArgs),\n            maxArgs != Integer.MAX_VALUE ?\n            \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n  }\n}",
    "fixed_function": "private void visitParameterList(NodeTraversal t, Node call,\n    FunctionType functionType) {\n  Iterator<Node> arguments = call.children().iterator();\n  arguments.next(); // skip the function name\n\n  Iterator<Node> parameters = functionType.getParameters().iterator();\n  int ordinal = 0;\n  Node parameter = null;\n  Node argument = null;\n  while (arguments.hasNext() &&\n         (parameters.hasNext() ||\n          parameter != null && parameter.isVarArgs())) {\n    // If there are no parameters left in the list, then the while loop\n    // above implies that this must be a var_args function.\n    if (parameters.hasNext()) {\n      parameter = parameters.next();\n    }\n    argument = arguments.next();\n    ordinal++;\n\n    validator.expectArgumentMatchesParameter(t, argument,\n        getJSType(argument), getJSType(parameter), call, ordinal);\n  }\n\n  int numArgs = call.getChildCount() - 1;\n  int minArgs = functionType.getMinArguments();\n  int maxArgs = functionType.getMaxArguments();\n  if (minArgs > numArgs || maxArgs < numArgs) {\n    report(t, call, WRONG_ARGUMENT_COUNT,\n            validator.getReadableJSTypeName(call.getFirstChild(), false),\n            String.valueOf(numArgs), String.valueOf(minArgs),\n            maxArgs != Integer.MAX_VALUE ?\n            \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n  }\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/TypeCheck.java",
      "first_line": 1399,
      "last_line": 1430
    },
    "javadoc": "/**\n* Visits the parameters of a CALL or a NEW node.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionArguments16": {
        "source": "  public void testFunctionArguments16() throws Exception {\n\n    testTypes(\n\n        \"/** @param {...number} var_args */\" +\n\n        \"function g(var_args) {} g(1, true);\",\n\n        \"actual parameter 2 of g does not match formal parameter\\n\" +\n\n        \"found   : boolean\\n\" +\n\n        \"required: (number|undefined)\");\n\n  }\n"
      }
    }
  },
  "Closure-97": {
    "id": "Closure-97",
    "project": "Closure",
    "number": "97",
    "buggy_function": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n\n    // check ranges.  We do not do anything that would clip the double to\n    // a 32-bit range, since the user likely does not intend that.\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n\n    // only the lower 5 bits are used when shifting, so don't do anything\n    // if the shift amount is outside [0,32)\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n\n    // Convert the numbers to ints\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Node.tokenToName(n.getType()));\n    }\n\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n\n  return n;\n}",
    "fixed_function": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n\n    // check ranges.  We do not do anything that would clip the double to\n    // a 32-bit range, since the user likely does not intend that.\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n\n    // only the lower 5 bits are used when shifting, so don't do anything\n    // if the shift amount is outside [0,32)\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n\n    // Convert the numbers to ints\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Node.tokenToName(n.getType()));\n    }\n\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n\n  return n;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "first_line": 652,
      "last_line": 713
    },
    "javadoc": "/**\n* Try to fold shift operations\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldBitShifts": {
        "source": "  public void testFoldBitShifts() {\n\n    fold(\"x = 1 << 0\", \"x = 1\");\n\n    fold(\"x = -1 << 0\", \"x = -1\");\n\n    fold(\"x = 1 << 1\", \"x = 2\");\n\n    fold(\"x = 3 << 1\", \"x = 6\");\n\n    fold(\"x = 1 << 8\", \"x = 256\");\n\n\n\n    fold(\"x = 1 >> 0\", \"x = 1\");\n\n    fold(\"x = -1 >> 0\", \"x = -1\");\n\n    fold(\"x = 1 >> 1\", \"x = 0\");\n\n    fold(\"x = 2 >> 1\", \"x = 1\");\n\n    fold(\"x = 5 >> 1\", \"x = 2\");\n\n    fold(\"x = 127 >> 3\", \"x = 15\");\n\n    fold(\"x = 3 >> 1\", \"x = 1\");\n\n    fold(\"x = 3 >> 2\", \"x = 0\");\n\n    fold(\"x = 10 >> 1\", \"x = 5\");\n\n    fold(\"x = 10 >> 2\", \"x = 2\");\n\n    fold(\"x = 10 >> 5\", \"x = 0\");\n\n\n\n    fold(\"x = 10 >>> 1\", \"x = 5\");\n\n    fold(\"x = 10 >>> 2\", \"x = 2\");\n\n    fold(\"x = 10 >>> 5\", \"x = 0\");\n\n    fold(\"x = -1 >>> 1\", \"x = 2147483647\"); // 0x7fffffff\n\n    fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff\n\n    fold(\"x = -2 >>> 0\", \"x = 4294967294\"); // 0xfffffffe\n\n\n\n    fold(\"3000000000 << 1\", \"3000000000<<1\",\n\n         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n\n    fold(\"1 << 32\", \"1<<32\",\n\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n\n    fold(\"1 << -1\", \"1<<32\",\n\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n\n    fold(\"3000000000 >> 1\", \"3000000000>>1\",\n\n        PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n\n    fold(\"1 >> 32\", \"1>>32\",\n\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n\n    fold(\"1.5 << 0\",  \"1.5<<0\",\n\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n\n    fold(\"1 << .5\",   \"1.5<<0\",\n\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n\n    fold(\"1.5 >>> 0\", \"1.5>>>0\",\n\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n\n    fold(\"1 >>> .5\",  \"1.5>>>0\",\n\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n\n    fold(\"1.5 >> 0\",  \"1.5>>0\",\n\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n\n    fold(\"1 >> .5\",   \"1.5>>0\",\n\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n\n  }\n"
      }
    }
  },
  "Closure-99": {
    "id": "Closure-99",
    "project": "Closure",
    "number": "99",
    "buggy_function": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n    \n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n          return false;\n        }\n    }\n  }\n\n  return true;\n}",
    "fixed_function": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n    \n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}",
    "replacement_info": {
      "file": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
      "first_line": 84,
      "last_line": 136
    },
    "javadoc": "/**\n* Since this pass reports errors only when a global {@code this} keyword\n* is encountered, there is no reason to traverse non global contexts.\n*/",
    "failing_tests": {
      "com.google.javascript.jscomp.CheckGlobalThisTest::testPropertyOfMethod": {
        "source": "  public void testPropertyOfMethod() {\n\n    testFailure(\"a.protoype.b = {}; \" +\n\n        \"a.prototype.b.c = function() { this.foo = 3; };\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.CheckGlobalThisTest::testMethod4": {
        "source": "  public void testMethod4() {\n\n    testSame(\"a.prototype['x' + 'y'] =  function() { this.foo = 3; };\");\n\n  }\n"
      },
      "com.google.javascript.jscomp.CheckGlobalThisTest::testInterface1": {
        "source": "  public void testInterface1() {\n\n    testSame(\n\n        \"/** @interface */function A() { /** @type {string} */ this.m2; }\");\n\n  }\n"
      }
    }
  },
  "Codec-10": {
    "id": "Codec-10",
    "project": "Codec",
    "number": "10",
    "buggy_function": "public String caverphone(String txt) {\n    // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n    // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n\n    // 1. Convert to lowercase\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n    // 2. Remove anything not A-Z\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n    // 2.5. Remove final e\n    txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n    // 3. Handle various start options\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n\n    // End \n    txt = txt.replaceAll(\"^mb\", \"m2\");\n\n    // 4. Handle replacements\n    txt = txt.replaceAll(\"cq\", \"2q\");\n    txt = txt.replaceAll(\"ci\", \"si\");\n    txt = txt.replaceAll(\"ce\", \"se\");\n    txt = txt.replaceAll(\"cy\", \"sy\");\n    txt = txt.replaceAll(\"tch\", \"2ch\");\n    txt = txt.replaceAll(\"c\", \"k\");\n    txt = txt.replaceAll(\"q\", \"k\");\n    txt = txt.replaceAll(\"x\", \"k\");\n    txt = txt.replaceAll(\"v\", \"f\");\n    txt = txt.replaceAll(\"dg\", \"2g\");\n    txt = txt.replaceAll(\"tio\", \"sio\");\n    txt = txt.replaceAll(\"tia\", \"sia\");\n    txt = txt.replaceAll(\"d\", \"t\");\n    txt = txt.replaceAll(\"ph\", \"fh\");\n    txt = txt.replaceAll(\"b\", \"p\");\n    txt = txt.replaceAll(\"sh\", \"s2\");\n    txt = txt.replaceAll(\"z\", \"s\");\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\n    txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n    txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n    txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt = txt.replaceAll(\"gh\", \"22\");\n    txt = txt.replaceAll(\"g\", \"k\");\n    txt = txt.replaceAll(\"s+\", \"S\");\n    txt = txt.replaceAll(\"t+\", \"T\");\n    txt = txt.replaceAll(\"p+\", \"P\");\n    txt = txt.replaceAll(\"k+\", \"K\");\n    txt = txt.replaceAll(\"f+\", \"F\");\n    txt = txt.replaceAll(\"m+\", \"M\");\n    txt = txt.replaceAll(\"n+\", \"N\");\n    txt = txt.replaceAll(\"w3\", \"W3\");\n    //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\n    txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n    txt = txt.replaceAll(\"w\", \"2\");\n    txt = txt.replaceAll(\"^h\", \"A\");\n    txt = txt.replaceAll(\"h\", \"2\");\n    txt = txt.replaceAll(\"r3\", \"R3\");\n    txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n    txt = txt.replaceAll(\"r\", \"2\");\n    txt = txt.replaceAll(\"l3\", \"L3\");\n    txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n    txt = txt.replaceAll(\"l\", \"2\");\n    //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n    //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n    //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n    // 5. Handle removals\n    txt = txt.replaceAll(\"2\", \"\");\n    txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"3\", \"\");\n\n    // 6. put ten 1s on the end\n    txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n    // 7. take the first six characters as the code\n    return txt.substring(0, 10);          // 1.0 truncates to 6\n}",
    "fixed_function": "public String caverphone(String txt) {\n    // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n    // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n\n    // 1. Convert to lowercase\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n    // 2. Remove anything not A-Z\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n    // 2.5. Remove final e\n    txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n    // 3. Handle various start options\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n\n    // End \n    txt = txt.replaceAll(\"mb$\", \"m2\");\n\n    // 4. Handle replacements\n    txt = txt.replaceAll(\"cq\", \"2q\");\n    txt = txt.replaceAll(\"ci\", \"si\");\n    txt = txt.replaceAll(\"ce\", \"se\");\n    txt = txt.replaceAll(\"cy\", \"sy\");\n    txt = txt.replaceAll(\"tch\", \"2ch\");\n    txt = txt.replaceAll(\"c\", \"k\");\n    txt = txt.replaceAll(\"q\", \"k\");\n    txt = txt.replaceAll(\"x\", \"k\");\n    txt = txt.replaceAll(\"v\", \"f\");\n    txt = txt.replaceAll(\"dg\", \"2g\");\n    txt = txt.replaceAll(\"tio\", \"sio\");\n    txt = txt.replaceAll(\"tia\", \"sia\");\n    txt = txt.replaceAll(\"d\", \"t\");\n    txt = txt.replaceAll(\"ph\", \"fh\");\n    txt = txt.replaceAll(\"b\", \"p\");\n    txt = txt.replaceAll(\"sh\", \"s2\");\n    txt = txt.replaceAll(\"z\", \"s\");\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\n    txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n    txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n    txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt = txt.replaceAll(\"gh\", \"22\");\n    txt = txt.replaceAll(\"g\", \"k\");\n    txt = txt.replaceAll(\"s+\", \"S\");\n    txt = txt.replaceAll(\"t+\", \"T\");\n    txt = txt.replaceAll(\"p+\", \"P\");\n    txt = txt.replaceAll(\"k+\", \"K\");\n    txt = txt.replaceAll(\"f+\", \"F\");\n    txt = txt.replaceAll(\"m+\", \"M\");\n    txt = txt.replaceAll(\"n+\", \"N\");\n    txt = txt.replaceAll(\"w3\", \"W3\");\n    //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\n    txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n    txt = txt.replaceAll(\"w\", \"2\");\n    txt = txt.replaceAll(\"^h\", \"A\");\n    txt = txt.replaceAll(\"h\", \"2\");\n    txt = txt.replaceAll(\"r3\", \"R3\");\n    txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n    txt = txt.replaceAll(\"r\", \"2\");\n    txt = txt.replaceAll(\"l3\", \"L3\");\n    txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n    txt = txt.replaceAll(\"l\", \"2\");\n    //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n    //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n    //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n    // 5. Handle removals\n    txt = txt.replaceAll(\"2\", \"\");\n    txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"3\", \"\");\n\n    // 6. put ten 1s on the end\n    txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n    // 7. take the first six characters as the code\n    return txt.substring(0, 10);          // 1.0 truncates to 6\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/language/Caverphone.java",
      "first_line": 50,
      "last_line": 142
    },
    "javadoc": "/**\n* Encodes the given String into a Caverphone value.\n*\n* @param txt String the source string\n* @return A caverphone code for the given String\n*/",
    "failing_tests": {
      "org.apache.commons.codec.language.CaverphoneTest::testEndMb": {
        "source": "    public void testEndMb() throws EncoderException {\n\n        String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n\n        this.checkEncodings(data);\n\n    }\n"
      }
    }
  },
  "Codec-15": {
    "id": "Codec-15",
    "project": "Codec",
    "number": "15",
    "buggy_function": "private char getMappingCode(final String str, final int index) {\n    // map() throws IllegalArgumentException\n    final char mappedChar = this.map(str.charAt(index));\n    // HW rule check\n    if (index > 1 && mappedChar != '0') {\n        final char hwChar = str.charAt(index - 1);\n        if ('H' == hwChar || 'W' == hwChar) {\n            final char preHWChar = str.charAt(index - 2);\n            final char firstCode = this.map(preHWChar);\n            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                return 0;\n            }\n        }\n    }\n    return mappedChar;\n}",
    "fixed_function": "private char getMappingCode(final String str, final int index) {\n    // map() throws IllegalArgumentException\n    final char mappedChar = this.map(str.charAt(index));\n    // HW rule check\n    if (index > 1 && mappedChar != '0') {\n        for (int i=index-1 ; i>=0 ; i--) {\n            final char prevChar = str.charAt(i);\n            if (this.map(prevChar)==mappedChar) {\n                return 0;\n            }\n            if ('H'!=prevChar && 'W'!=prevChar) {\n                break;\n            }\n        }\n    }\n    return mappedChar;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/codec/language/Soundex.java",
      "first_line": 183,
      "last_line": 198
    },
    "javadoc": "/**\n* Used internally by the Soundex algorithm.\n*\n* Consonants from the same code group separated by W or H are treated as one.\n*\n* @param str\n*                  the cleaned working string to encode (in upper case).\n* @param index\n*                  the character position to encode\n* @return Mapping code for a particular character\n* @throws IllegalArgumentException\n*                  if the character is not mapped\n*/",
    "failing_tests": {
      "org.apache.commons.codec.language.SoundexTest::testHWRuleEx1": {
        "source": "    public void testHWRuleEx1() {\n\n        // From\n\n        // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n\n        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1\n\n        // for the F). It is not coded A-226.\n\n        Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcraft\"));\n\n        Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcroft\"));\n\n        Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yehudit\"));\n\n        Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yhwdyt\"));\n\n    }\n"
      }
    }
  },
  "Codec-17": {
    "id": "Codec-17",
    "project": "Codec",
    "number": "17",
    "buggy_function": "public static String newStringIso8859_1(final byte[] bytes) {\n    return new String(bytes, Charsets.ISO_8859_1);\n}",
    "fixed_function": "public static String newStringIso8859_1(final byte[] bytes) {\n    return newString(bytes, Charsets.ISO_8859_1);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
      "first_line": 338,
      "last_line": 340
    },
    "javadoc": "/**\n* Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n*\n* @param bytes\n*            The bytes to be decoded into characters, may be <code>null</code>\n* @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n*         <code>null</code> if the input byte array was <code>null</code>.\n* @throws NullPointerException\n*             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n*             required by the Java platform specification.\n* @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.StringUtilsTest::testNewStringNullInput_CODEC229": {
        "source": "    public void testNewStringNullInput_CODEC229() {\n\n        Assert.assertNull(StringUtils.newStringUtf8(null));\n\n        Assert.assertNull(StringUtils.newStringIso8859_1(null));\n\n        Assert.assertNull(StringUtils.newStringUsAscii(null));\n\n        Assert.assertNull(StringUtils.newStringUtf16(null));\n\n        Assert.assertNull(StringUtils.newStringUtf16Be(null));\n\n        Assert.assertNull(StringUtils.newStringUtf16Le(null));\n\n    }\n"
      }
    }
  },
  "Codec-18": {
    "id": "Codec-18",
    "project": "Codec",
    "number": "18",
    "buggy_function": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}",
    "fixed_function": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
      "first_line": 71,
      "last_line": 82
    },
    "javadoc": "/**\n* <p>\n* Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n* </p>\n*\n* <p>\n* <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n* The comparison is case sensitive.\n* </p>\n*\n* <pre>\n* StringUtils.equals(null, null)   = true\n* StringUtils.equals(null, \"abc\")  = false\n* StringUtils.equals(\"abc\", null)  = false\n* StringUtils.equals(\"abc\", \"abc\") = true\n* StringUtils.equals(\"abc\", \"ABC\") = false\n* </pre>\n*\n* <p>\n* Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n* </p>\n*\n* @see Object#equals(Object)\n* @param cs1\n*            the first CharSequence, may be <code>null</code>\n* @param cs2\n*            the second CharSequence, may be <code>null</code>\n* @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n* @since 1.10\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1": {
        "source": "    public void testEqualsCS1() {\n\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), null));\n\n        Assert.assertFalse(StringUtils.equals(null, new StringBuilder(\"abc\")));\n\n        Assert.assertTrue(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abc\")));\n\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abcd\")));\n\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abcd\"), new StringBuilder(\"abc\")));\n\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"ABC\")));\n\n    }\n"
      },
      "org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS2": {
        "source": "    public void testEqualsCS2() {\n\n        Assert.assertTrue(StringUtils.equals(\"abc\", new StringBuilder(\"abc\")));\n\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"abcd\"));\n\n        Assert.assertFalse(StringUtils.equals(\"abcd\", new StringBuilder(\"abc\")));\n\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"ABC\"));\n\n    }\n"
      }
    }
  },
  "Codec-2": {
    "id": "Codec-2",
    "project": "Codec",
    "number": "2",
    "buggy_function": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}",
    "fixed_function": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/binary/Base64.java",
      "first_line": 414,
      "last_line": 473
    },
    "javadoc": "/**\n* <p>\n* Encodes all of the provided data, starting at inPos, for inAvail bytes.\n* Must be called at least twice:  once with the data to encode, and once\n* with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n* so flush last remaining bytes (if not multiple of 3).\n* </p><p>\n* Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n* and general approach.\n* http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n* </p>\n*\n* @param in byte[] array of binary data to base64 encode.\n* @param inPos Position to start reading data from.\n* @param inAvail Amount of bytes available from input for encoding.\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.Base64InputStreamTest::testBase64EmptyInputStream": {
        "source": "    public void testBase64EmptyInputStream() throws Exception {\n\n        byte[] emptyEncoded = new byte[0];\n\n        byte[] emptyDecoded = new byte[0];\n\n        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n\n        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n\n    }\n"
      },
      "org.apache.commons.codec.binary.Base64OutputStreamTest::testBase64EmptyOutputStream": {
        "source": "    public void testBase64EmptyOutputStream() throws Exception {\n\n        byte[] emptyEncoded = new byte[0];\n\n        byte[] emptyDecoded = new byte[0];\n\n        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n\n        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n\n    }    \n"
      }
    }
  },
  "Codec-3": {
    "id": "Codec-3",
    "project": "Codec",
    "number": "3",
    "buggy_function": "private int handleG(String value, \n                    DoubleMetaphoneResult result, \n                    int index, \n                    boolean slavoGermanic) {\n    if (charAt(value, index + 1) == 'H') {\n        index = handleGH(value, result, index);\n    } else if (charAt(value, index + 1) == 'N') {\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n            result.append(\"KN\", \"N\");\n        } else if (!contains(value, index + 2, 2, \"EY\") && \n                   charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n            result.append(\"N\", \"KN\");\n        } else {\n            result.append(\"KN\");\n        }\n        index = index + 2;\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n        result.append(\"KL\", \"L\");\n        index += 2;\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n        //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n        result.append('K', 'J');\n        index += 2;\n    } else if ((contains(value, index + 1, 2, \"ER\") || \n                charAt(value, index + 1) == 'Y') &&\n               !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n               !contains(value, index - 1, 1, \"E\", \"I\") && \n               !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n        //-- -ger-, -gy- --//\n        result.append('K', 'J');\n        index += 2;\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n               contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n        //-- Italian \"biaggi\" --//\n        if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n            //-- obvious germanic --//\n            result.append('K');\n        } else if (contains(value, index + 1, 4, \"IER\")) {\n            result.append('J');\n        } else {\n            result.append('J', 'K');\n        }\n        index += 2;\n    } else if (charAt(value, index + 1) == 'G') {\n        index += 2;\n        result.append('K');\n    } else {\n        index++;\n        result.append('K');\n    }\n    return index;\n}",
    "fixed_function": "private int handleG(String value, \n                    DoubleMetaphoneResult result, \n                    int index, \n                    boolean slavoGermanic) {\n    if (charAt(value, index + 1) == 'H') {\n        index = handleGH(value, result, index);\n    } else if (charAt(value, index + 1) == 'N') {\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n            result.append(\"KN\", \"N\");\n        } else if (!contains(value, index + 2, 2, \"EY\") && \n                   charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n            result.append(\"N\", \"KN\");\n        } else {\n            result.append(\"KN\");\n        }\n        index = index + 2;\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n        result.append(\"KL\", \"L\");\n        index += 2;\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n        //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n        result.append('K', 'J');\n        index += 2;\n    } else if ((contains(value, index + 1, 2, \"ER\") || \n                charAt(value, index + 1) == 'Y') &&\n               !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n               !contains(value, index - 1, 1, \"E\", \"I\") && \n               !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n        //-- -ger-, -gy- --//\n        result.append('K', 'J');\n        index += 2;\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n               contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n        //-- Italian \"biaggi\" --//\n        if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n            //-- obvious germanic --//\n            result.append('K');\n        } else if (contains(value, index + 1, 3, \"IER\")) {\n            result.append('J');\n        } else {\n            result.append('J', 'K');\n        }\n        index += 2;\n    } else if (charAt(value, index + 1) == 'G') {\n        index += 2;\n        result.append('K');\n    } else {\n        index++;\n        result.append('K');\n    }\n    return index;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
      "first_line": 418,
      "last_line": 469
    },
    "javadoc": "/**\n* Handles 'G' cases\n*/",
    "failing_tests": {
      "org.apache.commons.codec.language.DoubleMetaphone2Test::testDoubleMetaphoneAlternate": {
        "source": "    public void testDoubleMetaphoneAlternate() {\n\n        String value = null;\n\n        for (int i = 0; i < TEST_DATA.length; i++) {\n\n            value = TEST_DATA[i][0];\n\n            assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][2], doubleMetaphone.doubleMetaphone(value, true));\n\n        }\n\n    }\n"
      }
    }
  },
  "Codec-4": {
    "id": "Codec-4",
    "project": "Codec",
    "number": "4",
    "buggy_function": "public Base64() {\n    this(false);\n}",
    "fixed_function": "public Base64() {\n    this(0);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/binary/Base64.java",
      "first_line": 224,
      "last_line": 226
    },
    "javadoc": "/**\n* Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n* <p>\n* When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n* </p>\n*\n* <p>\n* When decoding all variants are supported.\n* </p>\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.Base64Codec13Test::testEncoder": {
        "source": "    public void testEncoder() throws EncoderException {\n\n        Encoder enc = new Base64();\n\n        for (int i = 0; i < STRINGS.length; i++) {\n\n            if (STRINGS[i] != null) {\n\n                byte[] base64 = utf8(STRINGS[i]);\n\n                byte[] binary = BYTES[i];\n\n                boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n\n                assertTrue(\"Encoder test-\" + i, b);\n\n            }\n\n        }\n\n    }\n"
      },
      "org.apache.commons.codec.binary.Base64Codec13Test::testBinaryEncoder": {
        "source": "    public void testBinaryEncoder() throws EncoderException {\n\n        BinaryEncoder enc = new Base64();\n\n        for (int i = 0; i < STRINGS.length; i++) {\n\n            if (STRINGS[i] != null) {\n\n                byte[] base64 = utf8(STRINGS[i]);\n\n                byte[] binary = BYTES[i];\n\n                boolean b = Arrays.equals(base64, enc.encode(binary));\n\n                assertTrue(\"BinaryEncoder test-\" + i, b);\n\n            }\n\n        }\n\n    }\n"
      }
    }
  },
  "Codec-5": {
    "id": "Codec-5",
    "project": "Codec",
    "number": "5",
    "buggy_function": "void decode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        byte b = in[inPos++];\n        if (b == PAD) {\n            // We're done.\n            eof = true;\n            break;\n        } else {\n            if (b >= 0 && b < DECODE_TABLE.length) {\n                int result = DECODE_TABLE[b];\n                if (result >= 0) {\n                    modulus = (++modulus) % 4;\n                    x = (x << 6) + result;\n                    if (modulus == 0) {\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                        buffer[pos++] = (byte) (x & MASK_8BITS);\n                    }\n                }\n            }\n        }\n    }\n\n    // Two forms of EOF as far as base64 decoder is concerned: actual\n    // EOF (-1) and first time '=' character is encountered in stream.\n    // This approach makes the '=' padding characters completely optional.\n    if (eof && modulus != 0) {\n        \n        x = x << 6;\n        switch (modulus) {\n            case 2 :\n                x = x << 6;\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                break;\n            case 3 :\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                break;\n        }\n    }\n}",
    "fixed_function": "void decode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        byte b = in[inPos++];\n        if (b == PAD) {\n            // We're done.\n            eof = true;\n            break;\n        } else {\n            if (b >= 0 && b < DECODE_TABLE.length) {\n                int result = DECODE_TABLE[b];\n                if (result >= 0) {\n                    modulus = (++modulus) % 4;\n                    x = (x << 6) + result;\n                    if (modulus == 0) {\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                        buffer[pos++] = (byte) (x & MASK_8BITS);\n                    }\n                }\n            }\n        }\n    }\n\n    // Two forms of EOF as far as base64 decoder is concerned: actual\n    // EOF (-1) and first time '=' character is encountered in stream.\n    // This approach makes the '=' padding characters completely optional.\n    if (eof && modulus != 0) {\n        if (buffer == null || buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        \n        x = x << 6;\n        switch (modulus) {\n            case 2 :\n                x = x << 6;\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                break;\n            case 3 :\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                break;\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/binary/Base64.java",
      "first_line": 550,
      "last_line": 599
    },
    "javadoc": "/**\n* <p>\n* Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n* with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n* call is not necessary when decoding, but it doesn't hurt, either.\n* </p>\n* <p>\n* Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n* silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n* garbage-out philosophy: it will not check the provided data for validity.\n* </p>\n* <p>\n* Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n* http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n* </p>\n*\n* @param in\n*            byte[] array of ascii data to base64 decode.\n* @param inPos\n*            Position to start reading data from.\n* @param inAvail\n*            Amount of bytes available from input for encoding.\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec98NPE": {
        "source": "    public void testCodec98NPE() throws Exception {\n\n        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n\n        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n\n        Base64InputStream stream = new Base64InputStream(data);\n\n\n\n        // This line causes an NPE in commons-codec-1.4.jar:\n\n        byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n\n\n\n        String decoded = StringUtils.newStringUtf8(decodedBytes);\n\n        assertEquals(\n\n            \"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n\n        );\n\n    }\n"
      },
      "org.apache.commons.codec.binary.Base64OutputStreamTest::testCodec98NPE": {
        "source": "    public void testCodec98NPE() throws Exception {\n\n        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n\n        byte[] codec98_1024 = new byte[1024];\n\n        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n\n        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n\n        Base64OutputStream stream = new Base64OutputStream(data, false);\n\n        stream.write(codec98_1024, 0, 1024);\n\n        stream.close();\n\n\n\n        byte[] decodedBytes = data.toByteArray();\n\n        String decoded = StringUtils.newStringUtf8(decodedBytes);\n\n        assertEquals(\n\n            \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n\n        );\n\n    }\n"
      }
    }
  },
  "Codec-6": {
    "id": "Codec-6",
    "project": "Codec",
    "number": "6",
    "buggy_function": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        /*\n         Rationale for while-loop on (readLen == 0):\n         -----\n         Base64.readResults() usually returns > 0 or EOF (-1).  In the\n         rare case where it returns 0, we just keep trying.\n\n         This is essentially an undocumented contract for InputStream\n         implementors that want their code to work properly with\n         java.io.InputStreamReader, since the latter hates it when\n         InputStream.read(byte[]) returns a zero.  Unfortunately our\n         readResults() call must return 0 if a large amount of the data\n         being decoded was non-base64, so this while-loop enables proper\n         interop with InputStreamReader for that scenario.\n         -----\n         This is a fix for CODEC-101\n        */\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n        return base64.readResults(b, offset, len);\n    }\n}",
    "fixed_function": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        /*\n         Rationale for while-loop on (readLen == 0):\n         -----\n         Base64.readResults() usually returns > 0 or EOF (-1).  In the\n         rare case where it returns 0, we just keep trying.\n\n         This is essentially an undocumented contract for InputStream\n         implementors that want their code to work properly with\n         java.io.InputStreamReader, since the latter hates it when\n         InputStream.read(byte[]) returns a zero.  Unfortunately our\n         readResults() call must return 0 if a large amount of the data\n         being decoded was non-base64, so this while-loop enables proper\n         interop with InputStreamReader for that scenario.\n         -----\n         This is a fix for CODEC-101\n        */\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
      "first_line": 138,
      "last_line": 180
    },
    "javadoc": "/**\n* Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n* from this InputStream.\n*\n* @param b\n*            destination byte array\n* @param offset\n*            where to start writing the bytes\n* @param len\n*            maximum number of bytes to read\n*\n* @return number of bytes read\n* @throws IOException\n*             if an I/O error occurs.\n* @throws NullPointerException\n*             if the byte array parameter is null\n* @throws IndexOutOfBoundsException\n*             if offset, len or buffer size are invalid\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec101": {
        "source": "    public void testCodec101() throws Exception {\n\n        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n\n        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n\n        Base64InputStream in = new Base64InputStream(bais);\n\n        byte[] result = new byte[8192];\n\n        int c = in.read(result);\n\n        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n\n\n\n        c = in.read(result);\n\n        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n\n    }\n"
      }
    }
  },
  "Codec-7": {
    "id": "Codec-7",
    "project": "Codec",
    "number": "7",
    "buggy_function": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}",
    "fixed_function": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/binary/Base64.java",
      "first_line": 669,
      "last_line": 671
    },
    "javadoc": "/**\n* Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n*\n* @param binaryData\n*            binary data to encode\n* @return String containing Base64 characters.\n* @since 1.4\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations": {
        "source": "    public void testByteToStringVariations() throws DecoderException {\n\n        Base64 base64 = new Base64(0);\n\n        byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n\n        byte[] b2 = new byte[0];\n\n        byte[] b3 = null;\n\n        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n\n\n\n        assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n\n        assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));\n\n        assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));\n\n        assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));\n\n        assertEquals(\"byteToString null\", null, base64.encodeToString(b3));\n\n        assertEquals(\"byteToString static null\", null, Base64.encodeBase64String(b3));\n\n        assertEquals(\"byteToString UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", base64.encodeToString(b4));\n\n        assertEquals(\"byteToString static UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", Base64.encodeBase64String(b4));\n\n        assertEquals(\"byteToString static-url-safe UUID\", \"K_fMJwH-Q5e0nr7tWsxwkA\", Base64.encodeBase64URLSafeString(b4));\n\n    }\n"
      },
      "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode": {
        "source": "    public void testRfc4648Section10Encode() {\n\n        assertEquals(\"\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"\")));\n\n        assertEquals(\"Zg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\")));\n\n        assertEquals(\"Zm8=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fo\")));\n\n        assertEquals(\"Zm9v\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foo\")));\n\n        assertEquals(\"Zm9vYg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foob\")));\n\n        assertEquals(\"Zm9vYmE=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fooba\")));\n\n        assertEquals(\"Zm9vYmFy\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foobar\")));\n\n    }\n"
      }
    }
  },
  "Codec-9": {
    "id": "Codec-9",
    "project": "Codec",
    "number": "9",
    "buggy_function": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n            \n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}",
    "fixed_function": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n            \n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/codec/binary/Base64.java",
      "first_line": 822,
      "last_line": 837
    },
    "javadoc": "/**\n* Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n*\n* @param binaryData\n*            Array containing binary data to encode.\n* @param isChunked\n*            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n* @param urlSafe\n*            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n* @param maxResultSize\n*            The maximum result size to accept.\n* @return Base64-encoded data.\n* @throws IllegalArgumentException\n*             Thrown when the input array needs an output array bigger than maxResultSize\n* @since 1.4\n*/",
    "failing_tests": {
      "org.apache.commons.codec.binary.Base64Test::testCodec112": {
        "source": "    public void testCodec112() { // size calculation assumes always chunked\n\n        byte[] in = new byte[] {0};\n\n        byte[] out=Base64.encodeBase64(in);\n\n        Base64.encodeBase64(in, false, false, out.length);\n\n    }\n"
      }
    }
  },
  "Collections-26": {
    "id": "Collections-26",
    "project": "Collections",
    "number": "26",
    "buggy_function": "private Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}",
    "fixed_function": "protected Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java",
      "first_line": 277,
      "last_line": 280
    },
    "javadoc": "/**\n* Recalculate the hash code after deserialization. The hash code of some\n* keys might have change (hash codes based on the system hash code are\n* only stable for the same process).\n* @return the instance with recalculated hash code\n*/",
    "failing_tests": {
      "org.apache.commons.collections4.keyvalue.MultiKeyTest::testEqualsAfterSerializationOfDerivedClass": {
        "source": "    public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException\n\n    {\n\n        final DerivedMultiKey<?> mk = new DerivedMultiKey<String>(\"A\", \"B\");\n\n\n\n        // serialize\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        final ObjectOutputStream out = new ObjectOutputStream(baos);\n\n        out.writeObject(mk);\n\n        out.close();\n\n\n\n        // deserialize\n\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\n        final ObjectInputStream in = new ObjectInputStream(bais);\n\n        final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>)in.readObject();\n\n        in.close();\n\n\n\n        assertEquals(mk.hashCode(), mk2.hashCode());\n\n    }\n"
      }
    }
  },
  "Compress-1": {
    "id": "Compress-1",
    "project": "Compress",
    "number": "1",
    "buggy_function": "public void close() throws IOException {\n    if (!this.closed) {\n        super.close();\n        this.closed = true;\n    }\n}",
    "fixed_function": "public void close() throws IOException {\n    if (!this.closed) {\n        this.finish();\n        super.close();\n        this.closed = true;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
      "first_line": 344,
      "last_line": 349
    },
    "javadoc": "/**\n* Closes the CPIO output stream as well as the stream being filtered.\n*\n* @throws IOException\n*             if an I/O error has occurred or if a CPIO file error has\n*             occurred\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.CpioTestCase::testCpioUnarchive": {
        "source": "    public void testCpioUnarchive() throws Exception {\n\n        final File output = new File(dir, \"bla.cpio\");\n\n        {\n\n            final File file1 = getFile(\"test1.xml\");\n\n            final File file2 = getFile(\"test2.xml\");\n\n\n\n            final OutputStream out = new FileOutputStream(output);\n\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n\n            os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n\n            IOUtils.copy(new FileInputStream(file1), os);\n\n            os.closeArchiveEntry();\n\n\n\n            os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n\n            IOUtils.copy(new FileInputStream(file2), os);\n\n            os.closeArchiveEntry();\n\n\n\n            os.close();\n\n            out.close();\n\n        }\n\n\n\n        // Unarchive Operation\n\n        final File input = output;\n\n        final InputStream is = new FileInputStream(input);\n\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\n\n\n\n\n        Map result = new HashMap();\n\n        ArchiveEntry entry = null;\n\n        while ((entry = in.getNextEntry()) != null) {\n\n            File target = new File(dir, entry.getName());\n\n            final OutputStream out = new FileOutputStream(target);\n\n            IOUtils.copy(in, out);\n\n            out.close();\n\n            result.put(entry.getName(), target);\n\n        }\n\n        in.close();\n\n\n\n        int lineSepLength = System.getProperty(\"line.separator\").length();\n\n\n\n        File t = (File)result.get(\"test1.xml\");\n\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n\n        assertEquals(\"length of \" + t.getAbsolutePath(),\n\n                     72 + 4 * lineSepLength, t.length());\n\n\n\n        t = (File)result.get(\"test2.xml\");\n\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n\n        assertEquals(\"length of \" + t.getAbsolutePath(),\n\n                     73 + 5 * lineSepLength, t.length());\n\n    }\n"
      }
    }
  },
  "Compress-10": {
    "id": "Compress-10",
    "project": "Compress",
    "number": "10",
    "buggy_function": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}",
    "fixed_function": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> origMap =\n        new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n    entries.clear();\n    for (ZipArchiveEntry ze : origMap.keySet()) {\n        OffsetEntry offsetEntry = origMap.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        entries.put(ze, offsetEntry);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java",
      "first_line": 801,
      "last_line": 843
    },
    "javadoc": "/**\n* Walks through all recorded entries and adds the data available\n* from the local file header.\n*\n* <p>Also records the offsets for the data to read from the\n* entries.</p>\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive": {
        "source": "    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n\n        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n\n        File archive = new File(new URI(zip.toString()));\n\n        ZipFile zf = null;\n\n        try {\n\n            zf = new ZipFile(archive, null, true);\n\n            assertCanRead(zf, ASCII_TXT);\n\n            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n\n            assertCanRead(zf, OIL_BARREL_TXT);\n\n        } finally {\n\n            ZipFile.closeQuietly(zf);\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-11": {
    "id": "Compress-11",
    "project": "Compress",
    "number": "11",
    "buggy_function": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\n        throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = in.read(tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        try {\n            TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n            tais.getNextEntry();\n            return new TarArchiveInputStream(in);\n        } catch (Exception e) { // NOPMD\n            // can generate IllegalArgumentException as well as IOException\n            // autodetection, simply not a TAR\n            // ignored\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}",
    "fixed_function": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\n        throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = in.read(tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n        try {\n            TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n            tais.getNextEntry();\n            return new TarArchiveInputStream(in);\n        } catch (Exception e) { // NOPMD\n            // can generate IllegalArgumentException as well as IOException\n            // autodetection, simply not a TAR\n            // ignored\n        }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java",
      "first_line": 197,
      "last_line": 254
    },
    "javadoc": "/**\n* Create an archive input stream from an input stream, autodetecting\n* the archive type from the first few bytes of the stream. The InputStream\n* must support marks, like BufferedInputStream.\n*\n* @param in the input stream\n* @return the archive input stream\n* @throws ArchiveException if the archiver name is not known\n* @throws IllegalArgumentException if the stream is null or does not support mark\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::shortTextFilesAreNoTARs": {
        "source": "    public void shortTextFilesAreNoTARs() throws Exception {\n\n        try {\n\n            new ArchiveStreamFactory()\n\n                .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n\n            fail(\"created an input stream for a non-archive\");\n\n        } catch (ArchiveException ae) {\n\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-12": {
    "id": "Compress-12",
    "project": "Compress",
    "number": "12",
    "buggy_function": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}",
    "fixed_function": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        IOException ioe = new IOException(\"Error detected parsing the header\");\n        ioe.initCause(e);\n        throw ioe;\n    }\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "first_line": 172,
      "last_line": 238
    },
    "javadoc": "/**\n* Get the next entry in this tar archive. This will skip\n* over any remaining data in the current entry, if there\n* is one, and place the input stream at the header of the\n* next entry, and read the header and instantiate a new\n* TarEntry from the header bytes and return that entry.\n* If there are no more entries in the archive, null will\n* be returned to indicate that the end of the archive has\n* been reached.\n*\n* @return The next TarEntry in the archive, or null.\n* @throws IOException on error\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.TarTestCase::testCOMPRESS178": {
        "source": "    public void testCOMPRESS178() throws Exception {\n\n        final File input = getFile(\"COMPRESS-178.tar\");\n\n        final InputStream is = new FileInputStream(input);\n\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n\n        try {\n\n            in.getNextEntry();\n\n            fail(\"Expected IOException\");\n\n        } catch (IOException e) {\n\n            Throwable t = e.getCause();\n\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n\n        }\n\n        in.close();\n\n    }\n"
      }
    }
  },
  "Compress-13": {
    "id": "Compress-13",
    "project": "Compress",
    "number": "13",
    "buggy_function": "protected void setName(String name) {\n    this.name = name;\n}",
    "fixed_function": "protected void setName(String name) {\n    if (name != null && getPlatform() == PLATFORM_FAT\n        && name.indexOf(\"/\") == -1) {\n        name = name.replace('\\\\', '/');\n    }\n    this.name = name;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java",
      "first_line": 511,
      "last_line": 513
    },
    "javadoc": "/**\n* Set the name of the entry.\n* @param name the name to use\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::winzipBackSlashWorkaround": {
        "source": "    public void winzipBackSlashWorkaround() throws Exception {\n\n        URL zip = getClass().getResource(\"/test-winzip.zip\");\n\n        ZipArchiveInputStream in = null;\n\n        try {\n\n            in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n\n            ZipArchiveEntry zae = in.getNextZipEntry();\n\n            zae = in.getNextZipEntry();\n\n            zae = in.getNextZipEntry();\n\n            assertEquals(\"\\u00e4/\", zae.getName());\n\n        } finally {\n\n            if (in != null) {\n\n                in.close();\n\n            }\n\n        }\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.zip.ZipFileTest::testWinzipBackSlashWorkaround": {
        "source": "    public void testWinzipBackSlashWorkaround() throws Exception {\n\n        URL zip = getClass().getResource(\"/test-winzip.zip\");\n\n        File archive = new File(new URI(zip.toString()));\n\n        zf = new ZipFile(archive);\n\n        assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\n\n        assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\n\n    }\n"
      }
    }
  },
  "Compress-14": {
    "id": "Compress-14",
    "project": "Compress",
    "number": "14",
    "buggy_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i] != 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    // May have additional NUL or space\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "fixed_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    // May have additional NUL or space\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 56,
      "last_line": 112
    },
    "javadoc": "/**\n* Parse an octal string from a buffer.\n*\n* <p>Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.</p>\n*\n* <p>The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).</p>\n*\n* <p>To work-around some tar implementations that insert a\n* leading NUL this method returns 0 if it detects a leading NUL\n* since Commons Compress 1.4.</p>\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::workaroundForBrokenTimeHeader": {
        "source": "    public void workaroundForBrokenTimeHeader() throws Exception {\n\n        URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\");\n\n        TarArchiveInputStream in = null;\n\n        try {\n\n            in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n\n            TarArchiveEntry tae = in.getNextTarEntry();\n\n            tae = in.getNextTarEntry();\n\n            assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\n\n            assertEquals(new Date(0), tae.getLastModifiedDate());\n\n            assertTrue(tae.isSymbolicLink());\n\n        } finally {\n\n            if (in != null) {\n\n                in.close();\n\n            }\n\n        }\n\n    }        \n"
      }
    }
  },
  "Compress-15": {
    "id": "Compress-15",
    "project": "Compress",
    "number": "15",
    "buggy_function": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    String myName = getName();\n    String otherName = other.getName();\n    if (myName == null) {\n        if (otherName != null) {\n            return false;\n        }\n    } else if (!myName.equals(otherName)) {\n        return false;\n    }\n    String myComment = getComment();\n    String otherComment = other.getComment();\n    if (myComment == null) {\n        if (otherComment != null) {\n            return false;\n        }\n    } else if (!myComment.equals(otherComment)) {\n        return false;\n    }\n    return getTime() == other.getTime()\n        && getInternalAttributes() == other.getInternalAttributes()\n        && getPlatform() == other.getPlatform()\n        && getExternalAttributes() == other.getExternalAttributes()\n        && getMethod() == other.getMethod()\n        && getSize() == other.getSize()\n        && getCrc() == other.getCrc()\n        && getCompressedSize() == other.getCompressedSize()\n        && Arrays.equals(getCentralDirectoryExtra(),\n                         other.getCentralDirectoryExtra())\n        && Arrays.equals(getLocalFileDataExtra(),\n                         other.getLocalFileDataExtra())\n        && gpb.equals(other.gpb);\n}",
    "fixed_function": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    String myName = getName();\n    String otherName = other.getName();\n    if (myName == null) {\n        if (otherName != null) {\n            return false;\n        }\n    } else if (!myName.equals(otherName)) {\n        return false;\n    }\n    String myComment = getComment();\n    String otherComment = other.getComment();\n    if (myComment == null) {\n        myComment = \"\";\n    }\n    if (otherComment == null) {\n        otherComment = \"\";\n    }\n    return getTime() == other.getTime()\n        && myComment.equals(otherComment)\n        && getInternalAttributes() == other.getInternalAttributes()\n        && getPlatform() == other.getPlatform()\n        && getExternalAttributes() == other.getExternalAttributes()\n        && getMethod() == other.getMethod()\n        && getSize() == other.getSize()\n        && getCrc() == other.getCrc()\n        && getCompressedSize() == other.getCompressedSize()\n        && Arrays.equals(getCentralDirectoryExtra(),\n                         other.getCentralDirectoryExtra())\n        && Arrays.equals(getLocalFileDataExtra(),\n                         other.getLocalFileDataExtra())\n        && gpb.equals(other.gpb);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java",
      "first_line": 649,
      "last_line": 688
    },
    "javadoc": "/** {@inheritDoc} */\npublic Date getLastModifiedDate() {\nreturn new Date(getTime());\n}\n\n/* (non-Javadoc)\n* @see java.lang.Object#equals(java.lang.Object)\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment": {
        "source": "    public void testNullCommentEqualsEmptyComment() {\n\n        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n\n        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n\n        ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n\n        entry1.setComment(null);\n\n        entry2.setComment(\"\");\n\n        entry3.setComment(\"bar\");\n\n        assertEquals(entry1, entry2);\n\n        assertFalse(entry1.equals(entry3));\n\n        assertFalse(entry2.equals(entry3));\n\n    }\n"
      }
    }
  },
  "Compress-16": {
    "id": "Compress-16",
    "project": "Compress",
    "number": "16",
    "buggy_function": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\n        throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = in.read(tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                tais.getNextEntry();\n                    return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}",
    "fixed_function": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\n        throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = in.read(tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in);\n                }\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java",
      "first_line": 197,
      "last_line": 258
    },
    "javadoc": "/**\n* Create an archive input stream from an input stream, autodetecting\n* the archive type from the first few bytes of the stream. The InputStream\n* must support marks, like BufferedInputStream.\n*\n* @param in the input stream\n* @return the archive input stream\n* @throws ArchiveException if the archiver name is not known\n* @throws IllegalArgumentException if the stream is null or does not support mark\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::aiffFilesAreNoTARs": {
        "source": "    public void aiffFilesAreNoTARs() throws Exception {\n\n        InputStream is = null;\n\n        try {\n\n            is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));\n\n            new ArchiveStreamFactory().createArchiveInputStream(is);\n\n            fail(\"created an input stream for a non-archive\");\n\n        } catch (ArchiveException ae) {\n\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n\n        } finally {\n\n            if (is != null) {\n\n                is.close();\n\n            }\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-17": {
    "id": "Compress-17",
    "project": "Compress",
    "number": "17",
    "buggy_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    // May have additional NULs or spaces\n    trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "fixed_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    // May have additional NULs or spaces\n    trailer = buffer[end - 1];\n    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 102,
      "last_line": 151
    },
    "javadoc": "/**\n* Parse an octal string from a buffer.\n*\n* <p>Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.</p>\n*\n* <p>The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).</p>\n*\n* <p>To work-around some tar implementations that insert a\n* leading NUL this method returns 0 if it detects a leading NUL\n* since Commons Compress 1.4.</p>\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197": {
        "source": "    public void testCompress197() throws Exception {\n\n        TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n\n        try {\n\n            TarArchiveEntry entry = tar.getNextTarEntry();\n\n            while (entry != null) {\n\n                entry = tar.getNextTarEntry();\n\n            }\n\n        } catch (IOException e) {\n\n            fail(\"COMPRESS-197: \" + e.getMessage());\n\n        } finally {\n\n            tar.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-18": {
    "id": "Compress-18",
    "project": "Compress",
    "number": "18",
    "buggy_function": "void writePaxHeaders(String entryName,\n                     Map<String, String> headers) throws IOException {\n    String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        // TarEntry's constructor would think this is a directory\n        // and not allow any data to be written\n    if (name.length() >= TarConstants.NAMELEN) {\n        name = name.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry pex = new TarArchiveEntry(name,\n                                              TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n    StringWriter w = new StringWriter();\n    for (Map.Entry<String, String> h : headers.entrySet()) {\n        String key = h.getKey();\n        String value = h.getValue();\n        int len = key.length() + value.length()\n            + 3 /* blank, equals and newline */\n            + 2 /* guess 9 < actual length < 100 */;\n        String line = len + \" \" + key + \"=\" + value + \"\\n\";\n        int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        while (len != actualLength) {\n            // Adjust for cases where length < 10 or > 100\n            // or where UTF-8 encoding isn't a single octet\n            // per character.\n            // Must be in loop as size may go from 99 to 100 in\n            // first pass so we'd need a second.\n            len = actualLength;\n            line = len + \" \" + key + \"=\" + value + \"\\n\";\n            actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        }\n        w.write(line);\n    }\n    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n    pex.setSize(data.length);\n    putArchiveEntry(pex);\n    write(data);\n    closeArchiveEntry();\n}",
    "fixed_function": "void writePaxHeaders(String entryName,\n                     Map<String, String> headers) throws IOException {\n    String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n    while (name.endsWith(\"/\")) {\n        // TarEntry's constructor would think this is a directory\n        // and not allow any data to be written\n        name = name.substring(0, name.length() - 1);\n    }\n    if (name.length() >= TarConstants.NAMELEN) {\n        name = name.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry pex = new TarArchiveEntry(name,\n                                              TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n    StringWriter w = new StringWriter();\n    for (Map.Entry<String, String> h : headers.entrySet()) {\n        String key = h.getKey();\n        String value = h.getValue();\n        int len = key.length() + value.length()\n            + 3 /* blank, equals and newline */\n            + 2 /* guess 9 < actual length < 100 */;\n        String line = len + \" \" + key + \"=\" + value + \"\\n\";\n        int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        while (len != actualLength) {\n            // Adjust for cases where length < 10 or > 100\n            // or where UTF-8 encoding isn't a single octet\n            // per character.\n            // Must be in loop as size may go from 99 to 100 in\n            // first pass so we'd need a second.\n            len = actualLength;\n            line = len + \" \" + key + \"=\" + value + \"\\n\";\n            actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        }\n        w.write(line);\n    }\n    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n    pex.setSize(data.length);\n    putArchiveEntry(pex);\n    write(data);\n    closeArchiveEntry();\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "first_line": 454,
      "last_line": 491
    },
    "javadoc": "/**\n* Writes a PAX extended header with the given map as contents.\n* @since 1.4\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testWriteNonAsciiDirectoryNamePosixMode": {
        "source": "    public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n\n        String n = \"f\\u00f6\\u00f6/\";\n\n        TarArchiveEntry t = new TarArchiveEntry(n);\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n\n        tos.setAddPaxHeadersForNonAsciiNames(true);\n\n        tos.putArchiveEntry(t);\n\n        tos.closeArchiveEntry();\n\n        tos.close();\n\n        byte[] data = bos.toByteArray();\n\n        TarArchiveInputStream tin =\n\n            new TarArchiveInputStream(new ByteArrayInputStream(data));\n\n        TarArchiveEntry e = tin.getNextTarEntry();\n\n        assertEquals(n, e.getName());\n\n        assertTrue(e.isDirectory());\n\n        tin.close();\n\n    }\n"
      }
    }
  },
  "Compress-19": {
    "id": "Compress-19",
    "project": "Compress",
    "number": "19",
    "buggy_function": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length != expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}",
    "fixed_function": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length < expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java",
      "first_line": 249,
      "last_line": 287
    },
    "javadoc": "/**\n* Parses the raw bytes read from the central directory extra\n* field with knowledge which fields are expected to be there.\n*\n* <p>All four fields inside the zip64 extended information extra\n* field are optional and must only be present if their corresponding\n* entry inside the central directory contains the correct magic\n* value.</p>\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField": {
        "source": "    public void testExcessDataInZip64ExtraField() throws Exception {\n\n        File archive = getFile(\"COMPRESS-228.zip\");\n\n        zf = new ZipFile(archive);\n\n        // actually, if we get here, the test already has passed\n\n\n\n        ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n\n        assertEquals(26101, ze.getSize());\n\n    }\n"
      }
    }
  },
  "Compress-21": {
    "id": "Compress-21",
    "project": "Compress",
    "number": "21",
    "buggy_function": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n    int cache = 0;\n    int shift = 7;\n    for (int i = 0; i < length; i++) {\n        cache |= ((bits.get(i) ? 1 : 0) << shift);\n        --shift;\n        if (shift == 0) {\n            header.write(cache);\n            shift = 7;\n            cache = 0;\n        }\n    }\n    if (length > 0 && shift > 0) {\n        header.write(cache);\n    }\n}",
    "fixed_function": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n    int cache = 0;\n    int shift = 7;\n    for (int i = 0; i < length; i++) {\n        cache |= ((bits.get(i) ? 1 : 0) << shift);\n        if (--shift < 0) {\n            header.write(cache);\n            shift = 7;\n            cache = 0;\n        }\n    }\n    if (shift != 7) {\n        header.write(cache);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java",
      "first_line": 634,
      "last_line": 649
    },
    "javadoc": "//",
    "failing_tests": {
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSevenEmptyFiles": {
        "source": "    public void testSevenEmptyFiles() throws Exception {\n\n        testCompress252(7, 0);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testEightFilesSomeNotEmpty": {
        "source": "    public void testEightFilesSomeNotEmpty() throws Exception {\n\n        testCompress252(8, 2);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSixEmptyFiles": {
        "source": "    public void testSixEmptyFiles() throws Exception {\n\n        testCompress252(6, 0);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testEightEmptyFiles": {
        "source": "    public void testEightEmptyFiles() throws Exception {\n\n        testCompress252(8, 0);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testNineEmptyFiles": {
        "source": "    public void testNineEmptyFiles() throws Exception {\n\n        testCompress252(9, 0);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSixFilesSomeNotEmpty": {
        "source": "    public void testSixFilesSomeNotEmpty() throws Exception {\n\n        testCompress252(6, 2);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testNineFilesSomeNotEmpty": {
        "source": "    public void testNineFilesSomeNotEmpty() throws Exception {\n\n        testCompress252(9, 2);\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSevenFilesSomeNotEmpty": {
        "source": "    public void testSevenFilesSomeNotEmpty() throws Exception {\n\n        testCompress252(7, 2);\n\n    }\n"
      }
    }
  },
  "Compress-23": {
    "id": "Compress-23",
    "project": "Compress",
    "number": "23",
    "buggy_function": "InputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}",
    "fixed_function": "InputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java",
      "first_line": 107,
      "last_line": 118
    },
    "javadoc": "/*\n*  Licensed to the Apache Software Foundation (ASF) under one or more\n*  contributor license agreements.  See the NOTICE file distributed with\n*  this work for additional information regarding copyright ownership.\n*  The ASF licenses this file to You under the Apache License, Version 2.0\n*  (the \"License\"); you may not use this file except in compliance with\n*  the License.  You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n*  Unless required by applicable law or agreed to in writing, software\n*  distributed under the License is distributed on an \"AS IS\" BASIS,\n*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*  See the License for the specific language governing permissions and\n*  limitations under the License.\n*\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.sevenz.SevenZFileTest::testCompressedHeaderWithNonDefaultDictionarySize": {
        "source": "    public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n\n        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n\n        try {\n\n            int count = 0;\n\n            while (sevenZFile.getNextEntry() != null) {\n\n                count++;\n\n            }\n\n            assertEquals(446, count);\n\n        } finally {\n\n            sevenZFile.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-24": {
    "id": "Compress-24",
    "project": "Compress",
    "number": "24",
    "buggy_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    trailer = buffer[end - 1];\n    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "fixed_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 102,
      "last_line": 153
    },
    "javadoc": "/**\n* Parse an octal string from a buffer.\n*\n* <p>Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.</p>\n*\n* <p>The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).</p>\n*\n* <p>To work-around some tar implementations that insert a\n* leading NUL this method returns 0 if it detects a leading NUL\n* since Commons Compress 1.4.</p>\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal": {
        "source": "    public void testParseOctal() throws Exception{\n\n        long value; \n\n        byte [] buffer;\n\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n\n        buffer[buffer.length - 1] = ' ';\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL, value);\n\n        buffer[buffer.length-1]=0;\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL, value);\n\n        buffer=new byte[]{0,0};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n        buffer=new byte[]{0,' '};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n    }\n"
      }
    }
  },
  "Compress-25": {
    "id": "Compress-25",
    "project": "Compress",
    "number": "25",
    "buggy_function": "public ZipArchiveInputStream(InputStream inputStream,\n                             String encoding,\n                             boolean useUnicodeExtraFields,\n                             boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor =\n        allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n}",
    "fixed_function": "public ZipArchiveInputStream(InputStream inputStream,\n                             String encoding,\n                             boolean useUnicodeExtraFields,\n                             boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor =\n        allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
      "first_line": 174,
      "last_line": 184
    },
    "javadoc": "/**\n* @param encoding the encoding to use for file names, use null\n* for the platform's default encoding\n* @param useUnicodeExtraFields whether to use InfoZIP Unicode\n* Extra Fields (if present) to set the file names.\n* @param allowStoredEntriesWithDataDescriptor whether the stream\n* will try to read STORED entries that use a data descriptor\n* @since 1.1\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::testReadingOfFirstStoredEntry": {
        "source": "    public void testReadingOfFirstStoredEntry() throws Exception {\n\n        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n\n        \n\n        try {\n\n            ZipArchiveEntry ze = in.getNextZipEntry();\n\n            assertEquals(5, ze.getSize());\n\n            assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n\n                              IOUtils.toByteArray(in));\n\n        } finally {\n\n            in.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-26": {
    "id": "Compress-26",
    "project": "Compress",
    "number": "26",
    "buggy_function": "public static long skip(InputStream input, long numToSkip) throws IOException {\n    long available = numToSkip;\n    while (numToSkip > 0) {\n        long skipped = input.skip(numToSkip);\n        if (skipped == 0) {\n            break;\n        }\n        numToSkip -= skipped;\n    }\n        \n    return available - numToSkip;\n}",
    "fixed_function": "public static long skip(InputStream input, long numToSkip) throws IOException {\n    long available = numToSkip;\n    while (numToSkip > 0) {\n        long skipped = input.skip(numToSkip);\n        if (skipped == 0) {\n            break;\n        }\n        numToSkip -= skipped;\n    }\n        \n    if (numToSkip > 0) {\n        byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n        while (numToSkip > 0) {\n            int read = readFully(input, skipBuf, 0,\n                                 (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n            if (read < 1) {\n                break;\n            }\n            numToSkip -= read;\n        }\n    }\n    return available - numToSkip;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/utils/IOUtils.java",
      "first_line": 94,
      "last_line": 105
    },
    "javadoc": "/**\n* Skips the given number of bytes by repeatedly invoking skip on\n* the given input stream if necessary.\n*\n* <p>In a case where the stream's skip() method returns 0 before\n* the requested number of bytes has been skip this implementation\n* will fall back to using the read() method.</p>\n*\n* <p>This method will only skip less than the requested number of\n* bytes if the end of the input stream has been reached.</p>\n*\n* @param input stream to skip bytes in\n* @param numToSkip the number of bytes to skip\n* @return the number of bytes actually skipped\n* @throws IOException\n*/",
    "failing_tests": {
      "org.apache.commons.compress.utils.IOUtilsTest::skipUsingRead": {
        "source": "    public void skipUsingRead() throws Exception {\n\n        skip(new StreamWrapper() {\n\n                public InputStream wrap(InputStream toWrap) {\n\n                    return new FilterInputStream(toWrap) {\n\n                        public long skip(long s) {\n\n                            return 0;\n\n                        }\n\n                    };\n\n                }\n\n            });\n\n    }\n"
      },
      "org.apache.commons.compress.utils.IOUtilsTest::skipUsingSkipAndRead": {
        "source": "    public void skipUsingSkipAndRead() throws Exception {\n\n        skip(new StreamWrapper() {\n\n                public InputStream wrap(final InputStream toWrap) {\n\n                    return new FilterInputStream(toWrap) {\n\n                        boolean skipped;\n\n                        public long skip(long s) throws IOException {\n\n                            if (!skipped) {\n\n                                toWrap.skip(5);\n\n                                skipped = true;\n\n                                return 5;\n\n                            }\n\n                            return 0;\n\n                        }\n\n                    };\n\n                }\n\n            });\n\n    }\n"
      }
    }
  },
  "Compress-27": {
    "id": "Compress-27",
    "project": "Compress",
    "number": "27",
    "buggy_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "fixed_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 102,
      "last_line": 150
    },
    "javadoc": "/**\n* Parse an octal string from a buffer.\n*\n* <p>Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.</p>\n*\n* <p>The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).</p>\n*\n* <p>To work-around some tar implementations that insert a\n* leading NUL this method returns 0 if it detects a leading NUL\n* since Commons Compress 1.4.</p>\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal": {
        "source": "    public void testParseOctal() throws Exception{\n\n        long value; \n\n        byte [] buffer;\n\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n\n        buffer[buffer.length - 1] = ' ';\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL, value);\n\n        buffer[buffer.length-1]=0;\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL, value);\n\n        buffer=new byte[]{0,0};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n        buffer=new byte[]{0,' '};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n        buffer=new byte[]{' ',0};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n    }\n"
      }
    }
  },
  "Compress-28": {
    "id": "Compress-28",
    "project": "Compress",
    "number": "28",
    "buggy_function": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\n\tint totalRead = 0;\n\n    if (hasHitEOF || entryOffset >= entrySize) {\n        return -1;\n    }\n\n    if (currEntry == null) {\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n\n    numToRead = Math.min(numToRead, available());\n    \n    totalRead = is.read(buf, offset, numToRead);\n    count(totalRead);\n    \n    if (totalRead == -1) {\n        hasHitEOF = true;\n    } else {\n        entryOffset += totalRead;\n    }\n\n    return totalRead;\n}",
    "fixed_function": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\n\tint totalRead = 0;\n\n    if (hasHitEOF || entryOffset >= entrySize) {\n        return -1;\n    }\n\n    if (currEntry == null) {\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n\n    numToRead = Math.min(numToRead, available());\n    \n    totalRead = is.read(buf, offset, numToRead);\n    \n    if (totalRead == -1) {\n        if (numToRead > 0) {\n            throw new IOException(\"Truncated TAR archive\");\n        }\n        hasHitEOF = true;\n    } else {\n        count(totalRead);\n        entryOffset += totalRead;\n    }\n\n    return totalRead;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "first_line": 569,
      "last_line": 592
    },
    "javadoc": "/**\n* Reads bytes from the current tar archive entry.\n*\n* This method is aware of the boundaries of the current\n* entry in the archive and will deal with them as if they\n* were this stream's start and EOF.\n*\n* @param buf The buffer into which to place bytes read.\n* @param offset The offset at which to place bytes read.\n* @param numToRead The number of bytes to read.\n* @return The number of bytes read, or -1 at EOF.\n* @throws IOException on error\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::shouldThrowAnExceptionOnTruncatedEntries": {
        "source": "    public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n\n        File dir = mkdir(\"COMPRESS-279\");\n\n        TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n\n        FileOutputStream out = null;\n\n        try {\n\n            TarArchiveEntry entry = is.getNextTarEntry();\n\n            int count = 0;\n\n            while (entry != null) {\n\n                out = new FileOutputStream(new File(dir, String.valueOf(count)));\n\n                IOUtils.copy(is, out);\n\n                out.close();\n\n                out = null;\n\n                count++;\n\n                entry = is.getNextTarEntry();\n\n            }\n\n        } finally {\n\n            is.close();\n\n            if (out != null) {\n\n                out.close();\n\n            }\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-30": {
    "id": "Compress-30",
    "project": "Compress",
    "number": "30",
    "buggy_function": "public int read(final byte[] dest, final int offs, final int len)\n    throws IOException {\n    if (offs < 0) {\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n    }\n    if (len < 0) {\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n    }\n    if (offs + len > dest.length) {\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                            + len + \") > dest.length(\" + dest.length + \").\");\n    }\n    if (this.in == null) {\n        throw new IOException(\"stream closed\");\n    }\n\n    final int hi = offs + len;\n    int destOffs = offs;\n    int b;\n    while (destOffs < hi && ((b = read0()) >= 0)) {\n        dest[destOffs++] = (byte) b;\n        count(1);\n    }\n\n    int c = (destOffs == offs) ? -1 : (destOffs - offs);\n    return c;\n}",
    "fixed_function": "public int read(final byte[] dest, final int offs, final int len)\n    throws IOException {\n    if (offs < 0) {\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n    }\n    if (len < 0) {\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n    }\n    if (offs + len > dest.length) {\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                            + len + \") > dest.length(\" + dest.length + \").\");\n    }\n    if (this.in == null) {\n        throw new IOException(\"stream closed\");\n    }\n    if (len == 0) {\n        return 0;\n    }\n\n    final int hi = offs + len;\n    int destOffs = offs;\n    int b;\n    while (destOffs < hi && ((b = read0()) >= 0)) {\n        dest[destOffs++] = (byte) b;\n        count(1);\n    }\n\n    int c = (destOffs == offs) ? -1 : (destOffs - offs);\n    return c;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java",
      "first_line": 153,
      "last_line": 179
    },
    "javadoc": "/**\n* Constructs a new BZip2CompressorInputStream which decompresses bytes\n* read from the specified stream.\n*\n* @param in the InputStream from which this object should be created\n* @param decompressConcatenated\n*                     if true, decompress until the end of the input;\n*                     if false, stop after the first .bz2 stream and\n*                     leave the input position to point to the next\n*                     byte after the .bz2 stream\n*\n* @throws IOException\n*             if the stream content is malformed or an I/O error occurs.\n* @throws NullPointerException\n*             if {@code in == null}\n*/\npublic BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\n\ninit(true);\ninitBlock();\n}\n\n@Override\npublic int read() throws IOException {\nif (this.in != null) {\nint r = read0();\ncount(r < 0 ? -1 : 1);\nreturn r;\n} else {\nthrow new IOException(\"stream closed\");\n}\n}\n\n/*\n* (non-Javadoc)\n*\n* @see java.io.InputStream#read(byte[], int, int)\n*/",
    "failing_tests": {
      "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStreamTest::readOfLength0ShouldReturn0": {
        "source": "    public void readOfLength0ShouldReturn0() throws Exception {\n\n        // Create a big random piece of data\n\n        byte[] rawData = new byte[1048576];\n\n        for (int i=0; i < rawData.length; ++i) {\n\n            rawData[i] = (byte) Math.floor(Math.random()*256);\n\n        }\n\n\n\n        // Compress it\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n\n        bzipOut.write(rawData);\n\n        bzipOut.flush();\n\n        bzipOut.close();\n\n        baos.flush();\n\n        baos.close();\n\n\n\n        // Try to read it back in\n\n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\n        BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n\n        byte[] buffer = new byte[1024];\n\n        Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n\n        Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n\n        Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n\n        bzipIn.close();\n\n    }\n"
      }
    }
  },
  "Compress-31": {
    "id": "Compress-31",
    "project": "Compress",
    "number": "31",
    "buggy_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte == 0) {\n            break;\n        }\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "fixed_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 101,
      "last_line": 148
    },
    "javadoc": "/**\n* Parse an octal string from a buffer.\n*\n* <p>Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.</p>\n*\n* <p>The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).</p>\n*\n* <p>To work-around some tar implementations that insert a\n* leading NUL this method returns 0 if it detects a leading NUL\n* since Commons Compress 1.4.</p>\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.TarTestCase::testCOMPRESS178": {
        "source": "    public void testCOMPRESS178() throws Exception {\n\n        final File input = getFile(\"COMPRESS-178.tar\");\n\n        final InputStream is = new FileInputStream(input);\n\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n\n        try {\n\n            in.getNextEntry();\n\n            fail(\"Expected IOException\");\n\n        } catch (IOException e) {\n\n            Throwable t = e.getCause();\n\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n\n        }\n\n        in.close();\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctalInvalid": {
        "source": "    public void testParseOctalInvalid() throws Exception{\n\n        byte [] buffer;\n\n        buffer=new byte[0]; // empty byte array\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer=new byte[]{0}; // 1-byte array\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \"abcdef \".getBytes(CharsetNames.UTF_8); // Invalid input\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \" 0 07 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded space\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - embedded space\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \" 0\\00007 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded NUL\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - embedded NUL\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-32": {
    "id": "Compress-32",
    "project": "Compress",
    "number": "32",
    "buggy_function": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n     * mtime\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid,uname\n     * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n     */\n    for (Entry<String, String> ent : headers.entrySet()){\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)){\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)){\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)){\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)){\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)){\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)){\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)){\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)){\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)){\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)){\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}",
    "fixed_function": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n     * mtime\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid,uname\n     * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n     */\n    for (Entry<String, String> ent : headers.entrySet()){\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)){\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)){\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)){\n            currEntry.setGroupId(Long.parseLong(val));\n        } else if (\"gname\".equals(key)){\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)){\n            currEntry.setUserId(Long.parseLong(val));\n        } else if (\"uname\".equals(key)){\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)){\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)){\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)){\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)){\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "first_line": 481,
      "last_line": 518
    },
    "javadoc": "// Drop trailing NL",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::shouldReadBigGid": {
        "source": "    public void shouldReadBigGid() throws Exception {\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n\n        TarArchiveEntry t = new TarArchiveEntry(\"name\");\n\n        t.setGroupId(4294967294l);\n\n        t.setSize(1);\n\n        tos.putArchiveEntry(t);\n\n        tos.write(30);\n\n        tos.closeArchiveEntry();\n\n        tos.close();\n\n        byte[] data = bos.toByteArray();\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n\n        TarArchiveInputStream tis =\n\n            new TarArchiveInputStream(bis);\n\n        t = tis.getNextTarEntry();\n\n        assertEquals(4294967294l, t.getLongGroupId());\n\n        tis.close();\n\n    }\n"
      }
    }
  },
  "Compress-35": {
    "id": "Compress-35",
    "project": "Compress",
    "number": "35",
    "buggy_function": "public static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "fixed_function": "public static boolean verifyCheckSum(byte[] header) {\n    long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 593,
      "last_line": 613
    },
    "javadoc": "/**\n* Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n* <blockquote>\n* The checksum is calculated by taking the sum of the unsigned byte values\n* of the header block with the eight checksum bytes taken to be ascii\n* spaces (decimal value 32). It is stored as a six digit octal number with\n* leading zeroes followed by a NUL and then a space. Various\n* implementations do not adhere to this format. For better compatibility,\n* ignore leading and trailing whitespace, and get the first six digits. In\n* addition, some historic tar implementations treated bytes as signed.\n* Implementations typically calculate the checksum both ways, and treat it\n* as good if either the signed or unsigned sum matches the included\n* checksum.\n* </blockquote>\n* <p>\n* The return value of this method should be treated as a best-effort\n* heuristic rather than an absolute and final truth. The checksum\n* verification logic may well evolve over time as more special cases\n* are encountered.\n*\n* @param header tar header\n* @return whether the checksum is reasonably good\n* @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n* @since 1.5\n*/",
    "failing_tests": {
      "org.apache.commons.compress.DetectArchiverTestCase::testCOMPRESS335": {
        "source": "    public void testCOMPRESS335() throws Exception {\n\n        final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n\n        assertNotNull(tar);\n\n        assertTrue(tar instanceof TarArchiveInputStream);\n\n    }\n"
      }
    }
  },
  "Compress-36": {
    "id": "Compress-36",
    "project": "Compress",
    "number": "36",
    "buggy_function": "private InputStream getCurrentStream() throws IOException {\n    if (deferredBlockStreams.isEmpty()) {\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n    }\n    \n    while (deferredBlockStreams.size() > 1) {\n        // In solid compression mode we need to decompress all leading folder'\n        // streams to get access to an entry. We defer this until really needed\n        // so that entire blocks can be skipped without wasting time for decompression.\n        final InputStream stream = deferredBlockStreams.remove(0);\n        IOUtils.skip(stream, Long.MAX_VALUE);\n        stream.close();\n    }\n\n    return deferredBlockStreams.get(0);\n}",
    "fixed_function": "private InputStream getCurrentStream() throws IOException {\n    if (archive.files[currentEntryIndex].getSize() == 0) {\n        return new ByteArrayInputStream(new byte[0]);\n    }\n    if (deferredBlockStreams.isEmpty()) {\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n    }\n    \n    while (deferredBlockStreams.size() > 1) {\n        // In solid compression mode we need to decompress all leading folder'\n        // streams to get access to an entry. We defer this until really needed\n        // so that entire blocks can be skipped without wasting time for decompression.\n        final InputStream stream = deferredBlockStreams.remove(0);\n        IOUtils.skip(stream, Long.MAX_VALUE);\n        stream.close();\n    }\n\n    return deferredBlockStreams.get(0);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java",
      "first_line": 901,
      "last_line": 916
    },
    "javadoc": "/**\n* Reads a byte of data.\n*\n* @return the byte read, or -1 if end of input is reached\n* @throws IOException\n*             if an I/O error has occurred\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.sevenz.SevenZFileTest::readEntriesOfSize0": {
        "source": "    public void readEntriesOfSize0() throws IOException {\n\n        final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n\n        try {\n\n            int entries = 0;\n\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n\n            while (entry != null) {\n\n                entries++;\n\n                int b = sevenZFile.read();\n\n                if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n\n                    assertEquals(-1, b);\n\n                } else {\n\n                    assertNotEquals(-1, b);\n\n                }\n\n                entry = sevenZFile.getNextEntry();\n\n            }\n\n            assertEquals(5, entries);\n\n        } finally {\n\n            sevenZFile.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-37": {
    "id": "Compress-37",
    "project": "Compress",
    "number": "37",
    "buggy_function": "Map<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while(true){ // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' '){\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '='){ // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) { // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + restLen\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0,\n                                                      restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                break; // Processed single header\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1){ // EOF\n            break;\n        }\n    }\n    return headers;\n}",
    "fixed_function": "Map<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while(true){ // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while((ch = i.read()) != -1) {\n            read++;\n            if (ch == '\\n') { // blank line in header\n                break;\n            } else if (ch == ' '){ // End of length string\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '='){ // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) { // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + restLen\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0,\n                                                      restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                break; // Processed single header\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1){ // EOF\n            break;\n        }\n    }\n    return headers;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
      "first_line": 452,
      "last_line": 502
    },
    "javadoc": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::survivesBlankLinesInPaxHeader": {
        "source": "    public void survivesBlankLinesInPaxHeader() throws Exception {\n\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n\n        try {\n\n            final TarArchiveEntry entry = is.getNextTarEntry();\n\n            assertEquals(\"package/package.json\", entry.getName());\n\n            assertNull(is.getNextTarEntry());\n\n        } finally {\n\n            is.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-38": {
    "id": "Compress-38",
    "project": "Compress",
    "number": "38",
    "buggy_function": "public boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n\n    return false;\n}",
    "fixed_function": "public boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n\n    if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n        return true;\n    }\n\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java",
      "first_line": 850,
      "last_line": 864
    },
    "javadoc": "/**\n* Return whether or not this entry represents a directory.\n*\n* @return True if this entry is a directory.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::survivesPaxHeaderWithNameEndingInSlash": {
        "source": "    public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n\n        try {\n\n            final TarArchiveEntry entry = is.getNextTarEntry();\n\n            assertEquals(\"package/package.json\", entry.getName());\n\n            assertNull(is.getNextTarEntry());\n\n        } finally {\n\n            is.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-40": {
    "id": "Compress-40",
    "project": "Compress",
    "number": "40",
    "buggy_function": "public long readBits(final int count) throws IOException {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n    }\n    while (bitsCachedSize < count) {\n        final long nextByte = in.read();\n        if (nextByte < 0) {\n            return nextByte;\n        }\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsCached |= (nextByte << bitsCachedSize);\n        } else {\n            bitsCached <<= 8;\n            bitsCached |= nextByte;\n        }\n        bitsCachedSize += 8;\n    }\n        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n    \n    final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n    return bitsOut;\n}",
    "fixed_function": "public long readBits(final int count) throws IOException {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n    }\n    while (bitsCachedSize < count && bitsCachedSize < 57) {\n        final long nextByte = in.read();\n        if (nextByte < 0) {\n            return nextByte;\n        }\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsCached |= (nextByte << bitsCachedSize);\n        } else {\n            bitsCached <<= 8;\n            bitsCached |= nextByte;\n        }\n        bitsCachedSize += 8;\n    }\n    int overflowBits = 0;\n    long overflow = 0l;\n    if (bitsCachedSize < count) {\n        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        int bitsToAddCount = count - bitsCachedSize;\n        overflowBits = 8 - bitsToAddCount;\n        final long nextByte = in.read();\n        if (nextByte < 0) {\n            return nextByte;\n        }\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n            bitsCached |= (bitsToAdd << bitsCachedSize);\n            overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n        } else {\n            bitsCached <<= bitsToAddCount;\n            long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n            bitsCached |= bitsToAdd;\n            overflow = nextByte & MASKS[overflowBits];\n        }\n        bitsCachedSize = count;\n    }\n    \n    final long bitsOut;\n    if (overflowBits == 0) {\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n    } else {\n        bitsOut = bitsCached & MASKS[count];\n        bitsCached = overflow;\n        bitsCachedSize = overflowBits;\n    }\n    return bitsOut;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java",
      "first_line": 81,
      "last_line": 109
    },
    "javadoc": "/**\n* Returns at most 63 bits read from the underlying stream.\n*\n* @param count the number of bits to read, must be a positive\n* number not bigger than 63.\n* @return the bits concatenated as a long using the stream's byte order.\n*         -1 if the end of the underlying stream has been reached before reading\n*         the requested number of bits\n* @throws IOException on error\n*/",
    "failing_tests": {
      "org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow": {
        "source": "    public void littleEndianWithOverflow() throws Exception {\n\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n\n                87, // 01010111\n\n                45, // 00101101\n\n                66, // 01000010\n\n                15, // 00001111\n\n                90, // 01011010\n\n                29, // 00011101\n\n                88, // 01011000\n\n                61, // 00111101\n\n                33, // 00100001\n\n                74  // 01001010\n\n            });\n\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n\n        assertEquals(23, // 10111\n\n                     bin.readBits(5));\n\n        assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n\n                     bin.readBits(63));\n\n        assertEquals(1186, // 01001010-0010\n\n                     bin.readBits(12));\n\n        assertEquals(-1 , bin.readBits(1));\n\n    }\n"
      },
      "org.apache.commons.compress.utils.BitInputStreamTest::bigEndianWithOverflow": {
        "source": "    public void bigEndianWithOverflow() throws Exception {\n\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n\n                87, // 01010111\n\n                45, // 00101101\n\n                66, // 01000010\n\n                15, // 00001111\n\n                90, // 01011010\n\n                29, // 00011101\n\n                88, // 01011000\n\n                61, // 00111101\n\n                33, // 00100001\n\n                74  // 01001010\n\n            });\n\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n\n        assertEquals(10, // 01010\n\n                     bin.readBits(5));\n\n        assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n\n                     bin.readBits(63));\n\n        assertEquals(330, // 0001-01001010\n\n                     bin.readBits(12));\n\n        assertEquals(-1 , bin.readBits(1));\n\n    }\n"
      }
    }
  },
  "Compress-41": {
    "id": "Compress-41",
    "project": "Compress",
    "number": "41",
    "buggy_function": "public ZipArchiveEntry getNextZipEntry() throws IOException {\n    boolean firstEntry = true;\n    if (closed || hitCentralDirectory) {\n        return null;\n    }\n    if (current != null) {\n        closeEntry();\n        firstEntry = false;\n    }\n\n    try {\n        if (firstEntry) {\n            // split archives have a special signature before the\n            // first local file header - look for it and fail with\n            // the appropriate error message if this is a split\n            // archive.\n            readFirstLocalFileHeader(LFH_BUF);\n        } else {\n            readFully(LFH_BUF);\n        }\n    } catch (final EOFException e) {\n        return null;\n    }\n\n    final ZipLong sig = new ZipLong(LFH_BUF);\n    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n        hitCentralDirectory = true;\n        skipRemainderOfArchive();\n    }\n    if (!sig.equals(ZipLong.LFH_SIG)) {\n        return null;\n    }\n\n    int off = WORD;\n    current = new CurrentEntry();\n\n    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n    current.entry.setGeneralPurposeBit(gpFlag);\n\n    off += SHORT;\n\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n    off += SHORT;\n\n    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n    current.entry.setTime(time);\n    off += WORD;\n\n    ZipLong size = null, cSize = null;\n    if (!current.hasDataDescriptor) {\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n        off += WORD;\n\n        cSize = new ZipLong(LFH_BUF, off);\n        off += WORD;\n\n        size = new ZipLong(LFH_BUF, off);\n        off += WORD;\n    } else {\n        off += 3 * WORD;\n    }\n\n    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n    off += SHORT;\n\n    final int extraLen = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n\n    final byte[] fileName = new byte[fileNameLen];\n    readFully(fileName);\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n    final byte[] extraData = new byte[extraLen];\n    readFully(extraData);\n    current.entry.setExtra(extraData);\n\n    if (!hasUTF8Flag && useUnicodeExtraFields) {\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n    }\n\n    processZip64Extra(size, cSize);\n\n    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            current.in = new ExplodingInputStream(\n                    current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                    current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                    new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        }\n    }\n    \n    entriesRead++;\n    return current.entry;\n}",
    "fixed_function": "public ZipArchiveEntry getNextZipEntry() throws IOException {\n    boolean firstEntry = true;\n    if (closed || hitCentralDirectory) {\n        return null;\n    }\n    if (current != null) {\n        closeEntry();\n        firstEntry = false;\n    }\n\n    try {\n        if (firstEntry) {\n            // split archives have a special signature before the\n            // first local file header - look for it and fail with\n            // the appropriate error message if this is a split\n            // archive.\n            readFirstLocalFileHeader(LFH_BUF);\n        } else {\n            readFully(LFH_BUF);\n        }\n    } catch (final EOFException e) {\n        return null;\n    }\n\n    final ZipLong sig = new ZipLong(LFH_BUF);\n    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n        hitCentralDirectory = true;\n        skipRemainderOfArchive();\n        return null;\n    }\n    if (!sig.equals(ZipLong.LFH_SIG)) {\n        throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n    }\n\n    int off = WORD;\n    current = new CurrentEntry();\n\n    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n    current.entry.setGeneralPurposeBit(gpFlag);\n\n    off += SHORT;\n\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n    off += SHORT;\n\n    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n    current.entry.setTime(time);\n    off += WORD;\n\n    ZipLong size = null, cSize = null;\n    if (!current.hasDataDescriptor) {\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n        off += WORD;\n\n        cSize = new ZipLong(LFH_BUF, off);\n        off += WORD;\n\n        size = new ZipLong(LFH_BUF, off);\n        off += WORD;\n    } else {\n        off += 3 * WORD;\n    }\n\n    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n    off += SHORT;\n\n    final int extraLen = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n\n    final byte[] fileName = new byte[fileNameLen];\n    readFully(fileName);\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n    final byte[] extraData = new byte[extraLen];\n    readFully(extraData);\n    current.entry.setExtra(extraData);\n\n    if (!hasUTF8Flag && useUnicodeExtraFields) {\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n    }\n\n    processZip64Extra(size, cSize);\n\n    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            current.in = new ExplodingInputStream(\n                    current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                    current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                    new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        }\n    }\n    \n    entriesRead++;\n    return current.entry;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
      "first_line": 219,
      "last_line": 324
    },
    "javadoc": "// haven't read anything so far",
    "failing_tests": {
      "org.apache.commons.compress.archivers.ZipTestCase::testListAllFilesWithNestedArchive": {
        "source": "    public void testListAllFilesWithNestedArchive() throws Exception {\n\n        final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n\n\n\n        final List<String> results = new ArrayList<>();\n\n        final List<ZipException> expectedExceptions = new ArrayList<>();\n\n\n\n        final InputStream is = new FileInputStream(input);\n\n        ArchiveInputStream in = null;\n\n        try {\n\n            in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n\n\n\n            ZipArchiveEntry entry = null;\n\n            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n\n                results.add(entry.getName());\n\n\n\n                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n\n                try {\n\n                    ZipArchiveEntry nestedEntry = null;\n\n                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n\n                        results.add(nestedEntry.getName());\n\n                    }\n\n                } catch (ZipException ex) {\n\n                    // expected since you cannot create a final ArchiveInputStream from test3.xml\n\n                    expectedExceptions.add(ex);\n\n                }\n\n                // nested stream must not be closed here\n\n            }\n\n        } finally {\n\n            if (in != null) {\n\n                in.close();\n\n            }\n\n        }\n\n        is.close();\n\n\n\n        assertTrue(results.contains(\"NestedArchiv.zip\"));\n\n        assertTrue(results.contains(\"test1.xml\"));\n\n        assertTrue(results.contains(\"test2.xml\"));\n\n        assertTrue(results.contains(\"test3.xml\"));\n\n        assertEquals(1, expectedExceptions.size());\n\n    }\n"
      },
      "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::testThrowOnInvalidEntry": {
        "source": "    public void testThrowOnInvalidEntry() throws Exception {\n\n        final InputStream is = ZipArchiveInputStreamTest.class\n\n                .getResourceAsStream(\"/invalid-zip.zip\");\n\n        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n\n\n\n        try {\n\n            zip.getNextZipEntry();\n\n            fail(\"IOException expected\");\n\n        } catch (ZipException expected) {\n\n            assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n\n        } finally {\n\n            zip.close();\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-44": {
    "id": "Compress-44",
    "project": "Compress",
    "number": "44",
    "buggy_function": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\n    this.checksum = checksum;\n    this.in = in;\n}",
    "fixed_function": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n    if ( checksum == null ){\n        throw new NullPointerException(\"Parameter checksum must not be null\");\n    }\n\n    if ( in == null ){\n        throw new NullPointerException(\"Parameter in must not be null\");\n    }\n\n    this.checksum = checksum;\n    this.in = in;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java",
      "first_line": 33,
      "last_line": 39
    },
    "javadoc": "/**\n* A stream that calculates the checksum of the data read.\n* @NotThreadSafe\n* @since 1.14\n*/",
    "failing_tests": {
      "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne": {
        "source": "    public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne() {\n\n\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,null);\n\n\n\n\n\n    }\n"
      },
      "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo": {
        "source": "    public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo() {\n\n\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,new ByteArrayInputStream(new byte[1]));\n\n\n\n\n\n    }\n"
      },
      "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree": {
        "source": "    public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree() {\n\n\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(new CRC32(),null);\n\n\n\n    }\n"
      }
    }
  },
  "Compress-45": {
    "id": "Compress-45",
    "project": "Compress",
    "number": "45",
    "buggy_function": "public static int formatLongOctalOrBinaryBytes(\n    final long value, final byte[] buf, final int offset, final int length) {\n\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n    final boolean negative = value < 0;\n    if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n        return formatLongOctalBytes(value, buf, offset, length);\n    }\n\n    if (length < 9) {\n        formatLongBinary(value, buf, offset, length, negative);\n    }\n    formatBigIntegerBinary(value, buf, offset, length, negative);\n\n    buf[offset] = (byte) (negative ? 0xff : 0x80);\n    return offset + length;\n}",
    "fixed_function": "public static int formatLongOctalOrBinaryBytes(\n    final long value, final byte[] buf, final int offset, final int length) {\n\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n    final boolean negative = value < 0;\n    if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n        return formatLongOctalBytes(value, buf, offset, length);\n    }\n\n    if (length < 9) {\n        formatLongBinary(value, buf, offset, length, negative);\n    } else {\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n    }\n\n    buf[offset] = (byte) (negative ? 0xff : 0x80);\n    return offset + length;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 474,
      "last_line": 492
    },
    "javadoc": "/**\n* Write an long integer into a buffer as an octal string if this\n* will fit, or as a binary number otherwise.\n*\n* Uses {@link #formatUnsignedOctalString} to format\n* the value as an octal string with leading zeros.\n* The converted number is followed by a space.\n*\n* @param value The value to write into the buffer.\n* @param buf The destination buffer.\n* @param offset The starting offset into the buffer.\n* @param length The length of the buffer.\n* @return The updated offset.\n* @throws IllegalArgumentException if the value (and trailer)\n* will not fit in the buffer.\n* @since 1.4\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripOctalOrBinary8": {
        "source": "    public void testRoundTripOctalOrBinary8() {\n\n        testRoundTripOctalOrBinary(8);\n\n    }\n"
      }
    }
  },
  "Compress-46": {
    "id": "Compress-46",
    "project": "Compress",
    "number": "46",
    "buggy_function": "private static ZipLong unixTimeToZipLong(long l) {\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n    }\n    return new ZipLong(l);\n}",
    "fixed_function": "private static ZipLong unixTimeToZipLong(long l) {\n    if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n    }\n    return new ZipLong(l);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java",
      "first_line": 528,
      "last_line": 534
    },
    "javadoc": "/**\n* Utility method converts java.util.Date (milliseconds since epoch)\n* into a ZipLong (seconds since epoch).\n* <p/>\n* Also makes sure the converted ZipLong is not too big to fit\n* in 32 unsigned bits.\n*\n* @param d java.util.Date to convert to ZipLong\n* @return ZipLong\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestampTest::testGettersSetters": {
        "source": "    public void testGettersSetters() {\n\n        // X5455 is concerned with time, so let's\n\n        // get a timestamp to play with (Jan 1st, 2000).\n\n        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n\n        cal.set(Calendar.YEAR, 2000);\n\n        cal.set(Calendar.MONTH, Calendar.JANUARY);\n\n        cal.set(Calendar.DATE, 1);\n\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n\n        cal.set(Calendar.MINUTE, 0);\n\n        cal.set(Calendar.SECOND, 0);\n\n        cal.set(Calendar.MILLISECOND, 0);\n\n        final long timeMillis = cal.getTimeInMillis();\n\n        final ZipLong time = new ZipLong(timeMillis / 1000);\n\n\n\n        // set too big\n\n        try {\n\n            // Java time is 1000 x larger (milliseconds).\n\n            xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n\n            fail(\"Time too big for 32 bits!\");\n\n        } catch (final IllegalArgumentException iae) {\n\n            // All is good.\n\n        }\n\n\n\n        // get/set modify time\n\n        xf.setModifyTime(time);\n\n        assertEquals(time, xf.getModifyTime());\n\n        Date xfModifyJavaTime = xf.getModifyJavaTime();\n\n        assertEquals(timeMillis, xfModifyJavaTime.getTime());\n\n        xf.setModifyJavaTime(new Date(timeMillis));\n\n        assertEquals(time, xf.getModifyTime());\n\n        assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n\n        // Make sure milliseconds get zeroed out:\n\n        xf.setModifyJavaTime(new Date(timeMillis + 123));\n\n        assertEquals(time, xf.getModifyTime());\n\n        assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n\n        // Null\n\n        xf.setModifyTime(null);\n\n        assertNull(xf.getModifyJavaTime());\n\n        xf.setModifyJavaTime(null);\n\n        assertNull(xf.getModifyTime());\n\n\n\n        // get/set access time\n\n        xf.setAccessTime(time);\n\n        assertEquals(time, xf.getAccessTime());\n\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n\n        xf.setAccessJavaTime(new Date(timeMillis));\n\n        assertEquals(time, xf.getAccessTime());\n\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n\n        // Make sure milliseconds get zeroed out:\n\n        xf.setAccessJavaTime(new Date(timeMillis + 123));\n\n        assertEquals(time, xf.getAccessTime());\n\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n\n        // Null\n\n        xf.setAccessTime(null);\n\n        assertNull(xf.getAccessJavaTime());\n\n        xf.setAccessJavaTime(null);\n\n        assertNull(xf.getAccessTime());\n\n\n\n        // get/set create time\n\n        xf.setCreateTime(time);\n\n        assertEquals(time, xf.getCreateTime());\n\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n\n        xf.setCreateJavaTime(new Date(timeMillis));\n\n        assertEquals(time, xf.getCreateTime());\n\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n\n        // Make sure milliseconds get zeroed out:\n\n        xf.setCreateJavaTime(new Date(timeMillis + 123));\n\n        assertEquals(time, xf.getCreateTime());\n\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n\n        // Null\n\n        xf.setCreateTime(null);\n\n        assertNull(xf.getCreateJavaTime());\n\n        xf.setCreateJavaTime(null);\n\n        assertNull(xf.getCreateTime());\n\n\n\n\n\n        // initialize for flags\n\n        xf.setModifyTime(time);\n\n        xf.setAccessTime(time);\n\n        xf.setCreateTime(time);\n\n\n\n        // get/set flags: 000\n\n        xf.setFlags((byte) 0);\n\n        assertEquals(0, xf.getFlags());\n\n        assertFalse(xf.isBit0_modifyTimePresent());\n\n        assertFalse(xf.isBit1_accessTimePresent());\n\n        assertFalse(xf.isBit2_createTimePresent());\n\n        // Local length=1, Central length=1 (flags only!)\n\n        assertEquals(1, xf.getLocalFileDataLength().getValue());\n\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n\n\n        // get/set flags: 001\n\n        xf.setFlags((byte) 1);\n\n        assertEquals(1, xf.getFlags());\n\n        assertTrue(xf.isBit0_modifyTimePresent());\n\n        assertFalse(xf.isBit1_accessTimePresent());\n\n        assertFalse(xf.isBit2_createTimePresent());\n\n        // Local length=5, Central length=5 (flags + mod)\n\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n\n\n        // get/set flags: 010\n\n        xf.setFlags((byte) 2);\n\n        assertEquals(2, xf.getFlags());\n\n        assertFalse(xf.isBit0_modifyTimePresent());\n\n        assertTrue(xf.isBit1_accessTimePresent());\n\n        assertFalse(xf.isBit2_createTimePresent());\n\n        // Local length=5, Central length=1\n\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n\n\n        // get/set flags: 100\n\n        xf.setFlags((byte) 4);\n\n        assertEquals(4, xf.getFlags());\n\n        assertFalse(xf.isBit0_modifyTimePresent());\n\n        assertFalse(xf.isBit1_accessTimePresent());\n\n        assertTrue(xf.isBit2_createTimePresent());\n\n        // Local length=5, Central length=1\n\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n\n\n        // get/set flags: 111\n\n        xf.setFlags((byte) 7);\n\n        assertEquals(7, xf.getFlags());\n\n        assertTrue(xf.isBit0_modifyTimePresent());\n\n        assertTrue(xf.isBit1_accessTimePresent());\n\n        assertTrue(xf.isBit2_createTimePresent());\n\n        // Local length=13, Central length=5\n\n        assertEquals(13, xf.getLocalFileDataLength().getValue());\n\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n\n\n        // get/set flags: 11111111\n\n        xf.setFlags((byte) -1);\n\n        assertEquals(-1, xf.getFlags());\n\n        assertTrue(xf.isBit0_modifyTimePresent());\n\n        assertTrue(xf.isBit1_accessTimePresent());\n\n        assertTrue(xf.isBit2_createTimePresent());\n\n        // Local length=13, Central length=5\n\n        assertEquals(13, xf.getLocalFileDataLength().getValue());\n\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n    }\n"
      }
    }
  },
  "Compress-5": {
    "id": "Compress-5",
    "project": "Compress",
    "number": "5",
    "buggy_function": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n\n    // avoid int overflow, check null buffer\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read == 0 && inf.finished()) {\n            return -1;\n        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
    "fixed_function": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n\n    // avoid int overflow, check null buffer\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read == 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (lengthOfLastRead == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
      "first_line": 191,
      "last_line": 246
    },
    "javadoc": "/**\n* @param encoding the encoding to use for file names, use null\n* for the platform's default encoding\n* @param useUnicodeExtraFields whether to use InfoZIP Unicode\n* Extra Fields (if present) to set the file names.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest::testRead7ZipMultiVolumeArchiveForStream": {
        "source": "    public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n\n\t    URISyntaxException {\n\n\t\n\n\tURL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n\n\tFileInputStream archive = new FileInputStream(\n\n\t\tnew File(new URI(zip.toString())));\n\n\tZipArchiveInputStream zi = null;\n\n\ttry {\n\n\t    zi = new ZipArchiveInputStream(archive,null,false);\n\n\t    \n\n\t    // these are the entries that are supposed to be processed\n\n\t    // correctly without any problems\n\n\t    for (int i = 0; i < ENTRIES.length; i++) {\n\n\t\tassertEquals(ENTRIES[i], zi.getNextEntry().getName());\n\n\t    }\n\n\t    \n\n\t    // this is the last entry that is truncated\n\n\t    ArchiveEntry lastEntry = zi.getNextEntry();\n\n\t    assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n\n\t    byte [] buffer = new byte [4096];\n\n\t    \n\n\t    // before the fix, we'd get 0 bytes on this read and all\n\n\t    // subsequent reads thus a client application might enter\n\n\t    // an infinite loop after the fix, we should get an\n\n\t    // exception\n\n\t    try {\n\n                int read = 0;\n\n\t\twhile ((read = zi.read(buffer)) > 0) { }\n\n\t\tfail(\"shouldn't be able to read from truncated entry\");\n\n\t    } catch (IOException e) {\n\n                assertEquals(\"Truncated ZIP file\", e.getMessage());\n\n\t    }\n\n\t    \n\n\t    // and now we get another entry, which should also yield\n\n\t    // an exception\n\n\t    try {\n\n\t\tzi.getNextEntry();\n\n\t\tfail(\"shouldn't be able to read another entry from truncated\"\n\n                     + \" file\");\n\n\t    } catch (IOException e) {\n\n\t\t// this is to be expected\n\n\t    }\n\n\t} finally {\n\n\t    if (zi != null) {\n\n\t\tzi.close();\n\n\t    }\n\n\t}\n\n    }\n"
      }
    }
  },
  "Compress-7": {
    "id": "Compress-7",
    "project": "Compress",
    "number": "7",
    "buggy_function": "public static String parseName(byte[] buffer, final int offset, final int length) {\n    StringBuffer result = new StringBuffer(length);\n    int          end = offset + length;\n\n    for (int i = offset; i < end; ++i) {\n        if (buffer[i] == 0) {\n            break;\n        }\n        result.append((char) buffer[i]);\n    }\n\n    return result.toString();\n}",
    "fixed_function": "public static String parseName(byte[] buffer, final int offset, final int length) {\n    StringBuffer result = new StringBuffer(length);\n    int          end = offset + length;\n\n    for (int i = offset; i < end; ++i) {\n        byte b = buffer[i];\n        if (b == 0) { // Trailing null\n            break;\n        }\n        result.append((char) (b & 0xFF)); // Allow for sign-extension\n    }\n\n    return result.toString();\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 93,
      "last_line": 105
    },
    "javadoc": "/**\n* Parse an entry name from a buffer.\n* Parsing stops when a NUL is found\n* or the buffer length is reached.\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse.\n* @return The entry name.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames": {
        "source": "    public void testRoundTripNames(){\n\n        checkName(\"\");\n\n        checkName(\"The quick brown fox\\n\");\n\n        checkName(\"\\177\");\n\n        // checkName(\"\\0\"); // does not work, because NUL is ignored\n\n        // COMPRESS-114\n\n        checkName(\"0302-0601-3\u00b1\u00b1\u00b1F06\u00b1W220\u00b1ZB\u00b1LALALA\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1CAN\u00b1\u00b1DC\u00b1\u00b1\u00b104\u00b1060302\u00b1MOE.model\");\n\n    }\n"
      }
    }
  },
  "Compress-8": {
    "id": "Compress-8",
    "project": "Compress",
    "number": "8",
    "buggy_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    boolean stillPadding = true;\n    int     end = offset + length;\n    int     start = offset;\n\n    for (int i = start; i < end; i++){\n        final byte currentByte = buffer[i];\n        if (currentByte == 0) {\n            break;\n        }\n\n    // Skip leading spaces\n        if (currentByte == (byte) ' ' || currentByte == '0') {\n            if (stillPadding) {\n               continue;\n        }\n            if (currentByte == (byte) ' ') {\n            break;\n            }\n        }\n\n    // Must have trailing NUL or space\n    // May have additional NUL or space\n\n        stillPadding = false;\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "fixed_function": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i] != 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    // May have additional NUL or space\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java",
      "first_line": 51,
      "last_line": 87
    },
    "javadoc": "/**\n* Parse an octal string from a buffer.\n* Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.\n*\n* The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctalInvalid": {
        "source": "    public void testParseOctalInvalid() throws Exception{\n\n        byte [] buffer;\n\n        buffer=new byte[0]; // empty byte array\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer=new byte[]{0}; // 1-byte array\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer=new byte[]{0,0,' '}; // not all NULs\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - not all NULs\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer=new byte[]{' ',0,0,0}; // not all NULs\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - not all NULs\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - no trailer\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - embedded space\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n\n        try {\n\n            TarUtils.parseOctal(buffer,0, buffer.length);\n\n            fail(\"Expected IllegalArgumentException - embedded NUL\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Csv-1": {
    "id": "Csv-1",
    "project": "Csv",
    "number": "1",
    "buggy_function": "public int read() throws IOException {\n    int current = super.read();\n    if (current == '\\n') {\n        lineCounter++;\n    }\n    lastChar = current;\n    return lastChar;\n}",
    "fixed_function": "public int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n        lineCounter++;\n    }\n    lastChar = current;\n    return lastChar;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
      "first_line": 56,
      "last_line": 63
    },
    "javadoc": "/**\n* Created extended buffered reader using default buffer-size\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVParserTest::testGetLineNumberWithCR": {
        "source": "    public void testGetLineNumberWithCR() throws Exception {\n\n        CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n\n        \n\n        assertEquals(0, parser.getLineNumber());\n\n        assertNotNull(parser.getRecord());\n\n        assertEquals(1, parser.getLineNumber());\n\n        assertNotNull(parser.getRecord());\n\n        assertEquals(2, parser.getLineNumber());\n\n        assertNotNull(parser.getRecord());\n\n        assertEquals(2, parser.getLineNumber());\n\n        assertNull(parser.getRecord());\n\n    }\n"
      }
    }
  },
  "Csv-10": {
    "id": "Csv-10",
    "project": "Csv",
    "number": "10",
    "buggy_function": "public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n    Assertions.notNull(out, \"out\");\n    Assertions.notNull(format, \"format\");\n\n    this.out = out;\n    this.format = format;\n    this.format.validate();\n    // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n    // It seems a pain to have to track whether the header has already been printed or not.\n}",
    "fixed_function": "public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n    Assertions.notNull(out, \"out\");\n    Assertions.notNull(format, \"format\");\n\n    this.out = out;\n    this.format = format;\n    this.format.validate();\n    // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n    // It seems a pain to have to track whether the header has already been printed or not.\n    if (format.getHeader() != null) {\n        this.printRecord((Object[]) format.getHeader());\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
      "first_line": 61,
      "last_line": 70
    },
    "javadoc": "/**\n* Creates a printer that will print values to the given stream following the CSVFormat.\n* <p>\n* Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n* and escaping with a different character) are not supported.\n* </p>\n*\n* @param out\n*        stream to which to print. Must not be null.\n* @param format\n*        the CSV format. Must not be null.\n* @throws IOException\n*         thrown if the optional header cannot be printed.\n* @throws IllegalArgumentException\n*         thrown if the parameters of the format are inconsistent or if either out or format are null.\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVPrinterTest::testHeader": {
        "source": "    public void testHeader() throws IOException {\n\n        final StringWriter sw = new StringWriter();\n\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null)\n\n                .withHeader(\"C1\", \"C2\", \"C3\"));\n\n        printer.printRecord(\"a\", \"b\", \"c\");\n\n        printer.printRecord(\"x\", \"y\", \"z\");\n\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n\n        printer.close();\n\n    }\n"
      }
    }
  },
  "Csv-11": {
    "id": "Csv-11",
    "project": "Csv",
    "number": "11",
    "buggy_function": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}",
    "fixed_function": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "first_line": 359,
      "last_line": 394
    },
    "javadoc": "/**\n* Initializes the name to index mapping if the format defines a header.\n*\n* @return null if the format has no header.\n* @throws IOException if there is a problem reading the header or skipping the first record\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVParserTest::testHeaderMissingWithNull": {
        "source": "    public void testHeaderMissingWithNull() throws Exception {\n\n        final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n\n        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator();\n\n    }\n"
      }
    }
  },
  "Csv-14": {
    "id": "Csv-14",
    "project": "Csv",
    "number": "14",
    "buggy_function": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "fixed_function": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVFormat.java",
      "first_line": 1001,
      "last_line": 1106
    },
    "javadoc": "// the original object is needed so can check for Number",
    "failing_tests": {
      "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1": {
        "source": "    public void testEscapeNull1() throws IOException {\n\n        StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n\n            printer.print(\"\\\\\");\n\n        }\n\n        assertEquals(\"\\\\\", sw.toString());\n\n    }\n"
      },
      "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4": {
        "source": "    public void testEscapeNull4() throws IOException {\n\n        StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n\n            printer.print(\"\\\\\\\\\");\n\n        }\n\n        assertEquals(\"\\\\\\\\\", sw.toString());\n\n    }\n"
      },
      "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5": {
        "source": "    public void testEscapeNull5() throws IOException {\n\n        StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n\n            printer.print(\"\\\\\\\\\");\n\n        }\n\n        assertEquals(\"\\\\\\\\\", sw.toString());\n\n    }\n"
      },
      "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1": {
        "source": "    public void testEscapeBackslash1() throws IOException {\n\n        StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n\n            printer.print(\"\\\\\");\n\n        }\n\n        assertEquals(\"\\\\\", sw.toString());\n\n    }\n"
      },
      "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4": {
        "source": "    public void testEscapeBackslash4() throws IOException {\n\n        StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n\n            printer.print(\"\\\\\\\\\");\n\n        }\n\n        assertEquals(\"\\\\\\\\\", sw.toString());\n\n    }\n"
      },
      "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5": {
        "source": "    public void testEscapeBackslash5() throws IOException {\n\n        StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n\n            printer.print(\"\\\\\\\\\");\n\n        }\n\n        assertEquals(\"\\\\\\\\\", sw.toString());\n\n    }\n"
      }
    }
  },
  "Csv-15": {
    "id": "Csv-15",
    "project": "Csv",
    "number": "15",
    "buggy_function": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "fixed_function": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVFormat.java",
      "first_line": 1151,
      "last_line": 1256
    },
    "javadoc": "// the original object is needed so can check for Number",
    "failing_tests": {
      "org.apache.commons.csv.CSVPrinterTest::testDontQuoteEuroFirstChar": {
        "source": "    public void testDontQuoteEuroFirstChar() throws IOException {\n\n        final StringWriter sw = new StringWriter();\n\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n\n            printer.printRecord(EURO_CH, \"Deux\");\n\n            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n\n        }\n\n    }\n"
      }
    }
  },
  "Csv-2": {
    "id": "Csv-2",
    "project": "Csv",
    "number": "2",
    "buggy_function": "public String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Integer index = mapping.get(name);\n        return index != null ? values[index.intValue()] : null;\n}",
    "fixed_function": "public String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Integer index = mapping.get(name);\n    try {\n        return index != null ? values[index.intValue()] : null;\n    } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IllegalArgumentException(\n                String.format(\n                        \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n                        name, index.intValue(), values.length));\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
      "first_line": 79,
      "last_line": 86
    },
    "javadoc": "/**\n* Returns a value by name.\n*\n* @param name\n*            the name of the column to be retrieved.\n* @return the column value, or {@code null} if the column name is not found\n* @throws IllegalStateException\n*             if no header mapping was provided\n* @throws IllegalArgumentException\n*             if the record is inconsistent\n* @see #isConsistent()\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVRecordTest::testGetStringInconsistentRecord": {
        "source": "    public void testGetStringInconsistentRecord() {\n\n        header.put(\"fourth\", Integer.valueOf(4));\n\n        recordWithHeader.get(\"fourth\");\n\n    }\n"
      }
    }
  },
  "Csv-3": {
    "id": "Csv-3",
    "project": "Csv",
    "number": "3",
    "buggy_function": "int readEscape() throws IOException {\n    // the escape char has just been read (normally a backslash)\n    final int c = in.read();\n    switch (c) {\n    case 'r':\n        return CR;\n    case 'n':\n        return LF;\n    case 't':\n        return TAB;\n    case 'b':\n        return BACKSPACE;\n    case 'f':\n        return FF;\n    case CR:\n    case LF:\n    case FF: // TODO is this correct?\n    case TAB: // TODO is this correct? Do tabs need to be escaped?\n    case BACKSPACE: // TODO is this correct?\n        return c;\n    case END_OF_STREAM:\n        throw new IOException(\"EOF whilst processing escape sequence\");\n    default:\n        // Now check for meta-characters\n            return c;\n        // indicate unexpected char - available from in.getLastChar()\n    }\n}",
    "fixed_function": "int readEscape() throws IOException {\n    // the escape char has just been read (normally a backslash)\n    final int c = in.read();\n    switch (c) {\n    case 'r':\n        return CR;\n    case 'n':\n        return LF;\n    case 't':\n        return TAB;\n    case 'b':\n        return BACKSPACE;\n    case 'f':\n        return FF;\n    case CR:\n    case LF:\n    case FF: // TODO is this correct?\n    case TAB: // TODO is this correct? Do tabs need to be escaped?\n    case BACKSPACE: // TODO is this correct?\n        return c;\n    case END_OF_STREAM:\n        throw new IOException(\"EOF whilst processing escape sequence\");\n    default:\n        // Now check for meta-characters\n        if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {\n            return c;\n        }\n        // indicate unexpected char - available from in.getLastChar()\n        return END_OF_STREAM;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/Lexer.java",
      "first_line": 87,
      "last_line": 114
    },
    "javadoc": "/**\n* Handle an escape sequence.\n* The current character must be the escape character.\n* On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n* on the input stream.\n*\n* @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n* @throws IOException if there is a problem reading the stream or the end of stream is detected:\n* the escape character is not allowed at end of strem\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVLexerTest::testEscapedMySqlNullValue": {
        "source": "    public void testEscapedMySqlNullValue() throws Exception {\n\n        // MySQL uses \\N to symbolize null values. We have to restore this\n\n        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n\n        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n\n    }\n"
      },
      "org.apache.commons.csv.CSVLexerTest::testEscapedCharacter": {
        "source": "    public void testEscapedCharacter() throws Exception {\n\n        final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n\n        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n\n    }\n"
      },
      "org.apache.commons.csv.CSVParserTest::testBackslashEscaping": {
        "source": "    public void testBackslashEscaping() throws IOException {\n\n\n\n        // To avoid confusion over the need for escaping chars in java code,\n\n        // We will test with a forward slash as the escape char, and a single\n\n        // quote as the encapsulator.\n\n\n\n        final String code =\n\n                \"one,two,three\\n\" // 0\n\n                        + \"'',''\\n\"       // 1) empty encapsulators\n\n                        + \"/',/'\\n\"       // 2) single encapsulators\n\n                        + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n\n                        + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n\n                        + \"/,,/,\\n\"       // 5) separator escaped\n\n                        + \"//,//\\n\"       // 6) escape escaped\n\n                        + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n\n                        + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n\n                        + \"9,   /\\n   \\n\"  // escaped newline\n\n                        + \"\";\n\n        final String[][] res = {\n\n                {\"one\", \"two\", \"three\"}, // 0\n\n                {\"\", \"\"},                // 1\n\n                {\"'\", \"'\"},              // 2\n\n                {\"'\", \"'\"},              // 3\n\n                {\"'\", \"'\"},              // 4\n\n                {\",\", \",\"},              // 5\n\n                {\"/\", \"/\"},              // 6\n\n                {\"/\", \"/\"},              // 7\n\n                {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"},\n\n                {\"9\", \"   \\n   \"},\n\n        };\n\n\n\n\n\n        final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\\'').withEscape('/')\n\n                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n\n\n\n        final CSVParser parser = new CSVParser(code, format);\n\n        final List<CSVRecord> records = parser.getRecords();\n\n        assertTrue(records.size() > 0);\n\n\n\n        Utils.compare(\"Records do not match expected result\", res, records);\n\n    }\n"
      }
    }
  },
  "Csv-4": {
    "id": "Csv-4",
    "project": "Csv",
    "number": "4",
    "buggy_function": "public Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(this.headerMap);\n}",
    "fixed_function": "public Map<String, Integer> getHeaderMap() {\n    return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "first_line": 287,
      "last_line": 289
    },
    "javadoc": "/**\n* Returns a copy of the header map that iterates in column order.\n* <p>\n* The map keys are column names. The map values are 0-based indices.\n* </p>\n* @return a copy of the header map that iterates in column order.\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVParserTest::testNoHeaderMap": {
        "source": "    public void testNoHeaderMap() throws Exception {\n\n        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n\n        Assert.assertNull(parser.getHeaderMap());\n\n    }\n"
      }
    }
  },
  "Csv-5": {
    "id": "Csv-5",
    "project": "Csv",
    "number": "5",
    "buggy_function": "public void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n        out.append(recordSeparator);\n    newRecord = true;\n}",
    "fixed_function": "public void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    if (recordSeparator != null) {\n        out.append(recordSeparator);\n    }\n    newRecord = true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
      "first_line": 323,
      "last_line": 327
    },
    "javadoc": "/**\n* Outputs the record separator.\n*\n* @throws IOException\n*             If an I/O error occurs\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVFormatTest::testNullRecordSeparatorCsv106": {
        "source": "    public void testNullRecordSeparatorCsv106() {\n\n        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\", \"H2\");\n\n        final String formatStr = format.format(\"A\", \"B\");\n\n        assertNotNull(formatStr);\n\n        assertFalse(formatStr.endsWith(\"null\"));\n\n    }\n"
      }
    }
  },
  "Csv-6": {
    "id": "Csv-6",
    "project": "Csv",
    "number": "6",
    "buggy_function": "<M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n            map.put(entry.getKey(), values[col]);\n    }\n    return map;\n}",
    "fixed_function": "<M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length) {\n            map.put(entry.getKey(), values[col]);\n        }\n    }\n    return map;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
      "first_line": 179,
      "last_line": 185
    },
    "javadoc": "/**\n* Puts all values of this record into the given Map.\n*\n* @param map The Map to populate.\n* @return the given map.\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVRecordTest::testToMapWithShortRecord": {
        "source": "    public void testToMapWithShortRecord() throws Exception {\n\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n\n       final CSVRecord shortRec = parser.iterator().next();\n\n       shortRec.toMap();\n\n    }\n"
      }
    }
  },
  "Csv-9": {
    "id": "Csv-9",
    "project": "Csv",
    "number": "9",
    "buggy_function": "<M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length) {\n            map.put(entry.getKey(), values[col]);\n        }\n    }\n    return map;\n}",
    "fixed_function": "<M extends Map<String, String>> M putIn(final M map) {\n    if (mapping == null) {\n        return map;\n    }\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length) {\n            map.put(entry.getKey(), values[col]);\n        }\n    }\n    return map;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
      "first_line": 179,
      "last_line": 187
    },
    "javadoc": "/**\n* Puts all values of this record into the given Map.\n*\n* @param map The Map to populate.\n* @return the given map.\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVRecordTest::testToMapWithNoHeader": {
        "source": "    public void testToMapWithNoHeader() throws Exception {\n\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));\n\n       final CSVRecord shortRec = parser.iterator().next();\n\n       Map<String, String> map = shortRec.toMap();\n\n       assertNotNull(\"Map is not null.\", map);\n\n       assertTrue(\"Map is empty.\", map.isEmpty());\n\n    }\n"
      }
    }
  },
  "Gson-11": {
    "id": "Gson-11",
    "project": "Gson",
    "number": "11",
    "buggy_function": "public Number read(JsonReader in) throws IOException {\n  JsonToken jsonToken = in.peek();\n  switch (jsonToken) {\n  case NULL:\n    in.nextNull();\n    return null;\n  case NUMBER:\n    return new LazilyParsedNumber(in.nextString());\n  default:\n    throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n  }\n}",
    "fixed_function": "public Number read(JsonReader in) throws IOException {\n  JsonToken jsonToken = in.peek();\n  switch (jsonToken) {\n  case NULL:\n    in.nextNull();\n    return null;\n  case NUMBER:\n  case STRING:\n    return new LazilyParsedNumber(in.nextString());\n  default:\n    throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n  }\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
      "first_line": 364,
      "last_line": 375
    },
    "javadoc": "/**\n* Writes a boolean as a string. Useful for map keys, where booleans aren't\n* otherwise permitted.\n*/",
    "failing_tests": {
      "com.google.gson.functional.PrimitiveTest::testNumberAsStringDeserialization": {
        "source": "  public void testNumberAsStringDeserialization() {\n\n    Number value = gson.fromJson(\"\\\"18\\\"\", Number.class);\n\n    assertEquals(18, value.intValue());\n\n  }\n"
      }
    }
  },
  "Gson-12": {
    "id": "Gson-12",
    "project": "Gson",
    "number": "12",
    "buggy_function": "@Override public void skipValue() throws IOException {\n  if (peek() == JsonToken.NAME) {\n    nextName();\n    pathNames[stackSize - 2] = \"null\";\n  } else {\n    popStack();\n      pathNames[stackSize - 1] = \"null\";\n  }\n    pathIndices[stackSize - 1]++;\n}",
    "fixed_function": "@Override public void skipValue() throws IOException {\n  if (peek() == JsonToken.NAME) {\n    nextName();\n    pathNames[stackSize - 2] = \"null\";\n  } else {\n    popStack();\n    if (stackSize > 0) {\n      pathNames[stackSize - 1] = \"null\";\n    }\n  }\n  if (stackSize > 0) {\n    pathIndices[stackSize - 1]++;\n  }\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
      "first_line": 256,
      "last_line": 265
    },
    "javadoc": "/**\n* This reader walks the elements of a JsonElement as if it was coming from a\n* character stream.\n*\n* @author Jesse Wilson\n*/\npublic final class JsonTreeReader extends JsonReader {\nprivate static final Reader UNREADABLE_READER = new Reader() {\n@Override public int read(char[] buffer, int offset, int count) throws IOException {\nthrow new AssertionError();\n}\n@Override public void close() throws IOException {\nthrow new AssertionError();\n}\n};\nprivate static final Object SENTINEL_CLOSED = new Object();\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate Object[] stack = new Object[32];\nprivate int stackSize = 0;\n\n/*\n* The path members. It corresponds directly to stack: At indices where the\n* stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n* pathNames contains the name at this scope. Where it contains an array\n* (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n* that array. Otherwise the value is undefined, and we take advantage of that\n* by incrementing pathIndices when doing so isn't useful.\n*/",
    "failing_tests": {
      "com.google.gson.internal.bind.JsonTreeReaderTest::testSkipValue_filledJsonObject": {
        "source": "  public void testSkipValue_filledJsonObject() throws IOException {\n\n    JsonObject jsonObject = new JsonObject();\n\n    JsonArray jsonArray = new JsonArray();\n\n    jsonArray.add('c');\n\n    jsonArray.add(\"text\");\n\n    jsonObject.add(\"a\", jsonArray);\n\n    jsonObject.addProperty(\"b\", true);\n\n    jsonObject.addProperty(\"i\", 1);\n\n    jsonObject.add(\"n\", JsonNull.INSTANCE);\n\n    JsonObject jsonObject2 = new JsonObject();\n\n    jsonObject2.addProperty(\"n\", 2L);\n\n    jsonObject.add(\"o\", jsonObject2);\n\n    jsonObject.addProperty(\"s\", \"text\");\n\n    JsonTreeReader in = new JsonTreeReader(jsonObject);\n\n    in.skipValue();\n\n    assertEquals(JsonToken.END_DOCUMENT, in.peek());\n\n  }\n"
      },
      "com.google.gson.internal.bind.JsonTreeReaderTest::testSkipValue_emptyJsonObject": {
        "source": "  public void testSkipValue_emptyJsonObject() throws IOException {\n\n    JsonTreeReader in = new JsonTreeReader(new JsonObject());\n\n    in.skipValue();\n\n    assertEquals(JsonToken.END_DOCUMENT, in.peek());\n\n  }\n"
      }
    }
  },
  "Gson-13": {
    "id": "Gson-13",
    "project": "Gson",
    "number": "13",
    "buggy_function": "private int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}",
    "fixed_function": "private int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
      "first_line": 641,
      "last_line": 742
    },
    "javadoc": "// We've found the keyword followed either by EOF or by a non-literal character.",
    "failing_tests": {
      "com.google.gson.stream.JsonReaderTest::testNegativeZero": {
        "source": "  public void testNegativeZero() throws Exception {\n\n\t  \tJsonReader reader = new JsonReader(reader(\"[-0]\"));\n\n\t    reader.setLenient(false);\n\n\t    reader.beginArray();\n\n\t    assertEquals(NUMBER, reader.peek());\n\n\t    assertEquals(\"-0\", reader.nextString());\n\n  }\n"
      }
    }
  },
  "Gson-15": {
    "id": "Gson-15",
    "project": "Gson",
    "number": "15",
    "buggy_function": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}",
    "fixed_function": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
      "first_line": 493,
      "last_line": 501
    },
    "javadoc": "/**\n* Encodes {@code value}.\n*\n* @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n*     {@link Double#isInfinite() infinities}.\n* @return this writer.\n*/",
    "failing_tests": {
      "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient": {
        "source": "  public void testNonFiniteDoublesWhenLenient() throws IOException {\n\n    StringWriter stringWriter = new StringWriter();\n\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n\n    jsonWriter.setLenient(true);\n\n    jsonWriter.beginArray();\n\n    jsonWriter.value(Double.NaN);\n\n    jsonWriter.value(Double.NEGATIVE_INFINITY);\n\n    jsonWriter.value(Double.POSITIVE_INFINITY);\n\n    jsonWriter.endArray();\n\n    assertEquals(\"[NaN,-Infinity,Infinity]\", stringWriter.toString());\n\n  }\n"
      }
    }
  },
  "Gson-16": {
    "id": "Gson-16",
    "project": "Gson",
    "number": "16",
    "buggy_function": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                            Collection<TypeVariable> visitedTypeVariables) {\n  // this implementation is made a little more complicated in an attempt to avoid object-creation\n  while (true) {\n    if (toResolve instanceof TypeVariable) {\n      TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        // cannot reduce due to infinite recursion\n      toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n      if (toResolve == typeVariable) {\n        return toResolve;\n      }\n\n    } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n      Class<?> original = (Class<?>) toResolve;\n      Type componentType = original.getComponentType();\n      Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n      return componentType == newComponentType\n          ? original\n          : arrayOf(newComponentType);\n\n    } else if (toResolve instanceof GenericArrayType) {\n      GenericArrayType original = (GenericArrayType) toResolve;\n      Type componentType = original.getGenericComponentType();\n      Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n      return componentType == newComponentType\n          ? original\n          : arrayOf(newComponentType);\n\n    } else if (toResolve instanceof ParameterizedType) {\n      ParameterizedType original = (ParameterizedType) toResolve;\n      Type ownerType = original.getOwnerType();\n      Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n      boolean changed = newOwnerType != ownerType;\n\n      Type[] args = original.getActualTypeArguments();\n      for (int t = 0, length = args.length; t < length; t++) {\n        Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n        if (resolvedTypeArgument != args[t]) {\n          if (!changed) {\n            args = args.clone();\n            changed = true;\n          }\n          args[t] = resolvedTypeArgument;\n        }\n      }\n\n      return changed\n          ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n          : original;\n\n    } else if (toResolve instanceof WildcardType) {\n      WildcardType original = (WildcardType) toResolve;\n      Type[] originalLowerBound = original.getLowerBounds();\n      Type[] originalUpperBound = original.getUpperBounds();\n\n      if (originalLowerBound.length == 1) {\n        Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n        if (lowerBound != originalLowerBound[0]) {\n          return supertypeOf(lowerBound);\n        }\n      } else if (originalUpperBound.length == 1) {\n        Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n        if (upperBound != originalUpperBound[0]) {\n          return subtypeOf(upperBound);\n        }\n      }\n      return original;\n\n    } else {\n      return toResolve;\n    }\n  }\n}",
    "fixed_function": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                            Collection<TypeVariable> visitedTypeVariables) {\n  // this implementation is made a little more complicated in an attempt to avoid object-creation\n  while (true) {\n    if (toResolve instanceof TypeVariable) {\n      TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n      if (visitedTypeVariables.contains(typeVariable)) {\n        // cannot reduce due to infinite recursion\n        return toResolve;\n      } else {\n        visitedTypeVariables.add(typeVariable);\n      }\n      toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n      if (toResolve == typeVariable) {\n        return toResolve;\n      }\n\n    } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n      Class<?> original = (Class<?>) toResolve;\n      Type componentType = original.getComponentType();\n      Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n      return componentType == newComponentType\n          ? original\n          : arrayOf(newComponentType);\n\n    } else if (toResolve instanceof GenericArrayType) {\n      GenericArrayType original = (GenericArrayType) toResolve;\n      Type componentType = original.getGenericComponentType();\n      Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n      return componentType == newComponentType\n          ? original\n          : arrayOf(newComponentType);\n\n    } else if (toResolve instanceof ParameterizedType) {\n      ParameterizedType original = (ParameterizedType) toResolve;\n      Type ownerType = original.getOwnerType();\n      Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n      boolean changed = newOwnerType != ownerType;\n\n      Type[] args = original.getActualTypeArguments();\n      for (int t = 0, length = args.length; t < length; t++) {\n        Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n        if (resolvedTypeArgument != args[t]) {\n          if (!changed) {\n            args = args.clone();\n            changed = true;\n          }\n          args[t] = resolvedTypeArgument;\n        }\n      }\n\n      return changed\n          ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n          : original;\n\n    } else if (toResolve instanceof WildcardType) {\n      WildcardType original = (WildcardType) toResolve;\n      Type[] originalLowerBound = original.getLowerBounds();\n      Type[] originalUpperBound = original.getUpperBounds();\n\n      if (originalLowerBound.length == 1) {\n        Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n        if (lowerBound != originalLowerBound[0]) {\n          return supertypeOf(lowerBound);\n        }\n      } else if (originalUpperBound.length == 1) {\n        Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n        if (upperBound != originalUpperBound[0]) {\n          return subtypeOf(upperBound);\n        }\n      }\n      return original;\n\n    } else {\n      return toResolve;\n    }\n  }\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/$Gson$Types.java",
      "first_line": 336,
      "last_line": 408
    },
    "javadoc": "// TODO: strip wildcards?",
    "failing_tests": {
      "com.google.gson.internal.bind.RecursiveTypesResolveTest::testRecursiveTypeVariablesResolve12": {
        "source": "  public void testRecursiveTypeVariablesResolve12() throws Exception {\n\n    TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);\n\n    assertNotNull(adapter);\n\n  }\n"
      },
      "com.google.gson.internal.bind.RecursiveTypesResolveTest::testRecursiveTypeVariablesResolve1": {
        "source": "  public void testRecursiveTypeVariablesResolve1() throws Exception {\n\n    TypeAdapter<TestType> adapter = new Gson().getAdapter(TestType.class);\n\n    assertNotNull(adapter);\n\n  }\n"
      }
    }
  },
  "Gson-17": {
    "id": "Gson-17",
    "project": "Gson",
    "number": "17",
    "buggy_function": "public Date read(JsonReader in) throws IOException {\n  if (in.peek() != JsonToken.STRING) {\n    throw new JsonParseException(\"The date should be a string value\");\n  }\n  Date date = deserializeToDate(in.nextString());\n  if (dateType == Date.class) {\n    return date;\n  } else if (dateType == Timestamp.class) {\n    return new Timestamp(date.getTime());\n  } else if (dateType == java.sql.Date.class) {\n    return new java.sql.Date(date.getTime());\n  } else {\n    // This must never happen: dateType is guarded in the primary constructor\n    throw new AssertionError();\n  }\n}",
    "fixed_function": "public Date read(JsonReader in) throws IOException {\n  if (in.peek() == JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  Date date = deserializeToDate(in.nextString());\n  if (dateType == Date.class) {\n    return date;\n  } else if (dateType == Timestamp.class) {\n    return new Timestamp(date.getTime());\n  } else if (dateType == java.sql.Date.class) {\n    return new java.sql.Date(date.getTime());\n  } else {\n    // This must never happen: dateType is guarded in the primary constructor\n    throw new AssertionError();\n  }\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
      "first_line": 98,
      "last_line": 113
    },
    "javadoc": "// See issue 162",
    "failing_tests": {
      "com.google.gson.DefaultDateTypeAdapterTest::testUnexpectedToken": {
        "source": "  public void testUnexpectedToken() throws Exception {\n\n    try {\n\n      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n\n      adapter.fromJson(\"{}\");\n\n      fail(\"Unexpected token should fail.\");\n\n    } catch (IllegalStateException expected) { }\n\n  }\n"
      },
      "com.google.gson.DefaultDateTypeAdapterTest::testNullValue": {
        "source": "  public void testNullValue() throws Exception {\n\n    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n\n    assertNull(adapter.fromJson(\"null\"));\n\n    assertEquals(\"null\", adapter.toJson(null));\n\n  }\n"
      }
    }
  },
  "Gson-18": {
    "id": "Gson-18",
    "project": "Gson",
    "number": "18",
    "buggy_function": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n  checkArgument(supertype.isAssignableFrom(contextRawType));\n  return resolve(context, contextRawType,\n      $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}",
    "fixed_function": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n  if (context instanceof WildcardType) {\n    // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n    context = ((WildcardType)context).getUpperBounds()[0];\n  }\n  checkArgument(supertype.isAssignableFrom(contextRawType));\n  return resolve(context, contextRawType,\n      $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/$Gson$Types.java",
      "first_line": 277,
      "last_line": 282
    },
    "javadoc": "/**\n* Returns the generic form of {@code supertype}. For example, if this is {@code\n* ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n* Iterable.class}.\n*\n* @param supertype a superclass of, or interface implemented by, this.\n*/",
    "failing_tests": {
      "com.google.gson.functional.CollectionTest::testIssue1107": {
        "source": "  public void testIssue1107() {\n\n    String json = \"{\\n\" +\n\n            \"  \\\"inBig\\\": {\\n\" +\n\n            \"    \\\"key\\\": [\\n\" +\n\n            \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n\n            \"    ]\\n\" +\n\n            \"  }\\n\" +\n\n            \"}\";\n\n    BigClass bigClass = new Gson().fromJson(json, BigClass.class);\n\n    SmallClass small = bigClass.inBig.get(\"key\").get(0);\n\n    assertNotNull(small);\n\n    assertEquals(\"hello\", small.inSmall);\n\n  }\n"
      }
    }
  },
  "Gson-5": {
    "id": "Gson-5",
    "project": "Gson",
    "number": "5",
    "buggy_function": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                  //String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}",
    "fixed_function": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                  //String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
      "first_line": 123,
      "last_line": 276
    },
    "javadoc": "/**\n* Parse a date from ISO-8601 formatted string. It expects a format\n* [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n*\n* @param date ISO string to parse in the appropriate format.\n* @param pos The position to start parsing from, updated to where parsing stopped.\n* @return the parsed date\n* @throws ParseException if the date is not in the appropriate format\n*/",
    "failing_tests": {
      "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601": {
        "source": "  public void testDateDeserializationISO8601() throws Exception {\n\n  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n\n    assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n\n    assertParsed(\"1970-01-01T00:00Z\", adapter);\n\n    assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n\n    assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n\n    assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n\n  }\n"
      }
    }
  },
  "Gson-6": {
    "id": "Gson-6",
    "project": "Gson",
    "number": "6",
    "buggy_function": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n    TypeToken<?> fieldType, JsonAdapter annotation) {\n  Class<?> value = annotation.value();\n  TypeAdapter<?> typeAdapter;\n  if (TypeAdapter.class.isAssignableFrom(value)) {\n    Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n    typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n  } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n    Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n    typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n        .construct()\n        .create(gson, fieldType);\n  } else {\n    throw new IllegalArgumentException(\n        \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n  }\n    typeAdapter = typeAdapter.nullSafe();\n  return typeAdapter;\n}",
    "fixed_function": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n    TypeToken<?> fieldType, JsonAdapter annotation) {\n  Class<?> value = annotation.value();\n  TypeAdapter<?> typeAdapter;\n  if (TypeAdapter.class.isAssignableFrom(value)) {\n    Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n    typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n  } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n    Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n    typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n        .construct()\n        .create(gson, fieldType);\n  } else {\n    throw new IllegalArgumentException(\n        \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n  }\n  if (typeAdapter != null) {\n    typeAdapter = typeAdapter.nullSafe();\n  }\n  return typeAdapter;\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
      "first_line": 51,
      "last_line": 69
    },
    "javadoc": "/**\n* Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the\n* specified class as the default type adapter.\n*\n* @since 2.3\n*/",
    "failing_tests": {
      "com.google.gson.regression.JsonAdapterNullSafeTest::testNullSafeBugDeserialize": {
        "source": "  public void testNullSafeBugDeserialize() throws Exception {\n\n    Device device = gson.fromJson(\"{'id':'ec57803e2'}\", Device.class);\n\n    assertEquals(\"ec57803e2\", device.id);\n\n  }\n"
      },
      "com.google.gson.regression.JsonAdapterNullSafeTest::testNullSafeBugSerialize": {
        "source": "  public void testNullSafeBugSerialize() throws Exception {\n\n    Device device = new Device(\"ec57803e\");\n\n    gson.toJson(device);\n\n  }\n"
      }
    }
  },
  "JacksonCore-11": {
    "id": "JacksonCore-11",
    "project": "JacksonCore",
    "number": "11",
    "buggy_function": "private void _verifySharing()\n{\n    if (_hashShared) {\n        _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n        _names = Arrays.copyOf(_names, _names.length);\n        _hashShared = false;\n        // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n        //    we rehash as needed, as need-rehash flag is not copied from parent\n    }\n    if (_needRehash) {\n        rehash();\n    }\n}",
    "fixed_function": "private void _verifySharing()\n{\n    if (_hashShared) {\n        _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n        _names = Arrays.copyOf(_names, _names.length);\n        _hashShared = false;\n        // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n        //    we rehash as needed, as need-rehash flag is not copied from parent\n        _verifyNeedForRehash();\n    }\n    if (_needRehash) {\n        rehash();\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java",
      "first_line": 874,
      "last_line": 886
    },
    "javadoc": "// Yes if above 80%, or above 50% AND have ~1% spill-overs",
    "failing_tests": {
      "com.fasterxml.jackson.core.sym.SymbolsViaParserTest::testSymbolTableExpansionBytes": {
        "source": "    public void testSymbolTableExpansionBytes() throws Exception {\n\n        _testSymbolTableExpansion(true);\n\n    }\n"
      }
    }
  },
  "JacksonCore-15": {
    "id": "JacksonCore-15",
    "project": "JacksonCore",
    "number": "15",
    "buggy_function": "    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \t\t//if not scalar and ended successfully, then return null\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }",
    "fixed_function": "    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \tif(!_allowMultipleMatches && _currToken != null && _exposedContext == null){\n    \t\t//if not scalar and ended successfully, then return null\n    \t\tif((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n    \t\telse if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath \n    \t\t\t\t&& _itemFilter == TokenFilter.INCLUDE_ALL) {\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t}\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
      "first_line": 222,
      "last_line": 433
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testNotAllowMultipleMatches": {
        "source": "    public void testNotAllowMultipleMatches() throws Exception\n\n    {\n\n    \tString jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'value':4,'b':true}\");\n\n        JsonParser p0 = JSON_F.createParser(jsonString);\n\n        JsonParser p = new FilteringParserDelegate(p0,\n\n               new NameMatchFilter(\"value\"),\n\n                   false, // includePath\n\n                   false // multipleMatches -false\n\n                );\n\n        String result = readAndWrite(JSON_F, p);\n\n        assertEquals(aposToQuotes(\"3\"), result);\n\n    }\n"
      }
    }
  },
  "JacksonCore-20": {
    "id": "JacksonCore-20",
    "project": "JacksonCore",
    "number": "20",
    "buggy_function": "public void writeEmbeddedObject(Object object) throws IOException {\n    // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n    throw new JsonGenerationException(\"No native support for writing embedded objects\",\n            this);\n}",
    "fixed_function": "public void writeEmbeddedObject(Object object) throws IOException {\n    // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n    if (object == null) {\n        writeNull();\n        return;\n    }\n    if (object instanceof byte[]) {\n        writeBinary((byte[]) object);\n        return;\n    }\n    throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n            +object.getClass().getName(),\n            this);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/JsonGenerator.java",
      "first_line": 1328,
      "last_line": 1332
    },
    "javadoc": "/**\n* Method that can be called on backends that support passing opaque datatypes of\n* non-JSON formats\n*\n* @since 2.8\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject": {
        "source": "    public void testBinaryAsEmbeddedObject() throws Exception\n\n    {\n\n        JsonGenerator g;\n\n\n\n        StringWriter sw = new StringWriter();\n\n        g = JSON_F.createGenerator(sw);\n\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n\n        g.close();\n\n        assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), sw.toString());\n\n\n\n        ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n\n        g = JSON_F.createGenerator(bytes);\n\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n\n        g.close();\n\n        assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), bytes.toString(\"UTF-8\"));\n\n    }\n"
      },
      "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded": {
        "source": "    public void testAsEmbedded() throws Exception\n\n    {\n\n        JsonGenerator g;\n\n\n\n        StringWriter sw = new StringWriter();\n\n        g = JSON_F.createGenerator(sw);\n\n        g.writeEmbeddedObject(null);\n\n        g.close();\n\n        assertEquals(\"null\", sw.toString());\n\n\n\n        ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n\n        g = JSON_F.createGenerator(bytes);\n\n        g.writeEmbeddedObject(null);\n\n        g.close();\n\n        assertEquals(\"null\", bytes.toString(\"UTF-8\"));\n\n\n\n        // also, for fun, try illegal unknown thingy\n\n\n\n        try {\n\n            g = JSON_F.createGenerator(bytes);\n\n            // try writing a Class object\n\n            g.writeEmbeddedObject(getClass());\n\n            fail(\"Expected an exception\");\n\n            g.close(); // never gets here\n\n        } catch (JsonGenerationException e) {\n\n            verifyException(e, \"No native support for\");\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonCore-21": {
    "id": "JacksonCore-21",
    "project": "JacksonCore",
    "number": "21",
    "buggy_function": "    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }",
    "fixed_function": "    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n            if (!_includePath) {\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n                }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
      "first_line": 227,
      "last_line": 454
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testTokensSingleMatchWithPath": {
        "source": "    public void testTokensSingleMatchWithPath() throws Exception\n\n    {\n\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n\n        JsonParser p = new FilteringParserDelegate(p0,\n\n               new NameMatchFilter(\"value\"),\n\n                   true, // includePath\n\n                   false // multipleMatches\n\n                );\n\n\n\n        assertFalse(p.hasCurrentToken());\n\n        assertNull(p.getCurrentToken());\n\n        assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());\n\n        assertFalse(p.isExpectedStartObjectToken());\n\n        assertFalse(p.isExpectedStartArrayToken());\n\n        \n\n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n\n//      String result = readAndWrite(JSON_F, p);\n\n//      assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());\n\n        assertTrue(p.isExpectedStartObjectToken());\n\n        assertFalse(p.isExpectedStartArrayToken());\n\n\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());\n\n        assertEquals(\"ob\", p.getCurrentName());\n\n//        assertEquals(\"ob\", p.getText());\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(\"ob\", p.getCurrentName());\n\n\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"value\", p.getCurrentName());\n\n        assertEquals(\"value\", p.getText());\n\n\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());\n\n        assertEquals(NumberType.INT, p.getNumberType());\n\n        assertEquals(3, p.getIntValue());\n\n        assertEquals(\"value\", p.getCurrentName());\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n\n\n        p.clearCurrentToken();\n\n        assertNull(p.getCurrentToken());\n\n        \n\n        p.close();\n\n    }\n"
      },
      "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testBasicSingleMatchFilteringWithPath": {
        "source": "    public void testBasicSingleMatchFilteringWithPath() throws Exception\n\n    {\n\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n\n        JsonParser p = new FilteringParserDelegate(p0,\n\n               new NameMatchFilter(\"value\"),\n\n                   true, // includePath\n\n                   false // multipleMatches\n\n                );\n\n\n\n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n\n        String result = readAndWrite(JSON_F, p);\n\n        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n    }\n"
      },
      "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testSkippingForSingleWithPath": {
        "source": "    public void testSkippingForSingleWithPath() throws Exception\n\n    {\n\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n\n        JsonParser p = new FilteringParserDelegate(p0,\n\n               new NameMatchFilter(\"value\"),\n\n                   true, // includePath\n\n                   false // multipleMatches\n\n                );\n\n\n\n//        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        p.skipChildren();\n\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        assertNull(p.nextToken());\n\n    }\n"
      }
    }
  },
  "JacksonCore-23": {
    "id": "JacksonCore-23",
    "project": "JacksonCore",
    "number": "23",
    "buggy_function": "public DefaultPrettyPrinter createInstance() {\n    return new DefaultPrettyPrinter(this);\n}",
    "fixed_function": "public DefaultPrettyPrinter createInstance() {\n    if (getClass() != DefaultPrettyPrinter.class) { // since 2.10\n        throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName()\n                +\" does not override method; it has to\");\n    }\n    return new DefaultPrettyPrinter(this);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java",
      "first_line": 254,
      "last_line": 256
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.util.TestDefaultPrettyPrinter::testInvalidSubClass": {
        "source": "    public void testInvalidSubClass() throws Exception\n\n    {\n\n        DefaultPrettyPrinter pp = new MyPrettyPrinter();\n\n        try {\n\n            pp.createInstance();\n\n            fail(\"Should not pass\");\n\n        } catch (IllegalStateException e) {\n\n            verifyException(e, \"does not override\");\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonCore-25": {
    "id": "JacksonCore-25",
    "project": "JacksonCore",
    "number": "25",
    "buggy_function": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}",
    "fixed_function": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
      "first_line": 1948,
      "last_line": 1990
    },
    "javadoc": "// Ok, let's add char to output:",
    "failing_tests": {
      "com.fasterxml.jackson.core.read.NonStandardUnquotedNamesTest::testUnquotedIssue510": {
        "source": "    public void testUnquotedIssue510() throws Exception\n\n    {\n\n        // NOTE! Requires longer input buffer to trigger longer codepath\n\n        char[] fullChars = new char[4001];\n\n        for (int i = 0; i < 3998; i++) {\n\n             fullChars[i] = ' ';\n\n        }\n\n        fullChars[3998] = '{';\n\n        fullChars[3999] = 'a';\n\n        fullChars[4000] = 256;\n\n\n\n        JsonParser p = UNQUOTED_FIELDS_F.createParser(new java.io.StringReader(new String(fullChars)));\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        try {\n\n            p.nextToken();\n\n            fail(\"Should not pass\");\n\n        } catch (JsonParseException e) {\n\n            ; // should fail here\n\n        }\n\n        p.close();\n\n    }\n\n\n\n    /*\n\n    /****************************************************************\n\n    /* Secondary test methods\n\n    /****************************************************************\n\n     */\n\n    \n\n    private void _testLargeUnquoted(int mode) throws Exception\n\n    {\n\n        StringBuilder sb = new StringBuilder(5000);\n\n        sb.append(\"[\\n\");\n\n        //final int REPS = 2000;\n\n        final int REPS = 1050;\n\n        for (int i = 0; i < REPS; ++i) {\n\n            if (i > 0) {\n\n                sb.append(',');\n\n                if ((i & 7) == 0) {\n\n                    sb.append('\\n');\n\n                }\n\n            }\n\n            sb.append(\"{\");\n\n            sb.append(\"abc\").append(i&127).append(':');\n\n            sb.append((i & 1) != 0);\n\n            sb.append(\"}\\n\");\n\n        }\n\n        sb.append(\"]\");\n\n        String JSON = sb.toString();\n\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n        assertToken(JsonToken.START_ARRAY, p.nextToken());\n\n        for (int i = 0; i < REPS; ++i) {\n\n            assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n            assertEquals(\"abc\"+(i&127), p.getCurrentName());\n\n            assertToken(((i&1) != 0) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, p.nextToken());\n\n            assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        }\n\n        assertToken(JsonToken.END_ARRAY, p.nextToken());\n\n        p.close();\n\n    }\n\n\n\n    private void _testSimpleUnquoted(int mode) throws Exception\n\n    {\n\n        String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"a\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"_foo\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"$\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n\n        assertEquals(\"money!\", p.getText());\n\n\n\n        // and then regular quoted one should still work too:\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\" \", p.getCurrentName());\n\n\n\n        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n\n\n\n        // Another thing, as per [Issue#102]: numbers\n\n\n\n        JSON = \"{ 123:true,4:false }\";\n\n        p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"123\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n\n\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"4\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_FALSE, p.nextToken());\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n\n    }\n\n}\n"
      }
    }
  },
  "JacksonCore-26": {
    "id": "JacksonCore-26",
    "project": "JacksonCore",
    "number": "26",
    "buggy_function": "public void feedInput(byte[] buf, int start, int end) throws IOException\n{\n    // Must not have remaining input\n    if (_inputPtr < _inputEnd) {\n        _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n    }\n    if (end < start) {\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n    }\n    // and shouldn't have been marked as end-of-input\n    if (_endOfInput) {\n        _reportError(\"Already closed, can not feed more input\");\n    }\n    // Time to update pointers first\n    _currInputProcessed += _origBufferLen;\n\n    // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n    _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n    // And then update buffer settings\n    _inputBuffer = buf;\n    _inputPtr = start;\n    _inputEnd = end;\n    _origBufferLen = end - start;\n}",
    "fixed_function": "public void feedInput(byte[] buf, int start, int end) throws IOException\n{\n    // Must not have remaining input\n    if (_inputPtr < _inputEnd) {\n        _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n    }\n    if (end < start) {\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n    }\n    // and shouldn't have been marked as end-of-input\n    if (_endOfInput) {\n        _reportError(\"Already closed, can not feed more input\");\n    }\n    // Time to update pointers first\n    _currInputProcessed += _origBufferLen;\n\n    // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n    _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n    // And then update buffer settings\n    _currBufferStart = start;\n    _inputBuffer = buf;\n    _inputPtr = start;\n    _inputEnd = end;\n    _origBufferLen = end - start;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java",
      "first_line": 88,
      "last_line": 112
    },
    "javadoc": "/**********************************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.json.async.AsyncLocationTest::testLocationOffsets": {
        "source": "    public void testLocationOffsets() throws Exception\n\n    {\n\n        JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser();\n\n        ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\n\n\n\n        byte[] input = utf8Bytes(\"[[[\");\n\n\n\n        feeder.feedInput(input, 2, 3);\n\n        assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n\n        assertEquals(1, parser.getCurrentLocation().getByteOffset());\n\n        assertEquals(1, parser.getTokenLocation().getByteOffset());\n\n        assertEquals(1, parser.getCurrentLocation().getLineNr());\n\n        assertEquals(1, parser.getTokenLocation().getLineNr());\n\n        assertEquals(2, parser.getCurrentLocation().getColumnNr());\n\n        assertEquals(1, parser.getTokenLocation().getColumnNr());\n\n\n\n        feeder.feedInput(input, 0, 1);\n\n        assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n\n        assertEquals(2, parser.getCurrentLocation().getByteOffset());\n\n        assertEquals(2, parser.getTokenLocation().getByteOffset());\n\n        assertEquals(1, parser.getCurrentLocation().getLineNr());\n\n        assertEquals(1, parser.getTokenLocation().getLineNr());\n\n        assertEquals(3, parser.getCurrentLocation().getColumnNr());\n\n        assertEquals(2, parser.getTokenLocation().getColumnNr());\n\n        parser.close();\n\n    }\n"
      }
    }
  },
  "JacksonCore-3": {
    "id": "JacksonCore-3",
    "project": "JacksonCore",
    "number": "3",
    "buggy_function": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n        ObjectCodec codec, BytesToNameCanonicalizer sym,\n        byte[] inputBuffer, int start, int end,\n        boolean bufferRecyclable)\n{\n    super(ctxt, features);\n    _inputStream = in;\n    _objectCodec = codec;\n    _symbols = sym;\n    _inputBuffer = inputBuffer;\n    _inputPtr = start;\n    _inputEnd = end;\n    // If we have offset, need to omit that from byte offset, so:\n    _bufferRecyclable = bufferRecyclable;\n}",
    "fixed_function": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n        ObjectCodec codec, BytesToNameCanonicalizer sym,\n        byte[] inputBuffer, int start, int end,\n        boolean bufferRecyclable)\n{\n    super(ctxt, features);\n    _inputStream = in;\n    _objectCodec = codec;\n    _symbols = sym;\n    _inputBuffer = inputBuffer;\n    _inputPtr = start;\n    _inputEnd = end;\n    _currInputRowStart = start;\n    // If we have offset, need to omit that from byte offset, so:\n    _currInputProcessed = -start;\n    _bufferRecyclable = bufferRecyclable;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
      "first_line": 113,
      "last_line": 127
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.json.TestLocation::testOffsetWithInputOffset": {
        "source": "    public void testOffsetWithInputOffset() throws Exception\n\n    {\n\n        final JsonFactory f = new JsonFactory();\n\n        JsonLocation loc;\n\n        JsonParser p;\n\n        // 3 spaces before, 2 after, just for padding\n\n        byte[] b = \"   { }  \".getBytes(\"UTF-8\");\n\n\n\n        // and then peel them off\n\n        p = f.createParser(b, 3, b.length-5);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n\n\n        loc = p.getTokenLocation();\n\n        assertEquals(0L, loc.getByteOffset());\n\n        assertEquals(-1L, loc.getCharOffset());\n\n        assertEquals(1, loc.getLineNr());\n\n        assertEquals(1, loc.getColumnNr());\n\n        \n\n        loc = p.getCurrentLocation();\n\n        assertEquals(1L, loc.getByteOffset());\n\n        assertEquals(-1L, loc.getCharOffset());\n\n        assertEquals(1, loc.getLineNr());\n\n        assertEquals(2, loc.getColumnNr());\n\n\n\n        p.close();\n\n    }\n"
      }
    }
  },
  "JacksonCore-4": {
    "id": "JacksonCore-4",
    "project": "JacksonCore",
    "number": "4",
    "buggy_function": "public char[] expandCurrentSegment()\n{\n    final char[] curr = _currentSegment;\n    // Let's grow by 50% by default\n    final int len = curr.length;\n    // but above intended maximum, slow to increase by 25%\n    int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n    return (_currentSegment = Arrays.copyOf(curr, newLen));\n}",
    "fixed_function": "public char[] expandCurrentSegment()\n{\n    final char[] curr = _currentSegment;\n    // Let's grow by 50% by default\n    final int len = curr.length;\n    int newLen = len + (len >> 1);\n    // but above intended maximum, slow to increase by 25%\n    if (newLen > MAX_SEGMENT_LEN) {\n        newLen = len + (len >> 2);\n    }\n    return (_currentSegment = Arrays.copyOf(curr, newLen));\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java",
      "first_line": 580,
      "last_line": 588
    },
    "javadoc": "/**\n* Method called to expand size of the current segment, to\n* accommodate for more contiguous content. Usually only\n* used when parsing tokens like names if even then.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.util.TestTextBuffer::testExpand": {
        "source": "      public void testExpand()\n\n      {\n\n          TextBuffer tb = new TextBuffer(new BufferRecycler());\n\n          char[] buf = tb.getCurrentSegment();\n\n\n\n          while (buf.length < 500 * 1000) {\n\n              char[] old = buf;\n\n              buf = tb.expandCurrentSegment();\n\n              if (old.length >= buf.length) {\n\n                  fail(\"Expected buffer of \"+old.length+\" to expand, did not, length now \"+buf.length);\n\n              }\n\n          }\n\n      }\n"
      }
    }
  },
  "JacksonCore-5": {
    "id": "JacksonCore-5",
    "project": "JacksonCore",
    "number": "5",
    "buggy_function": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i++);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
    "fixed_function": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
      "first_line": 185,
      "last_line": 205
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.TestJsonPointer::testWonkyNumber173": {
        "source": "    public void testWonkyNumber173() throws Exception\n\n    {\n\n        JsonPointer ptr = JsonPointer.compile(\"/1e0\");\n\n        assertFalse(ptr.matches());\n\n    }\n"
      }
    }
  },
  "JacksonCore-6": {
    "id": "JacksonCore-6",
    "project": "JacksonCore",
    "number": "6",
    "buggy_function": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [core#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    // [core#176]: no leading zeroes allowed\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
    "fixed_function": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [core#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    // [core#176]: no leading zeroes allowed\n    char c = str.charAt(0);\n    if (c <= '0') {\n        return (len == 1 && c == '0') ? 0 : -1;\n    }\n    if (c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
      "first_line": 185,
      "last_line": 206
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.TestJsonPointer::testIZeroIndex": {
        "source": "    public void testIZeroIndex() throws Exception\n\n    {\n\n        JsonPointer ptr = JsonPointer.compile(\"/0\");\n\n        assertEquals(0, ptr.getMatchingIndex());\n\n        ptr = JsonPointer.compile(\"/00\");\n\n        assertEquals(-1, ptr.getMatchingIndex());\n\n    }\n"
      }
    }
  },
  "JacksonCore-7": {
    "id": "JacksonCore-7",
    "project": "JacksonCore",
    "number": "7",
    "buggy_function": "public int writeValue() {\n    // Most likely, object:\n    if (_type == TYPE_OBJECT) {\n        _gotName = false;\n        ++_index;\n        return STATUS_OK_AFTER_COLON;\n    }\n\n    // Ok, array?\n    if (_type == TYPE_ARRAY) {\n        int ix = _index;\n        ++_index;\n        return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n    }\n    \n    // Nope, root context\n    // No commas within root context, but need space\n    ++_index;\n    return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n}",
    "fixed_function": "public int writeValue() {\n    // Most likely, object:\n    if (_type == TYPE_OBJECT) {\n        if (!_gotName) {\n            return STATUS_EXPECT_NAME;\n        }\n        _gotName = false;\n        ++_index;\n        return STATUS_OK_AFTER_COLON;\n    }\n\n    // Ok, array?\n    if (_type == TYPE_ARRAY) {\n        int ix = _index;\n        ++_index;\n        return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n    }\n    \n    // Nope, root context\n    // No commas within root context, but need space\n    ++_index;\n    return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java",
      "first_line": 166,
      "last_line": 185
    },
    "javadoc": "/**\n* Method that writer is to call before it writes a field name.\n*\n* @return Index of the field entry (0-based)\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.core.json.GeneratorFailTest::testFailOnWritingStringNotFieldNameBytes": {
        "source": "    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n\n        _testFailOnWritingStringNotFieldName(F, false);\n\n    }\n"
      },
      "com.fasterxml.jackson.core.json.GeneratorFailTest::testFailOnWritingStringNotFieldNameChars": {
        "source": "    public void testFailOnWritingStringNotFieldNameChars() throws Exception {\n\n        _testFailOnWritingStringNotFieldName(F, true);        \n\n    }\n"
      }
    }
  },
  "JacksonCore-8": {
    "id": "JacksonCore-8",
    "project": "JacksonCore",
    "number": "8",
    "buggy_function": "public char[] getTextBuffer()\n{\n    // Are we just using shared input buffer?\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments)  return _currentSegment;\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}",
    "fixed_function": "public char[] getTextBuffer()\n{\n    // Are we just using shared input buffer?\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java",
      "first_line": 298,
      "last_line": 310
    },
    "javadoc": "// not if we have String as value",
    "failing_tests": {
      "com.fasterxml.jackson.core.util.TestTextBuffer::testEmpty": {
        "source": "    public void testEmpty() {\n\n        TextBuffer tb = new TextBuffer(new BufferRecycler());\n\n        tb.resetWithEmpty();\n\n\n\n        assertTrue(tb.getTextBuffer().length == 0);\n\n        tb.contentsAsString();\n\n        assertTrue(tb.getTextBuffer().length == 0);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-1": {
    "id": "JacksonDatabind-1",
    "project": "JacksonDatabind",
    "number": "1",
    "buggy_function": "public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n    throws Exception\n{\n    Object value = get(bean);\n    if (value == null) { // nulls need specialized handling\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, jgen, prov);\n        } else { // can NOT suppress entries in tabular output\n            jgen.writeNull();\n        }\n    }\n    // otherwise find serializer to use\n    JsonSerializer<Object> ser = _serializer;\n    if (ser == null) {\n        Class<?> cls = value.getClass();\n        PropertySerializerMap map = _dynamicSerializers;\n        ser = map.serializerFor(cls);\n        if (ser == null) {\n            ser = _findAndAddDynamic(map, cls, prov);\n        }\n    }\n    // and then see if we must suppress certain values (default, empty)\n    if (_suppressableValue != null) {\n        if (MARKER_FOR_EMPTY == _suppressableValue) {\n            if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n            serializeAsPlaceholder(bean, jgen, prov);\n            return;\n        }\n    }\n    // For non-nulls: simple check for direct cycles\n    if (value == bean) {\n        _handleSelfReference(bean, ser);\n    }\n    if (_typeSerializer == null) {\n        ser.serialize(value, jgen, prov);\n    } else {\n        ser.serializeWithType(value, jgen, prov, _typeSerializer);\n    }\n}",
    "fixed_function": "public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n    throws Exception\n{\n    Object value = get(bean);\n    if (value == null) { // nulls need specialized handling\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, jgen, prov);\n        } else { // can NOT suppress entries in tabular output\n            jgen.writeNull();\n        }\n        return;\n    }\n    // otherwise find serializer to use\n    JsonSerializer<Object> ser = _serializer;\n    if (ser == null) {\n        Class<?> cls = value.getClass();\n        PropertySerializerMap map = _dynamicSerializers;\n        ser = map.serializerFor(cls);\n        if (ser == null) {\n            ser = _findAndAddDynamic(map, cls, prov);\n        }\n    }\n    // and then see if we must suppress certain values (default, empty)\n    if (_suppressableValue != null) {\n        if (MARKER_FOR_EMPTY == _suppressableValue) {\n            if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n            serializeAsPlaceholder(bean, jgen, prov);\n            return;\n        }\n    }\n    // For non-nulls: simple check for direct cycles\n    if (value == bean) {\n        _handleSelfReference(bean, ser);\n    }\n    if (_typeSerializer == null) {\n        ser.serialize(value, jgen, prov);\n    } else {\n        ser.serializeWithType(value, jgen, prov, _typeSerializer);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java",
      "first_line": 582,
      "last_line": 624
    },
    "javadoc": "/**\n* Alternative to {@link #serializeAsField} that is used when a POJO\n* is serialized as JSON Array; the difference is that no field names\n* are written.\n*\n* @since 2.1\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.struct.TestPOJOAsArray::testNullColumn": {
        "source": "    public void testNullColumn() throws Exception\n\n    {\n\n        assertEquals(\"[null,\\\"bar\\\"]\", MAPPER.writeValueAsString(new TwoStringsBean()));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-100": {
    "id": "JacksonDatabind-100",
    "project": "JacksonDatabind",
    "number": "100",
    "buggy_function": "public byte[] getBinaryValue(Base64Variant b64variant)\n    throws IOException, JsonParseException\n{\n    // Multiple possibilities...\n    JsonNode n = currentNode();\n    if (n != null) {\n        // [databind#2096]: although `binaryValue()` works for real binary node\n        // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n        byte[] data = n.binaryValue();\n        if (data != null) {\n            return data;\n        }\n        if (n.isPojo()) {\n            Object ob = ((POJONode) n).getPojo();\n            if (ob instanceof byte[]) {\n                return (byte[]) ob;\n            }\n        }\n    }\n    // otherwise return null to mark we have no binary content\n    return null;\n}",
    "fixed_function": "public byte[] getBinaryValue(Base64Variant b64variant)\n    throws IOException, JsonParseException\n{\n    // Multiple possibilities...\n    JsonNode n = currentNode();\n    if (n != null) {\n        // [databind#2096]: although `binaryValue()` works for real binary node\n        // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n        if (n instanceof TextNode) {\n            return ((TextNode) n).getBinaryValue(b64variant);\n        }\n        return n.binaryValue();\n    }\n    // otherwise return null to mark we have no binary content\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java",
      "first_line": 355,
      "last_line": 376
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.node.TestConversions::testBase64Text": {
        "source": "    public void testBase64Text() throws Exception\n\n    {\n\n        // let's actually iterate over sets of encoding modes, lengths\n\n        \n\n        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n\n        final Base64Variant[] VARIANTS = {\n\n                Base64Variants.MIME,\n\n                Base64Variants.MIME_NO_LINEFEEDS,\n\n                Base64Variants.MODIFIED_FOR_URL,\n\n                Base64Variants.PEM\n\n        };\n\n\n\n        for (int len : LENS) {\n\n            byte[] input = new byte[len];\n\n            for (int i = 0; i < input.length; ++i) {\n\n                input[i] = (byte) i;\n\n            }\n\n            for (Base64Variant variant : VARIANTS) {\n\n                TextNode n = new TextNode(variant.encode(input));\n\n                byte[] data = null;\n\n                try {\n\n                    data = n.getBinaryValue(variant);\n\n                } catch (Exception e) {\n\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n\n                }\n\n                assertNotNull(data);\n\n                assertArrayEquals(data, input);\n\n\n\n                // 15-Aug-2018, tatu: [databind#2096] requires another test\n\n                JsonParser p = new TreeTraversingParser(n);\n\n                assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n\n                try {\n\n                    data = p.getBinaryValue(variant);\n\n                } catch (Exception e) {\n\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n\n                }\n\n                assertNotNull(data);\n\n                assertArrayEquals(data, input);\n\n                p.close();\n\n            }\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-101": {
    "id": "JacksonDatabind-101",
    "project": "JacksonDatabind",
    "number": "101",
    "buggy_function": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n    //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n    //    Ok however to pass via setter or field.\n    \n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // Last creator property to set?\n            if (buffer.assignParameter(creatorProp,\n                    _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    bean = wrapInstantiationProblem(e, ctxt);\n                }\n                // [databind#631]: Assign current value, to be accessible by custom serializers\n                p.setCurrentValue(bean);\n                // if so, need to copy all remaining tokens into buffer\n                while (t == JsonToken.FIELD_NAME) {\n                    // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                    p.nextToken();\n                    tokens.copyCurrentStructure(p);\n                    t = p.nextToken();\n                }\n                // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                //    problems if we maintain invariants\n                tokens.writeEndObject();\n                if (bean.getClass() != _beanType.getRawClass()) {\n                    // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                    //   it's too complicated, so bail out\n                    ctxt.reportInputMismatch(creatorProp,\n                            \"Cannot create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n            continue;\n        }\n        // Things marked as ignorable should not be passed to any setter\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // 29-Nov-2016, tatu: probably should try to avoid sending content\n        //    both to any setter AND buffer... but, for now, the only thing\n        //    we can do.\n        // how about any setter? We'll get copies but...\n        if (_anySetter == null) {\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        } else {\n            // Need to copy to a separate buffer first\n            TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n            tokens.writeFieldName(propName);\n            tokens.append(b2);\n            try {\n                buffer.bufferAnyProperty(_anySetter, propName,\n                        _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n            } catch (Exception e) {\n                wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n            }\n            continue;\n        }\n    }\n\n    // We hit END_OBJECT, so:\n    Object bean;\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
    "fixed_function": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n    //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n    //    Ok however to pass via setter or field.\n    \n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // Last creator property to set?\n            if (buffer.assignParameter(creatorProp,\n                    _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    bean = wrapInstantiationProblem(e, ctxt);\n                }\n                // [databind#631]: Assign current value, to be accessible by custom serializers\n                p.setCurrentValue(bean);\n                // if so, need to copy all remaining tokens into buffer\n                while (t == JsonToken.FIELD_NAME) {\n                    // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                    tokens.copyCurrentStructure(p);\n                    t = p.nextToken();\n                }\n                // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                //    problems if we maintain invariants\n                if (t != JsonToken.END_OBJECT) {\n                    ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \n                            \"Attempted to unwrap '%s' value\",\n                            handledType().getName());\n                }\n                tokens.writeEndObject();\n                if (bean.getClass() != _beanType.getRawClass()) {\n                    // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                    //   it's too complicated, so bail out\n                    ctxt.reportInputMismatch(creatorProp,\n                            \"Cannot create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n            continue;\n        }\n        // Things marked as ignorable should not be passed to any setter\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // 29-Nov-2016, tatu: probably should try to avoid sending content\n        //    both to any setter AND buffer... but, for now, the only thing\n        //    we can do.\n        // how about any setter? We'll get copies but...\n        if (_anySetter == null) {\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        } else {\n            // Need to copy to a separate buffer first\n            TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n            tokens.writeFieldName(propName);\n            tokens.append(b2);\n            try {\n                buffer.bufferAnyProperty(_anySetter, propName,\n                        _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n            } catch (Exception e) {\n                wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n            }\n            continue;\n        }\n    }\n\n    // We hit END_OBJECT, so:\n    Object bean;\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
      "first_line": 736,
      "last_line": 836
    },
    "javadoc": "// Need to copy to a separate buffer first",
    "failing_tests": {
      "com.fasterxml.jackson.databind.struct.TestUnwrapped::testIssue2088UnwrappedFieldsAfterLastCreatorProp": {
        "source": "    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp() throws Exception\n\n    {\n\n        Issue2088Bean bean = MAPPER.readValue(\"{\\\"x\\\":1,\\\"a\\\":2,\\\"y\\\":3,\\\"b\\\":4}\", Issue2088Bean.class);\n\n        assertEquals(1, bean.x);\n\n        assertEquals(2, bean.w.a);\n\n        assertEquals(3, bean.y);\n\n        assertEquals(4, bean.w.b);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-102": {
    "id": "JacksonDatabind-102",
    "project": "JacksonDatabind",
    "number": "102",
    "buggy_function": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // Note! Should not skip if `property` null since that'd skip check\n        // for config overrides, in case of root value\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }",
    "fixed_function": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // Note! Should not skip if `property` null since that'd skip check\n        // for config overrides, in case of root value\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java",
      "first_line": 62,
      "last_line": 136
    },
    "javadoc": "/**\n* If {@link #_customFormat} is used, we will try to reuse instances in simplest\n* possible form; thread-safe, but without overhead of <code>ThreadLocal</code>\n* (not from code, but wrt retaining of possibly large number of format instances\n* over all threads, properties with custom formats).\n*\n* @since 2.9\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.jdk.SqlDateSerializationTest::testSqlDateConfigOverride": {
        "source": "    public void testSqlDateConfigOverride() throws Exception\n\n    {\n\n        ObjectMapper mapper = newObjectMapper();\n\n        mapper.configOverride(java.sql.Date.class)\n\n            .setFormat(JsonFormat.Value.forPattern(\"yyyy+MM+dd\"));        \n\n        assertEquals(\"\\\"1980+04+14\\\"\",\n\n            mapper.writeValueAsString(java.sql.Date.valueOf(\"1980-04-14\")));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-107": {
    "id": "JacksonDatabind-107",
    "project": "JacksonDatabind",
    "number": "107",
    "buggy_function": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
    "fixed_function": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return NullifyingDeserializer.instance;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
      "first_line": 146,
      "last_line": 199
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.filter.ProblemHandlerUnknownTypeId2221Test::testWithDeserializationProblemHandler": {
        "source": "    public void testWithDeserializationProblemHandler() throws Exception {\n\n        final ObjectMapper mapper = new ObjectMapper()\n\n                .enableDefaultTyping();\n\n        mapper.addHandler(new DeserializationProblemHandler() {\n\n            @Override\n\n            public JavaType handleUnknownTypeId(DeserializationContext ctxt, JavaType baseType, String subTypeId, TypeIdResolver idResolver, String failureMsg) throws IOException {\n\n//                System.out.println(\"Print out a warning here\");\n\n                return ctxt.constructType(Void.class);\n\n            }\n\n        });\n\n        GenericContent processableContent = mapper.readValue(JSON, GenericContent.class);\n\n        assertNotNull(processableContent.getInnerObjects());\n\n        assertEquals(2, processableContent.getInnerObjects().size());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-11": {
    "id": "JacksonDatabind-11",
    "project": "JacksonDatabind",
    "number": "11",
    "buggy_function": "protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n{\n    final String name = type.getName();\n    // 19-Mar-2015: Without context, all we can check are bounds.\n    if (context == null) {\n        // And to prevent infinite loops, now need this:\n        return _unknownType();\n    } else {\n        // Ok: here's where context might come in handy!\n        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n         *   unresolved type variables to handle some cases where bounds\n         *   are enough. Let's hope it does not hide real fail cases.\n         */\n        JavaType actualType = context.findType(name);\n        if (actualType != null) {\n            return actualType;\n        }\n    }\n\n    /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n     *   bound: but the problem is that this can occur for generic \"base\"\n     *   method, overridden by sub-class. If so, we will want to ignore\n     *   current type (for method) since it will be masked.\n     */\n    Type[] bounds = type.getBounds();\n\n    // With type variables we must use bound information.\n    // Theoretically this gets tricky, as there may be multiple\n    // bounds (\"... extends A & B\"); and optimally we might\n    // want to choose the best match. Also, bounds are optional;\n    // but here we are lucky in that implicit \"Object\" is\n    // added as bounds if so.\n    // Either way let's just use the first bound, for now, and\n    // worry about better match later on if there is need.\n\n    /* 29-Jan-2010, tatu: One more problem are recursive types\n     *   (T extends Comparable<T>). Need to add \"placeholder\"\n     *   for resolution to catch those.\n     */\n    context._addPlaceholder(name);\n    return _constructType(bounds[0], context);\n}",
    "fixed_function": "protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n{\n    final String name = type.getName();\n    // 19-Mar-2015: Without context, all we can check are bounds.\n    if (context == null) {\n        // And to prevent infinite loops, now need this:\n        context = new TypeBindings(this, (Class<?>) null);\n    } else {\n        // Ok: here's where context might come in handy!\n        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n         *   unresolved type variables to handle some cases where bounds\n         *   are enough. Let's hope it does not hide real fail cases.\n         */\n        JavaType actualType = context.findType(name, false);\n        if (actualType != null) {\n            return actualType;\n        }\n    }\n\n    /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n     *   bound: but the problem is that this can occur for generic \"base\"\n     *   method, overridden by sub-class. If so, we will want to ignore\n     *   current type (for method) since it will be masked.\n     */\n    Type[] bounds = type.getBounds();\n\n    // With type variables we must use bound information.\n    // Theoretically this gets tricky, as there may be multiple\n    // bounds (\"... extends A & B\"); and optimally we might\n    // want to choose the best match. Also, bounds are optional;\n    // but here we are lucky in that implicit \"Object\" is\n    // added as bounds if so.\n    // Either way let's just use the first bound, for now, and\n    // worry about better match later on if there is need.\n\n    /* 29-Jan-2010, tatu: One more problem are recursive types\n     *   (T extends Comparable<T>). Need to add \"placeholder\"\n     *   for resolution to catch those.\n     */\n    context._addPlaceholder(name);\n    return _constructType(bounds[0], context);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
      "first_line": 889,
      "last_line": 930
    },
    "javadoc": "// Ok: Map or Collection?",
    "failing_tests": {
      "com.fasterxml.jackson.databind.type.TestJavaType::testLocalType728": {
        "source": "    public void testLocalType728() throws Exception\n\n    {\n\n        TypeFactory tf = TypeFactory.defaultInstance();\n\n        Method m = Issue728.class.getMethod(\"method\", CharSequence.class);\n\n        assertNotNull(m);\n\n\n\n        // Start with return type\n\n        // first type-erased\n\n        JavaType t = tf.constructType(m.getReturnType());\n\n        assertEquals(CharSequence.class, t.getRawClass());\n\n        // then generic\n\n        t = tf.constructType(m.getGenericReturnType());\n\n        assertEquals(CharSequence.class, t.getRawClass());\n\n\n\n        // then parameter type\n\n        t = tf.constructType(m.getParameterTypes()[0]);\n\n        assertEquals(CharSequence.class, t.getRawClass());\n\n        t = tf.constructType(m.getGenericParameterTypes()[0]);\n\n        assertEquals(CharSequence.class, t.getRawClass());\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.type.TestLocalType609::testLocalPartialType609": {
        "source": "    public void testLocalPartialType609() throws Exception {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        \n\n        EntityContainer input = new EntityContainer(); \n\n        input.entity = new RuleForm(12);\n\n        String json = mapper.writeValueAsString(input);\n\n        \n\n        EntityContainer output = mapper.readValue(json, EntityContainer.class);\n\n        assertEquals(12, output.getEntity().value);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-112": {
    "id": "JacksonDatabind-112",
    "project": "JacksonDatabind",
    "number": "112",
    "buggy_function": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegate = null;\n    if (_valueInstantiator != null) {\n        // [databind#2324]: check both array-delegating and delegating\n        AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n        if (delegateCreator != null) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            delegate = findDeserializer(ctxt, delegateType, property);\n        }\n    }\n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    final JavaType valueType = _containerType.getContentType();\n    if (valueDeser == null) {\n        // [databind#125]: May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        if (valueDeser == null) {\n        // And we may also need to get deserializer for String\n            valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n        }\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n    }\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n    if (isDefaultDeserializer(valueDeser)) {\n        valueDeser = null;\n    }\n    return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n}",
    "fixed_function": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegate = null;\n    if (_valueInstantiator != null) {\n        // [databind#2324]: check both array-delegating and delegating\n        AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator();\n        if (delegateCreator != null) {\n            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            delegate = findDeserializer(ctxt, delegateType, property);\n        } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            delegate = findDeserializer(ctxt, delegateType, property);\n        }\n    }\n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    final JavaType valueType = _containerType.getContentType();\n    if (valueDeser == null) {\n        // [databind#125]: May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        if (valueDeser == null) {\n        // And we may also need to get deserializer for String\n            valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n        }\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n    }\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n    if (isDefaultDeserializer(valueDeser)) {\n        valueDeser = null;\n    }\n    return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java",
      "first_line": 100,
      "last_line": 134
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.creators.DelegatingArrayCreator2324Test::testDeserializeBagOfStrings": {
        "source": "    public void testDeserializeBagOfStrings() throws Exception {\n\n        WithBagOfStrings result = MAPPER.readerFor(WithBagOfStrings.class)\n\n                .readValue(\"{\\\"strings\\\": [ \\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n\n        assertEquals(3, result.getStrings().size());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-12": {
    "id": "JacksonDatabind-12",
    "project": "JacksonDatabind",
    "number": "12",
    "buggy_function": "public boolean isCachable() {\n    /* As per [databind#735], existence of value or key deserializer (only passed\n     * if annotated to use non-standard one) should also prevent caching.\n     */\n    return (_valueTypeDeserializer == null)\n            && (_ignorableProperties == null);\n}",
    "fixed_function": "public boolean isCachable() {\n    /* As per [databind#735], existence of value or key deserializer (only passed\n     * if annotated to use non-standard one) should also prevent caching.\n     */\n    return (_valueDeserializer == null)\n            && (_keyDeserializer == null)\n            && (_valueTypeDeserializer == null)\n            && (_ignorableProperties == null);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java",
      "first_line": 299,
      "last_line": 305
    },
    "javadoc": "/**\n* Turns out that these are expensive enough to create so that caching\n* does make sense.\n*<p>\n* IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n* a value type deserializer; this caused an issue with 2.4.4 of\n* JAXB Annotations (failing a test).\n* It is also possible that some other settings could make deserializers\n* un-cacheable; but on the other hand, caching can make a big positive\n* difference with performance... so it's a hard choice.\n*\n* @since 2.4.4\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestCustomDeserializers::testCustomMapValueDeser735": {
        "source": "    public void testCustomMapValueDeser735() throws Exception {\n\n        String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n\n        TestMapBean735 bean = MAPPER.readValue(json, TestMapBean735.class);\n\n\n\n        assertEquals(100, bean.map1.get(\"a\").intValue());\n\n        assertEquals(1, bean.map2.get(\"a\").intValue());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-16": {
    "id": "JacksonDatabind-16",
    "project": "JacksonDatabind",
    "number": "16",
    "buggy_function": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return (previous != null) && previous.equals(ann);\n}",
    "fixed_function": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return (previous == null) || !previous.equals(ann);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java",
      "first_line": 107,
      "last_line": 113
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.mixins.MixinsWithBundlesTest::testMixinWithBundles": {
        "source": "    public void testMixinWithBundles() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n\n        String result = mapper.writeValueAsString(new Foo(\"result\"));\n\n        assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-17": {
    "id": "JacksonDatabind-17",
    "project": "JacksonDatabind",
    "number": "17",
    "buggy_function": "        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }",
    "fixed_function": "        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
      "first_line": 167,
      "last_line": 193
    },
    "javadoc": "/**\n* Method called to check if the default type handler should be\n* used for given type.\n* Note: \"natural types\" (String, Boolean, Integer, Double) will never\n* use typing; that is both due to them being concrete and final,\n* and since actual serializers and deserializers will also ignore any\n* attempts to enforce typing.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.node.TestJsonNode::testArrayWithDefaultTyping": {
        "source": "    public void testArrayWithDefaultTyping() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper()\n\n            .enableDefaultTyping();\n\n\n\n        JsonNode array = mapper.readTree(\"[ 1, 2 ]\");\n\n        assertTrue(array.isArray());\n\n        assertEquals(2, array.size());\n\n\n\n        JsonNode obj = mapper.readTree(\"{ \\\"a\\\" : 2 }\");\n\n        assertTrue(obj.isObject());\n\n        assertEquals(1, obj.size());\n\n        assertEquals(2, obj.path(\"a\").asInt());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-19": {
    "id": "JacksonDatabind-19",
    "project": "JacksonDatabind",
    "number": "19",
    "buggy_function": "private JavaType _mapType(Class<?> rawClass)\n{\n    // 28-May-2015, tatu: Properties are special, as per [databind#810]\n    JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n    // ok to have no types (\"raw\")\n    if (typeParams == null) {\n        return MapType.construct(rawClass, _unknownType(), _unknownType());\n    }\n    // but exactly 2 types if any found\n    if (typeParams.length != 2) {\n        throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n    }\n    return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n}",
    "fixed_function": "private JavaType _mapType(Class<?> rawClass)\n{\n    // 28-May-2015, tatu: Properties are special, as per [databind#810]\n    if (rawClass == Properties.class) {\n        return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);\n    }\n    JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n    // ok to have no types (\"raw\")\n    if (typeParams == null) {\n        return MapType.construct(rawClass, _unknownType(), _unknownType());\n    }\n    // but exactly 2 types if any found\n    if (typeParams.length != 2) {\n        throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n    }\n    return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
      "first_line": 1018,
      "last_line": 1031
    },
    "javadoc": "/**\n* This method deals with parameterized types, that is,\n* first class generic classes.\n*/\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n/* First: what is the actual base type? One odd thing\n* is that 'getRawType' returns Type, not Class<?> as\n* one might expect. But let's assume it is always of\n* type Class: if not, need to add more code to resolve\n* it to Class.\n*/\nClass<?> rawType = (Class<?>) type.getRawType();\nType[] args = type.getActualTypeArguments();\nint paramCount = (args == null) ? 0 : args.length;\n\nJavaType[] pt;\n\nif (paramCount == 0) {\npt = NO_TYPES;\n} else {\npt = new JavaType[paramCount];\nfor (int i = 0; i < paramCount; ++i) {\npt[i] = _constructType(args[i], context);\n}\n}\n\n// Ok: Map or Collection?\nif (Map.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, rawType, pt);\nJavaType[] mapParams = findTypeParameters(subtype, Map.class);\nif (mapParams.length != 2) {\nthrow new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n}\nreturn MapType.construct(rawType, mapParams[0], mapParams[1]);\n}\nif (Collection.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, rawType, pt);\nJavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\nif (collectionParams.length != 1) {\nthrow new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n}\nreturn CollectionType.construct(rawType, collectionParams[0]);\n}\n// 28-Apr-2015, tatu: New class of types, referential...\nif (AtomicReference.class.isAssignableFrom(rawType)) {\nJavaType rt = null;\n\nif (rawType == AtomicReference.class) {\nif (paramCount == 1) {\nrt = pt[0];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\nif (pts != null && pts.length != 1) {\nrt = pts[0];\n}\n}\nreturn constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n}\nif (Map.Entry.class.isAssignableFrom(rawType)) {\nJavaType kt = null, vt = null;\n\nif (rawType == Map.Entry.class) {\nif (paramCount == 2) {\nkt = pt[0];\nvt = pt[1];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\nif (pts != null && pts.length != 2) {\nkt = pts[0];\nvt = pts[1];\n}\n}\nreturn constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n(kt == null) ? unknownType() : kt,\n(vt == null) ? unknownType() : vt });\n}\n\nif (paramCount == 0) { // no generics\nreturn new SimpleType(rawType);\n}\nreturn constructSimpleType(rawType, pt);\n}\n\nprotected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n{\nJavaType compType = _constructType(type.getGenericComponentType(), context);\nreturn ArrayType.construct(compType, null, null);\n}\n\nprotected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n{\nfinal String name = type.getName();\n// 19-Mar-2015: Without context, all we can check are bounds.\nif (context == null) {\n// And to prevent infinite loops, now need this:\ncontext = new TypeBindings(this, (Class<?>) null);\n} else {\n// Ok: here's where context might come in handy!\n/* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n*   unresolved type variables to handle some cases where bounds\n*   are enough. Let's hope it does not hide real fail cases.\n*/\nJavaType actualType = context.findType(name, false);\nif (actualType != null) {\nreturn actualType;\n}\n}\n\n/* 29-Jan-2010, tatu: We used to throw exception here, if type was\n*   bound: but the problem is that this can occur for generic \"base\"\n*   method, overridden by sub-class. If so, we will want to ignore\n*   current type (for method) since it will be masked.\n*/\nType[] bounds = type.getBounds();\n\n// With type variables we must use bound information.\n// Theoretically this gets tricky, as there may be multiple\n// bounds (\"... extends A & B\"); and optimally we might\n// want to choose the best match. Also, bounds are optional;\n// but here we are lucky in that implicit \"Object\" is\n// added as bounds if so.\n// Either way let's just use the first bound, for now, and\n// worry about better match later on if there is need.\n\n/* 29-Jan-2010, tatu: One more problem are recursive types\n*   (T extends Comparable<T>). Need to add \"placeholder\"\n*   for resolution to catch those.\n*/\ncontext._addPlaceholder(name);\nreturn _constructType(bounds[0], context);\n}\n\nprotected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n{\n/* Similar to challenges with TypeVariable, we may have\n* multiple upper bounds. But it is also possible that if\n* upper bound defaults to Object, we might want to consider\n* lower bounds instead.\n*\n* For now, we won't try anything more advanced; above is\n* just for future reference.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.convert.TestMapConversions::testMapToProperties": {
        "source": "    public void testMapToProperties() throws Exception\n\n    {\n\n        Bean bean = new Bean();\n\n        bean.A = 129;\n\n        bean.B = \"13\";\n\n        Properties props = MAPPER.convertValue(bean, Properties.class);\n\n\n\n        assertEquals(2, props.size());\n\n\n\n        assertEquals(\"13\", props.getProperty(\"B\"));\n\n        // should coercce non-Strings to Strings\n\n        assertEquals(\"129\", props.getProperty(\"A\"));\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.deser.TestMapDeserialization::testReadProperties": {
        "source": "    public void testReadProperties() throws Exception\n\n    {\n\n        Properties props = MAPPER.readValue(aposToQuotes(\"{'a':'foo', 'b':123, 'c':true}\"),\n\n                Properties.class);\n\n        assertEquals(3, props.size());\n\n        assertEquals(\"foo\", props.getProperty(\"a\"));\n\n        assertEquals(\"123\", props.getProperty(\"b\"));\n\n        assertEquals(\"true\", props.getProperty(\"c\"));\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.type.TestTypeFactory::testProperties": {
        "source": "    public void testProperties()\n\n    {\n\n        TypeFactory tf = TypeFactory.defaultInstance();\n\n        JavaType t = tf.constructType(Properties.class);\n\n        assertEquals(MapType.class, t.getClass());\n\n        assertSame(Properties.class, t.getRawClass());\n\n\n\n        // so far so good. But how about parameterization?\n\n        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n\n        assertSame(String.class, ((MapType) t).getContentType().getRawClass());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-24": {
    "id": "JacksonDatabind-24",
    "project": "JacksonDatabind",
    "number": "24",
    "buggy_function": "public BaseSettings withDateFormat(DateFormat df) {\n    if (_dateFormat == df) {\n        return this;\n    }\n    TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n            _typeResolverBuilder, df, _handlerInstantiator, _locale,\n            tz, _defaultBase64);\n}",
    "fixed_function": "public BaseSettings withDateFormat(DateFormat df) {\n    if (_dateFormat == df) {\n        return this;\n    }\n    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n            _typeResolverBuilder, df, _handlerInstantiator, _locale,\n            _timeZone, _defaultBase64);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java",
      "first_line": 230,
      "last_line": 238
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.TestConfig::testDateFormatConfig": {
        "source": "    public void testDateFormatConfig() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        TimeZone tz1 = TimeZone.getTimeZone(\"America/Los_Angeles\");\n\n        TimeZone tz2 = TimeZone.getTimeZone(\"Central Standard Time\");\n\n\n\n        // sanity checks\n\n        assertEquals(tz1, tz1);\n\n        assertEquals(tz2, tz2);\n\n        if (tz1.equals(tz2)) {\n\n            fail();\n\n        }\n\n\n\n        mapper.setTimeZone(tz1);\n\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());\n\n        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());\n\n\n\n        // also better stick via reader/writer as well\n\n        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());\n\n        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());\n\n        \n\n        SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        f.setTimeZone(tz2);\n\n        mapper.setDateFormat(f);\n\n\n\n        // should not change the timezone tho\n\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());\n\n        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());\n\n        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());\n\n        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-27": {
    "id": "JacksonDatabind-27",
    "project": "JacksonDatabind",
    "number": "27",
    "buggy_function": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // first: let's check to see if this might be part of value with external type id:\n            // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n            //   since it is not the bean\n            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                ;\n            } else {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                        //   it's too complicated, so bail out\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        // external type id (or property that depends on it)?\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        /* As per [JACKSON-313], things marked as ignorable should not be\n         * passed to any setter\n         */\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n}",
    "fixed_function": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // first: let's check to see if this might be part of value with external type id:\n            // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n            //   since it is not the bean\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                ;\n            } else {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                        //   it's too complicated, so bail out\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        // external type id (or property that depends on it)?\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        /* As per [JACKSON-313], things marked as ignorable should not be\n         * passed to any setter\n         */\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
      "first_line": 774,
      "last_line": 857
    },
    "javadoc": "// and when we get this far, let's try finalizing the deal:",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.TestExternalId::testInverseExternalId928": {
        "source": "    public void testInverseExternalId928() throws Exception\n\n    {\n\n        final String CLASS = Payload928.class.getName();\n\n\n\n        ObjectMapper mapper = new ObjectMapper();\n\n\n\n        final String successCase = \"{\\\"payload\\\":{\\\"something\\\":\\\"test\\\"},\\\"class\\\":\\\"\"+CLASS+\"\\\"}\";\n\n        Envelope928 envelope1 = mapper.readValue(successCase, Envelope928.class);\n\n        assertNotNull(envelope1);\n\n        assertEquals(Payload928.class, envelope1._payload.getClass());\n\n\n\n        // and then re-ordered case that was problematic\n\n        final String failCase = \"{\\\"class\\\":\\\"\"+CLASS+\"\\\",\\\"payload\\\":{\\\"something\\\":\\\"test\\\"}}\";\n\n        Envelope928 envelope2 = mapper.readValue(failCase, Envelope928.class);\n\n        assertNotNull(envelope2);\n\n        assertEquals(Payload928.class, envelope2._payload.getClass());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-28": {
    "id": "JacksonDatabind-28",
    "project": "JacksonDatabind",
    "number": "28",
    "buggy_function": "public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n        p.nextToken();\n        return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n    }\n    // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n    //    if caller has advanced to the first token of Object, but for empty Object\n    if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n        return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n    }\n    throw ctxt.mappingException(ObjectNode.class);\n }",
    "fixed_function": "public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n        return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n    }\n    // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n    //    if caller has advanced to the first token of Object, but for empty Object\n    if (p.hasToken(JsonToken.END_OBJECT)) {\n        return ctxt.getNodeFactory().objectNode();\n    }\n    throw ctxt.mappingException(ObjectNode.class);\n }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java",
      "first_line": 95,
      "last_line": 107
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.node.TestObjectNode::testIssue941": {
        "source": "    public void testIssue941() throws Exception\n\n    {\n\n        ObjectNode object = MAPPER.createObjectNode();\n\n\n\n        String json = MAPPER.writeValueAsString(object);\n\n        System.out.println(\"json: \"+json);\n\n\n\n        ObjectNode de1 = MAPPER.readValue(json, ObjectNode.class);  // this works\n\n        System.out.println(\"Deserialized to ObjectNode: \"+de1);\n\n\n\n        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception\n\n        System.out.println(\"Deserialized to MyValue: \"+de2);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-33": {
    "id": "JacksonDatabind-33",
    "project": "JacksonDatabind",
    "number": "33",
    "buggy_function": "public PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n            /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n             *   it's actually bit tricky to do it more efficiently (meta-annotations\n             *   add more lookups; AnnotationMap costs etc)\n             */\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"\";\n        } else {\n            return null;\n        }\n    }\n    return PropertyName.construct(name);\n}",
    "fixed_function": "public PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n            /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n             *   it's actually bit tricky to do it more efficiently (meta-annotations\n             *   add more lookups; AnnotationMap costs etc)\n             */\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)\n                || _hasAnnotation(a, JsonUnwrapped.class)\n                || _hasAnnotation(a, JsonBackReference.class)\n                || _hasAnnotation(a, JsonManagedReference.class)) {\n            name = \"\";\n        } else {\n            return null;\n        }\n    }\n    return PropertyName.construct(name);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java",
      "first_line": 731,
      "last_line": 755
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.struct.TestUnwrapped::testUnwrappedAsPropertyIndicator": {
        "source": "    public void testUnwrappedAsPropertyIndicator() throws Exception\n\n    {\n\n        Inner inner = new Inner();\n\n        inner.animal = \"Zebra\";\n\n\n\n        Outer outer = new Outer();\n\n        outer.inner = inner;\n\n\n\n        String actual = MAPPER.writeValueAsString(outer);\n\n\n\n        assertTrue(actual.contains(\"animal\"));\n\n        assertTrue(actual.contains(\"Zebra\"));\n\n        assertFalse(actual.contains(\"inner\"));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-34": {
    "id": "JacksonDatabind-34",
    "project": "JacksonDatabind",
    "number": "34",
    "buggy_function": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            // otherwise bit unclear what to call... but let's try:\n            /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n        }\n    }\n}",
    "fixed_function": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else {\n            // otherwise bit unclear what to call... but let's try:\n            /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java",
      "first_line": 74,
      "last_line": 87
    },
    "javadoc": "// We'll have to use fallback \"untyped\" number write method",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsonschema.NewSchemaTest::testSimpleNumbers": {
        "source": "    public void testSimpleNumbers() throws Exception\n\n    {\n\n        final StringBuilder sb = new StringBuilder();\n\n        \n\n        MAPPER.acceptJsonFormatVisitor(Numbers.class,\n\n                new JsonFormatVisitorWrapper.Base() {\n\n            @Override\n\n            public JsonObjectFormatVisitor expectObjectFormat(final JavaType type) {\n\n                return new JsonObjectFormatVisitor.Base(getProvider()) {\n\n                    @Override\n\n                    public void optionalProperty(BeanProperty prop) throws JsonMappingException {\n\n                        sb.append(\"[optProp \").append(prop.getName()).append(\"(\");\n\n                        JsonSerializer<Object> ser = null;\n\n                        if (prop instanceof BeanPropertyWriter) {\n\n                            BeanPropertyWriter bpw = (BeanPropertyWriter) prop;\n\n                            ser = bpw.getSerializer();\n\n                        }\n\n                        final SerializerProvider prov = getProvider();\n\n                        if (ser == null) {\n\n                            ser = prov.findValueSerializer(prop.getType(), prop);\n\n                        }\n\n                        ser.acceptJsonFormatVisitor(new JsonFormatVisitorWrapper.Base() {\n\n                            @Override\n\n                            public JsonNumberFormatVisitor expectNumberFormat(\n\n                                    JavaType type) throws JsonMappingException {\n\n                                return new JsonNumberFormatVisitor() {\n\n                                    @Override\n\n                                    public void format(JsonValueFormat format) {\n\n                                        sb.append(\"[numberFormat=\").append(format).append(\"]\");\n\n                                    }\n\n\n\n                                    @Override\n\n                                    public void enumTypes(Set<String> enums) { }\n\n\n\n                                    @Override\n\n                                    public void numberType(NumberType numberType) {\n\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n\n                                    }\n\n                                };\n\n                            }\n\n\n\n                            @Override\n\n                            public JsonIntegerFormatVisitor expectIntegerFormat(JavaType type) throws JsonMappingException {\n\n                                return new JsonIntegerFormatVisitor() {\n\n                                    @Override\n\n                                    public void format(JsonValueFormat format) {\n\n                                        sb.append(\"[integerFormat=\").append(format).append(\"]\");\n\n                                    }\n\n\n\n                                    @Override\n\n                                    public void enumTypes(Set<String> enums) { }\n\n\n\n                                    @Override\n\n                                    public void numberType(NumberType numberType) {\n\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n\n                                    }\n\n                                };\n\n                            }\n\n                        }, prop.getType());\n\n\n\n                        sb.append(\")]\");\n\n                    }\n\n                };\n\n            }\n\n        });\n\n        assertEquals(\"[optProp dec([numberType=BIG_DECIMAL])][optProp bigInt([numberType=BIG_INTEGER])]\",\n\n                sb.toString());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-35": {
    "id": "JacksonDatabind-35",
    "project": "JacksonDatabind",
    "number": "35",
    "buggy_function": "private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 02-Aug-2013, tatu: May need to use native type ids\n    if (p.canReadTypeId()) {\n        Object typeId = p.getTypeId();\n        if (typeId != null) {\n            return _deserializeWithNativeTypeId(p, ctxt, typeId);\n        }\n    }\n    // first, sanity checks\n    if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n    }\n        // should always get field name, but just in case...\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n        }\n    final String typeId = p.getText();\n    JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n    p.nextToken();\n\n    // Minor complication: we may need to merge type id in?\n    if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n        // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n        TokenBuffer tb = new TokenBuffer(null, false);\n        tb.writeStartObject(); // recreate START_OBJECT\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n        p.nextToken();\n    }\n    \n    Object value = deser.deserialize(p, ctxt);\n    // And then need the closing END_OBJECT\n    if (p.nextToken() != JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                \"expected closing END_OBJECT after type information and deserialized value\");\n    }\n    return value;\n}",
    "fixed_function": "private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 02-Aug-2013, tatu: May need to use native type ids\n    if (p.canReadTypeId()) {\n        Object typeId = p.getTypeId();\n        if (typeId != null) {\n            return _deserializeWithNativeTypeId(p, ctxt, typeId);\n        }\n    }\n    // first, sanity checks\n    JsonToken t = p.getCurrentToken();\n    if (t == JsonToken.START_OBJECT) {\n        // should always get field name, but just in case...\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n        }\n    } else if (t != JsonToken.FIELD_NAME) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n    }\n    final String typeId = p.getText();\n    JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n    p.nextToken();\n\n    // Minor complication: we may need to merge type id in?\n    if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n        // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n        TokenBuffer tb = new TokenBuffer(null, false);\n        tb.writeStartObject(); // recreate START_OBJECT\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n        p.nextToken();\n    }\n    \n    Object value = deser.deserialize(p, ctxt);\n    // And then need the closing END_OBJECT\n    if (p.nextToken() != JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                \"expected closing END_OBJECT after type information and deserialized value\");\n    }\n    return value;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java",
      "first_line": 79,
      "last_line": 120
    },
    "javadoc": "/**\n* Method that handles type information wrapper, locates actual\n* subtype deserializer to use, and calls it to do actual\n* deserialization.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest::testSimple": {
        "source": "    public void testSimple() throws Exception\n\n    {\n\n        Company comp = new Company();\n\n        comp.addComputer(new DesktopComputer(\"computer-1\", \"Bangkok\"));\n\n        comp.addComputer(new DesktopComputer(\"computer-2\", \"Pattaya\"));\n\n        comp.addComputer(new LaptopComputer(\"computer-3\", \"Apple\"));\n\n\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n\n\n        String json = mapper.writerWithDefaultPrettyPrinter()\n\n                .writeValueAsString(comp);\n\n\n\n        System.out.println(\"JSON: \"+json);\n\n\n\n        Company result = mapper.readValue(json, Company.class);\n\n        assertNotNull(result);\n\n        assertNotNull(result.computers);\n\n        assertEquals(3, result.computers.size());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-37": {
    "id": "JacksonDatabind-37",
    "project": "JacksonDatabind",
    "number": "37",
    "buggy_function": "protected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values, so no.\n    /*\n    if (!_class.isAssignableFrom(subclass)) {\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n    }\n    */\n    // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n            _valueHandler, _typeHandler, _asStatic);\n}",
    "fixed_function": "protected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values, so no.\n    /*\n    if (!_class.isAssignableFrom(subclass)) {\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n    }\n    */\n    // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n    return new SimpleType(subclass, _bindings, this, _superInterfaces,\n            _valueHandler, _typeHandler, _asStatic);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java",
      "first_line": 120,
      "last_line": 137
    },
    "javadoc": "// ... and while we are at it, not array types either",
    "failing_tests": {
      "com.fasterxml.jackson.databind.objectid.Objecid1083Test::testSimple": {
        "source": "      public void testSimple() throws Exception {\n\n          final ObjectMapper mapper = new ObjectMapper();\n\n          final String json = aposToQuotes(\"{'schemas': [{\\n\"\n\n              + \"  'name': 'FoodMart'\\n\"\n\n              + \"}]}\\n\");\n\n          mapper.readValue(json, JsonRoot.class);\n\n      }\n"
      }
    }
  },
  "JacksonDatabind-39": {
    "id": "JacksonDatabind-39",
    "project": "JacksonDatabind",
    "number": "39",
    "buggy_function": "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n    //    special unfortunately\n        p.skipChildren();\n    return null;\n}",
    "fixed_function": "public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n    //    special unfortunately\n    if (p.hasToken(JsonToken.FIELD_NAME)) {\n        while (true) {\n            JsonToken t = p.nextToken();\n            if ((t == null) || (t == JsonToken.END_OBJECT)) {\n                break;\n            }\n            p.skipChildren();\n        }\n    } else {\n        p.skipChildren();\n    }\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java",
      "first_line": 31,
      "last_line": 37
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl::testUnknownTypeIDRecovery": {
        "source": "    public void testUnknownTypeIDRecovery() throws Exception\n\n    {\n\n        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(\n\n                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n\n        String json = aposToQuotes(\"{'version':0.0,'application':'123',\"\n\n                +\"'item':{'type':'xevent','location':'location1'},\"\n\n                +\"'item2':{'type':'event','location':'location1'}}\");\n\n        // can't read item2 - which is valid\n\n        CallRecord r = reader.readValue(json);\n\n        assertNull(r.item);\n\n        assertNotNull(r.item2);\n\n\n\n        json = aposToQuotes(\"{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}\");\n\n        CallRecord r3 = reader.readValue(json);\n\n        assertNull(r3.item);\n\n        assertEquals(\"123\", r3.application);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-42": {
    "id": "JacksonDatabind-42",
    "project": "JacksonDatabind",
    "number": "42",
    "buggy_function": "protected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return URI.create(\"\");\n    }\n    // As per [databind#1123], Locale too\n    return super._deserializeFromEmptyString();\n}",
    "fixed_function": "protected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return URI.create(\"\");\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java",
      "first_line": 278,
      "last_line": 285
    },
    "javadoc": "// host or unbracketed IPv6, without port number",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestJdkTypes::testLocale": {
        "source": "    public void testLocale() throws IOException\n\n    {\n\n        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n\n        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n\n        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"),\n\n                MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n\n        // [databind#1123]\n\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n\n        assertSame(Locale.ROOT, loc);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-44": {
    "id": "JacksonDatabind-44",
    "project": "JacksonDatabind",
    "number": "44",
    "buggy_function": "protected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n        /*\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n                */\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}",
    "fixed_function": "protected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n    if (!_class.isAssignableFrom(subclass)) {\n        /*\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n                */\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    Class<?> next = subclass.getSuperclass();\n    if (next == _class) { // straight up parent class? Great.\n        return new SimpleType(subclass, _bindings, this,\n                _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    if ((next != null) && _class.isAssignableFrom(next)) {\n        JavaType superb = _narrow(next);\n        return new SimpleType(subclass, _bindings, superb,\n                null, _valueHandler, _typeHandler, _asStatic);\n    }\n    // if not found, try a super-interface\n    Class<?>[] nextI = subclass.getInterfaces();\n    for (Class<?> iface : nextI) {\n        if (iface == _class) { // directly implemented\n            return new SimpleType(subclass, _bindings, null,\n                    new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic);\n        }\n        if (_class.isAssignableFrom(iface)) { // indirect, so recurse\n            JavaType superb = _narrow(iface);\n            return new SimpleType(subclass, _bindings, null,\n                    new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic);\n        }\n    }\n    // should not get here but...\n    throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \"\n            +_class.getName());\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java",
      "first_line": 123,
      "last_line": 141
    },
    "javadoc": "// ... and while we are at it, not array types either",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.TestSubtypes::testIssue1125WithDefault": {
        "source": "    public void testIssue1125WithDefault() throws Exception\n\n    {\n\n        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes(\"{'value':{'a':3,'def':9,'b':5}}\"),\n\n        \t\tIssue1125Wrapper.class);\n\n        assertNotNull(result.value);\n\n        assertEquals(Default1125.class, result.value.getClass());\n\n        Default1125 impl = (Default1125) result.value;\n\n        assertEquals(3, impl.a);\n\n        assertEquals(5, impl.b);\n\n        assertEquals(9, impl.def);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-45": {
    "id": "JacksonDatabind-45",
    "project": "JacksonDatabind",
    "number": "45",
    "buggy_function": "public JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n\n        \t// Simple case first: serialize as numeric timestamp?\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n\n            if (format.getShape() == JsonFormat.Shape.STRING) {\n                TimeZone tz = format.getTimeZone();\n                final String pattern = format.hasPattern()\n                                ? format.getPattern()\n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale loc = format.hasLocale()\n                                ? format.getLocale()\n                                : serializers.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = serializers.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n    }\n    return this;\n}",
    "fixed_function": "public JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n\n        \t// Simple case first: serialize as numeric timestamp?\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n\n            if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                            || format.hasLocale() || format.hasTimeZone()) {\n                TimeZone tz = format.getTimeZone();\n                final String pattern = format.hasPattern()\n                                ? format.getPattern()\n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale loc = format.hasLocale()\n                                ? format.getLocale()\n                                : serializers.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = serializers.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n    }\n    return this;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java",
      "first_line": 50,
      "last_line": 81
    },
    "javadoc": "/**\n* Specific format to use, if not default format: non null value\n* also indicates that serialization is to be done as JSON String,\n* not numeric timestamp, unless {@link #_useTimestamp} is true.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.DateSerializationTest::testDateDefaultShape": {
        "source": "    public void testDateDefaultShape() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        // No @JsonFormat => default to user config\n\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n\n        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n\n\n        // Empty @JsonFormat => default to user config\n\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n\n        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n\n\n        // @JsonFormat with Shape.ANY and pattern => STRING shape, regardless of user config\n\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);\n\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);\n\n\n\n        // @JsonFormat with Shape.ANY and locale => STRING shape, regardless of user config\n\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n\n\n        // @JsonFormat with Shape.ANY and timezone => STRING shape, regardless of user config\n\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T01:00:00.000+0100'}\"), json);\n\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T01:00:00.000+0100'}\"), json);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-46": {
    "id": "JacksonDatabind-46",
    "project": "JacksonDatabind",
    "number": "46",
    "buggy_function": "public StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(';');\n    return sb;\n}",
    "fixed_function": "public StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java",
      "first_line": 151,
      "last_line": 158
    },
    "javadoc": "// Hmmh. For now, assume it's the raw type",
    "failing_tests": {
      "com.fasterxml.jackson.databind.type.TestJavaType::testGenericSignature1195": {
        "source": "    public void testGenericSignature1195() throws Exception\n\n    {\n\n        TypeFactory tf = TypeFactory.defaultInstance();\n\n        Method m;\n\n        JavaType t;\n\n\n\n        m = Generic1195.class.getMethod(\"getList\");\n\n        t  = tf.constructType(m.getGenericReturnType());\n\n        assertEquals(\"Ljava/util/List<Ljava/lang/String;>;\", t.getGenericSignature());\n\n\n\n        m = Generic1195.class.getMethod(\"getMap\");\n\n        t  = tf.constructType(m.getGenericReturnType());\n\n        assertEquals(\"Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;\",\n\n                t.getGenericSignature());\n\n\n\n        m = Generic1195.class.getMethod(\"getGeneric\");\n\n        t  = tf.constructType(m.getGenericReturnType());\n\n        assertEquals(\"Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\", t.getGenericSignature());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-47": {
    "id": "JacksonDatabind-47",
    "project": "JacksonDatabind",
    "number": "47",
    "buggy_function": "public JavaType refineSerializationType(final MapperConfig<?> config,\n        final Annotated a, final JavaType baseType) throws JsonMappingException\n{\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    \n    // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n    //    now-deprecated secondary methods; this because while\n    //    direct sub-class not yet retrofitted may only override\n    //    those methods. With 2.8 or later we may consider removal\n    //    of these methods\n\n    \n    // Ok: start by refining the main type itself; common to all types\n    Class<?> serClass = findSerializationType(a);\n    if (serClass != null) {\n        if (type.hasRawClass(serClass)) {\n            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n            //    static typing this way\n            type = type.withStaticTyping();\n        } else {\n            try {\n                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                //   may be needed here too in future?\n                    type = tf.constructGeneralizedType(type, serClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                type, serClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n    }\n    // Then further processing for container types\n\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        Class<?> keyClass = findSerializationKeyType(a, keyType);\n        if (keyClass != null) {\n            if (keyType.hasRawClass(keyClass)) {\n                keyType = keyType.withStaticTyping();\n            } else {\n                Class<?> currRaw = keyType.getRawClass();\n                try {\n                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                    //   specialize (narrow) type sometimes, even if more commonly opposite\n                    //   is needed.\n                    if (keyClass.isAssignableFrom(currRaw)) { // common case\n                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n                    } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                        keyType = tf.constructSpecializedType(keyType, keyClass);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                        keyType, keyClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n            type = ((MapLikeType) type).withKeyType(keyType);\n        }\n    }\n\n    JavaType contentType = type.getContentType();\n    if (contentType != null) { // collection[like], map[like], array, reference\n        // And then value types for all containers:\n       Class<?> contentClass = findSerializationContentType(a, contentType);\n       if (contentClass != null) {\n           if (contentType.hasRawClass(contentClass)) {\n               contentType = contentType.withStaticTyping();\n           } else {\n               // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n               //   specialize (narrow) type sometimes, even if more commonly opposite\n               //   is needed.\n               Class<?> currRaw = contentType.getRawClass();\n               try {\n                   if (contentClass.isAssignableFrom(currRaw)) { // common case\n                       contentType = tf.constructGeneralizedType(contentType, contentClass);\n                   } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                       contentType = tf.constructSpecializedType(contentType, contentClass);\n                   } else {\n                       throw new JsonMappingException(null,\n                               String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                       contentType, contentClass.getName()));\n                   }\n               } catch (IllegalArgumentException iae) { // shouldn't really happen\n                   throw new JsonMappingException(null,\n                           String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n           type = type.withContentType(contentType);\n       }\n    }\n    return type;\n}",
    "fixed_function": "public JavaType refineSerializationType(final MapperConfig<?> config,\n        final Annotated a, final JavaType baseType) throws JsonMappingException\n{\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    \n    // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n    //    now-deprecated secondary methods; this because while\n    //    direct sub-class not yet retrofitted may only override\n    //    those methods. With 2.8 or later we may consider removal\n    //    of these methods\n\n    \n    // Ok: start by refining the main type itself; common to all types\n    Class<?> serClass = findSerializationType(a);\n    if (serClass != null) {\n        if (type.hasRawClass(serClass)) {\n            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n            //    static typing this way\n            type = type.withStaticTyping();\n        } else {\n            Class<?> currRaw = type.getRawClass();\n            try {\n                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                //   may be needed here too in future?\n                if (serClass.isAssignableFrom(currRaw)) { // common case\n                    type = tf.constructGeneralizedType(type, serClass);\n                } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n                    type = tf.constructSpecializedType(type, serClass);\n                } else {\n                    throw new JsonMappingException(null,\n                            String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                    type, serClass.getName()));\n                }\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                type, serClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n    }\n    // Then further processing for container types\n\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        Class<?> keyClass = findSerializationKeyType(a, keyType);\n        if (keyClass != null) {\n            if (keyType.hasRawClass(keyClass)) {\n                keyType = keyType.withStaticTyping();\n            } else {\n                Class<?> currRaw = keyType.getRawClass();\n                try {\n                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                    //   specialize (narrow) type sometimes, even if more commonly opposite\n                    //   is needed.\n                    if (keyClass.isAssignableFrom(currRaw)) { // common case\n                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n                    } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                        keyType = tf.constructSpecializedType(keyType, keyClass);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                        keyType, keyClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n            type = ((MapLikeType) type).withKeyType(keyType);\n        }\n    }\n\n    JavaType contentType = type.getContentType();\n    if (contentType != null) { // collection[like], map[like], array, reference\n        // And then value types for all containers:\n       Class<?> contentClass = findSerializationContentType(a, contentType);\n       if (contentClass != null) {\n           if (contentType.hasRawClass(contentClass)) {\n               contentType = contentType.withStaticTyping();\n           } else {\n               // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n               //   specialize (narrow) type sometimes, even if more commonly opposite\n               //   is needed.\n               Class<?> currRaw = contentType.getRawClass();\n               try {\n                   if (contentClass.isAssignableFrom(currRaw)) { // common case\n                       contentType = tf.constructGeneralizedType(contentType, contentClass);\n                   } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                       contentType = tf.constructSpecializedType(contentType, contentClass);\n                   } else {\n                       throw new JsonMappingException(null,\n                               String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                       contentType, contentClass.getName()));\n                   }\n               } catch (IllegalArgumentException iae) { // shouldn't really happen\n                   throw new JsonMappingException(null,\n                           String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n           type = type.withContentType(contentType);\n       }\n    }\n    return type;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java",
      "first_line": 795,
      "last_line": 896
    },
    "javadoc": "/**\n* Method called to find out possible type refinements to use\n* for deserialization.\n*\n* @since 2.7\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.TestJsonSerialize::testBrokenAnnotation": {
        "source": "    public void testBrokenAnnotation() throws Exception\n\n    {\n\n        try {\n\n            serializeAsString(MAPPER, new BrokenClass());\n\n        } catch (Exception e) {\n\n            verifyException(e, \"types not related\");\n\n        }\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.ser.TestJsonSerializeAs::testSpecializedAsIntermediate": {
        "source": "    public void testSpecializedAsIntermediate() throws IOException {\n\n        assertEquals(aposToQuotes(\"{'value':{'a':1,'b':2}}\"),\n\n                WRITER.writeValueAsString(new Bean1178Holder()));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-49": {
    "id": "JacksonDatabind-49",
    "project": "JacksonDatabind",
    "number": "49",
    "buggy_function": "public Object generateId(Object forPojo) {\n    // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n    //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n    //    need to use existing id if there is one:\n        id = generator.generateId(forPojo);\n    return id;\n}",
    "fixed_function": "public Object generateId(Object forPojo) {\n    // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n    //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n    //    need to use existing id if there is one:\n    if (id == null) {\n        id = generator.generateId(forPojo);\n    }\n    return id;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java",
      "first_line": 46,
      "last_line": 52
    },
    "javadoc": "// 03-Aug-2013, tatu: Prefer Native Object Ids if available",
    "failing_tests": {
      "com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1255": {
        "source": "    public void testIssue1255() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        Foo mo = new Foo();\n\n        mo.bar1 = new Bar();\n\n        mo.bar2 = mo.bar1;\n\n\n\n        String json = mapper.writeValueAsString(mo);\n\n\n\n        Foo result = mapper.readValue(json, Foo.class);\n\n        assertNotNull(result);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-5": {
    "id": "JacksonDatabind-5",
    "project": "JacksonDatabind",
    "number": "5",
    "buggy_function": "protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n        Class<?> mixInCls, AnnotatedMethodMap mixIns)\n{\n    List<Class<?>> parents = new ArrayList<Class<?>>();\n    parents.add(mixInCls);\n    ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n    for (Class<?> mixin : parents) {\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod am = methods.find(m);\n            /* Do we already have a method to augment (from sub-class\n             * that will mask this mixIn)? If so, add if visible\n             * without masking (no such annotation)\n             */\n            if (am != null) {\n                _addMixUnders(m, am);\n                /* Otherwise will have precedence, but must wait\n                 * until we find the real method (mixIn methods are\n                 * just placeholder, can't be called)\n                 */\n            } else {\n                // Well, or, as per [Issue#515], multi-level merge within mixins...\n                    mixIns.add(_constructMethod(m));\n            }\n        }\n    }\n}",
    "fixed_function": "protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n        Class<?> mixInCls, AnnotatedMethodMap mixIns)\n{\n    List<Class<?>> parents = new ArrayList<Class<?>>();\n    parents.add(mixInCls);\n    ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n    for (Class<?> mixin : parents) {\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod am = methods.find(m);\n            /* Do we already have a method to augment (from sub-class\n             * that will mask this mixIn)? If so, add if visible\n             * without masking (no such annotation)\n             */\n            if (am != null) {\n                _addMixUnders(m, am);\n                /* Otherwise will have precedence, but must wait\n                 * until we find the real method (mixIn methods are\n                 * just placeholder, can't be called)\n                 */\n            } else {\n                // Well, or, as per [Issue#515], multi-level merge within mixins...\n                am = mixIns.find(m);\n                if (am != null) {\n                    _addMixUnders(m, am);\n                } else {\n                    mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java",
      "first_line": 634,
      "last_line": 662
    },
    "javadoc": "/**********************************************************\n*/\n\nprotected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\nClass<?> mixInCls, AnnotatedMethodMap mixIns)\n{\n// first, mixIns, since they have higher priority then class methods\nif (mixInCls != null) {\n_addMethodMixIns(cls, methods, mixInCls, mixIns);\n}\nif (cls == null) { // just so caller need not check when passing super-class\nreturn;\n}\n\n// then methods from the class itself\nfor (Method m : cls.getDeclaredMethods()) {\nif (!_isIncludableMemberMethod(m)) {\ncontinue;\n}\nAnnotatedMethod old = methods.find(m);\nif (old == null) {\nAnnotatedMethod newM = _constructMethod(m);\nmethods.add(newM);\n// Ok, but is there a mix-in to connect now?\nold = mixIns.remove(m);\nif (old != null) {\n_addMixOvers(old.getAnnotated(), newM, false);\n}\n} else {\n/* If sub-class already has the method, we only want to augment\n* annotations with entries that are not masked by sub-class.\n*/\n_addMixUnders(m, old);\n\n/* 06-Jan-2010, tatu: [JACKSON-450] Except that if method we saw first is\n*   from an interface, and we now find a non-interface definition, we should\n*   use this method, but with combination of annotations.\n*   This helps (or rather, is essential) with JAXB annotations and\n*   may also result in faster method calls (interface calls are slightly\n*   costlier than regular method calls)\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.introspect.TestMixinMerging::testDisappearingMixins515": {
        "source": "    public void testDisappearingMixins515() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)\n\n            .disable(MapperFeature.AUTO_DETECT_FIELDS)\n\n            .disable(MapperFeature.AUTO_DETECT_GETTERS)\n\n            .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)\n\n            .disable(MapperFeature.INFER_PROPERTY_MUTATORS);\n\n        SimpleModule module = new SimpleModule(\"Test\");\n\n        module.setMixInAnnotation(Person.class, PersonMixin.class);        \n\n        mapper.registerModule(module);\n\n\n\n        assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl()));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-51": {
    "id": "JacksonDatabind-51",
    "project": "JacksonDatabind",
    "number": "51",
    "buggy_function": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) { // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
    "fixed_function": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) { // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
      "first_line": 140,
      "last_line": 191
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom": {
        "source": "    public void testPolymorphicTypeViaCustom() throws Exception {\n\n        Base1270<Poly1> req = new Base1270<Poly1>();\n\n        Poly1 o = new Poly1();\n\n        o.val = \"optionValue\";\n\n        req.options = o;\n\n        req.val = \"some value\";\n\n        Top1270 top = new Top1270();\n\n        top.b = req;\n\n        String json = MAPPER.writeValueAsString(top);\n\n        JsonNode tree = MAPPER.readTree(json);\n\n        assertNotNull(tree.get(\"b\"));\n\n        assertNotNull(tree.get(\"b\").get(\"options\"));\n\n        assertNotNull(tree.get(\"b\").get(\"options\").get(\"val\"));\n\n\n\n        // Can we reverse the process? I have some doubts\n\n        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);\n\n        assertNotNull(itemRead);\n\n        assertNotNull(itemRead.b);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-54": {
    "id": "JacksonDatabind-54",
    "project": "JacksonDatabind",
    "number": "54",
    "buggy_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              //serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "fixed_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              //serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
      "first_line": 68,
      "last_line": 171
    },
    "javadoc": "/**\n* @param contentTypeSer Optional explicit type information serializer\n*    to use for contained values (only used for properties that are\n*    of container type)\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestJDKAtomicTypes::testEmpty1256": {
        "source": "    public void testEmpty1256() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n\n\n\n        String json = mapper.writeValueAsString(new Issue1256Bean());\n\n        assertEquals(\"{}\", json);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-57": {
    "id": "JacksonDatabind-57",
    "project": "JacksonDatabind",
    "number": "57",
    "buggy_function": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n            true));\n}",
    "fixed_function": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n            true));\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
      "first_line": 1435,
      "last_line": 1443
    },
    "javadoc": "/**\n* Overloaded version of {@link #readValue(InputStream)}.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.seq.ReadValuesTest::testRootBeans": {
        "source": "    public void testRootBeans() throws Exception\n\n    {\n\n        for (Source src : Source.values()) {\n\n            _testRootBeans(src);\n\n        }\n\n    }\n\n    private void _testRootBeans(Source srcType) throws Exception\n"
      }
    }
  },
  "JacksonDatabind-58": {
    "id": "JacksonDatabind-58",
    "project": "JacksonDatabind",
    "number": "58",
    "buggy_function": "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n        JavaType propType0)\n    throws JsonMappingException\n{\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n    if (ctxt.canOverrideAccessModifiers()) {\n        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        // !!! NOTE: should be handled better for 2.8 and later\n            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n    }\n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n            propType0, propDef.getWrapperName(),\n            beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n    // did type change?\n    if (type != propType0) {\n        property = property.withType(type);\n    }\n\n    // First: does the Method specify the deserializer to use? If so, let's use it.\n    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n    type = modifyTypeByAnnotation(ctxt, mutator, type);\n    TypeDeserializer typeDeser = type.getTypeHandler();\n    SettableBeanProperty prop;\n    if (mutator instanceof AnnotatedMethod) {\n        prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n    } else {\n        prop = new FieldProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n    }\n    if (propDeser != null) {\n        prop = prop.withValueDeserializer(propDeser);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n    if (ref != null && ref.isManagedReference()) {\n        prop.setManagedReferenceName(ref.getName());\n    }\n    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n    if(objectIdInfo != null){\n        prop.setObjectIdInfo(objectIdInfo);\n    }\n    return prop;\n}",
    "fixed_function": "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n        JavaType propType0)\n    throws JsonMappingException\n{\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n    if (ctxt.canOverrideAccessModifiers()) {\n        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        // !!! NOTE: should be handled better for 2.8 and later\n        if ((mutator instanceof AnnotatedField)\n                && \"cause\".equals(mutator.getName())) {\n            ;\n        } else {\n            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n            propType0, propDef.getWrapperName(),\n            beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n    // did type change?\n    if (type != propType0) {\n        property = property.withType(type);\n    }\n\n    // First: does the Method specify the deserializer to use? If so, let's use it.\n    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n    type = modifyTypeByAnnotation(ctxt, mutator, type);\n    TypeDeserializer typeDeser = type.getTypeHandler();\n    SettableBeanProperty prop;\n    if (mutator instanceof AnnotatedMethod) {\n        prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n    } else {\n        prop = new FieldProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n    }\n    if (propDeser != null) {\n        prop = prop.withValueDeserializer(propDeser);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n    if (ref != null && ref.isManagedReference()) {\n        prop.setManagedReferenceName(ref.getName());\n    }\n    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n    if(objectIdInfo != null){\n        prop.setObjectIdInfo(objectIdInfo);\n    }\n    return prop;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "first_line": 703,
      "last_line": 752
    },
    "javadoc": "/**\n* Method that will construct a regular bean property setter using\n* the given setter method.\n*\n* @return Property constructed, if any; or null to indicate that\n*   there should be no property based on given definitions.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral": {
        "source": "    public void testCauseOfThrowableIgnoral() throws Exception\n\n    {\n\n        final SecurityManager origSecMan = System.getSecurityManager();\n\n        try {\n\n            System.setSecurityManager(new CauseBlockingSecurityManager());\n\n            _testCauseOfThrowableIgnoral();\n\n        } finally {\n\n            System.setSecurityManager(origSecMan);\n\n        }\n\n    }\n\n    private void _testCauseOfThrowableIgnoral() throws Exception\n"
      }
    }
  },
  "JacksonDatabind-6": {
    "id": "JacksonDatabind-6",
    "project": "JacksonDatabind",
    "number": "6",
    "buggy_function": "protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n{\n    /* 21-May-2009, tatu: DateFormat has very strict handling of\n     * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n     */\n\n    /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n     * quite simple because we already set date format timezone to be\n     * GMT, and hence can just strip out 'Z' altogether\n     */\n    int len = dateStr.length();\n    char c = dateStr.charAt(len-1);\n    DateFormat df;\n\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len-4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len-1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len-3);\n            if (c == ':') { // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len-3, len-2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') { // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len-9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                    sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}",
    "fixed_function": "protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n{\n    /* 21-May-2009, tatu: DateFormat has very strict handling of\n     * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n     */\n\n    /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n     * quite simple because we already set date format timezone to be\n     * GMT, and hence can just strip out 'Z' altogether\n     */\n    int len = dateStr.length();\n    char c = dateStr.charAt(len-1);\n    DateFormat df;\n\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len-4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len-1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len-3);\n            if (c == ':') { // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len-3, len-2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') { // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n                int offset = len - 5; // insertion offset, before tz-offset\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch (timeLen) {\n                case 11:\n                    sb.insert(offset, '0'); break;\n                case 10:\n                    sb.insert(offset, \"00\"); break;\n                case 9: // is this legal? (just second fraction marker)\n                    sb.insert(offset, \"000\"); break;\n                case 8:\n                    sb.insert(offset, \".000\"); break;\n                case 7: // not legal to have single-digit second\n                    break;\n                case 6: // probably not legal, but let's allow\n                    sb.insert(offset, \"00.000\");\n                case 5: // is legal to omit seconds\n                    sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen < 12) { // missing, or partial\n                switch (timeLen) {\n                case 11: sb.append('0');\n                case 10: sb.append('0');\n                case 9: sb.append('0');\n                    break;\n                default:\n                    sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
      "first_line": 359,
      "last_line": 434
    },
    "javadoc": "/**\n* Overridable helper method used to figure out which of supported\n* formats is the likeliest match.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestDateDeserialization::testISO8601MissingSeconds": {
        "source": "    public void testISO8601MissingSeconds() throws Exception\n\n    {\n\n        String inputStr;\n\n        Date inputDate;\n\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n\n    \n\n        inputStr = \"1997-07-16T19:20+01:00\";\n\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n\n        c.setTime(inputDate);\n\n        assertEquals(1997, c.get(Calendar.YEAR));\n\n        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n\n        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n\n        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n\n        assertEquals(0, c.get(Calendar.SECOND));\n\n        assertEquals(0, c.get(Calendar.MILLISECOND));\n\n}\n"
      },
      "com.fasterxml.jackson.databind.deser.TestDateDeserialization::testISO8601PartialMilliseconds": {
        "source": "    public void testISO8601PartialMilliseconds() throws Exception\n\n    {\n\n        String inputStr;\n\n        Date inputDate;\n\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n\n        \n\n        inputStr = \"2014-10-03T18:00:00.6-05:00\";\n\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n\n        c.setTime(inputDate);\n\n        assertEquals(2014, c.get(Calendar.YEAR));\n\n        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n\n        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n\n        assertEquals(600, c.get(Calendar.MILLISECOND));\n\n\n\n        inputStr = \"2014-10-03T18:00:00.61-05:00\";\n\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n\n        c.setTime(inputDate);\n\n        assertEquals(2014, c.get(Calendar.YEAR));\n\n        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n\n        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n\n        assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));\n\n        assertEquals(0, c.get(Calendar.MINUTE));\n\n        assertEquals(0, c.get(Calendar.SECOND));\n\n        assertEquals(610, c.get(Calendar.MILLISECOND));\n\n\n\n        inputStr = \"1997-07-16T19:20:30.45+01:00\";\n\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n\n        c.setTime(inputDate);\n\n        assertEquals(1997, c.get(Calendar.YEAR));\n\n        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n\n        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n\n        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n\n        assertEquals(20, c.get(Calendar.MINUTE));\n\n        assertEquals(30, c.get(Calendar.SECOND));\n\n        assertEquals(450, c.get(Calendar.MILLISECOND));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-62": {
    "id": "JacksonDatabind-62",
    "project": "JacksonDatabind",
    "number": "62",
    "buggy_function": "public CollectionDeserializer createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegateDeser = null;\n    if (_valueInstantiator != null) {\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, delegateType, property);\n        }\n    }\n    // [databind#1043]: allow per-property allow-wrapping of single overrides:\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    // also, often value deserializer is resolved here:\n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    \n    // May have a content converter\n    valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n    final JavaType vt = _collectionType.getContentType();\n    if (valueDeser == null) {\n        valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n    }\n    // and finally, type deserializer needs context as well\n    TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n    if (valueTypeDeser != null) {\n        valueTypeDeser = valueTypeDeser.forProperty(property);\n    }\n    return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n}",
    "fixed_function": "public CollectionDeserializer createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegateDeser = null;\n    if (_valueInstantiator != null) {\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, delegateType, property);\n        } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, delegateType, property);\n        }\n    }\n    // [databind#1043]: allow per-property allow-wrapping of single overrides:\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    // also, often value deserializer is resolved here:\n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    \n    // May have a content converter\n    valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n    final JavaType vt = _collectionType.getContentType();\n    if (valueDeser == null) {\n        valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n    }\n    // and finally, type deserializer needs context as well\n    TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n    if (valueTypeDeser != null) {\n        valueTypeDeser = valueTypeDeser.forProperty(property);\n    }\n    return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java",
      "first_line": 170,
      "last_line": 208
    },
    "javadoc": "/**\n* Method called to finalize setup of this deserializer,\n* when it is known for which property deserializer is needed\n* for.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.creators.ArrayDelegatorCreatorForCollectionTest::testUnmodifiable": {
        "source": "    public void testUnmodifiable() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        Class<?> unmodSetType = Collections.unmodifiableSet(Collections.<String>emptySet()).getClass();\n\n        mapper.addMixIn(unmodSetType, UnmodifiableSetMixin.class);\n\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n\n\n        final String EXPECTED_JSON = \"[\\\"\"+unmodSetType.getName()+\"\\\",[]]\";\n\n\n\n        Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);\n\n        assertTrue(foo.isEmpty());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-64": {
    "id": "JacksonDatabind-64",
    "project": "JacksonDatabind",
    "number": "64",
    "buggy_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n    \n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n\n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        if (_useRealPropertyDefaults) {\n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n            suppressNulls = true;\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "fixed_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n    \n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n        Object defaultBean;\n\n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            try {\n                valueToSuppress = am.getValue(defaultBean);\n            } catch (Exception e) {\n                _throwWrapped(e, propDef.getName(), defaultBean);\n            }\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n            suppressNulls = true;\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
      "first_line": 90,
      "last_line": 216
    },
    "javadoc": "/**\n* @param contentTypeSer Optional explicit type information serializer\n*    to use for contained values (only used for properties that are\n*    of container type)\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.filter.JsonIncludeTest::testIssue1351": {
        "source": "    public void testIssue1351() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n\n        assertEquals(aposToQuotes(\"{}\"),\n\n                mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));\n\n        // [databind#1417]\n\n        assertEquals(aposToQuotes(\"{}\"),\n\n                mapper.writeValueAsString(new Issue1351NonBean(0)));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-67": {
    "id": "JacksonDatabind-67",
    "project": "JacksonDatabind",
    "number": "67",
    "buggy_function": "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n        JavaType type)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    KeyDeserializer deser = null;\n    if (_factoryConfig.hasKeyDeserializers()) {\n        BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n        for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n            deser = d.findKeyDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                break;\n            }\n        }\n    }\n    // the only non-standard thing is this:\n    if (deser == null) {\n        if (type.isEnumType()) {\n            return _createEnumKeyDeserializer(ctxt, type);\n        }\n        deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n    }\n    // and then post-processing\n    if (deser != null) {\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyKeyDeserializer(config, type, deser);\n            }\n        }\n    }\n    return deser;\n}",
    "fixed_function": "public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n        JavaType type)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    KeyDeserializer deser = null;\n    if (_factoryConfig.hasKeyDeserializers()) {\n        BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n        for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n            deser = d.findKeyDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                break;\n            }\n        }\n    }\n    // the only non-standard thing is this:\n    if (deser == null) {\n        if (type.isEnumType()) {\n            deser = _createEnumKeyDeserializer(ctxt, type);\n        } else {\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n    }\n    // and then post-processing\n    if (deser != null) {\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyKeyDeserializer(config, type, deser);\n            }\n        }\n    }\n    return deser;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "first_line": 1385,
      "last_line": 1416
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer::testCustomEnumValueAndKeyViaModifier": {
        "source": "    public void testCustomEnumValueAndKeyViaModifier() throws IOException\n\n    {\n\n        SimpleModule module = new SimpleModule();\n\n        module.setDeserializerModifier(new BeanDeserializerModifier() {        \n\n            @Override\n\n            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,\n\n                    final JavaType type, BeanDescription beanDesc,\n\n                    final JsonDeserializer<?> deserializer) {\n\n                return new JsonDeserializer<Enum>() {\n\n                    @Override\n\n                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n\n                        final String str = p.getValueAsString().toLowerCase();\n\n                        return KeyEnum.valueOf(rawClass, str);\n\n                    }\n\n                };\n\n            }\n\n\n\n            @Override\n\n            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,\n\n                    final JavaType type, KeyDeserializer deserializer)\n\n            {\n\n                if (!type.isEnumType()) {\n\n                    return deserializer;\n\n                }\n\n                return new KeyDeserializer() {\n\n                    @Override\n\n                    public Object deserializeKey(String key, DeserializationContext ctxt)\n\n                            throws IOException\n\n                    {\n\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n\n                        return Enum.valueOf(rawClass, key.toLowerCase());\n\n                    }\n\n                };\n\n            }\n\n        });\n\n        ObjectMapper mapper = new ObjectMapper()\n\n                .registerModule(module);\n\n\n\n        // First, enum value as is\n\n        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),\n\n                KeyEnum.class);\n\n        assertSame(KeyEnum.replacements, key);\n\n\n\n        // and then as key\n\n        EnumMap<KeyEnum,String> map = mapper.readValue(\n\n                aposToQuotes(\"{'REPlaceMENTS':'foobar'}\"),\n\n                new TypeReference<EnumMap<KeyEnum,String>>() { });\n\n        assertEquals(1, map.size());\n\n        assertSame(KeyEnum.replacements, map.keySet().iterator().next());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-7": {
    "id": "JacksonDatabind-7",
    "project": "JacksonDatabind",
    "number": "7",
    "buggy_function": "public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n{\n        copyCurrentStructure(jp);\n    /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n     *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n     *    to assume one did exist.\n     */\n    return this;\n}",
    "fixed_function": "public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n{\n    if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n        copyCurrentStructure(jp);\n        return this;\n    }\n    /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n     *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n     *    to assume one did exist.\n     */\n    JsonToken t;\n    writeStartObject();\n    do {\n        copyCurrentStructure(jp);\n    } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n    if (t != JsonToken.END_OBJECT) {\n        throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n    }\n    writeEndObject();\n    return this;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
      "first_line": 403,
      "last_line": 411
    },
    "javadoc": "/**\n* Helper method used by standard deserializer.\n*\n* @since 2.3\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.creators.TestCreatorsDelegating::testDelegateWithTokenBuffer": {
        "source": "    public void testDelegateWithTokenBuffer() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        Value592 value = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Value592.class);\n\n        assertNotNull(value);\n\n        Object ob = value.stuff;\n\n        assertEquals(TokenBuffer.class, ob.getClass());\n\n        JsonParser jp = ((TokenBuffer) ob).asParser();\n\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n\n        assertEquals(\"a\", jp.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n\n        assertEquals(1, jp.getIntValue());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n\n        assertEquals(\"b\", jp.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n\n        assertEquals(2, jp.getIntValue());\n\n        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n\n        jp.close();\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-70": {
    "id": "JacksonDatabind-70",
    "project": "JacksonDatabind",
    "number": "70",
    "buggy_function": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n            //   as only former is lower-case in case-insensitive case\n            found = key.equals(prop.getName());\n            if (found) {\n                // need to leave a hole here\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}",
    "fixed_function": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n            //   as only former is lower-case in case-insensitive case\n            found = key.equals(_hashArea[i-1]);\n            if (found) {\n                // need to leave a hole here\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java",
      "first_line": 426,
      "last_line": 453
    },
    "javadoc": "/**\n* Specialized method for removing specified existing entry.\n* NOTE: entry MUST exist, otherwise an exception is thrown.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.struct.TestUnwrapped::testCaseInsensitiveUnwrap": {
        "source": "    public void testCaseInsensitiveUnwrap() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n\n        Person p = mapper.readValue(\"{ }\", Person.class);\n\n        assertNotNull(p);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-71": {
    "id": "JacksonDatabind-71",
    "project": "JacksonDatabind",
    "number": "71",
    "buggy_function": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n\n    // first common types:\n    if (raw == String.class || raw == Object.class) {\n        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    // then less common ones...\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}",
    "fixed_function": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n\n    // first common types:\n    if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    // then less common ones...\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
      "first_line": 70,
      "last_line": 116
    },
    "javadoc": "/**\n* Some types that are deserialized using a helper deserializer.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestMapDeserialization::testcharSequenceKeyMap": {
        "source": "    public void testcharSequenceKeyMap() throws Exception {\n\n        String JSON = aposToQuotes(\"{'a':'b'}\");\n\n        Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { });\n\n        assertNotNull(result);\n\n        assertEquals(1, result.size());\n\n        assertEquals(\"b\", result.get(\"a\"));\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-74": {
    "id": "JacksonDatabind-74",
    "project": "JacksonDatabind",
    "number": "74",
    "buggy_function": "protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n        TokenBuffer tb) throws IOException\n{\n    // As per [JACKSON-614], may have default implementation to use\n    JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n    if (deser != null) {\n        if (tb != null) {\n            tb.writeEndObject();\n            p = tb.asParser(p);\n            // must move to point to the first token:\n            p.nextToken();\n        }\n        return deser.deserialize(p, ctxt);\n    }\n    // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n    Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n    if (result != null) {\n        return result;\n    }\n    // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n    if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n        return super.deserializeTypedFromAny(p, ctxt);\n    }\n    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n            \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    return null;\n}",
    "fixed_function": "protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n        TokenBuffer tb) throws IOException\n{\n    // As per [JACKSON-614], may have default implementation to use\n    JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n    if (deser != null) {\n        if (tb != null) {\n            tb.writeEndObject();\n            p = tb.asParser(p);\n            // must move to point to the first token:\n            p.nextToken();\n        }\n        return deser.deserialize(p, ctxt);\n    }\n    // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n    Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n    if (result != null) {\n        return result;\n    }\n    // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n    if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n        return super.deserializeTypedFromAny(p, ctxt);\n    } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n            String str = p.getText().trim();\n            if (str.isEmpty()) {\n                return null;\n            }\n        }\n    }\n    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n            \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java",
      "first_line": 134,
      "last_line": 160
    },
    "javadoc": "// off-lined to keep main method lean and mean...",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl::testWithEmptyStringAsNullObject1533": {
        "source": "    public void testWithEmptyStringAsNullObject1533() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper().enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n\n        AsPropertyWrapper wrapper = mapper.readValue(\"{ \\\"value\\\": \\\"\\\" }\", AsPropertyWrapper.class);\n\n        assertNull(wrapper.value);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-76": {
    "id": "JacksonDatabind-76",
    "project": "JacksonDatabind",
    "number": "76",
    "buggy_function": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                t = p.nextToken();\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                    continue;\n                }\n                while (t == JsonToken.FIELD_NAME) {\n                    p.nextToken();\n                    tokens.copyCurrentStructure(p);\n                    t = p.nextToken();\n                }\n                tokens.writeEndObject();\n                if (bean.getClass() != _beanType.getRawClass()) {\n                    ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT, so:\n    Object bean;\n    // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
    "fixed_function": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT, so:\n    Object bean;\n    // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java",
      "first_line": 566,
      "last_line": 637
    },
    "javadoc": "// how about any setter? We'll get copies but...",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.builder.BuilderWithUnwrappedTest::testWithUnwrappedAndCreatorSingleParameterAtBeginning": {
        "source": "    public void testWithUnwrappedAndCreatorSingleParameterAtBeginning() throws Exception {\n\n        final String json = aposToQuotes(\"{'person_id':1234,'first_name':'John','last_name':'Doe','years_old':30,'living':true}\");\n\n\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        Person person = mapper.readValue(json, Person.class);\n\n        assertEquals(1234, person.getId());\n\n        assertNotNull(person.getName());\n\n        assertEquals(\"John\", person.getName().getFirst());\n\n        assertEquals(\"Doe\", person.getName().getLast());\n\n        assertEquals(30, person.getAge());\n\n        assertEquals(true, person.isAlive());\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.deser.builder.BuilderWithUnwrappedTest::testWithUnwrappedAndCreatorMultipleParametersAtBeginning": {
        "source": "    public void testWithUnwrappedAndCreatorMultipleParametersAtBeginning() throws Exception {\n\n        final String json = aposToQuotes(\"{'animal_id':1234,'living':true,'first_name':'John','last_name':'Doe','years_old':30}\");\n\n\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        Animal animal = mapper.readValue(json, Animal.class);\n\n        assertEquals(1234, animal.getId());\n\n        assertNotNull(animal.getName());\n\n        assertEquals(\"John\", animal.getName().getFirst());\n\n        assertEquals(\"Doe\", animal.getName().getLast());\n\n        assertEquals(30, animal.getAge());\n\n        assertEquals(true, animal.isAlive());\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.deser.builder.BuilderWithUnwrappedTest::testWithUnwrappedAndCreatorSingleParameterInMiddle": {
        "source": "    public void testWithUnwrappedAndCreatorSingleParameterInMiddle() throws Exception {\n\n        final String json = aposToQuotes(\"{'first_name':'John','last_name':'Doe','person_id':1234,'years_old':30,'living':true}\");\n\n\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        Person person = mapper.readValue(json, Person.class);\n\n        assertEquals(1234, person.getId());\n\n        assertNotNull(person.getName());\n\n        assertEquals(\"John\", person.getName().getFirst());\n\n        assertEquals(\"Doe\", person.getName().getLast());\n\n        assertEquals(30, person.getAge());\n\n        assertEquals(true, person.isAlive());\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.deser.builder.BuilderWithUnwrappedTest::testWithUnwrappedAndCreatorMultipleParametersInMiddle": {
        "source": "    public void testWithUnwrappedAndCreatorMultipleParametersInMiddle() throws Exception {\n\n        final String json = aposToQuotes(\"{'first_name':'John','animal_id':1234,'last_name':'Doe','living':true,'years_old':30}\");\n\n\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        Animal animal = mapper.readValue(json, Animal.class);\n\n        assertEquals(1234, animal.getId());\n\n        assertNotNull(animal.getName());\n\n        assertEquals(\"John\", animal.getName().getFirst());\n\n        assertEquals(\"Doe\", animal.getName().getLast());\n\n        assertEquals(30, animal.getAge());\n\n        assertEquals(true, animal.isAlive());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-8": {
    "id": "JacksonDatabind-8",
    "project": "JacksonDatabind",
    "number": "8",
    "buggy_function": "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n{\n    final int mask = (1 << typeIndex);\n    _hasNonDefaultCreator = true;\n    AnnotatedWithParams oldOne = _creators[typeIndex];\n    // already had an explicitly marked one?\n    if (oldOne != null) {\n\n        if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n            // but skip, if new one not annotated\n            if (!explicit) {\n                return;\n            }\n            // both explicit: verify\n            // otherwise only verify if neither explicitly annotated.\n        }\n\n        // one more thing: ok to override in sub-class\n        if (oldOne.getClass() == newOne.getClass()) {\n            // [databind#667]: avoid one particular class of bogus problems\n\n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            // otherwise, which one to choose?\n                // new type more generic, use old\n            // new type more specific, use it\n        }\n    }\n    if (explicit) {\n        _explicitCreators |= mask;\n    }\n    _creators[typeIndex] = _fixAccess(newOne);\n}",
    "fixed_function": "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n{\n    final int mask = (1 << typeIndex);\n    _hasNonDefaultCreator = true;\n    AnnotatedWithParams oldOne = _creators[typeIndex];\n    // already had an explicitly marked one?\n    if (oldOne != null) {\n        boolean verify;\n\n        if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n            // but skip, if new one not annotated\n            if (!explicit) {\n                return;\n            }\n            // both explicit: verify\n            verify = true;\n        } else {\n            // otherwise only verify if neither explicitly annotated.\n            verify = !explicit;\n        }\n\n        // one more thing: ok to override in sub-class\n        if (verify && (oldOne.getClass() == newOne.getClass())) {\n            // [databind#667]: avoid one particular class of bogus problems\n            Class<?> oldType = oldOne.getRawParameterType(0);\n            Class<?> newType = newOne.getRawParameterType(0);\n\n            if (oldType == newType) {\n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            }\n            // otherwise, which one to choose?\n            if (newType.isAssignableFrom(oldType)) {\n                // new type more generic, use old\n                return;\n            }\n            // new type more specific, use it\n        }\n    }\n    if (explicit) {\n        _explicitCreators |= mask;\n    }\n    _creators[typeIndex] = _fixAccess(newOne);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java",
      "first_line": 276,
      "last_line": 308
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestJdkTypes::testStringBuilder": {
        "source": "    public void testStringBuilder() throws Exception\n\n    {\n\n        StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class);\n\n        assertEquals(\"abc\", sb.toString());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-82": {
    "id": "JacksonDatabind-82",
    "project": "JacksonDatabind",
    "number": "82",
    "buggy_function": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    \n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    }\n    else {\n    \tanySetterField = beanDesc.findAnySetterField();\n    \tif(anySetterField != null) {\n    \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n    \t}\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    \n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            /* If property is passed via constructor parameter, we must\n             * handle things in special way. Not sure what is the most optimal way...\n             * for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
    "fixed_function": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    \n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.findIgnoredForDeserialization();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    }\n    else {\n    \tanySetterField = beanDesc.findAnySetterField();\n    \tif(anySetterField != null) {\n    \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n    \t}\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    \n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            /* If property is passed via constructor parameter, we must\n             * handle things in special way. Not sure what is the most optimal way...\n             * for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "first_line": 472,
      "last_line": 615
    },
    "javadoc": "/**\n* Method called to figure out settable properties for the\n* bean deserializer to use.\n*<p>\n* Note: designed to be overridable, and effort is made to keep interface\n* similar between versions.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.filter.IgnorePropertyOnDeserTest::testIgnoreGetterNotSetter1595": {
        "source": "    public void testIgnoreGetterNotSetter1595() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        Simple1595 config = new Simple1595();\n\n        config.setId(123);\n\n        config.setName(\"jack\");\n\n        String json = mapper.writeValueAsString(config);\n\n        assertEquals(aposToQuotes(\"{'id':123}\"), json);\n\n        Simple1595 des = mapper.readValue(aposToQuotes(\"{'id':123,'name':'jack'}\"), Simple1595.class);\n\n        assertEquals(\"jack\", des.getName());\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-83": {
    "id": "JacksonDatabind-83",
    "project": "JacksonDatabind",
    "number": "83",
    "buggy_function": "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String text = p.getValueAsString();\n    if (text != null) { // has String representation\n        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception cause = null;\n        try {\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            if (_deserialize(text, ctxt) != null) {\n            return _deserialize(text, ctxt);\n            }\n        } catch (IllegalArgumentException iae) {\n            cause = iae;\n        } catch (MalformedURLException me) {\n            cause = me;\n        }\n        String msg = \"not a valid textual representation\";\n        if (cause != null) {\n            String m2 = cause.getMessage();\n            if (m2 != null) {\n                msg = msg + \", problem: \"+m2;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n        if (cause != null) {\n            e.initCause(cause);\n        }\n        throw e;\n        // nothing to do here, yet? We'll fail anyway\n    }\n    JsonToken t = p.getCurrentToken();\n    // [databind#381]\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}",
    "fixed_function": "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String text = p.getValueAsString();\n    if (text != null) { // has String representation\n        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception cause = null;\n        try {\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            return _deserialize(text, ctxt);\n        } catch (IllegalArgumentException iae) {\n            cause = iae;\n        } catch (MalformedURLException me) {\n            cause = me;\n        }\n        String msg = \"not a valid textual representation\";\n        if (cause != null) {\n            String m2 = cause.getMessage();\n            if (m2 != null) {\n                msg = msg + \", problem: \"+m2;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n        if (cause != null) {\n            e.initCause(cause);\n        }\n        throw e;\n        // nothing to do here, yet? We'll fail anyway\n    }\n    JsonToken t = p.getCurrentToken();\n    // [databind#381]\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java",
      "first_line": 105,
      "last_line": 159
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.filter.ProblemHandlerTest::testWeirdStringHandling": {
        "source": "    public void testWeirdStringHandling() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper()\n\n            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))\n\n            ;\n\n        SingleValuedEnum result = mapper.readValue(\"\\\"B\\\"\", SingleValuedEnum.class);\n\n        assertEquals(SingleValuedEnum.A, result);\n\n\n\n        // also, write [databind#1629] try this\n\n        mapper = new ObjectMapper()\n\n                .addHandler(new WeirdStringHandler(null));\n\n        UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class);\n\n        assertNull(result2);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-85": {
    "id": "JacksonDatabind-85",
    "project": "JacksonDatabind",
    "number": "85",
    "buggy_function": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n\n\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n//            serializers.reportBadDefinition(handledType(), String.format(\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        return this;\n    }",
    "fixed_function": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n//            serializers.reportBadDefinition(handledType(), String.format(\n            serializers.reportMappingProblem(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\",\ndf0.getClass().getName());\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java",
      "first_line": 49,
      "last_line": 95
    },
    "javadoc": "/**\n* Specific format to use, if not default format: non null value\n* also indicates that serialization is to be done as JSON String,\n* not numeric timestamp, unless {@link #_useTimestamp} is true.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern": {
        "source": "    public void testFormatWithoutPattern() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\"));\n\n        String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01X01:00:00'}\"), json);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-88": {
    "id": "JacksonDatabind-88",
    "project": "JacksonDatabind",
    "number": "88",
    "buggy_function": "protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = tf.constructFromCanonical(id);\n            // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}",
    "fixed_function": "protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n            throw new IllegalArgumentException(String.format(\n                    \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java",
      "first_line": 45,
      "last_line": 78
    },
    "javadoc": "// not used with class name - based resolvers",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test::testNestedTypeCheck1735": {
        "source": "    public void testNestedTypeCheck1735() throws Exception\n\n    {\n\n        try {\n\n            MAPPER.readValue(aposToQuotes(\n\n\"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}\"),\n\n                    Wrapper1735.class);\n\n            fail(\"Should not pass\");\n\n        } catch (JsonMappingException e) {\n\n            verifyException(e, \"not subtype of\");\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-9": {
    "id": "JacksonDatabind-9",
    "project": "JacksonDatabind",
    "number": "9",
    "buggy_function": "public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n    String str;\n    \n    if (value instanceof Date) {\n        provider.defaultSerializeDateKey((Date) value, jgen);\n        return;\n    } else {\n        str = value.toString();\n    }\n    jgen.writeFieldName(str);\n}",
    "fixed_function": "public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n    String str;\n    Class<?> cls = value.getClass();\n    \n    if (cls == String.class) {\n        str = (String) value;\n    } else if (Date.class.isAssignableFrom(cls)) {\n        provider.defaultSerializeDateKey((Date) value, jgen);\n        return;\n    } else if (cls == Class.class) {\n        str = ((Class<?>) value).getName();\n    } else {\n        str = value.toString();\n    }\n    jgen.writeFieldName(str);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java",
      "first_line": 25,
      "last_line": 35
    },
    "javadoc": "/**\n* Specialized serializer that can be used as the generic key\n* serializer, when serializing {@link java.util.Map}s to JSON\n* Objects.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.TestMapSerialization::testClassKey": {
        "source": "    public void testClassKey() throws IOException\n\n    {\n\n        Map<Class<?>,Integer> map = new LinkedHashMap<Class<?>,Integer>();\n\n        map.put(String.class, 2);\n\n        String json = MAPPER.writeValueAsString(map);\n\n        assertEquals(aposToQuotes(\"{'java.lang.String':2}\"), json);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-91": {
    "id": "JacksonDatabind-91",
    "project": "JacksonDatabind",
    "number": "91",
    "buggy_function": "private boolean _hasCustomHandlers(JavaType t) {\n    if (t.isContainerType()) {\n        // First: value types may have both value and type handlers\n        JavaType ct = t.getContentType();\n        if (ct != null) {\n            return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n        // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n        }\n    }\n    return false;\n}",
    "fixed_function": "private boolean _hasCustomHandlers(JavaType t) {\n    if (t.isContainerType()) {\n        // First: value types may have both value and type handlers\n        JavaType ct = t.getContentType();\n        if (ct != null) {\n            if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                return true;\n            }\n        }\n        // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n        if (t.isMapLikeType()) {\n            JavaType kt = t.getKeyType();\n            if (kt.getValueHandler() != null) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
      "first_line": 536,
      "last_line": 546
    },
    "javadoc": "/**\n* Helper method used to prevent both caching and cache lookups for structured\n* types that have custom value handlers\n*\n* @since 2.8.11\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest::testCachedSerialize": {
        "source": "    public void testCachedSerialize() throws IOException {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        String json = aposToQuotes(\"{'data':{'1st':'onedata','2nd':'twodata'}}\");\n\n\n\n        // Do deserialization with non-annotated map property\n\n        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);\n\n        assertTrue(ignored.data.containsKey(\"1st\"));\n\n        assertTrue(ignored.data.containsKey(\"2nd\"));\n\n\n\n//mapper = new ObjectMapper();\n\n        \n\n        MapHolder model2 = mapper.readValue(json, MapHolder.class);\n\n        if (!model2.data.containsKey(\"1st (CUSTOM)\")\n\n            || !model2.data.containsKey(\"2nd (CUSTOM)\")) {\n\n            fail(\"Not using custom key deserializer for input: \"+json+\"; resulted in: \"+model2.data);\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-93": {
    "id": "JacksonDatabind-93",
    "project": "JacksonDatabind",
    "number": "93",
    "buggy_function": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    // There are certain nasty classes that could cause problems, mostly\n    // via default typing -- catch them here.\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n\n        // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n        //    for some Spring framework types\n        // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n                String name = cls.getSimpleName();\n                // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                if (\"AbstractPointcutAdvisor\".equals(name)\n                        // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                        || \"AbstractApplicationContext\".equals(name)) {\n                    break main_check;\n                }\n            }\n        }\n        return;\n    } while (false);\n\n    throw JsonMappingException.from(ctxt,\n            String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n}",
    "fixed_function": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    // There are certain nasty classes that could cause problems, mostly\n    // via default typing -- catch them here.\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n\n        // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n        //    for some Spring framework types\n        // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n        if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                String name = cls.getSimpleName();\n                // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                if (\"AbstractPointcutAdvisor\".equals(name)\n                        // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                        || \"AbstractApplicationContext\".equals(name)) {\n                    break main_check;\n                }\n            }\n        }\n        return;\n    } while (false);\n\n    throw JsonMappingException.from(ctxt,\n            String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java",
      "first_line": 67,
      "last_line": 99
    },
    "javadoc": "/**\n* Set of class names of types that are never to be deserialized.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testJDKTypes1872": {
        "source": "    public void testJDKTypes1872() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n    \n\n        String json = aposToQuotes(String.format(\"{'@class':'%s','authorities':['java.util.ArrayList',[]]}\",\n\n                Authentication1872.class.getName()));\n\n        Authentication1872 result = mapper.readValue(json, Authentication1872.class);\n\n        assertNotNull(result);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-96": {
    "id": "JacksonDatabind-96",
    "project": "JacksonDatabind",
    "number": "96",
    "buggy_function": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n    if (1 != candidate.paramCount()) {\n        // Ok: for delegates, we want one and exactly one parameter without\n        // injection AND without name\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            // getting close; but most not have name\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n    // If there's injection or explicit name, should be properties-based\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n        // One more thing: if implicit name matches property with a getter\n        // or field, we'll consider it property-based as well\n\n        // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n        //    not implicit name, but name with possible strategy-based-rename\n          paramName = candidate.findImplicitParamName(0);\n        paramName = candidate.findImplicitParamName(0);\n        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n    // one more thing: sever link to creator property, to avoid possible later\n    // problems with \"unresolved\" constructor property\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}",
    "fixed_function": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n    if (1 != candidate.paramCount()) {\n        // Ok: for delegates, we want one and exactly one parameter without\n        // injection AND without name\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            // getting close; but most not have name\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n    // If there's injection or explicit name, should be properties-based\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n        // One more thing: if implicit name matches property with a getter\n        // or field, we'll consider it property-based as well\n\n        // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n        //    not implicit name, but name with possible strategy-based-rename\n          paramName = candidate.findImplicitParamName(0);\n        paramName = candidate.paramName(0);\n        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n    // one more thing: sever link to creator property, to avoid possible later\n    // problems with \"unresolved\" constructor property\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "first_line": 701,
      "last_line": 752
    },
    "javadoc": "/**\n* Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n*\n* @since 2.9.2\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest::testSnakeCaseWithOneArg": {
        "source": "    public void testSnakeCaseWithOneArg() throws Exception\n\n    {\n\n        final String MSG = \"1st\";\n\n        OneProperty actual = MAPPER.readValue(\n\n                \"{\\\"param_name0\\\":\\\"\"+MSG+\"\\\"}\",\n\n                OneProperty.class);\n\n        assertEquals(\"CTOR:\"+MSG, actual.paramName0);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-97": {
    "id": "JacksonDatabind-97",
    "project": "JacksonDatabind",
    "number": "97",
    "buggy_function": "public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n        //    this to preserve contextual information\n        gen.writeObject(_value);\n    }\n}",
    "fixed_function": "public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n        //    this to preserve contextual information\n        ctxt.defaultSerializeValue(_value, gen);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/node/POJONode.java",
      "first_line": 105,
      "last_line": 116
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.node.POJONodeTest::testPOJONodeCustomSer": {
        "source": "    public void testPOJONodeCustomSer() throws Exception\n\n    {\n\n      Data data = new Data();\n\n      data.aStr = \"Hello\";\n\n\n\n      Map<String, Object> mapTest = new HashMap<>();\n\n      mapTest.put(\"data\", data);\n\n\n\n      ObjectNode treeTest = MAPPER.createObjectNode();\n\n      treeTest.putPOJO(\"data\", data);\n\n\n\n      final String EXP = \"{\\\"data\\\":{\\\"aStr\\\":\\\"The value is: Hello!\\\"}}\";\n\n      \n\n      String mapOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(mapTest);\n\n      assertEquals(EXP, mapOut);\n\n\n\n      String treeOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);\n\n      assertEquals(EXP, treeOut);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-98": {
    "id": "JacksonDatabind-98",
    "project": "JacksonDatabind",
    "number": "98",
    "buggy_function": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
    "fixed_function": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                final Object v;\n                if (typeProp.getType().hasRawClass(String.class)) {\n                    v = typeId;\n                } else {\n                    TokenBuffer tb = new TokenBuffer(p, ctxt);\n                    tb.writeString(typeId);\n                    v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt);\n                    tb.close();\n                }\n                buffer.assignParameter(typeProp, v);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java",
      "first_line": 255,
      "last_line": 311
    },
    "javadoc": "/**\n* Variant called when creation of the POJO involves buffering of creator properties\n* as well as property-based creator.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdWithEnum1328Test::testExample": {
        "source": "    public void testExample() throws Exception {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        \n\n        String json = mapper.writerWithDefaultPrettyPrinter()\n\n                .writeValueAsString(Arrays.asList(new AnimalAndType(AnimalType.Dog, new Dog())));\n\n        List<AnimalAndType> list = mapper.readerFor(new TypeReference<List<AnimalAndType>>() { })\n\n            .readValue(json);\n\n        assertNotNull(list);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-99": {
    "id": "JacksonDatabind-99",
    "project": "JacksonDatabind",
    "number": "99",
    "buggy_function": "protected String buildCanonicalName()\n{\n    StringBuilder sb = new StringBuilder();\n    sb.append(_class.getName());\n    sb.append('<');\n    sb.append(_referencedType.toCanonical());\n    return sb.toString();\n}",
    "fixed_function": "protected String buildCanonicalName()\n{\n    StringBuilder sb = new StringBuilder();\n    sb.append(_class.getName());\n    sb.append('<');\n    sb.append(_referencedType.toCanonical());\n    sb.append('>');\n    return sb.toString();\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java",
      "first_line": 163,
      "last_line": 170
    },
    "javadoc": "// !!! TODO: missing supertypes",
    "failing_tests": {
      "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames": {
        "source": "    public void testCanonicalNames()\n\n    {\n\n        TypeFactory tf = TypeFactory.defaultInstance();\n\n        JavaType t = tf.constructType(java.util.Calendar.class);\n\n        String can = t.toCanonical();\n\n        assertEquals(\"java.util.Calendar\", can);\n\n        assertEquals(t, tf.constructFromCanonical(can));\n\n\n\n        // Generic maps and collections will default to Object.class if type-erased\n\n        t = tf.constructType(java.util.ArrayList.class);\n\n        can = t.toCanonical();\n\n        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n\n        assertEquals(t, tf.constructFromCanonical(can));\n\n\n\n        t = tf.constructType(java.util.TreeMap.class);\n\n        can = t.toCanonical();\n\n        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n\n        assertEquals(t, tf.constructFromCanonical(can));\n\n\n\n        // And then EnumMap (actual use case for us)\n\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n\n        can = t.toCanonical();\n\n        assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n\n                can);\n\n        assertEquals(t, tf.constructFromCanonical(can));\n\n\n\n        // [databind#2109]: also ReferenceTypes\n\n        t = tf.constructType(new TypeReference<AtomicReference<Long>>() { });\n\n        can = t.toCanonical();\n\n        assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\",\n\n                can);\n\n        assertEquals(t, tf.constructFromCanonical(can));\n\n\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n\n        assertEquals(List.class, t.getRawClass());\n\n        assertEquals(CollectionType.class, t.getClass());\n\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n\n        //    But currently we do NOT get any\n\n        /*\n\n        assertEquals(1, t.containedTypeCount());\n\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n\n        */\n\n        assertEquals(Object.class, t.getContentType().getRawClass());\n\n        can = t.toCanonical();\n\n        assertEquals(\"java.util.List<java.lang.Object>\", can);\n\n        assertEquals(t, tf.constructFromCanonical(can));\n\n    }\n"
      }
    }
  },
  "JacksonXml-1": {
    "id": "JacksonXml-1",
    "project": "JacksonXml",
    "number": "1",
    "buggy_function": "public JsonToken nextToken() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default: // VALUE_STRING, VALUE_NULL\n            // should be fine as is?\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        // Simple, except that if this is a leaf, need to suppress end:\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n            return (_currToken = JsonToken.VALUE_NULL);\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        return _currToken;\n        \n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n        return (_currToken = JsonToken.FIELD_NAME);\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currText = _xmlTokens.getText();\n        return (_currToken = JsonToken.VALUE_STRING);\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            /* One more refinement (pronunced like \"hack\") is that if\n             * we had an empty String (or all white space), and we are\n             * deserializing an array, we better hide the empty text.\n             */\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n            if (_parsingContext.inArray()) {\n                if (_isEmpty(_currText)) {\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null (or, worse, as used to\n                    //    be done, by swallowing the token)\n                    _currToken = JsonToken.END_ARRAY;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            return (_currToken = JsonToken.VALUE_STRING);\n        } else {\n            // [dataformat-xml#177]: empty text may also need to be skipped\n            if (_parsingContext.inObject()\n                    && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                _currToken = JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n            }\n        }\n        // If not a leaf (or otherwise ignorable), need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        return (_currToken = JsonToken.FIELD_NAME);\n    case XmlTokenStream.XML_END:\n        return (_currToken = null);\n    }\n    \n    // should never get here\n    _throwInternal();\n    return null;\n}",
    "fixed_function": "public JsonToken nextToken() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default: // VALUE_STRING, VALUE_NULL\n            // should be fine as is?\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        // Simple, except that if this is a leaf, need to suppress end:\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            if (_parsingContext.inArray()) {\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                _nextToken = JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            return (_currToken = JsonToken.VALUE_NULL);\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        return _currToken;\n        \n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n        return (_currToken = JsonToken.FIELD_NAME);\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currText = _xmlTokens.getText();\n        return (_currToken = JsonToken.VALUE_STRING);\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            /* One more refinement (pronunced like \"hack\") is that if\n             * we had an empty String (or all white space), and we are\n             * deserializing an array, we better hide the empty text.\n             */\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n            if (_parsingContext.inArray()) {\n                if (_isEmpty(_currText)) {\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null (or, worse, as used to\n                    //    be done, by swallowing the token)\n                    _nextToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n            }\n            return (_currToken = JsonToken.VALUE_STRING);\n        } else {\n            // [dataformat-xml#177]: empty text may also need to be skipped\n            if (_parsingContext.inObject()\n                    && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                _currToken = JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n            }\n        }\n        // If not a leaf (or otherwise ignorable), need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        return (_currToken = JsonToken.FIELD_NAME);\n    case XmlTokenStream.XML_END:\n        return (_currToken = null);\n    }\n    \n    // should never get here\n    _throwInternal();\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java",
      "first_line": 445,
      "last_line": 578
    },
    "javadoc": "/**\n* Since xml representation can not really distinguish between array\n* and object starts (both are represented with elements), this method\n* is overridden and taken to mean that expecation is that the current\n* start element is to mean 'start array', instead of default of\n* 'start object'.\n*/\n@Override\npublic boolean isExpectedStartArrayToken()\n{\nJsonToken t = _currToken;\nif (t == JsonToken.START_OBJECT) {\n_currToken = JsonToken.START_ARRAY;\n// Ok: must replace current context with array as well\n_parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n// And just in case a field name was to be returned, wipe it\n_nextToken = null;\n// and last thing, [dataformat-xml#33], better ignore attributes\n_xmlTokens.skipAttributes();\nreturn true;\n}\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\nreturn (t == JsonToken.START_ARRAY);\n}\n\n// DEBUGGING\n/*\n@Override\npublic JsonToken nextToken() throws IOException\n{\nJsonToken t = nextToken0();\nif (t != null) {\nswitch (t) {\ncase FIELD_NAME:\nSystem.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\nbreak;\ncase VALUE_STRING:\nSystem.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\nbreak;\ndefault:\nSystem.out.println(\"JsonToken: \"+t);\n}\n}\nreturn t;\n}\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedLists180Test::testNestedUnwrappedLists180": {
        "source": "    public void testNestedUnwrappedLists180() throws Exception\n\n    {\n\n        /*\n\n        Records recs = new Records();\n\n        recs.records.add(new Record());\n\n        recs.records.add(new Record());\n\n        recs.records.add(new Record());\n\n        recs.records.get(0).fields.add(new Field(\"a\"));\n\n        recs.records.get(2).fields.add(new Field(\"b\"));\n\n\n\n        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n\n        */\n\n\n\n        String xml =\n\n\"<Records>\\n\"\n\n// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n\n//+\"<records>\\n</records>\\n\"\n\n+\"<records></records>\\n\"\n\n+\"  <records>\\n\"\n\n+\"   <fields name='b'/>\\n\"\n\n+\"  </records>\\n\"\n\n+\"</Records>\\n\"\n\n;\n\n        \n\n//System.out.println(\"XML: \"+xml);\n\n\n\n        Records result = MAPPER.readValue(xml, Records.class);\n\n        assertNotNull(result.records);\n\n        assertEquals(2, result.records.size());\n\n        assertNotNull(result.records.get(1));\n\n        assertEquals(1, result.records.get(1).fields.size());\n\n        assertEquals(\"b\", result.records.get(1).fields.get(0).name);\n\n\n\n        // also, first one ought not be null should it? Ideally not...\n\n        assertNotNull(result.records.get(0));\n\n    }\n"
      },
      "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest::testNestedWithEmpty2": {
        "source": "    public void testNestedWithEmpty2() throws Exception\n\n    {\n\n        final String XML =\n\n\"<ServiceDelivery>\\n\"\n\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n\n+\"  <VehicleMonitoringDelivery>\\n\"\n\n+\"    <VehicleActivity>\\n\"\n\n+\"    </VehicleActivity>\\n\"\n\n+\"  </VehicleMonitoringDelivery>\\n\"\n\n+\"</ServiceDelivery>\\n\"\n\n                ;\n\n        \n\n        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n\n        assertNotNull(svc);\n\n        assertNotNull(svc.vehicleMonitoringDelivery);\n\n        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n\n        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n\n        assertNotNull(del.vehicleActivity);\n\n        // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n\n        assertEquals(1, del.vehicleActivity.size());\n\n    }\n"
      },
      "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest::testNestedWithEmpty": {
        "source": "    public void testNestedWithEmpty() throws Exception\n\n    {\n\n        final String XML =\n\n\"<ServiceDelivery>\\n\"\n\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n\n+\"  <VehicleMonitoringDelivery>\\n\"\n\n+\"  </VehicleMonitoringDelivery>\\n\"\n\n+\"</ServiceDelivery>\\n\"\n\n                ;\n\n        \n\n        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n\n        assertNotNull(svc);\n\n        assertNotNull(svc.vehicleMonitoringDelivery);\n\n        // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n\n        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n\n    }\n"
      }
    }
  },
  "JacksonXml-3": {
    "id": "JacksonXml-3",
    "project": "JacksonXml",
    "number": "3",
    "buggy_function": "public String nextTextValue() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (t == JsonToken.VALUE_STRING) {\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // mostly copied from 'nextToken()'\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        if (_mayBeLeaf) {\n            // NOTE: this is different from nextToken() -- produce \"\", NOT null\n            _mayBeLeaf = false;\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = \"\");\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n        } else {\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currText = _xmlTokens.getText();\n        _currToken = JsonToken.VALUE_STRING;\n        break;\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n\n            // NOTE: this is different from nextToken() -- NO work-around\n            // for otherwise empty List/array\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        }\n        // If not a leaf, need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        _currToken = JsonToken.FIELD_NAME;\n        break;\n    case XmlTokenStream.XML_END:\n        _currToken = null;\n    }\n    return null;\n}",
    "fixed_function": "public String nextTextValue() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (t == JsonToken.VALUE_STRING) {\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // mostly copied from 'nextToken()'\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        if (_mayBeLeaf) {\n            // NOTE: this is different from nextToken() -- produce \"\", NOT null\n            _mayBeLeaf = false;\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = \"\");\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n        } else {\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currToken = JsonToken.VALUE_STRING;\n        return (_currText = _xmlTokens.getText());\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n\n            // NOTE: this is different from nextToken() -- NO work-around\n            // for otherwise empty List/array\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        }\n        // If not a leaf, need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        _currToken = JsonToken.FIELD_NAME;\n        break;\n    case XmlTokenStream.XML_END:\n        _currToken = null;\n    }\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java",
      "first_line": 601,
      "last_line": 693
    },
    "javadoc": "/**\n* Method overridden to support more reliable deserialization of\n* String collections.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest::testXmlAttributesWithNextTextValue": {
        "source": "    public void testXmlAttributesWithNextTextValue() throws Exception\n\n    {\n\n        final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\n\n\n\n        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n\n\n\n        // First: verify handling without forcing array handling:\n\n        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\n\n        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\n\n        assertEquals(\"max\", xp.getCurrentName());\n\n\n\n        assertEquals(\"7\", xp.nextTextValue());\n\n\n\n        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n\n        assertEquals(\"offset\", xp.getCurrentName());\n\n\n\n        assertEquals(\"offset\", xp.getText());\n\n\n\n        assertEquals(\"9\", xp.nextTextValue());\n\n\n\n        assertEquals(\"9\", xp.getText());\n\n\n\n        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n\n        xp.close();\n\n    }\n"
      }
    }
  },
  "JacksonXml-4": {
    "id": "JacksonXml-4",
    "project": "JacksonXml",
    "number": "4",
    "buggy_function": "protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n{\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n    //    configured root name...\n    if (jgen instanceof ToXmlGenerator) {\n        _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n    }\n    super.serializeValue(jgen, null);\n}",
    "fixed_function": "protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n{\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n    //    configured root name...\n    QName rootName = _rootNameFromConfig();\n    if (rootName == null) {\n        rootName = ROOT_NAME_FOR_NULL;\n    }\n    if (jgen instanceof ToXmlGenerator) {\n        _initWithRootName((ToXmlGenerator) jgen, rootName);\n    }\n    super.serializeValue(jgen, null);\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java",
      "first_line": 200,
      "last_line": 208
    },
    "javadoc": "// end of super-class implementation",
    "failing_tests": {
      "com.fasterxml.jackson.dataformat.xml.misc.RootNameTest::testDynamicRootName": {
        "source": "    public void testDynamicRootName() throws IOException\n\n    {\n\n        String xml;\n\n\n\n        ObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\n\n\n\n        xml = w.writeValueAsString(new StringBean(\"foo\"));\n\n        assertEquals(\"<rudy><text>foo</text></rudy>\", xml);\n\n\n\n        xml = w.writeValueAsString(new StringBean(null));\n\n        assertEquals(\"<rudy><text/></rudy>\", xml);\n\n\n\n        // and even with null will respect configured root name\n\n        xml = w.writeValueAsString(null);\n\n        assertEquals(\"<rudy/>\", xml);\n\n    }\n"
      }
    }
  },
  "JacksonXml-5": {
    "id": "JacksonXml-5",
    "project": "JacksonXml",
    "number": "5",
    "buggy_function": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n    //    root name lookup as that may link back to diff version, configuration\n    _rootNameLookup = src._rootNameLookup;\n}",
    "fixed_function": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n    //    root name lookup as that may link back to diff version, configuration\n    _rootNameLookup = new XmlRootNameLookup();\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java",
      "first_line": 55,
      "last_line": 60
    },
    "javadoc": "/**\n* @since 2.8.9\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.dataformat.xml.MapperCopyTest::testCopyWith": {
        "source": "    public void testCopyWith() throws Exception\n\n    {\n\n        XmlMapper xmlMapper = newMapper();\n\n        final ObjectMapper xmlMapperNoAnno = xmlMapper.copy()\n\n                .disable(MapperFeature.USE_ANNOTATIONS)\n\n                .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n\n\n\n        String xml1 = xmlMapper.writeValueAsString(new Pojo282());\n\n        String xml2 = xmlMapperNoAnno.writeValueAsString(new Pojo282());\n\n\n\n        if (!xml1.contains(\"AnnotatedName\")) {\n\n            fail(\"Should use name 'AnnotatedName', xml = \"+xml1);\n\n        }\n\n        if (!xml2.contains(\"Pojo282\")\n\n                || xml2.contains(\"AnnotatedName\")) {\n\n            fail(\"Should NOT use name 'AnnotatedName' but 'Pojo282', xml = \"+xml1);\n\n        }\n\n    }\n"
      }
    }
  },
  "Jsoup-1": {
    "id": "Jsoup-1",
    "project": "Jsoup",
    "number": "1",
    "buggy_function": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(new TextNode(\" \", \"\"));\n        body().appendChild(node);\n    }\n}",
    "fixed_function": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().prependChild(node);\n        body().prependChild(new TextNode(\" \", \"\"));\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Document.java",
      "first_line": 113,
      "last_line": 128
    },
    "javadoc": "// does not recurse.",
    "failing_tests": {
      "org.jsoup.parser.ParserTest::createsStructureFromBodySnippet": {
        "source": "    @Test public void createsStructureFromBodySnippet() {\n\n        // the bar baz stuff naturally goes into the body, but the 'foo' goes into root, and the normalisation routine\n\n        // needs to move into the start of the body\n\n        String html = \"foo <b>bar</b> baz\";\n\n        Document doc = Jsoup.parse(html);\n\n        assertEquals (\"foo bar baz\", doc.text());\n\n\n\n    }\n"
      }
    }
  },
  "Jsoup-10": {
    "id": "Jsoup-10",
    "project": "Jsoup",
    "number": "10",
    "buggy_function": "public String absUrl(String attributeKey) {\n    Validate.notEmpty(attributeKey);\n\n    String relUrl = attr(attributeKey);\n    if (!hasAttr(attributeKey)) {\n        return \"\"; // nothing to make absolute with\n    } else {\n        URL base;\n        try {\n            try {\n                base = new URL(baseUri);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute may be abs on its own, so try that\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            }\n            // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n            URL abs = new URL(base, relUrl);\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    }\n}",
    "fixed_function": "public String absUrl(String attributeKey) {\n    Validate.notEmpty(attributeKey);\n\n    String relUrl = attr(attributeKey);\n    if (!hasAttr(attributeKey)) {\n        return \"\"; // nothing to make absolute with\n    } else {\n        URL base;\n        try {\n            try {\n                base = new URL(baseUri);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute may be abs on its own, so try that\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            }\n            // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n            if (relUrl.startsWith(\"?\"))\n                relUrl = base.getPath() + relUrl;\n            URL abs = new URL(base, relUrl);\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Node.java",
      "first_line": 156,
      "last_line": 179
    },
    "javadoc": "/**\n* Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n* <code>&lt;img src></code>).\n* <p/>\n* E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n* <p/>\n* If the attribute value is already absolute (i.e. it starts with a protocol, like\n* <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n* returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n* absolute using that.\n* <p/>\n* As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n* <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n*\n* @param attributeKey The attribute key\n* @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n* could not be made successfully into a URL.\n* @see #attr\n* @see java.net.URL#URL(java.net.URL, String)\n*/",
    "failing_tests": {
      "org.jsoup.nodes.NodeTest::absHandlesRelativeQuery": {
        "source": "    @Test public void absHandlesRelativeQuery() {\n\n        Document doc = Jsoup.parse(\"<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>\", \"http://jsoup.org/path/file?bar\");\n\n\n\n        Element a1 = doc.select(\"a\").first();\n\n        assertEquals(\"http://jsoup.org/path/file?foo\", a1.absUrl(\"href\"));\n\n\n\n        Element a2 = doc.select(\"a\").get(1);\n\n        assertEquals(\"http://jsoup.org/path/bar.html?foo\", a2.absUrl(\"href\"));\n\n    }\n"
      }
    }
  },
  "Jsoup-13": {
    "id": "Jsoup-13",
    "project": "Jsoup",
    "number": "13",
    "buggy_function": "public boolean hasAttr(String attributeKey) {\n    Validate.notNull(attributeKey);\n\n    return attributes.hasKey(attributeKey);\n}",
    "fixed_function": "public boolean hasAttr(String attributeKey) {\n    Validate.notNull(attributeKey);\n\n    if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n        String key = attributeKey.substring(\"abs:\".length());\n        if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n            return true;\n    }\n    return attributes.hasKey(attributeKey);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Node.java",
      "first_line": 104,
      "last_line": 108
    },
    "javadoc": "/**\n* Test if this element has an attribute.\n* @param attributeKey The attribute key to check.\n* @return true if the attribute exists, false if not.\n*/",
    "failing_tests": {
      "org.jsoup.nodes.NodeTest::handlesAbsPrefixOnHasAttr": {
        "source": "    @Test public void handlesAbsPrefixOnHasAttr() {\n\n        // 1: no abs url; 2: has abs url\n\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>\");\n\n        Element one = doc.select(\"#1\").first();\n\n        Element two = doc.select(\"#2\").first();\n\n\n\n        assertFalse(one.hasAttr(\"abs:href\"));\n\n        assertTrue(one.hasAttr(\"href\"));\n\n        assertEquals(\"\", one.absUrl(\"href\"));\n\n\n\n        assertTrue(two.hasAttr(\"abs:href\"));\n\n        assertTrue(two.hasAttr(\"href\"));\n\n        assertEquals(\"http://jsoup.org/\", two.absUrl(\"href\"));\n\n    }\n"
      },
      "org.jsoup.nodes.NodeTest::handlesAbsPrefix": {
        "source": "    @Test public void handlesAbsPrefix() {\n\n        Document doc = Jsoup.parse(\"<a href=/foo>Hello</a>\", \"http://jsoup.org/\");\n\n        Element a = doc.select(\"a\").first();\n\n        assertEquals(\"/foo\", a.attr(\"href\"));\n\n        assertEquals(\"http://jsoup.org/foo\", a.attr(\"abs:href\"));\n\n        assertTrue(a.hasAttr(\"abs:href\"));\n\n    }\n"
      },
      "org.jsoup.select.ElementsTest::absAttr": {
        "source": "    @Test public void absAttr() {\n\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>\");\n\n        Elements one = doc.select(\"#1\");\n\n        Elements two = doc.select(\"#2\");\n\n        Elements both = doc.select(\"a\");\n\n\n\n        assertEquals(\"\", one.attr(\"abs:href\"));\n\n        assertEquals(\"http://jsoup.org\", two.attr(\"abs:href\"));\n\n        assertEquals(\"http://jsoup.org\", both.attr(\"abs:href\"));\n\n    }\n"
      },
      "org.jsoup.select.ElementsTest::hasAbsAttr": {
        "source": "    @Test public void hasAbsAttr() {\n\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>\");\n\n        Elements one = doc.select(\"#1\");\n\n        Elements two = doc.select(\"#2\");\n\n        Elements both = doc.select(\"a\");\n\n        assertFalse(one.hasAttr(\"abs:href\"));\n\n        assertTrue(two.hasAttr(\"abs:href\"));\n\n        assertTrue(both.hasAttr(\"abs:href\")); // hits on #2\n\n    }\n"
      }
    }
  },
  "Jsoup-15": {
    "id": "Jsoup-15",
    "project": "Jsoup",
    "number": "15",
    "buggy_function": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                    \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                // todo: ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                Element form = tb.insert(startTag);\n                tb.setFormElement(form);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name,\n                    \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                // we're not supposed to ask.\n                startTag.name(\"img\");\n                return tb.process(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                TreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(\"rp\", \"rt\")) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name,\n                    \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                    \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                    \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                // todo: refactor these lookups\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name,\n                    \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    for (int si = 0; si < stack.size(); si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "fixed_function": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                    \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                // todo: ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                Element form = tb.insert(startTag);\n                tb.setFormElement(form);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name,\n                    \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                // we're not supposed to ask.\n                startTag.name(\"img\");\n                return tb.process(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                TreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(\"rp\", \"rt\")) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name,\n                    \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                    \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                    \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                // todo: refactor these lookups\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name,\n                    \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    for (int si = 0; si < stack.size(); si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/TreeBuilderState.java",
      "first_line": 246,
      "last_line": 761
    },
    "javadoc": "// skips some script rules as won't execute them",
    "failing_tests": {
      "org.jsoup.parser.ParserTest::handlesDataOnlyTags": {
        "source": "    @Test public void handlesDataOnlyTags() {\n\n        String t = \"<style>font-family: bold</style>\";\n\n        List<Element> tels = Jsoup.parse(t).getElementsByTag(\"style\");\n\n        assertEquals(\"font-family: bold\", tels.get(0).data());\n\n        assertEquals(\"\", tels.get(0).text());\n\n\n\n        String s = \"<p>Hello</p><script>obj.insert('<a rel=\\\"none\\\" />');\\ni++;</script><p>There</p>\";\n\n        Document doc = Jsoup.parse(s);\n\n        assertEquals(\"Hello There\", doc.text());\n\n        assertEquals(\"obj.insert('<a rel=\\\"none\\\" />');\\ni++;\", doc.data());\n\n    }\n"
      }
    }
  },
  "Jsoup-19": {
    "id": "Jsoup-19",
    "project": "Jsoup",
    "number": "19",
    "buggy_function": "private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n    // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n    // rels without a baseuri get removed\n    String value = el.absUrl(attr.getKey());\n    if (!preserveRelativeLinks)\n        attr.setValue(value);\n    \n    for (Protocol protocol : protocols) {\n        String prot = protocol.toString() + \":\";\n        if (value.toLowerCase().startsWith(prot)) {\n            return true;\n        }\n    }\n    return false;\n}",
    "fixed_function": "private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n    // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n    // rels without a baseuri get removed\n    String value = el.absUrl(attr.getKey());\n    if (value.length() == 0)\n        value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols\n    if (!preserveRelativeLinks)\n        attr.setValue(value);\n    \n    for (Protocol protocol : protocols) {\n        String prot = protocol.toString() + \":\";\n        if (value.toLowerCase().startsWith(prot)) {\n            return true;\n        }\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/safety/Whitelist.java",
      "first_line": 338,
      "last_line": 352
    },
    "javadoc": "// ok if not defined protocol; otherwise test",
    "failing_tests": {
      "org.jsoup.safety.CleanerTest::handlesCustomProtocols": {
        "source": "    @Test public void handlesCustomProtocols() {\n\n        String html = \"<img src='cid:12345' /> <img src='data:gzzt' />\";\n\n        String dropped = Jsoup.clean(html, Whitelist.basicWithImages());\n\n        assertEquals(\"<img /> \\n<img />\", dropped);\n\n\n\n        String preserved = Jsoup.clean(html, Whitelist.basicWithImages().addProtocols(\"img\", \"src\", \"cid\", \"data\"));\n\n        assertEquals(\"<img src=\\\"cid:12345\\\" /> \\n<img src=\\\"data:gzzt\\\" />\", preserved);\n\n    }\n"
      }
    }
  },
  "Jsoup-2": {
    "id": "Jsoup-2",
    "project": "Jsoup",
    "number": "2",
    "buggy_function": "private void parseStartTag() {\n    tq.consume(\"<\");\n    String tagName = tq.consumeWord();\n\n    if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n        tq.addFirst(\"&lt;\");\n        parseTextNode();\n        return;\n    }\n\n    Attributes attributes = new Attributes();\n    while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n        Attribute attribute = parseAttribute();\n        if (attribute != null)\n            attributes.put(attribute);\n    }\n\n    Tag tag = Tag.valueOf(tagName);\n    Element child = new Element(tag, baseUri, attributes);\n\n    boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n    if (tq.matchChomp(\"/>\")) { // close empty element or tag\n        isEmptyElement = true;\n    } else {\n        tq.matchChomp(\">\");\n    }\n    addChildToParent(child, isEmptyElement);\n\n    // pc data only tags (textarea, script): chomp to end tag, add content as text node\n    if (tag.isData()) {\n        String data = tq.chompTo(\"</\" + tagName);\n        tq.chompTo(\">\");\n        \n        Node dataNode;\n        if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n            dataNode = TextNode.createFromEncoded(data, baseUri);\n        else\n            dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n        child.appendChild(dataNode);   \n    }\n\n    // <base href>: update the base uri\n    if (child.tagName().equals(\"base\")) {\n        String href = child.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n        }\n    }\n}",
    "fixed_function": "private void parseStartTag() {\n    tq.consume(\"<\");\n    String tagName = tq.consumeWord();\n\n    if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n        tq.addFirst(\"&lt;\");\n        parseTextNode();\n        return;\n    }\n\n    Attributes attributes = new Attributes();\n    while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n        Attribute attribute = parseAttribute();\n        if (attribute != null)\n            attributes.put(attribute);\n    }\n\n    Tag tag = Tag.valueOf(tagName);\n    Element child = new Element(tag, baseUri, attributes);\n\n    boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n    if (tq.matchChomp(\"/>\")) { // close empty element or tag\n        isEmptyElement = true;\n    } else {\n        tq.matchChomp(\">\");\n    }\n    addChildToParent(child, isEmptyElement);\n\n    // pc data only tags (textarea, script): chomp to end tag, add content as text node\n    if (tag.isData()) {\n        String data = tq.chompTo(\"</\" + tagName);\n        tq.chompTo(\">\");\n        popStackToClose(tag);\n        \n        Node dataNode;\n        if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n            dataNode = TextNode.createFromEncoded(data, baseUri);\n        else\n            dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n        child.appendChild(dataNode);   \n    }\n\n    // <base href>: update the base uri\n    if (child.tagName().equals(\"base\")) {\n        String href = child.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/Parser.java",
      "first_line": 116,
      "last_line": 165
    },
    "javadoc": "/**\nParse a fragment of HTML into the {@code body} of a Document.\n@param bodyHtml fragment of HTML\n@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n@return Document, with empty head, and HTML parsed into body\n*/",
    "failing_tests": {
      "org.jsoup.parser.ParserTest::handlesTextAfterData": {
        "source": "    @Test public void handlesTextAfterData() {\n\n        String h = \"<html><body>pre <script>inner</script> aft</body></html>\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html()));\n\n    }\n"
      }
    }
  },
  "Jsoup-20": {
    "id": "Jsoup-20",
    "project": "Jsoup",
    "number": "20",
    "buggy_function": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "fixed_function": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/DataUtil.java",
      "first_line": 73,
      "last_line": 103
    },
    "javadoc": "// switching the chartset midstream when a meta http-equiv tag defines the charset.",
    "failing_tests": {
      "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMark": {
        "source": "    @Test public void discardsSpuriousByteOrderMark() {\n\n        String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n\n        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n\n        Document doc = DataUtil.parseByteData(buffer, \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n\n        assertEquals(\"One\", doc.head().text());\n\n    }\n"
      }
    }
  },
  "Jsoup-24": {
    "id": "Jsoup-24",
    "project": "Jsoup",
    "number": "24",
    "buggy_function": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        r.advance();\n        return;\n    }\n\n    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\f':\n            case ' ':\n                t.transition(BeforeAttributeName);\n                break;\n            case '/':\n                t.transition(SelfClosingStartTag);\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            default:\n                t.dataBuffer.append(c);\n                anythingElse(t, r);\n                break;\n        }\n    } else {\n        anythingElse(t, r);\n    }\n}",
    "fixed_function": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\f':\n            case ' ':\n                t.transition(BeforeAttributeName);\n                break;\n            case '/':\n                t.transition(SelfClosingStartTag);\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            default:\n                t.dataBuffer.append(c);\n                anythingElse(t, r);\n                break;\n        }\n    } else {\n        anythingElse(t, r);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/TokeniserState.java",
      "first_line": 553,
      "last_line": 586
    },
    "javadoc": "// consuming to EOF; break out here",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::handlesQuotesInCommentsInScripts": {
        "source": "    @Test public void handlesQuotesInCommentsInScripts() {\n\n        String html = \"<script>\\n\" +\n\n                \"  <!--\\n\" +\n\n                \"    document.write('</scr' + 'ipt>');\\n\" +\n\n                \"  // -->\\n\" +\n\n                \"</script>\";\n\n        Document node = Jsoup.parseBodyFragment(html);\n\n        assertEquals(\"<script>\\n\" +\n\n                \"  <!--\\n\" +\n\n                \"    document.write('</scr' + 'ipt>');\\n\" +\n\n                \"  // -->\\n\" +\n\n                \"</script>\", node.body().html());\n\n    }\n"
      }
    }
  },
  "Jsoup-26": {
    "id": "Jsoup-26",
    "project": "Jsoup",
    "number": "26",
    "buggy_function": "public Document clean(Document dirtyDocument) {\n    Validate.notNull(dirtyDocument);\n\n    Document clean = Document.createShell(dirtyDocument.baseUri());\n        copySafeNodes(dirtyDocument.body(), clean.body());\n\n    return clean;\n}",
    "fixed_function": "public Document clean(Document dirtyDocument) {\n    Validate.notNull(dirtyDocument);\n\n    Document clean = Document.createShell(dirtyDocument.baseUri());\n    if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.\n        copySafeNodes(dirtyDocument.body(), clean.body());\n\n    return clean;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/safety/Cleaner.java",
      "first_line": 39,
      "last_line": 46
    },
    "javadoc": "/**\nCreates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\nThe original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n@param dirtyDocument Untrusted base document to clean.\n@return cleaned document.\n*/",
    "failing_tests": {
      "org.jsoup.safety.CleanerTest::handlesFramesets": {
        "source": "    @Test public void handlesFramesets() {\n\n        String dirty = \"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset></html>\";\n\n        String clean = Jsoup.clean(dirty, Whitelist.basic());\n\n        assertEquals(\"\", clean); // nothing good can come out of that\n\n\n\n        Document dirtyDoc = Jsoup.parse(dirty);\n\n        Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);\n\n        assertFalse(cleanDoc == null);\n\n        assertEquals(0, cleanDoc.body().childNodes().size());\n\n    }\n"
      }
    }
  },
  "Jsoup-27": {
    "id": "Jsoup-27",
    "project": "Jsoup",
    "number": "27",
    "buggy_function": "static String getCharsetFromContentType(String contentType) {\n    if (contentType == null) return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        return charset;\n    }\n    return null;\n}",
    "fixed_function": "static String getCharsetFromContentType(String contentType) {\n    if (contentType == null) return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset)) return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset)) return charset;\n    }\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/DataUtil.java",
      "first_line": 127,
      "last_line": 136
    },
    "javadoc": "/**\n* Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n* will kick in.)\n* @param contentType e.g. \"text/html; charset=EUC-JP\"\n* @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n*/",
    "failing_tests": {
      "org.jsoup.helper.DataUtilTest::testCharset": {
        "source": "    public void testCharset() {\n\n        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=utf-8 \"));\n\n        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=UTF-8\"));\n\n        assertEquals(\"ISO-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=ISO-8859-1\"));\n\n        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html\"));\n\n        assertEquals(null, DataUtil.getCharsetFromContentType(null));\n\n        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html;charset=Unknown\"));\n\n    }\n"
      },
      "org.jsoup.helper.DataUtilTest::testQuotedCharset": {
        "source": "    @Test public void testQuotedCharset() {\n\n        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"utf-8\\\"\"));\n\n        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=\\\"UTF-8\\\"\"));\n\n        assertEquals(\"ISO-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"ISO-8859-1\\\"\"));\n\n        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"Unsupported\\\"\"));\n\n    }\n"
      }
    }
  },
  "Jsoup-32": {
    "id": "Jsoup-32",
    "project": "Jsoup",
    "number": "32",
    "buggy_function": "public Element clone() {\n    Element clone = (Element) super.clone();\n    clone.classNames();\n    return clone;\n}",
    "fixed_function": "public Element clone() {\n    Element clone = (Element) super.clone();\n    clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n    return clone;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Element.java",
      "first_line": 1136,
      "last_line": 1140
    },
    "javadoc": "// todo: fixup, not very useful",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::testClonesClassnames": {
        "source": "    @Test public void testClonesClassnames() {\n\n        Document doc = Jsoup.parse(\"<div class='one two'></div>\");\n\n        Element div = doc.select(\"div\").first();\n\n        Set<String> classes = div.classNames();\n\n        assertEquals(2, classes.size());\n\n        assertTrue(classes.contains(\"one\"));\n\n        assertTrue(classes.contains(\"two\"));\n\n\n\n        Element copy = div.clone();\n\n        Set<String> copyClasses = copy.classNames();\n\n        assertEquals(2, copyClasses.size());\n\n        assertTrue(copyClasses.contains(\"one\"));\n\n        assertTrue(copyClasses.contains(\"two\"));\n\n        copyClasses.add(\"three\");\n\n        copyClasses.remove(\"one\");\n\n\n\n        assertTrue(classes.contains(\"one\"));\n\n        assertFalse(classes.contains(\"three\"));\n\n        assertFalse(copyClasses.contains(\"one\"));\n\n        assertTrue(copyClasses.contains(\"three\"));\n\n\n\n        assertEquals(\"\", div.html());\n\n        assertEquals(\"\", copy.html());\n\n    }\n"
      }
    }
  },
  "Jsoup-33": {
    "id": "Jsoup-33",
    "project": "Jsoup",
    "number": "33",
    "buggy_function": "Element insert(Token.StartTag startTag) {\n    // handle empty unknown tags\n    // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n    if (startTag.isSelfClosing()) {\n        Element el = insertEmpty(startTag);\n        stack.add(el);\n        tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n        return el;\n    }\n    \n    Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n    insert(el);\n    return el;\n}",
    "fixed_function": "Element insert(Token.StartTag startTag) {\n    // handle empty unknown tags\n    // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n    if (startTag.isSelfClosing()) {\n        Element el = insertEmpty(startTag);\n        stack.add(el);\n        tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n        tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n        return el;\n    }\n    \n    Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n    insert(el);\n    return el;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
      "first_line": 156,
      "last_line": 169
    },
    "javadoc": "// with form correctly",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::handlesKnownEmptyBlocks": {
        "source": "    @Test public void handlesKnownEmptyBlocks() {\n\n        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n\n        String h = \"<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n\n    }\n"
      }
    }
  },
  "Jsoup-34": {
    "id": "Jsoup-34",
    "project": "Jsoup",
    "number": "34",
    "buggy_function": "int nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}",
    "fixed_function": "int nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
      "first_line": 82,
      "last_line": 98
    },
    "javadoc": "/**\n* Returns the number of characters between the current position and the next instance of the input sequence\n*\n* @param seq scan target\n* @return offset between current position and next instance of target. -1 if not found.\n*/",
    "failing_tests": {
      "org.jsoup.parser.CharacterReaderTest::nextIndexOfUnmatched": {
        "source": "    @Test public void nextIndexOfUnmatched() {\n\n        CharacterReader r = new CharacterReader(\"<[[one]]\");\n\n        assertEquals(-1, r.nextIndexOf(\"]]>\"));\n\n    }\n"
      },
      "org.jsoup.parser.HtmlParserTest::handlesUnclosedCdataAtEOF": {
        "source": "    @Test public void handlesUnclosedCdataAtEOF() {\n\n        // https://github.com/jhy/jsoup/issues/349 would crash, as character reader would try to seek past EOF\n\n        String h = \"<![CDATA[]]\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(1, doc.body().childNodeSize());\n\n    }\n"
      }
    }
  },
  "Jsoup-35": {
    "id": "Jsoup-35",
    "project": "Jsoup",
    "number": "35",
    "buggy_function": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                    \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                // todo: ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertForm(startTag, true);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name,\n                    \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                // we're not supposed to ask.\n                startTag.name(\"img\");\n                return tb.process(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(\"rp\", \"rt\")) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name,\n                    \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                    \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                    \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                // todo: refactor these lookups\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name,\n                    \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    for (int si = 0; si < stack.size() && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "fixed_function": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                    \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                // todo: ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertForm(startTag, true);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name,\n                    \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                // we're not supposed to ask.\n                startTag.name(\"img\");\n                return tb.process(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(\"rp\", \"rt\")) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name,\n                    \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                    \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                    \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                // todo: refactor these lookups\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name,\n                    \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    for (int si = 0; si < stack.size() && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
      "first_line": 247,
      "last_line": 763
    },
    "javadoc": "// skips some script rules as won't execute them",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::handlesUnclosedAnchors": {
        "source": "    @Test public void handlesUnclosedAnchors() {\n\n        String h = \"<a href='http://example.com/'>Link<p>Error link</a>\";\n\n        Document doc = Jsoup.parse(h);\n\n        String want = \"<a href=\\\"http://example.com/\\\">Link</a>\\n<p><a href=\\\"http://example.com/\\\">Error link</a></p>\";\n\n        assertEquals(want, doc.body().html());\n\n    }\n"
      }
    }
  },
  "Jsoup-37": {
    "id": "Jsoup-37",
    "project": "Jsoup",
    "number": "37",
    "buggy_function": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString().trim();\n}",
    "fixed_function": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Element.java",
      "first_line": 1098,
      "last_line": 1102
    },
    "javadoc": "/**\n* Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n* {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n*\n* @return String of HTML.\n* @see #outerHtml()\n*/",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::testNotPretty": {
        "source": "    @Test public void testNotPretty() {\n\n        Document doc = Jsoup.parse(\"<div>   \\n<p>Hello\\n there\\n</p></div>\");\n\n        doc.outputSettings().prettyPrint(false);\n\n        assertEquals(\"<html><head></head><body><div>   \\n<p>Hello\\n there\\n</p></div></body></html>\", doc.html());\n\n\n\n        Element div = doc.select(\"div\").first();\n\n        assertEquals(\"   \\n<p>Hello\\n there\\n</p>\", div.html());\n\n    }\n"
      }
    }
  },
  "Jsoup-38": {
    "id": "Jsoup-38",
    "project": "Jsoup",
    "number": "38",
    "buggy_function": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                // todo: ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertForm(startTag, true);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "fixed_function": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                // todo: ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertForm(startTag, true);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                if (tb.getFromStack(\"svg\") == null)\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    tb.insert(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
      "first_line": 247,
      "last_line": 753
    },
    "javadoc": "// skips some script rules as won't execute them",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::convertsImageToImg": {
        "source": "    @Test public void convertsImageToImg() {\n\n        // image to img, unless in a svg. old html cruft.\n\n        String h = \"<body><image><svg><image /></svg></body>\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(\"<img />\\n<svg>\\n <image />\\n</svg>\", doc.body().html());\n\n    }\n"
      }
    }
  },
  "Jsoup-39": {
    "id": "Jsoup-39",
    "project": "Jsoup",
    "number": "39",
    "buggy_function": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n    if (docData.length() > 0 && docData.charAt(0) == 65279) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "fixed_function": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n    if (docData.length() > 0 && docData.charAt(0) == 65279) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/DataUtil.java",
      "first_line": 76,
      "last_line": 125
    },
    "javadoc": "// todo - this is getting gnarly. needs a rewrite.",
    "failing_tests": {
      "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet": {
        "source": "    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() {\n\n        String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n\n        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n\n        Document doc = DataUtil.parseByteData(buffer, null, \"http://foo.com/\", Parser.htmlParser());\n\n        assertEquals(\"One\", doc.head().text());\n\n        assertEquals(\"UTF-8\", doc.outputSettings().charset().displayName());\n\n    }\n"
      }
    }
  },
  "Jsoup-40": {
    "id": "Jsoup-40",
    "project": "Jsoup",
    "number": "40",
    "buggy_function": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n\n    Validate.notEmpty(name);\n    attr(\"name\", name);\n    attr(\"publicId\", publicId);\n    attr(\"systemId\", systemId);\n}",
    "fixed_function": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n\n    attr(\"name\", name);\n    attr(\"publicId\", publicId);\n    attr(\"systemId\", systemId);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
      "first_line": 19,
      "last_line": 26
    },
    "javadoc": "/**\n* Create a new doctype element.\n* @param name the doctype's name\n* @param publicId the doctype's public ID\n* @param systemId the doctype's system ID\n* @param baseUri the doctype's base URI\n*/",
    "failing_tests": {
      "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName": {
        "source": "    public void constructorValidationOkWithBlankName() {\n\n        DocumentType fail = new DocumentType(\"\",\"\", \"\", \"\");\n\n    }\n"
      },
      "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes": {
        "source": "    @Test public void handlesInvalidDoctypes() {\n\n        // would previously throw invalid name exception on empty doctype\n\n        Document doc = Jsoup.parse(\"<!DOCTYPE>\");\n\n        assertEquals(\n\n                \"<!DOCTYPE> <html> <head></head> <body></body> </html>\",\n\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n\n\n\n        doc = Jsoup.parse(\"<!DOCTYPE><html><p>Foo</p></html>\");\n\n        assertEquals(\n\n                \"<!DOCTYPE> <html> <head></head> <body> <p>Foo</p> </body> </html>\",\n\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n\n\n\n        doc = Jsoup.parse(\"<!DOCTYPE \\u0000>\");\n\n        assertEquals(\n\n                \"<!DOCTYPE \ufffd> <html> <head></head> <body></body> </html>\",\n\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n\n    }\n"
      }
    }
  },
  "Jsoup-41": {
    "id": "Jsoup-41",
    "project": "Jsoup",
    "number": "41",
    "buggy_function": "public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    Element element = (Element) o;\n\n    return this == o;\n}",
    "fixed_function": "public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    Element element = (Element) o;\n\n    return tag.equals(element.tag);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Element.java",
      "first_line": 1168,
      "last_line": 1176
    },
    "javadoc": "/**\n* Set this element's inner HTML. Clears the existing HTML first.\n* @param html HTML to parse and set into this element\n* @return this element\n* @see #append(String)\n*/",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::testHashAndEquals": {
        "source": "    public void testHashAndEquals() {\n\n        String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n\n                \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n\n\n\n        Document doc = Jsoup.parse(doc1);\n\n        Elements els = doc.select(\"p\");\n\n\n\n        /*\n\n        for (Element el : els) {\n\n            System.out.println(el.hashCode() + \" - \" + el.outerHtml());\n\n        }\n\n\n\n        0 1534787905 - <p class=\"one\">One</p>\n\n        1 1534787905 - <p class=\"one\">One</p>\n\n        2 1539683239 - <p class=\"one\">Two</p>\n\n        3 1535455211 - <p class=\"two\">One</p>\n\n        4 1534787905 - <p class=\"one\">One</p>\n\n        5 1534787905 - <p class=\"one\">One</p>\n\n        6 1539683239 - <p class=\"one\">Two</p>\n\n        7 1535455211 - <p class=\"two\">One</p>\n\n        */\n\n        assertEquals(8, els.size());\n\n        Element e0 = els.get(0);\n\n        Element e1 = els.get(1);\n\n        Element e2 = els.get(2);\n\n        Element e3 = els.get(3);\n\n        Element e4 = els.get(4);\n\n        Element e5 = els.get(5);\n\n        Element e6 = els.get(6);\n\n        Element e7 = els.get(7);\n\n\n\n        assertEquals(e0, e1);\n\n        assertEquals(e0, e4);\n\n        assertEquals(e0, e5);\n\n        assertFalse(e0.equals(e2));\n\n        assertFalse(e0.equals(e3));\n\n        assertFalse(e0.equals(e6));\n\n        assertFalse(e0.equals(e7));\n\n\n\n        assertEquals(e0.hashCode(), e1.hashCode());\n\n        assertEquals(e0.hashCode(), e4.hashCode());\n\n        assertEquals(e0.hashCode(), e5.hashCode());\n\n        assertFalse(e0.hashCode() == (e2.hashCode()));\n\n        assertFalse(e0.hashCode() == (e3).hashCode());\n\n        assertFalse(e0.hashCode() == (e6).hashCode());\n\n        assertFalse(e0.hashCode() == (e7).hashCode());\n\n    }\n"
      }
    }
  },
  "Jsoup-42": {
    "id": "Jsoup-42",
    "project": "Jsoup",
    "number": "42",
    "buggy_function": "public List<Connection.KeyVal> formData() {\n    ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element el: elements) {\n        if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n        String name = el.attr(\"name\");\n        if (name.length() == 0) continue;\n        String type = el.attr(\"type\");\n\n        if (\"select\".equals(el.tagName())) {\n            Elements options = el.select(\"option[selected]\");\n            boolean set = false;\n            for (Element option: options) {\n                data.add(HttpConnection.KeyVal.create(name, option.val()));\n                set = true;\n            }\n            if (!set) {\n                Element option = el.select(\"option\").first();\n                if (option != null)\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n            }\n        } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n            // only add checkbox or radio if they have the checked attribute\n            if (el.hasAttr(\"checked\")) {\n                final String val = el.val();\n                data.add(HttpConnection.KeyVal.create(name, val));\n            }\n        } else {\n            data.add(HttpConnection.KeyVal.create(name, el.val()));\n        }\n    }\n    return data;\n}",
    "fixed_function": "public List<Connection.KeyVal> formData() {\n    ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element el: elements) {\n        if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n        if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n        String name = el.attr(\"name\");\n        if (name.length() == 0) continue;\n        String type = el.attr(\"type\");\n\n        if (\"select\".equals(el.tagName())) {\n            Elements options = el.select(\"option[selected]\");\n            boolean set = false;\n            for (Element option: options) {\n                data.add(HttpConnection.KeyVal.create(name, option.val()));\n                set = true;\n            }\n            if (!set) {\n                Element option = el.select(\"option\").first();\n                if (option != null)\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n            }\n        } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n            // only add checkbox or radio if they have the checked attribute\n            if (el.hasAttr(\"checked\")) {\n                final String val = el.val().length() >  0 ? el.val() : \"on\";\n                data.add(HttpConnection.KeyVal.create(name, val));\n            }\n        } else {\n            data.add(HttpConnection.KeyVal.create(name, el.val()));\n        }\n    }\n    return data;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/FormElement.java",
      "first_line": 74,
      "last_line": 107
    },
    "javadoc": "/**\n* Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n* list will not be reflected in the DOM.\n* @return a list of key vals\n*/",
    "failing_tests": {
      "org.jsoup.nodes.FormElementTest::createsFormData": {
        "source": "    @Test public void createsFormData() {\n\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n\n                \"<input name='ten' value='text' disabled>\" +\n\n                \"</form>\";\n\n        Document doc = Jsoup.parse(html);\n\n        FormElement form = (FormElement) doc.select(\"form\").first();\n\n        List<Connection.KeyVal> data = form.formData();\n\n\n\n        assertEquals(6, data.size());\n\n        assertEquals(\"one=two\", data.get(0).toString());\n\n        assertEquals(\"three=four\", data.get(1).toString());\n\n        assertEquals(\"three=five\", data.get(2).toString());\n\n        assertEquals(\"six=seven\", data.get(3).toString());\n\n        assertEquals(\"seven=on\", data.get(4).toString()); // set\n\n        assertEquals(\"eight=on\", data.get(5).toString()); // default\n\n        // nine should not appear, not checked checkbox\n\n        // ten should not appear, disabled\n\n    }\n"
      },
      "org.jsoup.nodes.FormElementTest::usesOnForCheckboxValueIfNoValueSet": {
        "source": "    @Test public void usesOnForCheckboxValueIfNoValueSet() {\n\n        Document doc = Jsoup.parse(\"<form><input type=checkbox checked name=foo></form>\");\n\n        FormElement form = (FormElement) doc.select(\"form\").first();\n\n        List<Connection.KeyVal> data = form.formData();\n\n        assertEquals(\"on\", data.get(0).value());\n\n        assertEquals(\"foo\", data.get(0).key());\n\n    }\n"
      }
    }
  },
  "Jsoup-43": {
    "id": "Jsoup-43",
    "project": "Jsoup",
    "number": "43",
    "buggy_function": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search))\n            return i;\n    }\n    return null;\n}",
    "fixed_function": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element == search)\n            return i;\n    }\n    return null;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Element.java",
      "first_line": 568,
      "last_line": 578
    },
    "javadoc": "/**\n* Gets the last element sibling of this element\n* @return the last sibling that is an element (aka the parent's last element child)\n*/",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::testElementSiblingIndexSameContent": {
        "source": "    @Test public void testElementSiblingIndexSameContent() {\n\n        Document doc = Jsoup.parse(\"<div><p>One</p>...<p>One</p>...<p>One</p>\");\n\n        Elements ps = doc.select(\"p\");\n\n        assertTrue(0 == ps.get(0).elementSiblingIndex());\n\n        assertTrue(1 == ps.get(1).elementSiblingIndex());\n\n        assertTrue(2 == ps.get(2).elementSiblingIndex());\n\n    }\n"
      },
      "org.jsoup.nodes.ElementTest::testGetSiblingsWithDuplicateContent": {
        "source": "    @Test public void testGetSiblingsWithDuplicateContent() {\n\n        Document doc = Jsoup.parse(\"<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>\");\n\n        Element p = doc.getElementById(\"1\");\n\n        assertEquals(\"there\", p.text());\n\n        assertEquals(\"Hello\", p.previousElementSibling().text());\n\n        assertEquals(\"this\", p.nextElementSibling().text());\n\n        assertEquals(\"this\", p.nextElementSibling().nextElementSibling().text());\n\n        assertEquals(\"is\", p.nextElementSibling().nextElementSibling().nextElementSibling().text());\n\n        assertEquals(\"Hello\", p.firstElementSibling().text());\n\n        assertEquals(\"element\", p.lastElementSibling().text());\n\n    }\n"
      }
    }
  },
  "Jsoup-45": {
    "id": "Jsoup-45",
    "project": "Jsoup",
    "number": "45",
    "buggy_function": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; // frag\n        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; // frag\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; // frag\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; // frag\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        }\n    }\n}",
    "fixed_function": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; // frag\n        } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; // frag\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; // frag\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; // frag\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
      "first_line": 382,
      "last_line": 429
    },
    "javadoc": "// connect form controls to their form element",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::testReinsertionModeForThCelss": {
        "source": "    @Test public void testReinsertionModeForThCelss() {\n\n        String body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";\n\n        Document doc = Jsoup.parse(body);\n\n        assertEquals(1, doc.body().children().size());\n\n    }\n"
      }
    }
  },
  "Jsoup-46": {
    "id": "Jsoup-46",
    "project": "Jsoup",
    "number": "46",
    "buggy_function": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
    "fixed_function": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Entities.java",
      "first_line": 79,
      "last_line": 154
    },
    "javadoc": "// this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations",
    "failing_tests": {
      "org.jsoup.nodes.DocumentTest::testShiftJisRoundtrip": {
        "source": "    public void testShiftJisRoundtrip() throws Exception {\n\n        String input =\n\n                \"<html>\"\n\n                        +   \"<head>\"\n\n                        +     \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=Shift_JIS\\\" />\"\n\n                        +   \"</head>\"\n\n                        +   \"<body>\"\n\n                        +     \"before&nbsp;after\"\n\n                        +   \"</body>\"\n\n                        + \"</html>\";\n\n        InputStream is = new ByteArrayInputStream(input.getBytes(Charset.forName(\"ASCII\")));\n\n\n\n        Document doc = Jsoup.parse(is, null, \"http://example.com\");\n\n        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);\n\n\n\n        String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());\n\n\n\n        assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\"));\n\n        assertTrue(\"Should have contained a '&#xa0;' or a '&nbsp;'.\",\n\n                output.contains(\"&#xa0;\") || output.contains(\"&nbsp;\"));\n\n    }\n"
      }
    }
  },
  "Jsoup-47": {
    "id": "Jsoup-47",
    "project": "Jsoup",
    "number": "47",
    "buggy_function": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
    "fixed_function": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Entities.java",
      "first_line": 79,
      "last_line": 155
    },
    "javadoc": "// this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations",
    "failing_tests": {
      "org.jsoup.nodes.EntitiesTest::escapesGtInXmlAttributesButNotInHtml": {
        "source": "    @Test public void escapesGtInXmlAttributesButNotInHtml() {\n\n        // https://github.com/jhy/jsoup/issues/528 - < is OK in HTML attribute values, but not in XML\n\n\n\n\n\n        String docHtml = \"<a title='<p>One</p>'>One</a>\";\n\n        Document doc = Jsoup.parse(docHtml);\n\n        Element element = doc.select(\"a\").first();\n\n\n\n        doc.outputSettings().escapeMode(base);\n\n        assertEquals(\"<a title=\\\"<p>One</p>\\\">One</a>\", element.outerHtml());\n\n\n\n        doc.outputSettings().escapeMode(xhtml);\n\n        assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml());\n\n    }\n"
      }
    }
  },
  "Jsoup-48": {
    "id": "Jsoup-48",
    "project": "Jsoup",
    "number": "48",
    "buggy_function": "void processResponseHeaders(Map<String, List<String>> resHeaders) {\n    for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n        String name = entry.getKey();\n        if (name == null)\n            continue; // http/1.1 line\n\n        List<String> values = entry.getValue();\n        if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n            for (String value : values) {\n                if (value == null)\n                    continue;\n                TokenQueue cd = new TokenQueue(value);\n                String cookieName = cd.chompTo(\"=\").trim();\n                String cookieVal = cd.consumeTo(\";\").trim();\n                // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                // name not blank, value not null\n                if (cookieName.length() > 0)\n                    cookie(cookieName, cookieVal);\n            }\n        } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n            if (!values.isEmpty())\n                header(name, values.get(0));\n        }\n    }\n}",
    "fixed_function": "void processResponseHeaders(Map<String, List<String>> resHeaders) {\n    for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n        String name = entry.getKey();\n        if (name == null)\n            continue; // http/1.1 line\n\n        List<String> values = entry.getValue();\n        if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n            for (String value : values) {\n                if (value == null)\n                    continue;\n                TokenQueue cd = new TokenQueue(value);\n                String cookieName = cd.chompTo(\"=\").trim();\n                String cookieVal = cd.consumeTo(\";\").trim();\n                // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                // name not blank, value not null\n                if (cookieName.length() > 0)\n                    cookie(cookieName, cookieVal);\n            }\n        } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n            if (values.size() == 1)\n                header(name, values.get(0));\n            else if (values.size() > 1) {\n                StringBuilder accum = new StringBuilder();\n                for (int i = 0; i < values.size(); i++) {\n                    final String val = values.get(i);\n                    if (i != 0)\n                        accum.append(\", \");\n                    accum.append(val);\n                }\n                header(name, accum.toString());\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
      "first_line": 753,
      "last_line": 777
    },
    "javadoc": "// the default sun impl of conn.getHeaderFields() returns header values out of order",
    "failing_tests": {
      "org.jsoup.helper.HttpConnectionTest::sameHeadersCombineWithComma": {
        "source": "    @Test public void sameHeadersCombineWithComma() {\n\n        Map<String, List<String>> headers = new HashMap<String, List<String>>();\n\n        List<String> values = new ArrayList<String>();\n\n        values.add(\"no-cache\");\n\n        values.add(\"no-store\");\n\n        headers.put(\"Cache-Control\", values);\n\n        HttpConnection.Response res = new HttpConnection.Response();\n\n        res.processResponseHeaders(headers);\n\n        assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\"));\n\n    }\n"
      }
    }
  },
  "Jsoup-49": {
    "id": "Jsoup-49",
    "project": "Jsoup",
    "number": "49",
    "buggy_function": "protected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    for (int i = children.length - 1; i >= 0; i--) {\n        Node in = children[i];\n        reparentChild(in);\n        childNodes.add(index, in);\n    }\n    reindexChildren(index);\n}",
    "fixed_function": "protected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    for (int i = children.length - 1; i >= 0; i--) {\n        Node in = children[i];\n        reparentChild(in);\n        childNodes.add(index, in);\n        reindexChildren(index);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Node.java",
      "first_line": 438,
      "last_line": 447
    },
    "javadoc": "//most used. short circuit addChildren(int), which hits reindex children and array copy",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::appendMustCorrectlyMoveChildrenInsideOneParentElement": {
        "source": "    public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {\n\n        Document doc = new Document(\"\");\n\n        Element body = doc.appendElement(\"body\");\n\n        body.appendElement(\"div1\");\n\n        body.appendElement(\"div2\");\n\n        final Element div3 = body.appendElement(\"div3\");\n\n        div3.text(\"Check\");\n\n        final Element div4 = body.appendElement(\"div4\");\n\n\n\n        ArrayList<Element> toMove = new ArrayList<Element>();\n\n        toMove.add(div3);\n\n        toMove.add(div4);\n\n\n\n        body.insertChildren(0, toMove);\n\n\n\n        String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n\n        assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);\n\n\n\n    }\n"
      }
    }
  },
  "Jsoup-5": {
    "id": "Jsoup-5",
    "project": "Jsoup",
    "number": "5",
    "buggy_function": "private Attribute parseAttribute() {\n    tq.consumeWhitespace();\n    String key = tq.consumeAttributeKey();\n    String value = \"\";\n    tq.consumeWhitespace();\n    if (tq.matchChomp(\"=\")) {\n        tq.consumeWhitespace();\n\n        if (tq.matchChomp(SQ)) {\n            value = tq.chompTo(SQ);\n        } else if (tq.matchChomp(DQ)) {\n            value = tq.chompTo(DQ);\n        } else {\n            StringBuilder valueAccum = new StringBuilder();\n            // no ' or \" to look for, so scan to end tag or space (or end of stream)\n            while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                valueAccum.append(tq.consume());\n            }\n            value = valueAccum.toString();\n        }\n        tq.consumeWhitespace();\n    }\n    if (key.length() != 0)\n        return Attribute.createFromEncoded(key, value);\n    else {\n        tq.consume();\n            \n        return null;\n    }\n}",
    "fixed_function": "private Attribute parseAttribute() {\n    tq.consumeWhitespace();\n    String key = tq.consumeAttributeKey();\n    String value = \"\";\n    tq.consumeWhitespace();\n    if (tq.matchChomp(\"=\")) {\n        tq.consumeWhitespace();\n\n        if (tq.matchChomp(SQ)) {\n            value = tq.chompTo(SQ);\n        } else if (tq.matchChomp(DQ)) {\n            value = tq.chompTo(DQ);\n        } else {\n            StringBuilder valueAccum = new StringBuilder();\n            // no ' or \" to look for, so scan to end tag or space (or end of stream)\n            while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                valueAccum.append(tq.consume());\n            }\n            value = valueAccum.toString();\n        }\n        tq.consumeWhitespace();\n    }\n    if (key.length() != 0)\n        return Attribute.createFromEncoded(key, value);\n    else {\n        if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck\n            tq.advance();\n            \n        return null;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/Parser.java",
      "first_line": 181,
      "last_line": 210
    },
    "javadoc": "// <base href>: update the base uri",
    "failing_tests": {
      "org.jsoup.parser.ParserTest::parsesQuiteRoughAttributes": {
        "source": "    @Test public void parsesQuiteRoughAttributes() {\n\n        String html = \"<p =a>One<a =a\";\n\n        Document doc = Jsoup.parse(html);\n\n        assertEquals(\"<p>One<a></a></p>\", doc.body().html());\n\n        \n\n        doc = Jsoup.parse(\"<p .....\");\n\n        assertEquals(\"<p></p>\", doc.body().html());\n\n        \n\n        doc = Jsoup.parse(\"<p .....<p!!\");\n\n        assertEquals(\"<p></p>\\n<p></p>\", doc.body().html());\n\n    }\n"
      }
    }
  },
  "Jsoup-50": {
    "id": "Jsoup-50",
    "project": "Jsoup",
    "number": "50",
    "buggy_function": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "fixed_function": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n    byteData.mark();\n    byte[] bom = new byte[4];\n    byteData.get(bom);\n    byteData.rewind();\n    if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n        charsetName = \"UTF-32\"; // and I hope it's on your system\n    } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n        charsetName = \"UTF-16\"; // in all Javas\n    } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n        charsetName = \"UTF-8\"; // in all Javas\n        byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/DataUtil.java",
      "first_line": 88,
      "last_line": 138
    },
    "javadoc": "// todo - this is getting gnarly. needs a rewrite.",
    "failing_tests": {
      "org.jsoup.helper.DataUtilTest::supportsBOMinFiles": {
        "source": "    public void supportsBOMinFiles() throws IOException {\n\n        // test files from http://www.i18nl10n.com/korean/utftest/\n\n        File in = getFile(\"/bomtests/bom_utf16be.html\");\n\n        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-16BE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf16le.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-16LE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf32be.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-32BE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf32le.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-32LE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n    }\n"
      }
    }
  },
  "Jsoup-51": {
    "id": "Jsoup-51",
    "project": "Jsoup",
    "number": "51",
    "buggy_function": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
    "fixed_function": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
      "first_line": 296,
      "last_line": 301
    },
    "javadoc": "// '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::testSupportsNonAsciiTags": {
        "source": "    @Test public void testSupportsNonAsciiTags() {\n\n        String body = \"<\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>Yes</\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>\";\n\n        Document doc = Jsoup.parse(body);\n\n        Elements els = doc.select(\"\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5\");\n\n        assertEquals(\"Yes\", els.text());\n\n    }\n"
      }
    }
  },
  "Jsoup-53": {
    "id": "Jsoup-53",
    "project": "Jsoup",
    "number": "53",
    "buggy_function": "public String chompBalanced(char open, char close) {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    return (end >= 0) ? queue.substring(start, end) : \"\";\n}",
    "fixed_function": "public String chompBalanced(char open, char close) {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') || c.equals('\"') && c != open)\n                inQuote = !inQuote;\n            if (inQuote)\n                continue;\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    return (end >= 0) ? queue.substring(start, end) : \"\";\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
      "first_line": 260,
      "last_line": 284
    },
    "javadoc": "/**\n* Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n* and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n* in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n* contains text strings; use unescape for that.\n* @param open opener\n* @param close closer\n* @return data matched from the queue\n*/",
    "failing_tests": {
      "org.jsoup.select.SelectorTest::attributeWithBrackets": {
        "source": "    @Test public void attributeWithBrackets() {\n\n        String html = \"<div data='End]'>One</div> <div data='[Another)]]'>Two</div>\";\n\n        Document doc = Jsoup.parse(html);\n\n        assertEquals(\"One\", doc.select(\"div[data='End]'\").first().text());\n\n        assertEquals(\"Two\", doc.select(\"div[data='[Another)]]'\").first().text());\n\n    }\n"
      }
    }
  },
  "Jsoup-54": {
    "id": "Jsoup-54",
    "project": "Jsoup",
    "number": "54",
    "buggy_function": "private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n    for (Attribute attribute : source.attributes()) {\n        // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n        String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n            el.setAttribute(key, attribute.getValue());\n    }\n}",
    "fixed_function": "private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n    for (Attribute attribute : source.attributes()) {\n        // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n        String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n        if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n            el.setAttribute(key, attribute.getValue());\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/W3CDom.java",
      "first_line": 122,
      "last_line": 128
    },
    "javadoc": "// unhandled",
    "failing_tests": {
      "org.jsoup.helper.W3CDomTest::handlesInvalidAttributeNames": {
        "source": "    public void handlesInvalidAttributeNames() {\n\n        String html = \"<html><head></head><body style=\\\"color: red\\\" \\\" name\\\"></body></html>\";\n\n        org.jsoup.nodes.Document jsoupDoc;\n\n        jsoupDoc = Jsoup.parse(html);\n\n        Element body = jsoupDoc.select(\"body\").first();\n\n        assertTrue(body.hasAttr(\"\\\"\")); // actually an attribute with key '\"'. Correct per HTML5 spec, but w3c xml dom doesn't dig it\n\n        assertTrue(body.hasAttr(\"name\\\"\"));\n\n\n\n        Document w3Doc = new W3CDom().fromJsoup(jsoupDoc);\n\n    }\n"
      }
    }
  },
  "Jsoup-55": {
    "id": "Jsoup-55",
    "project": "Jsoup",
    "number": "55",
    "buggy_function": "void read(Tokeniser t, CharacterReader r) {\n    char c = r.consume();\n    switch (c) {\n        case '>':\n            t.tagPending.selfClosing = true;\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.error(this);\n            t.transition(BeforeAttributeName);\n    }\n}",
    "fixed_function": "void read(Tokeniser t, CharacterReader r) {\n    char c = r.consume();\n    switch (c) {\n        case '>':\n            t.tagPending.selfClosing = true;\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.error(this);\n            r.unconsume();\n            t.transition(BeforeAttributeName);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/TokeniserState.java",
      "first_line": 869,
      "last_line": 885
    },
    "javadoc": "// CharacterReferenceInAttributeValue state handled inline",
    "failing_tests": {
      "org.jsoup.parser.AttributeParseTest::dropsSlashFromAttributeName": {
        "source": "    @Test public void dropsSlashFromAttributeName() {\n\n        String html = \"<img /onerror='doMyJob'/>\";\n\n        Document doc = Jsoup.parse(html);\n\n        assertTrue(\"SelfClosingStartTag ignores last character\", doc.select(\"img[onerror]\").size() != 0);\n\n        assertEquals(\"<img onerror=\\\"doMyJob\\\">\", doc.body().html());\n\n\n\n        doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n\n        assertEquals(\"<img onerror=\\\"doMyJob\\\" />\", doc.html());\n\n    }\n"
      }
    }
  },
  "Jsoup-57": {
    "id": "Jsoup-57",
    "project": "Jsoup",
    "number": "57",
    "buggy_function": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            attributes.remove(attrKey);\n    }\n}",
    "fixed_function": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Attributes.java",
      "first_line": 118,
      "last_line": 127
    },
    "javadoc": "/**\nRemove an attribute by key. <b>Case insensitive.</b>\n@param key attribute key to remove\n*/",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::testChainedRemoveAttributes": {
        "source": "    public void testChainedRemoveAttributes() {\n\n        String html = \"<a one two three four>Text</a>\";\n\n        Document doc = Jsoup.parse(html);\n\n        Element a = doc.select(\"a\").first();\n\n        a\n\n            .removeAttr(\"zero\")\n\n            .removeAttr(\"one\")\n\n            .removeAttr(\"two\")\n\n            .removeAttr(\"three\")\n\n            .removeAttr(\"four\")\n\n            .removeAttr(\"five\");\n\n        assertEquals(\"<a>Text</a>\", a.outerHtml());\n\n    }\n"
      }
    }
  },
  "Jsoup-59": {
    "id": "Jsoup-59",
    "project": "Jsoup",
    "number": "59",
    "buggy_function": "final void newAttribute() {\n    if (attributes == null)\n        attributes = new Attributes();\n\n    if (pendingAttributeName != null) {\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName = pendingAttributeName.trim();\n            Attribute attribute;\n            if (hasPendingAttributeValue)\n                attribute = new Attribute(pendingAttributeName,\n                    pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n            else if (hasEmptyAttributeValue)\n                attribute = new Attribute(pendingAttributeName, \"\");\n            else\n                attribute = new BooleanAttribute(pendingAttributeName);\n            attributes.put(attribute);\n    }\n    pendingAttributeName = null;\n    hasEmptyAttributeValue = false;\n    hasPendingAttributeValue = false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS = null;\n}",
    "fixed_function": "final void newAttribute() {\n    if (attributes == null)\n        attributes = new Attributes();\n\n    if (pendingAttributeName != null) {\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName = pendingAttributeName.trim();\n        if (pendingAttributeName.length() > 0) {\n            Attribute attribute;\n            if (hasPendingAttributeValue)\n                attribute = new Attribute(pendingAttributeName,\n                    pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n            else if (hasEmptyAttributeValue)\n                attribute = new Attribute(pendingAttributeName, \"\");\n            else\n                attribute = new BooleanAttribute(pendingAttributeName);\n            attributes.put(attribute);\n        }\n    }\n    pendingAttributeName = null;\n    hasEmptyAttributeValue = false;\n    hasPendingAttributeValue = false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS = null;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/Token.java",
      "first_line": 100,
      "last_line": 122
    },
    "javadoc": "/**\n* Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n* piece of data, which immediately get GCed.\n*/",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::handlesControlCodeInAttributeName": {
        "source": "    @Test public void handlesControlCodeInAttributeName() {\n\n        Document doc = Jsoup.parse(\"<p><a \\06=foo>One</a><a/\\06=bar><a foo\\06=bar>Two</a></p>\");\n\n        assertEquals(\"<p><a>One</a><a></a><a foo=\\\"bar\\\">Two</a></p>\", doc.body().html());\n\n    }\n"
      },
      "org.jsoup.safety.CleanerTest::handlesControlCharactersAfterTagName": {
        "source": "    @Test public void handlesControlCharactersAfterTagName() {\n\n        String html = \"<a/\\06>\";\n\n        String clean = Jsoup.clean(html, Whitelist.basic());\n\n        assertEquals(\"<a rel=\\\"nofollow\\\"></a>\", clean);\n\n    }\n"
      }
    }
  },
  "Jsoup-6": {
    "id": "Jsoup-6",
    "project": "Jsoup",
    "number": "6",
    "buggy_function": "static String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 || charval > 0xFFFF) { // out of range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, c);\n        } else {\n            m.appendReplacement(accum, m.group(0));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}",
    "fixed_function": "static String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 || charval > 0xFFFF) { // out of range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Entities.java",
      "first_line": 45,
      "last_line": 77
    },
    "javadoc": "/**\n* HMTL entities, and escape routines.\n* Source: <a href=\"http://www.w3.org/TR/html5/named-character-references.html#named-character-references\">W3C HTML\n* named character references</a>.\n*/",
    "failing_tests": {
      "org.jsoup.integration.ParseTest::testYahooArticle": {
        "source": "    public void testYahooArticle() throws IOException {\n\n        File in = getFile(\"/htmltests/yahoo-article-1.html\");\n\n        Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");\n\n        Element p = doc.select(\"p:contains(Volt will be sold in the United States\").first();\n\n        assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n\n    }\n"
      },
      "org.jsoup.nodes.EntitiesTest::quoteReplacements": {
        "source": "    @Test public void quoteReplacements() {\n\n        String escaped = \"&#92; &#36;\";\n\n        String unescaped = \"\\\\ $\";\n\n        \n\n        assertEquals(unescaped, Entities.unescape(escaped));\n\n    }\n"
      }
    }
  },
  "Jsoup-61": {
    "id": "Jsoup-61",
    "project": "Jsoup",
    "number": "61",
    "buggy_function": "public boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}",
    "fixed_function": "public boolean hasClass(String className) {\n    final String classAttr = attributes.getIgnoreCase(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Element.java",
      "first_line": 1091,
      "last_line": 1132
    },
    "javadoc": "// performance sensitive",
    "failing_tests": {
      "org.jsoup.select.ElementsTest::hasClassCaseInsensitive": {
        "source": "    @Test public void hasClassCaseInsensitive() {\n\n        Elements els = Jsoup.parse(\"<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE\").select(\"p\");\n\n        Element one = els.get(0);\n\n        Element two = els.get(1);\n\n        Element thr = els.get(2);\n\n\n\n        assertTrue(one.hasClass(\"One\"));\n\n        assertTrue(one.hasClass(\"ONE\"));\n\n\n\n        assertTrue(two.hasClass(\"TWO\"));\n\n        assertTrue(two.hasClass(\"Two\"));\n\n\n\n        assertTrue(thr.hasClass(\"ThreE\"));\n\n        assertTrue(thr.hasClass(\"three\"));\n\n    }\n"
      },
      "org.jsoup.select.SelectorTest::testByClassCaseInsensitive": {
        "source": "    @Test public void testByClassCaseInsensitive() {\n\n        String html = \"<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four\";\n\n        Elements elsFromClass = Jsoup.parse(html).select(\"P.Foo\");\n\n        Elements elsFromAttr = Jsoup.parse(html).select(\"p[class=foo]\");\n\n\n\n        assertEquals(elsFromAttr.size(), elsFromClass.size());\n\n        assertEquals(3, elsFromClass.size());\n\n        assertEquals(\"Two\", elsFromClass.get(1).text());\n\n    }\n"
      }
    }
  },
  "Jsoup-62": {
    "id": "Jsoup-62",
    "project": "Jsoup",
    "number": "62",
    "buggy_function": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n    String name = t.asEndTag().normalName();\n    ArrayList<Element> stack = tb.getStack();\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (node.nodeName().equals(name)) {\n            tb.generateImpliedEndTags(name);\n            if (!name.equals(tb.currentElement().nodeName()))\n                tb.error(this);\n            tb.popStackToClose(name);\n            break;\n        } else {\n            if (tb.isSpecial(node)) {\n                tb.error(this);\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "fixed_function": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n    String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n    ArrayList<Element> stack = tb.getStack();\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (node.nodeName().equals(name)) {\n            tb.generateImpliedEndTags(name);\n            if (!name.equals(tb.currentElement().nodeName()))\n                tb.error(this);\n            tb.popStackToClose(name);\n            break;\n        } else {\n            if (tb.isSpecial(node)) {\n                tb.error(this);\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
      "first_line": 763,
      "last_line": 782
    },
    "javadoc": "// stop parsing",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::caseSensitiveParseTree": {
        "source": "    @Test public void caseSensitiveParseTree() {\n\n        String html = \"<r><X>A</X><y>B</y></r>\";\n\n        Parser parser = Parser.htmlParser();\n\n        parser.settings(ParseSettings.preserveCase);\n\n        Document doc = parser.parseInput(html, \"\");\n\n        assertEquals(\"<r> <X> A </X> <y> B </y> </r>\", StringUtil.normaliseWhitespace(doc.body().html()));\n\n\n\n    }\n"
      }
    }
  },
  "Jsoup-64": {
    "id": "Jsoup-64",
    "project": "Jsoup",
    "number": "64",
    "buggy_function": "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n    tb.insert(startTag);\n    tb.tokeniser.transition(TokeniserState.Rawtext);\n    tb.markInsertionMode();\n    tb.transition(Text);\n}",
    "fixed_function": "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n    tb.tokeniser.transition(TokeniserState.Rawtext);\n    tb.markInsertionMode();\n    tb.transition(Text);\n    tb.insert(startTag);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
      "first_line": 1488,
      "last_line": 1493
    },
    "javadoc": "// todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::handlesKnownEmptyStyle": {
        "source": "    @Test public void handlesKnownEmptyStyle() {\n\n        String h = \"<html><head><style /><meta name=foo></head><body>One</body></html>\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(\"<html><head><style></style><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n\n    }\n"
      },
      "org.jsoup.parser.HtmlParserTest::handlesKnownEmptyNoFrames": {
        "source": "    @Test public void handlesKnownEmptyNoFrames() {\n\n        String h = \"<html><head><noframes /><meta name=foo></head><body>One</body></html>\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(\"<html><head><noframes></noframes><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n\n    }\n"
      }
    }
  },
  "Jsoup-68": {
    "id": "Jsoup-68",
    "project": "Jsoup",
    "number": "68",
    "buggy_function": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n    // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n    int bottom = stack.size() -1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n    // don't walk too far up the tree\n\n    for (int pos = bottom; pos >= top; pos--) {\n        final String elName = stack.get(pos).nodeName();\n        if (inSorted(elName, targetNames))\n            return true;\n        if (inSorted(elName, baseTypes))\n            return false;\n        if (extraTypes != null && inSorted(elName, extraTypes))\n            return false;\n    }\n    //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n    return false;\n}",
    "fixed_function": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n    // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n    final int bottom = stack.size() -1;\n    final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n    // don't walk too far up the tree\n\n    for (int pos = bottom; pos >= top; pos--) {\n        final String elName = stack.get(pos).nodeName();\n        if (inSorted(elName, targetNames))\n            return true;\n        if (inSorted(elName, baseTypes))\n            return false;\n        if (extraTypes != null && inSorted(elName, extraTypes))\n            return false;\n    }\n    //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
      "first_line": 466,
      "last_line": 486
    },
    "javadoc": "// todo: tidy up in specific scope methods",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::testHandlesDeepSpans": {
        "source": "  @Test public void testHandlesDeepSpans() {\n\n        StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < 200; i++) {\n\n            sb.append(\"<span>\");\n\n        }\n\n\n\n        sb.append(\"<p>One</p>\");\n\n\n\n        Document doc = Jsoup.parse(sb.toString());\n\n        assertEquals(200, doc.select(\"span\").size());\n\n        assertEquals(1, doc.select(\"p\").size());\n\n  }\n"
      }
    }
  },
  "Jsoup-70": {
    "id": "Jsoup-70",
    "project": "Jsoup",
    "number": "70",
    "buggy_function": "static boolean preserveWhitespace(Node node) {\n    // looks only at this element and five levels up, to prevent recursion & needless stack searches\n    if (node != null && node instanceof Element) {\n        Element el = (Element) node;\n            if (el.tag.preserveWhitespace())\n                return true;\n            else\n                return el.parent() != null && el.parent().tag.preserveWhitespace();\n    }\n    return false;\n}",
    "fixed_function": "static boolean preserveWhitespace(Node node) {\n    // looks only at this element and five levels up, to prevent recursion & needless stack searches\n    if (node != null && node instanceof Element) {\n        Element el = (Element) node;\n        int i = 0;\n        do {\n            if (el.tag.preserveWhitespace())\n                return true;\n            el = el.parent();\n            i++;\n        } while (i < 6 && el != null);\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Element.java",
      "first_line": 1087,
      "last_line": 1097
    },
    "javadoc": "/**\n* Gets the text owned by this element only; does not get the combined text of all children.\n* <p>\n* For example, given HTML {@code <p>Hello <b>there</b> now!</p>}, {@code p.ownText()} returns {@code \"Hello now!\"},\n* whereas {@code p.text()} returns {@code \"Hello there now!\"}.\n* Note that the text within the {@code b} element is not returned, as it is not a direct child of the {@code p} element.\n*\n* @return unencoded text, or empty string if none.\n* @see #text()\n* @see #textNodes()\n*/",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::testKeepsPreTextAtDepth": {
        "source": "    @Test public void testKeepsPreTextAtDepth() {\n\n        String h = \"<pre><code><span><b>code\\n\\ncode</b></span></code></pre>\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(\"code\\n\\ncode\", doc.text());\n\n        assertEquals(\"<pre><code><span><b>code\\n\\ncode</b></span></code></pre>\", doc.body().html());\n\n    }\n"
      }
    }
  },
  "Jsoup-72": {
    "id": "Jsoup-72",
    "project": "Jsoup",
    "number": "72",
    "buggy_function": "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n    // limit (no cache):\n    if (count > maxStringCacheLen)\n        return new String(charBuf, start, count);\n\n    // calculate hash:\n    int hash = 0;\n    int offset = start;\n    for (int i = 0; i < count; i++) {\n        hash = 31 * hash + charBuf[offset++];\n    }\n\n    // get from cache\n    final int index = hash & stringCache.length - 1;\n    String cached = stringCache[index];\n\n    if (cached == null) { // miss, add\n        cached = new String(charBuf, start, count);\n        stringCache[index] = cached;\n    } else { // hashcode hit, check equality\n        if (rangeEquals(charBuf, start, count, cached)) { // hit\n            return cached;\n        } else { // hashcode conflict\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n        }\n    }\n    return cached;\n}",
    "fixed_function": "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n    // limit (no cache):\n    if (count > maxStringCacheLen)\n        return new String(charBuf, start, count);\n    if (count < 1)\n        return \"\";\n\n    // calculate hash:\n    int hash = 0;\n    int offset = start;\n    for (int i = 0; i < count; i++) {\n        hash = 31 * hash + charBuf[offset++];\n    }\n\n    // get from cache\n    final int index = hash & stringCache.length - 1;\n    String cached = stringCache[index];\n\n    if (cached == null) { // miss, add\n        cached = new String(charBuf, start, count);\n        stringCache[index] = cached;\n    } else { // hashcode hit, check equality\n        if (rangeEquals(charBuf, start, count, cached)) { // hit\n            return cached;\n        } else { // hashcode conflict\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n        }\n    }\n    return cached;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
      "first_line": 423,
      "last_line": 451
    },
    "javadoc": "/**\n* Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n* <p />\n* Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n* That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n* some more duplicates.\n*/",
    "failing_tests": {
      "org.jsoup.parser.CharacterReaderTest::consumeToNonexistentEndWhenAtAnd": {
        "source": "    public void consumeToNonexistentEndWhenAtAnd() {\n\n        CharacterReader r = new CharacterReader(\"<!\");\n\n        assertTrue(r.matchConsume(\"<!\"));\n\n        assertTrue(r.isEmpty());\n\n\n\n        String after = r.consumeTo('>');\n\n        assertEquals(\"\", after);\n\n\n\n        assertTrue(r.isEmpty());\n\n    }\n"
      },
      "org.jsoup.parser.HtmlParserTest::commentAtEnd": {
        "source": "  @Test public void commentAtEnd() throws Exception {\n\n      Document doc = Jsoup.parse(\"<!\");\n\n      assertTrue(doc.childNode(0) instanceof Comment);\n\n  }\n"
      }
    }
  },
  "Jsoup-75": {
    "id": "Jsoup-75",
    "project": "Jsoup",
    "number": "75",
    "buggy_function": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        // inlined from Attribute.html()\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n\n        // collapse checked=null, checked=\"\", checked=checked; write out others\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n            accum.append('\"');\n        }\n    }\n}",
    "fixed_function": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        // inlined from Attribute.html()\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n\n        // collapse checked=null, checked=\"\", checked=checked; write out others\n        if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n            accum.append('\"');\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Attributes.java",
      "first_line": 310,
      "last_line": 326
    },
    "javadoc": "/**\nGet the HTML representation of these attributes.\n@return HTML\n@throws SerializationException if the HTML representation of the attributes cannot be constructed.\n*/",
    "failing_tests": {
      "org.jsoup.nodes.ElementTest::booleanAttributeOutput": {
        "source": "    public void booleanAttributeOutput() {\n\n        Document doc = Jsoup.parse(\"<img src=foo noshade='' nohref async=async autofocus=false>\");\n\n        Element img = doc.selectFirst(\"img\");\n\n\n\n        assertEquals(\"<img src=\\\"foo\\\" noshade nohref async autofocus=\\\"false\\\">\", img.outerHtml());\n\n    }\n"
      }
    }
  },
  "Jsoup-76": {
    "id": "Jsoup-76",
    "project": "Jsoup",
    "number": "76",
    "buggy_function": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            // todo - refactor to a switch statement\n            String name = startTag.normalName();\n            if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.processEndTag(\"a\");\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"span\")) {\n                // same as final else, but short circuits lots of checks\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.processEndTag(\"li\");\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().get(0);\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.remove(stack.size()-1);\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertForm(startTag, true);\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                        tb.processEndTag(el.nodeName());\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.processEndTag(\"button\");\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.processEndTag(\"nobr\");\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                if (tb.getFromStack(\"svg\") == null)\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    tb.insert(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.processStartTag(\"form\");\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.processStartTag(\"hr\");\n                tb.processStartTag(\"label\");\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character().data(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.processStartTag(\"input\", inputAttribs);\n                tb.processEndTag(\"label\");\n                tb.processStartTag(\"hr\");\n                tb.processEndTag(\"form\");\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.processEndTag(\"option\");\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.normalName();\n            if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    ArrayList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue;\n                        } else if (node == formatEl)\n                            break;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                        // case will follow the original node (so honours ParseSettings)\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"span\")) {\n                // same as final fall through, but saves short circuit\n                return anyOtherEndTag(t, tb);\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.processEndTag(\"body\");\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.processStartTag(\"br\");\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "fixed_function": "boolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            // todo - refactor to a switch statement\n            String name = startTag.normalName();\n            if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.processEndTag(\"a\");\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"span\")) {\n                // same as final else, but short circuits lots of checks\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.processEndTag(\"li\");\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().get(0);\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.remove(stack.size()-1);\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertForm(startTag, true);\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                        tb.processEndTag(el.nodeName());\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.processEndTag(\"button\");\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.processEndTag(\"nobr\");\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                if (tb.getFromStack(\"svg\") == null)\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    tb.insert(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.processStartTag(\"form\");\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.processStartTag(\"hr\");\n                tb.processStartTag(\"label\");\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character().data(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.processStartTag(\"input\", inputAttribs);\n                tb.processEndTag(\"label\");\n                tb.processStartTag(\"hr\");\n                tb.processEndTag(\"form\");\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.processEndTag(\"option\");\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.normalName();\n            if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    ArrayList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue;\n                        } else if (node == formatEl)\n                            break;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                        // case will follow the original node (so honours ParseSettings)\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"span\")) {\n                // same as final fall through, but saves short circuit\n                return anyOtherEndTag(t, tb);\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.processEndTag(\"body\");\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.processStartTag(\"br\");\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
      "first_line": 252,
      "last_line": 764
    },
    "javadoc": "// skips some script rules as won't execute them",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::preSkipsFirstNewline": {
        "source": "  @Test public void preSkipsFirstNewline() {\n\n        Document doc = Jsoup.parse(\"<pre>\\n\\nOne\\nTwo\\n</pre>\");\n\n        Element pre = doc.selectFirst(\"pre\");\n\n        assertEquals(\"One\\nTwo\", pre.text());\n\n        assertEquals(\"\\nOne\\nTwo\\n\", pre.wholeText());\n\n  }\n"
      }
    }
  },
  "Jsoup-77": {
    "id": "Jsoup-77",
    "project": "Jsoup",
    "number": "77",
    "buggy_function": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}",
    "fixed_function": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.normalName();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
      "first_line": 116,
      "last_line": 136
    },
    "javadoc": "/**\n* If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n* found, skips.\n*\n* @param endTag tag to close\n*/",
    "failing_tests": {
      "org.jsoup.parser.XmlTreeBuilderTest::normalizesDiscordantTags": {
        "source": "    @Test public void normalizesDiscordantTags() {\n\n        Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\n\n        Document document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);\n\n        assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html());\n\n        // was failing -> toString() = \"<div>\\n test\\n <p></p>\\n</div>\"\n\n    }\n"
      }
    }
  },
  "Jsoup-80": {
    "id": "Jsoup-80",
    "project": "Jsoup",
    "number": "80",
    "buggy_function": "void insert(Token.Comment commentToken) {\n    Comment comment = new Comment(commentToken.getData());\n    Node insert = comment;\n    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n        String data = comment.getData();\n        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n            Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n        }\n    }\n    insertNode(insert);\n}",
    "fixed_function": "void insert(Token.Comment commentToken) {\n    Comment comment = new Comment(commentToken.getData());\n    Node insert = comment;\n    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n        String data = comment.getData();\n        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n            Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n            if (doc.childNodeSize() > 0) {\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            } // else, we couldn't parse it as a decl, so leave as a comment\n        }\n    }\n    insertNode(insert);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
      "first_line": 83,
      "last_line": 97
    },
    "javadoc": "// todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.",
    "failing_tests": {
      "org.jsoup.parser.XmlTreeBuilderTest::handlesDodgyXmlDecl": {
        "source": "    public void handlesDodgyXmlDecl() {\n\n        String xml = \"<?xml version='1.0'><val>One</val>\";\n\n        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n\n        assertEquals(\"One\", doc.select(\"val\").text());\n\n    }\n"
      }
    }
  },
  "Jsoup-82": {
    "id": "Jsoup-82",
    "project": "Jsoup",
    "number": "82",
    "buggy_function": "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}",
    "fixed_function": "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/DataUtil.java",
      "first_line": 95,
      "last_line": 175
    },
    "javadoc": "/**\n* Writes the input stream to the output stream. Doesn't close them.\n* @param in input stream to read from\n* @param out output stream to write to\n* @throws IOException on IO error\n*/",
    "failing_tests": {
      "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode": {
        "source": "    @Test public void fallbackToUtfIfCantEncode() throws IOException {\n\n        // that charset can't be encoded, so make sure we flip to utf\n\n\n\n        String in = \"<html><meta charset=\\\"ISO-2022-CN\\\"/>One</html>\";\n\n        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, \"\");\n\n\n\n        assertEquals(\"UTF-8\", doc.charset().name());\n\n        assertEquals(\"One\", doc.text());\n\n\n\n        String html = doc.outerHtml();\n\n        assertEquals(\"<html><head><meta charset=\\\"UTF-8\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(html));\n\n    }\n"
      }
    }
  },
  "Jsoup-84": {
    "id": "Jsoup-84",
    "project": "Jsoup",
    "number": "84",
    "buggy_function": "public void head(org.jsoup.nodes.Node source, int depth) {\n    namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n    if (source instanceof org.jsoup.nodes.Element) {\n        org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n        String prefix = updateNamespaces(sourceEl);\n        String namespace = namespacesStack.peek().get(prefix);\n        String tagName = sourceEl.tagName();\n\n        Element el = \n            doc.createElementNS(namespace, tagName);\n        copyAttributes(sourceEl, el);\n        if (dest == null) { // sets up the root\n            doc.appendChild(el);\n        } else {\n            dest.appendChild(el);\n        }\n        dest = el; // descend\n    } else if (source instanceof org.jsoup.nodes.TextNode) {\n        org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n        Text text = doc.createTextNode(sourceText.getWholeText());\n        dest.appendChild(text);\n    } else if (source instanceof org.jsoup.nodes.Comment) {\n        org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n        Comment comment = doc.createComment(sourceComment.getData());\n        dest.appendChild(comment);\n    } else if (source instanceof org.jsoup.nodes.DataNode) {\n        org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n        Text node = doc.createTextNode(sourceData.getWholeData());\n        dest.appendChild(node);\n    } else {\n        // unhandled\n    }\n}",
    "fixed_function": "public void head(org.jsoup.nodes.Node source, int depth) {\n    namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n    if (source instanceof org.jsoup.nodes.Element) {\n        org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n        String prefix = updateNamespaces(sourceEl);\n        String namespace = namespacesStack.peek().get(prefix);\n        String tagName = sourceEl.tagName();\n\n        Element el = namespace == null && tagName.contains(\":\") ?\n            doc.createElementNS(\"\", tagName) : // doesn't have a real namespace defined\n            doc.createElementNS(namespace, tagName);\n        copyAttributes(sourceEl, el);\n        if (dest == null) { // sets up the root\n            doc.appendChild(el);\n        } else {\n            dest.appendChild(el);\n        }\n        dest = el; // descend\n    } else if (source instanceof org.jsoup.nodes.TextNode) {\n        org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n        Text text = doc.createTextNode(sourceText.getWholeText());\n        dest.appendChild(text);\n    } else if (source instanceof org.jsoup.nodes.Comment) {\n        org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n        Comment comment = doc.createComment(sourceComment.getData());\n        dest.appendChild(comment);\n    } else if (source instanceof org.jsoup.nodes.DataNode) {\n        org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n        Text node = doc.createTextNode(sourceData.getWholeData());\n        dest.appendChild(node);\n    } else {\n        // unhandled\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/W3CDom.java",
      "first_line": 82,
      "last_line": 115
    },
    "javadoc": "/**\n* Implements the conversion by walking the input.\n*/",
    "failing_tests": {
      "org.jsoup.helper.W3CDomTest::treatsUndeclaredNamespaceAsLocalName": {
        "source": "    @Test public void treatsUndeclaredNamespaceAsLocalName() {\n\n        String html = \"<fb:like>One</fb:like>\";\n\n        org.jsoup.nodes.Document doc = Jsoup.parse(html);\n\n\n\n        Document w3Doc = new W3CDom().fromJsoup(doc);\n\n        Node htmlEl = w3Doc.getFirstChild();\n\n\n\n        assertNull(htmlEl.getNamespaceURI());\n\n        assertEquals(\"html\", htmlEl.getLocalName());\n\n        assertEquals(\"html\", htmlEl.getNodeName());\n\n\n\n        Node fb = htmlEl.getFirstChild().getNextSibling().getFirstChild();\n\n        assertNull(fb.getNamespaceURI());\n\n        assertEquals(\"like\", fb.getLocalName());\n\n        assertEquals(\"fb:like\", fb.getNodeName());\n\n\n\n    }\n"
      }
    }
  },
  "Jsoup-85": {
    "id": "Jsoup-85",
    "project": "Jsoup",
    "number": "85",
    "buggy_function": "public Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    this.key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    this.val = val;\n    this.parent = parent;\n}",
    "fixed_function": "public Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    this.key = key;\n    this.val = val;\n    this.parent = parent;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Attribute.java",
      "first_line": 42,
      "last_line": 48
    },
    "javadoc": "/**\n* Create a new attribute from unencoded (raw) key and value.\n* @param key attribute key; case is preserved.\n* @param value attribute value\n* @see #createFromEncoded\n*/",
    "failing_tests": {
      "org.jsoup.nodes.AttributeTest::validatesKeysNotEmpty": {
        "source": "    @Test(expected = IllegalArgumentException.class) public void validatesKeysNotEmpty() {\n\n        Attribute attr = new Attribute(\" \", \"Check\");\n\n    }\n"
      }
    }
  },
  "Jsoup-86": {
    "id": "Jsoup-86",
    "project": "Jsoup",
    "number": "86",
    "buggy_function": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    if (doc.childNodeSize() > 0) {\n        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}",
    "fixed_function": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    if (doc.children().size() > 0) {\n        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Comment.java",
      "first_line": 74,
      "last_line": 84
    },
    "javadoc": "/**\n* Attempt to cast this comment to an XML Declaration note.\n* @return an XML declaration if it could be parsed as one, null otherwise.\n*/",
    "failing_tests": {
      "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript": {
        "source": "    public void handlesLTinScript() {\n\n        // https://github.com/jhy/jsoup/issues/1139\n\n        String html = \"<script> var a=\\\"<?\\\"; var b=\\\"?>\\\"; </script>\";\n\n        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n\n        assertEquals(\"<script> var a=\\\"\\n <!--?\\\"; var b=\\\"?-->\\\"; </script>\", doc.html()); // converted from pseudo xmldecl to comment\n\n    }\n"
      }
    }
  },
  "Jsoup-88": {
    "id": "Jsoup-88",
    "project": "Jsoup",
    "number": "88",
    "buggy_function": "public String getValue() {\n    return val;\n}",
    "fixed_function": "public String getValue() {\n    return Attributes.checkNotNull(val);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Attribute.java",
      "first_line": 79,
      "last_line": 81
    },
    "javadoc": "/**\nGet the attribute value.\n@return the attribute value\n*/",
    "failing_tests": {
      "org.jsoup.nodes.AttributeTest::booleanAttributesAreEmptyStringValues": {
        "source": "    @Test public void booleanAttributesAreEmptyStringValues() {\n\n        Document doc = Jsoup.parse(\"<div hidden>\");\n\n        Attributes attributes = doc.body().child(0).attributes();\n\n        assertEquals(\"\", attributes.get(\"hidden\"));\n\n\n\n        Attribute first = attributes.iterator().next();\n\n        assertEquals(\"hidden\", first.getKey());\n\n        assertEquals(\"\", first.getValue());\n\n    }\n"
      }
    }
  },
  "Jsoup-89": {
    "id": "Jsoup-89",
    "project": "Jsoup",
    "number": "89",
    "buggy_function": "public String setValue(String val) {\n    String oldVal = parent.get(this.key);\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.vals[i] = val;\n    }\n    this.val = val;\n    return Attributes.checkNotNull(oldVal);\n}",
    "fixed_function": "public String setValue(String val) {\n    String oldVal = this.val;\n    if (parent != null) {\n        oldVal = parent.get(this.key); // trust the container more\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.vals[i] = val;\n    }\n    this.val = val;\n    return Attributes.checkNotNull(oldVal);\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/Attribute.java",
      "first_line": 87,
      "last_line": 96
    },
    "javadoc": "/**\nSet the attribute value.\n@param val the new attribute value; must not be null\n*/",
    "failing_tests": {
      "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute": {
        "source": "    @Test public void settersOnOrphanAttribute() {\n\n        Attribute attr = new Attribute(\"one\", \"two\");\n\n        attr.setKey(\"three\");\n\n        String oldVal = attr.setValue(\"four\");\n\n        assertEquals(\"two\", oldVal);\n\n        assertEquals(\"three\", attr.getKey());\n\n        assertEquals(\"four\", attr.getValue());\n\n        assertEquals(null, attr.parent);\n\n    }\n"
      }
    }
  },
  "Jsoup-90": {
    "id": "Jsoup-90",
    "project": "Jsoup",
    "number": "90",
    "buggy_function": "private static boolean looksLikeUtf8(byte[] input) {\n    int i = 0;\n    // BOM:\n    if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n        && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n        i = 3;\n    }\n\n    int end;\n    for (int j = input.length; i < j; ++i) {\n        int o = input[i];\n        if ((o & 0x80) == 0) {\n            continue; // ASCII\n        }\n\n        // UTF-8 leading:\n        if ((o & 0xE0) == 0xC0) {\n            end = i + 1;\n        } else if ((o & 0xF0) == 0xE0) {\n            end = i + 2;\n        } else if ((o & 0xF8) == 0xF0) {\n            end = i + 3;\n        } else {\n            return false;\n        }\n\n\n        while (i < end) {\n            i++;\n            o = input[i];\n            if ((o & 0xC0) != 0x80) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "fixed_function": "private static boolean looksLikeUtf8(byte[] input) {\n    int i = 0;\n    // BOM:\n    if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n        && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n        i = 3;\n    }\n\n    int end;\n    for (int j = input.length; i < j; ++i) {\n        int o = input[i];\n        if ((o & 0x80) == 0) {\n            continue; // ASCII\n        }\n\n        // UTF-8 leading:\n        if ((o & 0xE0) == 0xC0) {\n            end = i + 1;\n        } else if ((o & 0xF0) == 0xE0) {\n            end = i + 2;\n        } else if ((o & 0xF8) == 0xF0) {\n            end = i + 3;\n        } else {\n            return false;\n        }\n\n        if (end >= input.length)\n            return false;\n\n        while (i < end) {\n            i++;\n            o = input[i];\n            if ((o & 0xC0) != 0x80) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
      "first_line": 398,
      "last_line": 434
    },
    "javadoc": "// shouldn't happen as these both always exist",
    "failing_tests": {
      "org.jsoup.helper.HttpConnectionTest::handlesHeaderEncodingOnRequest": {
        "source": "    @Test public void handlesHeaderEncodingOnRequest() {\n\n        Connection.Request req = new HttpConnection.Request();\n\n        req.addHeader(\"xxx\", \"\u00e9\");\n\n    }\n"
      }
    }
  },
  "Jsoup-93": {
    "id": "Jsoup-93",
    "project": "Jsoup",
    "number": "93",
    "buggy_function": "public List<Connection.KeyVal> formData() {\n    ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element el: elements) {\n        if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n        if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n        String name = el.attr(\"name\");\n        if (name.length() == 0) continue;\n        String type = el.attr(\"type\");\n\n\n        if (\"select\".equals(el.normalName())) {\n            Elements options = el.select(\"option[selected]\");\n            boolean set = false;\n            for (Element option: options) {\n                data.add(HttpConnection.KeyVal.create(name, option.val()));\n                set = true;\n            }\n            if (!set) {\n                Element option = el.select(\"option\").first();\n                if (option != null)\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n            }\n        } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n            // only add checkbox or radio if they have the checked attribute\n            if (el.hasAttr(\"checked\")) {\n                final String val = el.val().length() >  0 ? el.val() : \"on\";\n                data.add(HttpConnection.KeyVal.create(name, val));\n            }\n        } else {\n            data.add(HttpConnection.KeyVal.create(name, el.val()));\n        }\n    }\n    return data;\n}",
    "fixed_function": "public List<Connection.KeyVal> formData() {\n    ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element el: elements) {\n        if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n        if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n        String name = el.attr(\"name\");\n        if (name.length() == 0) continue;\n        String type = el.attr(\"type\");\n\n        if (type.equalsIgnoreCase(\"button\")) continue; // browsers don't submit these\n\n        if (\"select\".equals(el.normalName())) {\n            Elements options = el.select(\"option[selected]\");\n            boolean set = false;\n            for (Element option: options) {\n                data.add(HttpConnection.KeyVal.create(name, option.val()));\n                set = true;\n            }\n            if (!set) {\n                Element option = el.select(\"option\").first();\n                if (option != null)\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n            }\n        } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n            // only add checkbox or radio if they have the checked attribute\n            if (el.hasAttr(\"checked\")) {\n                final String val = el.val().length() >  0 ? el.val() : \"on\";\n                data.add(HttpConnection.KeyVal.create(name, val));\n            }\n        } else {\n            data.add(HttpConnection.KeyVal.create(name, el.val()));\n        }\n    }\n    return data;\n}",
    "replacement_info": {
      "file": "src/main/java/org/jsoup/nodes/FormElement.java",
      "first_line": 78,
      "last_line": 113
    },
    "javadoc": "/**\n* Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n* list will not be reflected in the DOM.\n* @return a list of key vals\n*/",
    "failing_tests": {
      "org.jsoup.nodes.FormElementTest::createsFormData": {
        "source": "    @Test public void createsFormData() {\n\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n\n                \"<input name='ten' value='text' disabled>\" +\n\n                \"<input name='eleven' value='text' type='button'>\" +\n\n                \"</form>\";\n\n        Document doc = Jsoup.parse(html);\n\n        FormElement form = (FormElement) doc.select(\"form\").first();\n\n        List<Connection.KeyVal> data = form.formData();\n\n\n\n        assertEquals(6, data.size());\n\n        assertEquals(\"one=two\", data.get(0).toString());\n\n        assertEquals(\"three=four\", data.get(1).toString());\n\n        assertEquals(\"three=five\", data.get(2).toString());\n\n        assertEquals(\"six=seven\", data.get(3).toString());\n\n        assertEquals(\"seven=on\", data.get(4).toString()); // set\n\n        assertEquals(\"eight=on\", data.get(5).toString()); // default\n\n        // nine should not appear, not checked checkbox\n\n        // ten should not appear, disabled\n\n        // eleven should not appear, button\n\n    }\n"
      }
    }
  },
  "JxPath-10": {
    "id": "JxPath-10",
    "project": "JxPath",
    "number": "10",
    "buggy_function": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n            ? Boolean.TRUE : Boolean.FALSE;\n}",
    "fixed_function": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].compute(context), args[1].compute(context))\n            ? Boolean.TRUE : Boolean.FALSE;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java",
      "first_line": 41,
      "last_line": 44
    },
    "javadoc": "/**\n* Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n* @since JXPath 1.3\n*\n* @author Matt Benson\n* @version $Revision$ $Date$\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testEmptyNodeSetOperations": {
        "source": "    public void testEmptyNodeSetOperations() {\n\n        assertXPathValue(context, \"/idonotexist = 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"/idonotexist != 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"/idonotexist < 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"/idonotexist > 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"/idonotexist <= 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$array[position() < 1] = 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$array[position() < 1] != 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$array[position() < 1] < 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$array[position() < 1] > 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$array[position() < 1] >= 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$array[position() < 1] <= 0\", Boolean.FALSE, Boolean.class);\n\n    }\n"
      }
    }
  },
  "JxPath-12": {
    "id": "JxPath-12",
    "project": "JxPath",
    "number": "12",
    "buggy_function": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return nodeType == Node.ELEMENT_NODE\n                        || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT :\n                return nodeType == Node.CDATA_SECTION_NODE\n                    || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT :\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI :\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}",
    "fixed_function": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return nodeType == Node.ELEMENT_NODE\n                        || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT :\n                return nodeType == Node.CDATA_SECTION_NODE\n                    || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT :\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI :\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java",
      "first_line": 87,
      "last_line": 136
    },
    "javadoc": "/**\n* A Pointer that points to a DOM node.\n*\n* @author Dmitri Plotnikov\n* @version $Revision$ $Date$\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest::testElementDOM": {
        "source": "    public void testElementDOM() {\n\n        doTestElement(DocumentContainer.MODEL_DOM);\n\n    }\n"
      }
    }
  },
  "JxPath-21": {
    "id": "JxPath-21",
    "project": "JxPath",
    "number": "21",
    "buggy_function": "public int getLength() {\n    return ValueUtils.getLength(getBaseValue());\n}",
    "fixed_function": "public int getLength() {\n    Object baseValue = getBaseValue();\n    return baseValue == null ? 1 : ValueUtils.getLength(baseValue);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java",
      "first_line": 151,
      "last_line": 153
    },
    "javadoc": "/**\n* If the property contains a collection, then the length of that\n* collection, otherwise - 1.\n* @return int length\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.model.JXPath151Test::testMapValueEquality": {
        "source": "    public void testMapValueEquality() {\n\n        assertXPathValue(context, \"map/b != map/a\", Boolean.TRUE);\n\n        assertXPathValue(context, \"map/a != map/b\", Boolean.TRUE);\n\n        assertXPathValue(context, \"map/a != map/c\", Boolean.FALSE);\n\n        assertXPathValue(context, \"map/a = map/b\", Boolean.FALSE);\n\n        assertXPathValue(context, \"map/a = map/c\", Boolean.TRUE);\n\n        assertXPathValue(context, \"not(map/a = map/b)\", Boolean.TRUE);\n\n        assertXPathValue(context, \"not(map/a = map/c)\", Boolean.FALSE);\n\n    }\n"
      },
      "org.apache.commons.jxpath.ri.model.MixedModelTest::testNull": {
        "source": "    public void testNull() {\n\n\n\n        assertXPathPointerLenient(context, \"$null\", \"$null\");\n\n\n\n        assertXPathPointerLenient(context, \"$null[3]\", \"$null[3]\");\n\n\n\n        assertXPathPointerLenient(\n\n            context,\n\n            \"$testnull/nothing\",\n\n            \"$testnull/nothing\");\n\n\n\n        assertXPathPointerLenient(\n\n            context,\n\n            \"$testnull/nothing[2]\",\n\n            \"$testnull/nothing[2]\");\n\n\n\n        assertXPathPointerLenient(context, \"beans[8]/int\", \"/beans[8]/int\");\n\n\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"$testnull/nothing[1]\",\n\n            list(null));\n\n\n\n        JXPathContext ctx = JXPathContext.newContext(new TestNull());\n\n        assertXPathValue(ctx, \"nothing\", null);\n\n\n\n        assertXPathValue(ctx, \"child/nothing\", null);\n\n\n\n        assertXPathValue(ctx, \"array[2]\", null);\n\n\n\n        assertXPathValueLenient(ctx, \"nothing/something\", null);\n\n\n\n        assertXPathValueLenient(ctx, \"array[2]/something\", null);\n\n    }\n"
      }
    }
  },
  "JxPath-22": {
    "id": "JxPath-22",
    "project": "JxPath",
    "number": "22",
    "buggy_function": "public static String getNamespaceURI(Node node) {\n    if (node instanceof Document) {\n        node = ((Document) node).getDocumentElement();\n    }\n\n    Element element = (Element) node;\n\n    String uri = element.getNamespaceURI();\n    if (uri == null) {\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n    return uri;\n}",
    "fixed_function": "public static String getNamespaceURI(Node node) {\n    if (node instanceof Document) {\n        node = ((Document) node).getDocumentElement();\n    }\n\n    Element element = (Element) node;\n\n    String uri = element.getNamespaceURI();\n    if (uri == null) {\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    uri = attr.getValue();\n                    break;\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n    }\n    return \"\".equals(uri) ? null : uri;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java",
      "first_line": 672,
      "last_line": 697
    },
    "javadoc": "/**\n* Get the ns uri of the specified node.\n* @param node Node to check\n* @return String ns uri\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.model.JXPath154Test::testInnerEmptyNamespaceDOM": {
        "source": "    public void testInnerEmptyNamespaceDOM() {\n\n        doTest(\"b:foo/test\", DocumentContainer.MODEL_DOM, \"/b:foo[1]/test[1]\");\n\n    }\n"
      }
    }
  },
  "JxPath-5": {
    "id": "JxPath-5",
    "project": "JxPath",
    "number": "5",
    "buggy_function": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n\n    if (depth1 == 1) {\n        throw new JXPathException(\n                \"Cannot compare pointers that do not belong to the same tree: '\"\n                        + p1 + \"' and '\" + p2 + \"'\");\n    }\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n    if (r != 0) {\n        return r;\n    }\n\n    return p1.parent.compareChildNodePointers(p1, p2);\n}",
    "fixed_function": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n\n    if (depth1 == 1) {\n        return 0;\n    }\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n    if (r != 0) {\n        return r;\n    }\n\n    return p1.parent.compareChildNodePointers(p1, p2);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/model/NodePointer.java",
      "first_line": 642,
      "last_line": 675
    },
    "javadoc": "// Task 1: find the common parent",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.compiler.VariableTest::testUnionOfVariableAndNode": {
        "source": "    public void testUnionOfVariableAndNode() throws Exception {\n\n        Document doc = DocumentBuilderFactory.newInstance()\n\n                .newDocumentBuilder().parse(\n\n                        new InputSource(new StringReader(\n\n                                \"<MAIN><A/><A/></MAIN>\")));\n\n\n\n        JXPathContext context = JXPathContext.newContext(doc);\n\n        context.getVariables().declareVariable(\"var\", \"varValue\");\n\n        int sz = 0;\n\n        for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {\n\n            ptrs.next();\n\n        }\n\n        assertEquals(3, sz);\n\n    }\n"
      }
    }
  },
  "JxPath-6": {
    "id": "JxPath-6",
    "project": "JxPath",
    "number": "6",
    "buggy_function": "protected boolean equal(\n    EvalContext context,\n    Expression left,\n    Expression right) \n{\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n      System.err.println(\"COMPARING: \" +\n          (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n          (r == null ? \"null\" : r.getClass().getName()));\n\n    if (l instanceof InitialContext || l instanceof SelfContext) {\n        l = ((EvalContext) l).getSingleNodePointer();\n    }\n\n    if (r instanceof InitialContext || r instanceof SelfContext) {\n        r = ((EvalContext) r).getSingleNodePointer();\n    }\n\n    if (l instanceof Collection) {\n        l = ((Collection) l).iterator();\n    }\n\n    if (r instanceof Collection) {\n        r = ((Collection) r).iterator();\n    }\n\n    if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n        return contains((Iterator) l, r);\n    }\n    if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n        return contains((Iterator) r, l);\n    }\n    if (l instanceof Iterator && r instanceof Iterator) {\n        return findMatch((Iterator) l, (Iterator) r);\n    }\n    return equal(l, r);\n}",
    "fixed_function": "protected boolean equal(\n    EvalContext context,\n    Expression left,\n    Expression right) \n{\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n      System.err.println(\"COMPARING: \" +\n          (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n          (r == null ? \"null\" : r.getClass().getName()));\n\n    if (l instanceof InitialContext) {\n        ((EvalContext) l).reset();\n    }\n\n    if (l instanceof SelfContext) {\n        l = ((EvalContext) l).getSingleNodePointer();\n    }\n\n    if (r instanceof InitialContext) {\n        ((EvalContext) r).reset();\n    }\n\n    if (r instanceof SelfContext) {\n        r = ((EvalContext) r).getSingleNodePointer();\n    }\n\n    if (l instanceof Collection) {\n        l = ((Collection) l).iterator();\n    }\n\n    if (r instanceof Collection) {\n        r = ((Collection) r).iterator();\n    }\n\n    if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n        return contains((Iterator) l, r);\n    }\n    if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n        return contains((Iterator) r, l);\n    }\n    if (l instanceof Iterator && r instanceof Iterator) {\n        return findMatch((Iterator) l, (Iterator) r);\n    }\n    return equal(l, r);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java",
      "first_line": 45,
      "last_line": 83
    },
    "javadoc": "/**\n* Compares two values\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.compiler.VariableTest::testIterateVariable": {
        "source": "    public void testIterateVariable() throws Exception {\n\n        assertXPathValueIterator(context, \"$d\", list(\"a\", \"b\"));\n\n        assertXPathValue(context, \"$d = 'a'\", Boolean.TRUE);\n\n        assertXPathValue(context, \"$d = 'b'\", Boolean.TRUE);\n\n    }\n"
      }
    }
  },
  "JxPath-8": {
    "id": "JxPath-8",
    "project": "JxPath",
    "number": "8",
    "buggy_function": "private boolean compute(Object left, Object right) {\n    left = reduce(left);\n    right = reduce(right);\n\n    if (left instanceof InitialContext) {\n        ((InitialContext) left).reset();\n    }\n    if (right instanceof InitialContext) {\n        ((InitialContext) right).reset();\n    }\n    if (left instanceof Iterator && right instanceof Iterator) {\n        return findMatch((Iterator) left, (Iterator) right);\n    }\n    if (left instanceof Iterator) {\n        return containsMatch((Iterator) left, right);\n    }\n    if (right instanceof Iterator) {\n        return containsMatch((Iterator) right, left);\n    }\n    double ld = InfoSetUtil.doubleValue(left);\n    double rd = InfoSetUtil.doubleValue(right);\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n}",
    "fixed_function": "private boolean compute(Object left, Object right) {\n    left = reduce(left);\n    right = reduce(right);\n\n    if (left instanceof InitialContext) {\n        ((InitialContext) left).reset();\n    }\n    if (right instanceof InitialContext) {\n        ((InitialContext) right).reset();\n    }\n    if (left instanceof Iterator && right instanceof Iterator) {\n        return findMatch((Iterator) left, (Iterator) right);\n    }\n    if (left instanceof Iterator) {\n        return containsMatch((Iterator) left, right);\n    }\n    if (right instanceof Iterator) {\n        return containsMatch((Iterator) right, left);\n    }\n    double ld = InfoSetUtil.doubleValue(left);\n    if (Double.isNaN(ld)) {\n        return false;\n    }\n    double rd = InfoSetUtil.doubleValue(right);\n    if (Double.isNaN(rd)) {\n        return false;\n    }\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java",
      "first_line": 56,
      "last_line": 78
    },
    "javadoc": "/**\n* Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n* @since JXPath 1.3\n*\n* @author Matt Benson\n* @version $Revision$ $Date$\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNan": {
        "source": "    public void testNan() {\n\n        assertXPathValue(context, \"$nan > $nan\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan < $nan\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan = $nan\", Boolean.TRUE, Boolean.class);\n\n        assertXPathValue(context, \"$nan > 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan < 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan = 0\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan > 1\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan < 1\", Boolean.FALSE, Boolean.class);\n\n        assertXPathValue(context, \"$nan = 1\", Boolean.FALSE, Boolean.class);\n\n    }\n"
      }
    }
  },
  "Lang-1": {
    "id": "Lang-1",
    "project": "Lang",
    "number": "1",
    "buggy_function": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) { // we have a hex number\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) { // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8) { // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n    int numDecimals = 0; // Check required precision (LANG-693)\n    if (decPos > -1) { // there is a decimal point\n\n        if (expPos > -1) { // there is an exponent\n            if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n        numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) { // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n\n    //Must be a Float, Double, BigDecimal\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n            final Float f = createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n    try {\n        if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n            final Double d = createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n\n    return createBigDecimal(str);\n}",
    "fixed_function": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) { // we have a hex number\n        char firstSigDigit = 0; // strip leading zeroes\n        for(int i = pfxLen; i < str.length(); i++) {\n            firstSigDigit = str.charAt(i);\n            if (firstSigDigit == '0') { // count leading zeroes\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n    int numDecimals = 0; // Check required precision (LANG-693)\n    if (decPos > -1) { // there is a decimal point\n\n        if (expPos > -1) { // there is an exponent\n            if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n        numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) { // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n\n    //Must be a Float, Double, BigDecimal\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n            final Float f = createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n    try {\n        if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n            final Double d = createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n\n    return createBigDecimal(str);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "first_line": 450,
      "last_line": 614
    },
    "javadoc": "/**\n* <p>Turns a string value into a java.lang.Number.</p>\n*\n* <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n* will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n* prefix is more than 8 - or BigInteger if there are more than 16 digits.\n* </p>\n* <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n* <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n* trying to create successively larger types from the type specified\n* until one is found that can represent the value.</p>\n*\n* <p>If a type specifier is not found, it will check for a decimal point\n* and then try successively larger types from <code>Integer</code> to\n* <code>BigInteger</code> and from <code>Float</code> to\n* <code>BigDecimal</code>.</p>\n*\n* <p>\n* Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n* be Integer, Long or BigDecimal as appropriate.\n* </p>\n*\n* <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n*\n* <p>This method does not trim the input string, i.e., strings with leading\n* or trailing spaces will generate NumberFormatExceptions.</p>\n*\n* @param str  String containing a number, may be null\n* @return Number created from the string (or null if the input is null)\n* @throws NumberFormatException if the value cannot be converted\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.math.NumberUtilsTest::TestLang747": {
        "source": "    public void TestLang747() {\n\n        assertEquals(Integer.valueOf(0x8000),      NumberUtils.createNumber(\"0x8000\"));\n\n        assertEquals(Integer.valueOf(0x80000),     NumberUtils.createNumber(\"0x80000\"));\n\n        assertEquals(Integer.valueOf(0x800000),    NumberUtils.createNumber(\"0x800000\"));\n\n        assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x8000000\"));\n\n        assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x7FFFFFFF\"));\n\n        assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x80000000\"));\n\n        assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0xFFFFFFFF\"));\n\n\n\n        // Leading zero tests\n\n        assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x08000000\"));\n\n        assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x007FFFFFFF\"));\n\n        assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x080000000\"));\n\n        assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0x00FFFFFFFF\"));\n\n\n\n        assertEquals(Long.valueOf(0x800000000L),        NumberUtils.createNumber(\"0x800000000\"));\n\n        assertEquals(Long.valueOf(0x8000000000L),       NumberUtils.createNumber(\"0x8000000000\"));\n\n        assertEquals(Long.valueOf(0x80000000000L),      NumberUtils.createNumber(\"0x80000000000\"));\n\n        assertEquals(Long.valueOf(0x800000000000L),     NumberUtils.createNumber(\"0x800000000000\"));\n\n        assertEquals(Long.valueOf(0x8000000000000L),    NumberUtils.createNumber(\"0x8000000000000\"));\n\n        assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x80000000000000\"));\n\n        assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x800000000000000\"));\n\n        assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x7FFFFFFFFFFFFFFF\"));\n\n        // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n\n        assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x8000000000000000\"));\n\n        assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0xFFFFFFFFFFFFFFFF\"));\n\n\n\n        // Leading zero tests\n\n        assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x00080000000000000\"));\n\n        assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x0800000000000000\"));\n\n        assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x07FFFFFFFFFFFFFFF\"));\n\n        // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n\n        assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x00008000000000000000\"));\n\n        assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0x0FFFFFFFFFFFFFFFF\"));\n\n    }\n"
      }
    }
  },
  "Lang-10": {
    "id": "Lang-10",
    "project": "Lang",
    "number": "10",
    "buggy_function": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n        case '\\'':\n            if(unquote) {\n                if(++i==value.length()) {\n                    return regex;\n                }\n                c= value.charAt(i);\n            }\n            break;\n        case '?':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n        case '\\\\':\n        case '|':\n        case '*':\n        case '+':\n        case '^':\n        case '$':\n        case '.':\n            regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}",
    "fixed_function": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n        case '\\'':\n            if(unquote) {\n                if(++i==value.length()) {\n                    return regex;\n                }\n                c= value.charAt(i);\n            }\n            break;\n        case '?':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n        case '\\\\':\n        case '|':\n        case '*':\n        case '+':\n        case '^':\n        case '$':\n        case '.':\n            regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/time/FastDateParser.java",
      "first_line": 303,
      "last_line": 343
    },
    "javadoc": "/**\n* Escape constant fields into regular expression\n* @param regex The destination regex\n* @param value The source field\n* @param unquote If true, replace two success quotes ('') with single quote (')\n* @return The <code>StringBuilder</code>\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831": {
        "source": "    public void testLANG_831() throws Exception {\n\n        testSdfAndFdp(\"M E\",\"3  Tue\", true);\n\n    }\n"
      },
      "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831": {
        "source": "    public void testLANG_831() throws Exception {\n\n        testSdfAndFdp(\"M E\",\"3  Tue\", true);\n\n    }\n"
      }
    }
  },
  "Lang-11": {
    "id": "Lang-11",
    "project": "Lang",
    "number": "11",
    "buggy_function": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                            char[] chars, Random random) {\n    if (count == 0) {\n        return \"\";\n    } else if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else {\n            if (!letters && !numbers) {\n                end = Integer.MAX_VALUE;\n            } else {\n                end = 'z' + 1;\n                start = ' ';                \n            }\n        }\n    }\n\n    char[] buffer = new char[count];\n    int gap = end - start;\n\n    while (count-- != 0) {\n        char ch;\n        if (chars == null) {\n            ch = (char) (random.nextInt(gap) + start);\n        } else {\n            ch = chars[random.nextInt(gap) + start];\n        }\n        if (letters && Character.isLetter(ch)\n                || numbers && Character.isDigit(ch)\n                || !letters && !numbers) {\n            if(ch >= 56320 && ch <= 57343) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // low surrogate, insert high surrogate after putting it in\n                    buffer[count] = ch;\n                    count--;\n                    buffer[count] = (char) (55296 + random.nextInt(128));\n                }\n            } else if(ch >= 55296 && ch <= 56191) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // high surrogate, insert low surrogate before putting it in\n                    buffer[count] = (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] = ch;\n                }\n            } else if(ch >= 56192 && ch <= 56319) {\n                // private high surrogate, no effing clue, so skip it\n                count++;\n            } else {\n                buffer[count] = ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
    "fixed_function": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                            char[] chars, Random random) {\n    if (count == 0) {\n        return \"\";\n    } else if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else {\n            if (!letters && !numbers) {\n                end = Integer.MAX_VALUE;\n            } else {\n                end = 'z' + 1;\n                start = ' ';                \n            }\n        }\n    } else {\n        if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n\n    char[] buffer = new char[count];\n    int gap = end - start;\n\n    while (count-- != 0) {\n        char ch;\n        if (chars == null) {\n            ch = (char) (random.nextInt(gap) + start);\n        } else {\n            ch = chars[random.nextInt(gap) + start];\n        }\n        if (letters && Character.isLetter(ch)\n                || numbers && Character.isDigit(ch)\n                || !letters && !numbers) {\n            if(ch >= 56320 && ch <= 57343) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // low surrogate, insert high surrogate after putting it in\n                    buffer[count] = ch;\n                    count--;\n                    buffer[count] = (char) (55296 + random.nextInt(128));\n                }\n            } else if(ch >= 55296 && ch <= 56191) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // high surrogate, insert low surrogate before putting it in\n                    buffer[count] = (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] = ch;\n                }\n            } else if(ch >= 56192 && ch <= 56319) {\n                // private high surrogate, no effing clue, so skip it\n                count++;\n            } else {\n                buffer[count] = ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "first_line": 223,
      "last_line": 289
    },
    "javadoc": "/**\n* <p>Creates a random string based on a variety of options, using\n* supplied source of randomness.</p>\n*\n* <p>If start and end are both {@code 0}, start and end are set\n* to {@code ' '} and {@code 'z'}, the ASCII printable\n* characters, will be used, unless letters and numbers are both\n* {@code false}, in which case, start and end are set to\n* {@code 0} and {@code Integer.MAX_VALUE}.\n*\n* <p>If set is not {@code null}, characters between start and\n* end are chosen.</p>\n*\n* <p>This method accepts a user-supplied {@link Random}\n* instance to use as a source of randomness. By seeding a single\n* {@link Random} instance with a fixed seed and using it for each call,\n* the same random sequence of strings can be generated repeatedly\n* and predictably.</p>\n*\n* @param count  the length of random string to create\n* @param start  the position in set of chars to start at\n* @param end  the position in set of chars to end before\n* @param letters  only allow letters?\n* @param numbers  only allow numbers?\n* @param chars  the set of chars to choose randoms from, must not be empty.\n*  If {@code null}, then it will use the set of all chars.\n* @param random  a source of randomness.\n* @return the random string\n* @throws ArrayIndexOutOfBoundsException if there are not\n*  {@code (end - start) + 1} characters in the set array.\n* @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n* @since 2.0\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.RandomStringUtilsTest::testLANG807": {
        "source": "    public void testLANG807() {\n\n        try {\n\n            RandomStringUtils.random(3,5,5,false,false);\n\n            fail(\"Expected IllegalArgumentException\");\n\n        } catch (IllegalArgumentException ex) { // distinguish from Random#nextInt message\n\n            final String msg = ex.getMessage();\n\n            assertTrue(\"Message (\" + msg + \") must contain 'start'\", msg.contains(\"start\"));\n\n            assertTrue(\"Message (\" + msg + \") must contain 'end'\", msg.contains(\"end\"));\n\n        }\n\n    }\n"
      }
    }
  },
  "Lang-12": {
    "id": "Lang-12",
    "project": "Lang",
    "number": "12",
    "buggy_function": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                            char[] chars, Random random) {\n    if (count == 0) {\n        return \"\";\n    } else if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n\n    if (start == 0 && end == 0) {\n            if (!letters && !numbers) {\n                end = Integer.MAX_VALUE;\n            } else {\n                end = 'z' + 1;\n                start = ' ';                \n            }\n    }\n\n    char[] buffer = new char[count];\n    int gap = end - start;\n\n    while (count-- != 0) {\n        char ch;\n        if (chars == null) {\n            ch = (char) (random.nextInt(gap) + start);\n        } else {\n            ch = chars[random.nextInt(gap) + start];\n        }\n        if (letters && Character.isLetter(ch)\n                || numbers && Character.isDigit(ch)\n                || !letters && !numbers) {\n            if(ch >= 56320 && ch <= 57343) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // low surrogate, insert high surrogate after putting it in\n                    buffer[count] = ch;\n                    count--;\n                    buffer[count] = (char) (55296 + random.nextInt(128));\n                }\n            } else if(ch >= 55296 && ch <= 56191) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // high surrogate, insert low surrogate before putting it in\n                    buffer[count] = (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] = ch;\n                }\n            } else if(ch >= 56192 && ch <= 56319) {\n                // private high surrogate, no effing clue, so skip it\n                count++;\n            } else {\n                buffer[count] = ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
    "fixed_function": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                            char[] chars, Random random) {\n    if (count == 0) {\n        return \"\";\n    } else if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else {\n            if (!letters && !numbers) {\n                end = Integer.MAX_VALUE;\n            } else {\n                end = 'z' + 1;\n                start = ' ';                \n            }\n        }\n    }\n\n    char[] buffer = new char[count];\n    int gap = end - start;\n\n    while (count-- != 0) {\n        char ch;\n        if (chars == null) {\n            ch = (char) (random.nextInt(gap) + start);\n        } else {\n            ch = chars[random.nextInt(gap) + start];\n        }\n        if (letters && Character.isLetter(ch)\n                || numbers && Character.isDigit(ch)\n                || !letters && !numbers) {\n            if(ch >= 56320 && ch <= 57343) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // low surrogate, insert high surrogate after putting it in\n                    buffer[count] = ch;\n                    count--;\n                    buffer[count] = (char) (55296 + random.nextInt(128));\n                }\n            } else if(ch >= 55296 && ch <= 56191) {\n                if(count == 0) {\n                    count++;\n                } else {\n                    // high surrogate, insert low surrogate before putting it in\n                    buffer[count] = (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] = ch;\n                }\n            } else if(ch >= 56192 && ch <= 56319) {\n                // private high surrogate, no effing clue, so skip it\n                count++;\n            } else {\n                buffer[count] = ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "first_line": 223,
      "last_line": 282
    },
    "javadoc": "/**\n* <p>Creates a random string based on a variety of options, using\n* supplied source of randomness.</p>\n*\n* <p>If start and end are both {@code 0}, start and end are set\n* to {@code ' '} and {@code 'z'}, the ASCII printable\n* characters, will be used, unless letters and numbers are both\n* {@code false}, in which case, start and end are set to\n* {@code 0} and {@code Integer.MAX_VALUE}.\n*\n* <p>If set is not {@code null}, characters between start and\n* end are chosen.</p>\n*\n* <p>This method accepts a user-supplied {@link Random}\n* instance to use as a source of randomness. By seeding a single\n* {@link Random} instance with a fixed seed and using it for each call,\n* the same random sequence of strings can be generated repeatedly\n* and predictably.</p>\n*\n* @param count  the length of random string to create\n* @param start  the position in set of chars to start at\n* @param end  the position in set of chars to end before\n* @param letters  only allow letters?\n* @param numbers  only allow numbers?\n* @param chars  the set of chars to choose randoms from, must not be empty.\n*  If {@code null}, then it will use the set of all chars.\n* @param random  a source of randomness.\n* @return the random string\n* @throws ArrayIndexOutOfBoundsException if there are not\n*  {@code (end - start) + 1} characters in the set array.\n* @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n* @since 2.0\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.RandomStringUtilsTest::testExceptions": {
        "source": "    public void testExceptions() {\n\n        final char[] DUMMY = new char[]{'a'}; // valid char array\n\n        try {\n\n            RandomStringUtils.random(-1);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, true, true);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, DUMMY);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, \"\");\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, (String)null);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, 'a', 'z', false, false);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random());\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n    }\n"
      },
      "org.apache.commons.lang3.RandomStringUtilsTest::testLANG805": {
        "source": "    public void testLANG805() {\n\n        long seed = System.currentTimeMillis();\n\n        assertEquals(\"aaa\", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed)));\n\n    }\n"
      }
    }
  },
  "Lang-14": {
    "id": "Lang-14",
    "project": "Lang",
    "number": "14",
    "buggy_function": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n        return cs1.equals(cs2);\n}",
    "fixed_function": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/StringUtils.java",
      "first_line": 781,
      "last_line": 789
    },
    "javadoc": "/**\n* <p>Compares two CharSequences, returning {@code true} if they represent\n* equal sequences of characters.</p>\n*\n* <p>{@code null}s are handled without exceptions. Two {@code null}\n* references are considered to be equal. The comparison is case sensitive.</p>\n*\n* <pre>\n* StringUtils.equals(null, null)   = true\n* StringUtils.equals(null, \"abc\")  = false\n* StringUtils.equals(\"abc\", null)  = false\n* StringUtils.equals(\"abc\", \"abc\") = true\n* StringUtils.equals(\"abc\", \"ABC\") = false\n* </pre>\n*\n* @see java.lang.CharSequence#equals(Object)\n* @param cs1  the first CharSequence, may be {@code null}\n* @param cs2  the second CharSequence, may be {@code null}\n* @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n* @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testEquals": {
        "source": "    public void testEquals() {\n\n        final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR;\n\n        assertTrue(StringUtils.equals(null, null));\n\n        assertTrue(StringUtils.equals(fooCs, fooCs));\n\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new StringBuilder(FOO)));\n\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'o', 'o' })));\n\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new CustomCharSequence(FOO)));\n\n        assertTrue(StringUtils.equals((CharSequence) new CustomCharSequence(FOO), fooCs));\n\n        assertFalse(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'O', 'O' })));\n\n        assertFalse(StringUtils.equals(fooCs, barCs));\n\n        assertFalse(StringUtils.equals(fooCs, null));\n\n        assertFalse(StringUtils.equals(null, fooCs));\n\n        assertFalse(StringUtils.equals(fooCs, foobarCs));\n\n        assertFalse(StringUtils.equals(foobarCs, fooCs));\n\n    }\n"
      }
    }
  },
  "Lang-16": {
    "id": "Lang-16",
    "project": "Lang",
    "number": "16",
    "buggy_function": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
    "fixed_function": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "first_line": 444,
      "last_line": 594
    },
    "javadoc": "/**\n* <p>Turns a string value into a java.lang.Number.</p>\n*\n* <p>First, the value is examined for a type qualifier on the end\n* (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n* trying to create successively larger types from the type specified\n* until one is found that can represent the value.</p>\n*\n* <p>If a type specifier is not found, it will check for a decimal point\n* and then try successively larger types from <code>Integer</code> to\n* <code>BigInteger</code> and from <code>Float</code> to\n* <code>BigDecimal</code>.</p>\n*\n* <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n* will be interpreted as a hexadecimal integer.  Values with leading\n* <code>0</code>'s will not be interpreted as octal.</p>\n*\n* <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n*\n* <p>This method does not trim the input string, i.e., strings with leading\n* or trailing spaces will generate NumberFormatExceptions.</p>\n*\n* @param str  String containing a number, may be null\n* @return Number created from the string (or null if the input is null)\n* @throws NumberFormatException if the value cannot be converted\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber": {
        "source": "    public void testCreateNumber() {\n\n        // a lot of things can go wrong\n\n        assertEquals(\"createNumber(String) 1 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n\n        assertEquals(\"createNumber(String) 2 failed\", Integer.valueOf(\"12345\"), NumberUtils.createNumber(\"12345\"));\n\n        assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n\n        assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n\n        assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n\n        assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n\n        assertEquals(\"createNumber(String) 5 failed\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n\n            + (Integer.MAX_VALUE + 1L)));\n\n        assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345L\"));\n\n        assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345l\"));\n\n        assertEquals(\"createNumber(String) 7 failed\", Float.valueOf(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n\n        assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n\n        assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n\n        assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());\n\n        assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n\n        assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());\n\n        assertEquals(\"createNumber(String) 11 failed\", Double.valueOf(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n\n        assertEquals(\"createNumber(String) 12 failed\", Float.valueOf(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n\n        assertEquals(\"createNumber(String) 13 failed\", Double.valueOf(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n\n        assertEquals(\"createNumber(String) 14 failed\", Double.valueOf(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n\n                .createNumber(\"12345678901234567890L\"));\n\n\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n\n        if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n\n                    .createNumber(\"1.1E-700F\"));\n\n        }\n\n        assertEquals(\"createNumber(String) 16 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n\n        assertEquals(\"createNumber(String) 17 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n\n\n        // LANG-521\n\n        assertEquals(\"createNumber(String) LANG-521 failed\", Float.valueOf(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n\n\n        // LANG-638\n\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n\n\n\n        // LANG-693\n\n        assertEquals(\"createNumber(String) LANG-693 failed\", Double.valueOf(Double.MAX_VALUE), NumberUtils\n\n                    .createNumber(\"\" + Double.MAX_VALUE));\n\n    }\n"
      }
    }
  },
  "Lang-17": {
    "id": "Lang-17",
    "project": "Lang",
    "number": "17",
    "buggy_function": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = Character.codePointCount(input, 0, input.length());\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n        }\n        else {\n        // contract with translators is that they have to understand codepoints \n        // and they just took care of a surrogate pair\n        for (int pt = 0; pt < consumed; pt++) {\n                if (pos < len - 2) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n                } else {\n                    pos++;\n                }\n            }\n            pos--;\n        }\n        pos++;\n    }\n}",
    "fixed_function": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        // contract with translators is that they have to understand codepoints \n        // and they just took care of a surrogate pair\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java",
      "first_line": 75,
      "last_line": 104
    },
    "javadoc": "/**\n* Translate an input onto a Writer. This is intentionally final as its algorithm is\n* tightly coupled with the abstract method of this class.\n*\n* @param input CharSequence that is being translated\n* @param out Writer to translate the text to\n* @throws IOException if and only if the Writer produces an IOException\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.StringEscapeUtilsTest::testLang720": {
        "source": "    public void testLang720() {\n\n        String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n\n        String escaped = StringEscapeUtils.escapeXml(input);\n\n        assertEquals(input, escaped);\n\n    }\n"
      }
    }
  },
  "Lang-19": {
    "id": "Lang-19",
    "project": "Lang",
    "number": "19",
    "buggy_function": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    int seqEnd = input.length();\n    // Uses -2 to ensure there is something after the &#\n    if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n\n        char firstChar = input.charAt(start);\n        if(firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n\n            // Check there's more than just an x after the &#\n        }\n\n        int end = start;\n        // Note that this supports character codes without a ; on the end\n        while(input.charAt(end) != ';') \n        {\n            end++;\n        }\n\n        int entityValue;\n        try {\n            if(isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch(NumberFormatException nfe) {\n        System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n            return 0;\n        }\n\n        if(entityValue > 0xFFFF) {\n            char[] chrs = Character.toChars(entityValue);\n            out.write(chrs[0]);\n            out.write(chrs[1]);\n        } else {\n            out.write(entityValue);\n        }\n\n\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n    }\n    return 0;\n}",
    "fixed_function": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    int seqEnd = input.length();\n    // Uses -2 to ensure there is something after the &#\n    if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n\n        char firstChar = input.charAt(start);\n        if(firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n\n            // Check there's more than just an x after the &#\n            if(start == seqEnd) {\n                return 0;\n            }\n        }\n\n        int end = start;\n        // Note that this supports character codes without a ; on the end\n        while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n                                (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n                                (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n        {\n            end++;\n        }\n\n        int entityValue;\n        try {\n            if(isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch(NumberFormatException nfe) {\n        System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n            return 0;\n        }\n\n        if(entityValue > 0xFFFF) {\n            char[] chrs = Character.toChars(entityValue);\n            out.write(chrs[0]);\n            out.write(chrs[1]);\n        } else {\n            out.write(entityValue);\n        }\n\n        boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n\n        return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n    }\n    return 0;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java",
      "first_line": 37,
      "last_line": 83
    },
    "javadoc": "/**\n* {@inheritDoc}\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest::testUnfinishedEntity": {
        "source": "    public void testUnfinishedEntity() {\n\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n\n        String input = \"Test &#x30 not test\";\n\n        String expected = \"Test \\u0030 not test\";\n\n\n\n        String result = neu.translate(input);\n\n        assertEquals(\"Failed to support unfinished entities (i.e. missing semi-colon\", expected, result);\n\n    }\n"
      },
      "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest::testOutOfBounds": {
        "source": "    public void testOutOfBounds() {\n\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n\n\n\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &\", neu.translate(\"Test &\"));\n\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &#\", neu.translate(\"Test &#\"));\n\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &#x\", neu.translate(\"Test &#x\"));\n\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &#X\", neu.translate(\"Test &#X\"));\n\n    }\n"
      }
    }
  },
  "Lang-21": {
    "id": "Lang-21",
    "project": "Lang",
    "number": "21",
    "buggy_function": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}",
    "fixed_function": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "first_line": 258,
      "last_line": 270
    },
    "javadoc": "/**\n* <p>Checks if two calendar objects represent the same local time.</p>\n*\n* <p>This method compares the values of the fields of the two objects.\n* In addition, both calendars must be the same of the same type.</p>\n*\n* @param cal1  the first calendar, not altered, not null\n* @param cal2  the second calendar, not altered, not null\n* @return true if they represent the same millisecond instant\n* @throws IllegalArgumentException if either date is <code>null</code>\n* @since 2.1\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.time.DateUtilsTest::testIsSameLocalTime_Cal": {
        "source": "    public void testIsSameLocalTime_Cal() {\n\n        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n\n        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n\n        cal1.set(2004, 6, 9, 13, 45, 0);\n\n        cal1.set(Calendar.MILLISECOND, 0);\n\n        cal2.set(2004, 6, 9, 13, 45, 0);\n\n        cal2.set(Calendar.MILLISECOND, 0);\n\n        assertEquals(true, DateUtils.isSameLocalTime(cal1, cal2));\n\n\n\n        Calendar cal3 = Calendar.getInstance();\n\n        Calendar cal4 = Calendar.getInstance();\n\n        cal3.set(2004, 6, 9, 4,  0, 0);\n\n        cal4.set(2004, 6, 9, 16, 0, 0);\n\n        cal3.set(Calendar.MILLISECOND, 0);\n\n        cal4.set(Calendar.MILLISECOND, 0);\n\n        assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));\n\n        \n\n        cal2.set(2004, 6, 9, 11, 45, 0);\n\n        assertEquals(false, DateUtils.isSameLocalTime(cal1, cal2));\n\n        try {\n\n            DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n    }\n"
      }
    }
  },
  "Lang-22": {
    "id": "Lang-22",
    "project": "Lang",
    "number": "22",
    "buggy_function": "private static int greatestCommonDivisor(int u, int v) {\n    // From Commons Math:\n    //if either operand is abs 1, return 1:\n    if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u>0) { u=-u; } // make u negative\n    if (v>0) { v=-v; } // make v negative\n    // B1. [Find power of 2]\n    int k=0;\n    while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n        u/=2; v/=2; k++; // cast out twos.\n    }\n    if (k==31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t&1)==0) { // while t is even..\n            t/=2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t>0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u)/2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t!=0);\n    return -u*(1<<k); // gcd is u*2^k\n}",
    "fixed_function": "private static int greatestCommonDivisor(int u, int v) {\n    // From Commons Math:\n    if ((u == 0) || (v == 0)) {\n        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        return Math.abs(u) + Math.abs(v);\n    }\n    //if either operand is abs 1, return 1:\n    if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u>0) { u=-u; } // make u negative\n    if (v>0) { v=-v; } // make v negative\n    // B1. [Find power of 2]\n    int k=0;\n    while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n        u/=2; v/=2; k++; // cast out twos.\n    }\n    if (k==31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t&1)==0) { // while t is even..\n            t/=2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t>0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u)/2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t!=0);\n    return -u*(1<<k); // gcd is u*2^k\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/math/Fraction.java",
      "first_line": 581,
      "last_line": 624
    },
    "javadoc": "/**\n* <p>Gets the greatest common divisor of the absolute value of\n* two numbers, using the \"binary gcd\" method which avoids\n* division and modulo operations.  See Knuth 4.5.2 algorithm B.\n* This algorithm is due to Josef Stein (1961).</p>\n*\n* @param u  a non-zero number\n* @param v  a non-zero number\n* @return the greatest common divisor, never zero\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.math.FractionTest::testReducedFactory_int_int": {
        "source": "    public void testReducedFactory_int_int() {\n\n        Fraction f = null;\n\n        \n\n        // zero\n\n        f = Fraction.getReducedFraction(0, 1);\n\n        assertEquals(0, f.getNumerator());\n\n        assertEquals(1, f.getDenominator());\n\n        \n\n        // normal\n\n        f = Fraction.getReducedFraction(1, 1);\n\n        assertEquals(1, f.getNumerator());\n\n        assertEquals(1, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(2, 1);\n\n        assertEquals(2, f.getNumerator());\n\n        assertEquals(1, f.getDenominator());\n\n        \n\n        // improper\n\n        f = Fraction.getReducedFraction(22, 7);\n\n        assertEquals(22, f.getNumerator());\n\n        assertEquals(7, f.getDenominator());\n\n        \n\n        // negatives\n\n        f = Fraction.getReducedFraction(-6, 10);\n\n        assertEquals(-3, f.getNumerator());\n\n        assertEquals(5, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(6, -10);\n\n        assertEquals(-3, f.getNumerator());\n\n        assertEquals(5, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(-6, -10);\n\n        assertEquals(3, f.getNumerator());\n\n        assertEquals(5, f.getDenominator());\n\n        \n\n        // zero denominator\n\n        try {\n\n            f = Fraction.getReducedFraction(1, 0);\n\n            fail(\"expecting ArithmeticException\");\n\n        } catch (ArithmeticException ex) {}\n\n        \n\n        try {\n\n            f = Fraction.getReducedFraction(2, 0);\n\n            fail(\"expecting ArithmeticException\");\n\n        } catch (ArithmeticException ex) {}\n\n        \n\n        try {\n\n            f = Fraction.getReducedFraction(-3, 0);\n\n            fail(\"expecting ArithmeticException\");\n\n        } catch (ArithmeticException ex) {}\n\n\n\n        // reduced        \n\n        f = Fraction.getReducedFraction(0, 2);\n\n        assertEquals(0, f.getNumerator());\n\n        assertEquals(1, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(2, 2);\n\n        assertEquals(1, f.getNumerator());\n\n        assertEquals(1, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(2, 4);\n\n        assertEquals(1, f.getNumerator());\n\n        assertEquals(2, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(15, 10);\n\n        assertEquals(3, f.getNumerator());\n\n        assertEquals(2, f.getDenominator());\n\n        \n\n        f = Fraction.getReducedFraction(121, 22);\n\n        assertEquals(11, f.getNumerator());\n\n        assertEquals(2, f.getDenominator());\n\n        \n\n        // Extreme values \n\n        // OK, can reduce before negating\n\n        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n\n        assertEquals(1, f.getNumerator());\n\n        assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n\n        \n\n        // Can't reduce, negation will throw\n\n        try { \n\n            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n\n            fail(\"Expecting ArithmeticException\");\n\n        } catch (ArithmeticException ex) {}      \n\n\n\n        // LANG-662\n\n        f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n\n        assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());\n\n        assertEquals(1, f.getDenominator());\n\n    }\n"
      },
      "org.apache.commons.lang3.math.FractionTest::testReduce": {
        "source": "    public void testReduce() {\n\n        Fraction f = null;\n\n        \n\n        f = Fraction.getFraction(50, 75);\n\n        Fraction result = f.reduce();\n\n        assertEquals(2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n\n\n        f = Fraction.getFraction(-2, -3);\n\n        result = f.reduce();\n\n        assertEquals(2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n\n\n        f = Fraction.getFraction(2, -3);\n\n        result = f.reduce();\n\n        assertEquals(-2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n\n\n        f = Fraction.getFraction(-2, 3);\n\n        result = f.reduce();\n\n        assertEquals(-2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n        assertSame(f, result);\n\n\n\n        f = Fraction.getFraction(2, 3);\n\n        result = f.reduce();\n\n        assertEquals(2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n        assertSame(f, result);\n\n\n\n        f = Fraction.getFraction(0, 1);\n\n        result = f.reduce();\n\n        assertEquals(0, result.getNumerator());\n\n        assertEquals(1, result.getDenominator());\n\n        assertSame(f, result);\n\n\n\n        f = Fraction.getFraction(0, 100);\n\n        result = f.reduce();\n\n        assertEquals(0, result.getNumerator());\n\n        assertEquals(1, result.getDenominator());\n\n        assertSame(result, Fraction.ZERO);\n\n\n\n        f = Fraction.getFraction(Integer.MIN_VALUE, 2);\n\n        result = f.reduce();\n\n        assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n\n        assertEquals(1, result.getDenominator());\n\n    }\n"
      }
    }
  },
  "Lang-24": {
    "id": "Lang-24",
    "project": "Lang",
    "number": "24",
    "buggy_function": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; // str == \"0x\"\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent   \n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; // we need a digit after the E\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return foundDigit;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            // not allowing L with an exponent or decimal point\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}",
    "fixed_function": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; // str == \"0x\"\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent   \n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; // we need a digit after the E\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return foundDigit;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            // not allowing L with an exponent or decimal point\n            return foundDigit && !hasExp && !hasDecPoint;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "first_line": 1319,
      "last_line": 1421
    },
    "javadoc": "/**\n* <p>Checks whether the String a valid Java number.</p>\n*\n* <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n* qualifier, scientific notation and numbers marked with a type\n* qualifier (e.g. 123L).</p>\n*\n* <p><code>Null</code> and empty String will return\n* <code>false</code>.</p>\n*\n* @param str  the <code>String</code> to check\n* @return <code>true</code> if the string is a correctly formatted number\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.math.NumberUtilsTest::testIsNumber": {
        "source": "    public void testIsNumber() {\n\n        String val = \"12345\";\n\n        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n\n        val = \"1234.5\";\n\n        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n\n        val = \".12345\";\n\n        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n\n        val = \"1234E5\";\n\n        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n\n        val = \"1234E+5\";\n\n        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n\n        val = \"1234E-5\";\n\n        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n\n        val = \"123.4E5\";\n\n        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n\n        val = \"-1234\";\n\n        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n\n        val = \"-1234.5\";\n\n        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n\n        val = \"-.12345\";\n\n        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n\n        val = \"-1234E5\";\n\n        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n\n        val = \"0\";\n\n        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n\n        val = \"-0\";\n\n        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n\n        val = \"01234\";\n\n        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n\n        val = \"-01234\";\n\n        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n\n        val = \"0xABC123\";\n\n        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n\n        val = \"0x0\";\n\n        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n\n        val = \"123.4E21D\";\n\n        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n\n        val = \"-221.23F\";\n\n        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n\n        val = \"22338L\";\n\n        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n\n        val = null;\n\n        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n\n        val = \"\";\n\n        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n\n        val = \"--2.3\";\n\n        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n\n        val = \".12.3\";\n\n        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n\n        val = \"-123E\";\n\n        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n\n        val = \"-123E+-212\";\n\n        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n\n        val = \"-123E2.12\";\n\n        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n\n        val = \"0xGF\";\n\n        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n\n        val = \"0xFAE-1\";\n\n        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n\n        val = \".\";\n\n        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n\n        val = \"-0ABC123\";\n\n        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n\n        val = \"123.4E-D\";\n\n        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n\n        val = \"123.4ED\";\n\n        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n\n        val = \"1234E5l\";\n\n        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n\n        val = \"11a\";\n\n        assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"1a\";\n\n        assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"a\";\n\n        assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"11g\";\n\n        assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"11z\";\n\n        assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"11def\";\n\n        assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"11d11\";\n\n        assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n\n        val = \"11 11\";\n\n        assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n\n        val = \" 1111\";\n\n        assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n\n        val = \"1111 \";\n\n        assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n\n        assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n\n\n\n        // LANG-521\n\n        val = \"2.\";\n\n        assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));\n\n\n\n        // LANG-664\n\n        val = \"1.1L\";\n\n        assertFalse(\"isNumber(String) LANG-664 failed\", NumberUtils.isNumber(val));\n\n    }\n"
      }
    }
  },
  "Lang-26": {
    "id": "Lang-26",
    "project": "Lang",
    "number": "26",
    "buggy_function": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
    "fixed_function": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/time/FastDateFormat.java",
      "first_line": 819,
      "last_line": 823
    },
    "javadoc": "/**\n* <p>Formats a <code>Date</code> object.</p>\n*\n* @param date  the date to format\n* @return the formatted string\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.time.FastDateFormatTest::testLang645": {
        "source": "    public void testLang645() {\n\n        Locale locale = new Locale(\"sv\", \"SE\");\n\n\n\n        Calendar cal = Calendar.getInstance();\n\n        cal.set(2010, 0, 1, 12, 0, 0);\n\n        Date d = cal.getTime();\n\n\n\n        FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n\n\n\n        assertEquals(\"fredag, week 53\", fdf.format(d));\n\n    }\n"
      }
    }
  },
  "Lang-27": {
    "id": "Lang-27",
    "project": "Lang",
    "number": "27",
    "buggy_function": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
    "fixed_function": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "first_line": 452,
      "last_line": 599
    },
    "javadoc": "/**\n* <p>Turns a string value into a java.lang.Number.</p>\n*\n* <p>First, the value is examined for a type qualifier on the end\n* (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n* trying to create successively larger types from the type specified\n* until one is found that can represent the value.</p>\n*\n* <p>If a type specifier is not found, it will check for a decimal point\n* and then try successively larger types from <code>Integer</code> to\n* <code>BigInteger</code> and from <code>Float</code> to\n* <code>BigDecimal</code>.</p>\n*\n* <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n* will be interpreted as a hexadecimal integer.  Values with leading\n* <code>0</code>'s will not be interpreted as octal.</p>\n*\n* <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n*\n* <p>This method does not trim the input string, i.e., strings with leading\n* or trailing spaces will generate NumberFormatExceptions.</p>\n*\n* @param str  String containing a number, may be null\n* @return Number created from the string\n* @throws NumberFormatException if the value cannot be converted\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber": {
        "source": "    public void testCreateNumber() {\n\n        // a lot of things can go wrong\n\n        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n\n        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n\n        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n\n            + (Integer.MAX_VALUE + 1L)));\n\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n\n        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n\n        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n\n        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n\n        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n\n        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n\n        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n\n        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n\n        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n\n                .createNumber(\"12345678901234567890L\"));\n\n\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n\n                    .createNumber(\"1.1E-700F\"));\n\n        }\n\n        assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n\n        assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n\n\n        // LANG-521\n\n        assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n\n\n        // LANG-638\n\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n\n    }\n"
      }
    }
  },
  "Lang-28": {
    "id": "Lang-28",
    "project": "Lang",
    "number": "28",
    "buggy_function": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    // TODO: Protect from ArrayIndexOutOfBounds\n    if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n\n        char firstChar = input.charAt(start);\n        if(firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n        }\n\n        int end = start;\n        while(input.charAt(end) != ';') {\n            end++;\n        }\n\n        int entityValue;\n        try {\n            if(isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch(NumberFormatException nfe) {\n            return 0;\n        }\n\n            out.write(entityValue);\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n    }\n    return 0;\n}",
    "fixed_function": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    // TODO: Protect from ArrayIndexOutOfBounds\n    if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n\n        char firstChar = input.charAt(start);\n        if(firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n        }\n\n        int end = start;\n        while(input.charAt(end) != ';') {\n            end++;\n        }\n\n        int entityValue;\n        try {\n            if(isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch(NumberFormatException nfe) {\n            return 0;\n        }\n\n        if(entityValue > 0xFFFF) {\n            char[] chrs = Character.toChars(entityValue);\n            out.write(chrs[0]);\n            out.write(chrs[1]);\n        } else {\n            out.write(entityValue);\n        }\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n    }\n    return 0;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java",
      "first_line": 35,
      "last_line": 67
    },
    "javadoc": "/**\n* {@inheritDoc}\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest::testSupplementaryUnescaping": {
        "source": "    public void testSupplementaryUnescaping() {\n\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n\n        String input = \"&#68642;\";\n\n        String expected = \"\\uD803\\uDC22\";\n\n\n\n        String result = neu.translate(input);\n\n        assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result);\n\n    }\n"
      }
    }
  },
  "Lang-29": {
    "id": "Lang-29",
    "project": "Lang",
    "number": "29",
    "buggy_function": "static float toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}",
    "fixed_function": "static int toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/SystemUtils.java",
      "first_line": 1672,
      "last_line": 1674
    },
    "javadoc": "/**\n* <p>\n* Converts the given Java version string to an <code>int</code>.\n* </p>\n*\n* <p>\n* Example return values:\n* </p>\n* <ul>\n* <li><code>120</code> for Java 1.2</li>\n* <li><code>131</code> for Java 1.3.1</li>\n* <li><code>160</code> for Java 1.6.0_20</li>\n* </ul>\n*\n* <p>\n* Patch releases are not reported.\n* </p>\n* <p>\n* This method is package private instead of private to support unit test invocation.\n* </p>\n*\n* @return the version, for example 131 for Java 1.3.1\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.SystemUtilsTest::testJavaVersionAsInt": {
        "source": "    public void testJavaVersionAsInt() {\n\n        assertEquals(0, SystemUtils.toJavaVersionInt(null));\n\n        assertEquals(0, SystemUtils.toJavaVersionInt(\"\"));\n\n        assertEquals(0, SystemUtils.toJavaVersionInt(\"0\"));\n\n        assertEquals(110, SystemUtils.toJavaVersionInt(\"1.1\"));\n\n        assertEquals(120, SystemUtils.toJavaVersionInt(\"1.2\"));\n\n        assertEquals(130, SystemUtils.toJavaVersionInt(\"1.3.0\"));\n\n        assertEquals(131, SystemUtils.toJavaVersionInt(\"1.3.1\"));\n\n        assertEquals(140, SystemUtils.toJavaVersionInt(\"1.4.0\"));\n\n        assertEquals(141, SystemUtils.toJavaVersionInt(\"1.4.1\"));\n\n        assertEquals(142, SystemUtils.toJavaVersionInt(\"1.4.2\"));\n\n        assertEquals(150, SystemUtils.toJavaVersionInt(\"1.5.0\"));\n\n        assertEquals(160, SystemUtils.toJavaVersionInt(\"1.6.0\"));\n\n        assertEquals(131, SystemUtils.toJavaVersionInt(\"JavaVM-1.3.1\"));\n\n        assertEquals(131, SystemUtils.toJavaVersionInt(\"1.3.1 subset\"));\n\n        // This used to return 0f in [lang] version 2.5:\n\n        assertEquals(130, SystemUtils.toJavaVersionInt(\"XXX-1.3.x\"));\n\n    }\n"
      }
    }
  },
  "Lang-3": {
    "id": "Lang-3",
    "project": "Lang",
    "number": "3",
    "buggy_function": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) { // we have a hex number\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) { // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8) { // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n    int numDecimals = 0; // Check required precision (LANG-693)\n    if (decPos > -1) { // there is a decimal point\n\n        if (expPos > -1) { // there is an exponent\n            if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n        numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) { // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n\n    //Must be a Float, Double, BigDecimal\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n            final Float f = createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                return f;\n            }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n    try {\n            final Double d = createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                return d;\n            }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n\n    return createBigDecimal(str);\n}",
    "fixed_function": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) { // we have a hex number\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) { // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8) { // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n    int numDecimals = 0; // Check required precision (LANG-693)\n    if (decPos > -1) { // there is a decimal point\n\n        if (expPos > -1) { // there is an exponent\n            if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n        numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) { // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n\n    //Must be a Float, Double, BigDecimal\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n            final Float f = createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n    try {\n        if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n            final Double d = createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) { // NOPMD\n        // ignore the bad number\n    }\n\n    return createBigDecimal(str);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "first_line": 450,
      "last_line": 610
    },
    "javadoc": "/**\n* <p>Turns a string value into a java.lang.Number.</p>\n*\n* <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n* will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n* prefix is more than 8 - or BigInteger if there are more than 16 digits.\n* </p>\n* <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n* <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n* trying to create successively larger types from the type specified\n* until one is found that can represent the value.</p>\n*\n* <p>If a type specifier is not found, it will check for a decimal point\n* and then try successively larger types from <code>Integer</code> to\n* <code>BigInteger</code> and from <code>Float</code> to\n* <code>BigDecimal</code>.</p>\n*\n* <p>\n* Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n* be Integer, Long or BigDecimal as appropriate.\n* </p>\n*\n* <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n*\n* <p>This method does not trim the input string, i.e., strings with leading\n* or trailing spaces will generate NumberFormatExceptions.</p>\n*\n* @param str  String containing a number, may be null\n* @return Number created from the string (or null if the input is null)\n* @throws NumberFormatException if the value cannot be converted\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.math.NumberUtilsTest::testStringCreateNumberEnsureNoPrecisionLoss": {
        "source": "    public void testStringCreateNumberEnsureNoPrecisionLoss(){\n\n        String shouldBeFloat = \"1.23\";\n\n        String shouldBeDouble = \"3.40282354e+38\";\n\n        String shouldBeBigDecimal = \"1.797693134862315759e+308\";\n\n        \n\n        assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float);\n\n        assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double);\n\n        assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal);\n\n    }\n"
      }
    }
  },
  "Lang-31": {
    "id": "Lang-31",
    "project": "Lang",
    "number": "31",
    "buggy_function": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tchar ch = cs.charAt(i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}",
    "fixed_function": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tint csLastIndex = csLength - 1;\n\tint searchLastIndex = searchLength - 1;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tchar ch = cs.charAt(i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == ch) {\n\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/StringUtils.java",
      "first_line": 1440,
      "last_line": 1457
    },
    "javadoc": "/**\n* <p>Checks if the CharSequence contains any character in the given\n* set of characters.</p>\n*\n* <p>A <code>null</code> CharSequence will return <code>false</code>.\n* A <code>null</code> or zero length search array will return <code>false</code>.</p>\n*\n* <pre>\n* StringUtils.containsAny(null, *)                = false\n* StringUtils.containsAny(\"\", *)                  = false\n* StringUtils.containsAny(*, null)                = false\n* StringUtils.containsAny(*, [])                  = false\n* StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n* StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n* StringUtils.containsAny(\"aba\", ['z'])           = false\n* </pre>\n*\n* @param cs  the CharSequence to check, may be null\n* @param searchChars  the chars to search for, may be null\n* @return the <code>true</code> if any of the chars are found,\n* <code>false</code> if no match or null input\n* @since 2.4\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars": {
        "source": "\tpublic void testContainsAnyCharArrayWithSupplementaryChars() {\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000, CharU20000.toCharArray()));\n\n\t\t// Sanity check:\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\n\t\tassertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n\n\t\t// Test:\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000.toCharArray()));\n\n\t}\n"
      },
      "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars": {
        "source": "\tpublic void testContainsAnyStringWithSupplementaryChars() {\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000, CharU20000));\n\n\t\t// Sanity check:\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\n\t\tassertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n\n\t\t// Test:\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n\n\t}\n"
      }
    }
  },
  "Lang-33": {
    "id": "Lang-33",
    "project": "Lang",
    "number": "33",
    "buggy_function": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
    "fixed_function": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null ? null : array[i].getClass();\n    }\n    return classes;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
      "first_line": 902,
      "last_line": 913
    },
    "javadoc": "/**\n* <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n* If any of these objects is null, a null element will be inserted into the array.</p>\n*\n* <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n*\n* @param array an <code>Object</code> array\n* @return a <code>Class</code> array, <code>null</code> if null array input\n* @since 2.4\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.ClassUtilsTest::testToClass_object": {
        "source": "    public void testToClass_object() {\n\n        assertNull(ClassUtils.toClass(null));\n\n\n\n        assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY));\n\n\n\n        assertTrue(Arrays.equals(new Class[] { String.class, Integer.class, Double.class },\n\n                ClassUtils.toClass(new Object[] { \"Test\", 1, 99d })));\n\n\n\n        assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class },\n\n                ClassUtils.toClass(new Object[] { \"Test\", null, 99d })));\n\n    }\n"
      }
    }
  },
  "Lang-37": {
    "id": "Lang-37",
    "project": "Lang",
    "number": "37",
    "buggy_function": "public static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<?> type1 = array1.getClass().getComponentType();\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        // Check if problem is incompatible types\n    return joinedArray;\n}",
    "fixed_function": "public static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<?> type1 = array1.getClass().getComponentType();\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    try {\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n    } catch (ArrayStoreException ase) {\n        // Check if problem is incompatible types\n        final Class<?> type2 = array2.getClass().getComponentType();\n        if (!type1.isAssignableFrom(type2)){\n            throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n        }\n        throw ase; // No, so rethrow original\n    }\n    return joinedArray;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang3/ArrayUtils.java",
      "first_line": 2953,
      "last_line": 2965
    },
    "javadoc": "/**\n* <p>Adds all the elements of the given arrays into a new array.</p>\n* <p>The new array contains all of the element of <code>array1</code> followed\n* by all of the elements <code>array2</code>. When an array is returned, it is always\n* a new array.</p>\n*\n* <pre>\n* ArrayUtils.addAll(null, null)     = null\n* ArrayUtils.addAll(array1, null)   = cloned copy of array1\n* ArrayUtils.addAll(null, array2)   = cloned copy of array2\n* ArrayUtils.addAll([], [])         = []\n* ArrayUtils.addAll([null], [null]) = [null, null]\n* ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n* </pre>\n*\n* @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n* @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n* @return The new array, <code>null</code> if both arrays are <code>null</code>.\n*      The type of the new array is the type of the first array,\n*      unless the first array is null, in which case the type is the same as the second array.\n* @since 2.1\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.ArrayUtilsAddTest::testJira567": {
        "source": "    public void testJira567(){\n\n        Number[] n;\n\n        // Valid array construction\n\n        n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n\n        assertEquals(2,n.length);\n\n        assertEquals(Number.class,n.getClass().getComponentType());\n\n        try {\n\n            // Invalid - can't store Long in Integer array\n\n               n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n\n               fail(\"Should have generated IllegalArgumentException\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Lang-38": {
    "id": "Lang-38",
    "project": "Lang",
    "number": "38",
    "buggy_function": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}",
    "fixed_function": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar.getTime(); /// LANG-538\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang3/time/FastDateFormat.java",
      "first_line": 870,
      "last_line": 876
    },
    "javadoc": "/**\n* <p>Formats a <code>Calendar</code> object into the\n* supplied <code>StringBuffer</code>.</p>\n*\n* @param calendar  the calendar to format\n* @param buf  the buffer to format into\n* @return the specified string buffer\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.time.FastDateFormatTest::testLang538": {
        "source": "    public void testLang538() {\n\n        final String dateTime = \"2009-10-16T16:42:16.000Z\";\n\n\n\n        // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n\n        // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n\n        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n\n        cal.clear();\n\n        cal.set(2009, 9, 16, 8, 42, 16);\n\n\n\n        FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n\n        assertEquals(\"dateTime\", dateTime, format.format(cal));\n\n    }\n"
      }
    }
  },
  "Lang-39": {
    "id": "Lang-39",
    "project": "Lang",
    "number": "39",
    "buggy_function": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
    "fixed_function": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang3/StringUtils.java",
      "first_line": 3605,
      "last_line": 3731
    },
    "javadoc": "/**\n* <p>\n* Replaces all occurrences of Strings within another String.\n* </p>\n*\n* <p>\n* A <code>null</code> reference passed to this method is a no-op, or if\n* any \"search string\" or \"string to replace\" is null, that replace will be\n* ignored.\n* </p>\n*\n* <pre>\n*  StringUtils.replaceEach(null, *, *, *) = null\n*  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n*  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n*  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n*  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n*  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n*  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n*  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n*  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n*  (example of how it repeats)\n*  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n*  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n*  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n* </pre>\n*\n* @param text\n*            text to search and replace in, no-op if null\n* @param searchList\n*            the Strings to search for, no-op if null\n* @param replacementList\n*            the Strings to replace them with, no-op if null\n* @param repeat if true, then replace repeatedly\n*       until there are no more possible replacements or timeToLive < 0\n* @param timeToLive\n*            if less than 0 then there is a circular reference and endless\n*            loop\n* @return the text with any replacements processed, <code>null</code> if\n*         null String input\n* @throws IllegalArgumentException\n*             if the search is repeating and there is an endless loop due\n*             to outputs of one being inputs to another\n* @throws IndexOutOfBoundsException\n*             if the lengths of the arrays are not the same (null is ok,\n*             and/or size 0)\n* @since 2.4\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray": {
        "source": "    public void testReplace_StringStringArrayStringArray() {\n\n\n\n        \n\n        //JAVADOC TESTS START\n\n        assertNull(StringUtils.replaceEach(null, new String[]{\"a\"}, new String[]{\"b\"}));\n\n        assertEquals(StringUtils.replaceEach(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", null, null),\"aba\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null),\"aba\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]),\"aba\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null),\"aba\");\n\n\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n\n        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n\n        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"dcte\");\n\n        //JAVADOC TESTS END\n\n\n\n        assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[]{\"a\", \"b\"}, new String[]{\"b\", \"c\"}));\n\n        assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\",\n\n            new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \n\n                \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \n\n                \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \n\n                \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"},\n\n            new String[]{\"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \n\n                \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \n\n                \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \n\n                \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\"}));\n\n\n\n        // Test null safety inside arrays - LANG-552\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{null}),\"aba\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\");\n\n    }\n"
      }
    }
  },
  "Lang-40": {
    "id": "Lang-40",
    "project": "Lang",
    "number": "40",
    "buggy_function": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return contains(str.toUpperCase(), searchStr.toUpperCase());\n}",
    "fixed_function": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/StringUtils.java",
      "first_line": 1044,
      "last_line": 1049
    },
    "javadoc": "/**\n* <p>Checks if String contains a search String irrespective of case,\n* handling <code>null</code>. Case-insensitivity is defined as by\n* {@link String#equalsIgnoreCase(String)}.\n*\n* <p>A <code>null</code> String will return <code>false</code>.</p>\n*\n* <pre>\n* StringUtils.contains(null, *) = false\n* StringUtils.contains(*, null) = false\n* StringUtils.contains(\"\", \"\") = true\n* StringUtils.contains(\"abc\", \"\") = true\n* StringUtils.contains(\"abc\", \"a\") = true\n* StringUtils.contains(\"abc\", \"z\") = false\n* StringUtils.contains(\"abc\", \"A\") = true\n* StringUtils.contains(\"abc\", \"Z\") = false\n* </pre>\n*\n* @param str  the String to check, may be null\n* @param searchStr  the String to find, may be null\n* @return true if the String contains the search String irrespective of\n* case or false if not or <code>null</code> string input\n*/",
    "failing_tests": {
      "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence": {
        "source": "    public void testContainsIgnoreCase_LocaleIndependence() {\n\n        Locale orig = Locale.getDefault();\n\n\n\n        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n\n\n\n        String[][] tdata = { \n\n            { \"i\", \"I\" },\n\n            { \"I\", \"i\" },\n\n            { \"\\u03C2\", \"\\u03C3\" },\n\n            { \"\\u03A3\", \"\\u03C2\" },\n\n            { \"\\u03A3\", \"\\u03C3\" },\n\n        };\n\n\n\n        String[][] fdata = { \n\n            { \"\\u00DF\", \"SS\" },\n\n        };\n\n\n\n        try {\n\n            for (int i = 0; i < locales.length; i++) {\n\n                Locale.setDefault(locales[i]);\n\n                for (int j = 0; j < tdata.length; j++) {\n\n                    assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n\n                            .containsIgnoreCase(tdata[j][0], tdata[j][1]));\n\n                }\n\n                for (int j = 0; j < fdata.length; j++) {\n\n                    assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils\n\n                            .containsIgnoreCase(fdata[j][0], fdata[j][1]));\n\n                }\n\n            }\n\n        } finally {\n\n            Locale.setDefault(orig);\n\n        }\n\n    }\n"
      }
    }
  },
  "Lang-42": {
    "id": "Lang-42",
    "project": "Lang",
    "number": "42",
    "buggy_function": "public void escape(Writer writer, String str) throws IOException {\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        String entityName = this.entityName(c);\n        if (entityName == null) {\n            if (c > 0x7F) {\n                writer.write(\"&#\");\n                writer.write(Integer.toString(c, 10));\n                writer.write(';');\n            } else {\n                writer.write(c);\n            }\n        } else {\n            writer.write('&');\n            writer.write(entityName);\n            writer.write(';');\n        }\n    }\n}",
    "fixed_function": "public void escape(Writer writer, String str) throws IOException {\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        int c = Character.codePointAt(str, i); \n        String entityName = this.entityName(c);\n        if (entityName == null) {\n            if (c >= 0x010000 && i < len - 1) {\n                writer.write(\"&#\");\n                writer.write(Integer.toString(c, 10));\n                writer.write(';');\n                i++;\n            } else if (c > 0x7F) { \n                writer.write(\"&#\");\n                writer.write(Integer.toString(c, 10));\n                writer.write(';');\n            } else {\n                writer.write(c);\n            }\n        } else {\n            writer.write('&');\n            writer.write(entityName);\n            writer.write(';');\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/Entities.java",
      "first_line": 825,
      "last_line": 844
    },
    "javadoc": "/**\n* <p>\n* Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n* passed.\n* </p>\n*\n* @param writer\n*            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n* @param str\n*            The <code>String</code> to escape. Assumed to be a non-null value.\n* @throws IOException\n*             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n*             methods.\n*\n* @see #escape(String)\n* @see Writer\n*/",
    "failing_tests": {
      "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeHtmlHighUnicode": {
        "source": "    public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {\n\n        // this is the utf8 representation of the character:\n\n        // COUNTING ROD UNIT DIGIT THREE\n\n        // in unicode\n\n        // codepoint: U+1D362\n\n        byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n\n\n\n        String escaped = StringEscapeUtils.escapeHtml( new String(data, \"UTF8\") );\n\n        String unescaped = StringEscapeUtils.unescapeHtml( escaped );\n\n\n\n        assertEquals( \"High unicode was not escaped correctly\", \"&#119650;\", escaped);\n\n    }\n"
      }
    }
  },
  "Lang-43": {
    "id": "Lang-43",
    "project": "Lang",
    "number": "43",
    "buggy_function": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                    QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch (c[pos.getIndex()]) {\n        case QUOTE:\n            next(pos);\n            return appendTo == null ? null : appendTo.append(c, lastHold,\n                    pos.getIndex() - lastHold);\n        default:\n            next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + start);\n}",
    "fixed_function": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        next(pos);\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                    QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch (c[pos.getIndex()]) {\n        case QUOTE:\n            next(pos);\n            return appendTo == null ? null : appendTo.append(c, lastHold,\n                    pos.getIndex() - lastHold);\n        default:\n            next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + start);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "first_line": 417,
      "last_line": 444
    },
    "javadoc": "/**\n* Consume a quoted string, adding it to <code>appendTo</code> if\n* specified.\n*\n* @param pattern pattern to parse\n* @param pos current parse position\n* @param appendTo optional StringBuffer to append\n* @param escapingOn whether to process escaped quotes\n* @return <code>appendTo</code>\n*/",
    "failing_tests": {
      "org.apache.commons.lang.text.ExtendedMessageFormatTest::testEscapedQuote_LANG_477": {
        "source": "    public void testEscapedQuote_LANG_477() {\n\n        String pattern = \"it''s a {0,lower} 'test'!\";\n\n        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n\n        assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"}));\n\n    }\n"
      }
    }
  },
  "Lang-44": {
    "id": "Lang-44",
    "project": "Lang",
    "number": "44",
    "buggy_function": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(val + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n\n        }\n\n    }\n}",
    "fixed_function": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(val + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n\n        }\n\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/NumberUtils.java",
      "first_line": 138,
      "last_line": 286
    },
    "javadoc": "/**\n* <p>Turns a string value into a java.lang.Number.</p>\n*\n* <p>First, the value is examined for a type qualifier on the end\n* (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n* trying to create successively larger types from the type specified\n* until one is found that can hold the value.</p>\n*\n* <p>If a type specifier is not found, it will check for a decimal point\n* and then try successively larger types from <code>Integer</code> to\n* <code>BigInteger</code> and from <code>Float</code> to\n* <code>BigDecimal</code>.</p>\n*\n* <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n* will be interpreted as a hexadecimal integer.  Values with leading\n* <code>0</code>'s will not be interpreted as octal.</p>\n*\n* @param val String containing a number\n* @return Number created from the string\n* @throws NumberFormatException if the value cannot be converted\n*/",
    "failing_tests": {
      "org.apache.commons.lang.NumberUtilsTest::testLang457": {
        "source": "    public void testLang457() {\n\n        String[] badInputs = new String[] { \"l\", \"L\", \"f\", \"F\", \"junk\", \"bobL\"};\n\n        for(int i=0; i<badInputs.length; i++) {\n\n            try {\n\n                NumberUtils.createNumber(badInputs[i]);\n\n                fail(\"NumberFormatException was expected for \" + badInputs[i]);\n\n            } catch (NumberFormatException e) {\n\n                return; // expected\n\n            }\n\n        }\n\n    }\n"
      }
    }
  },
  "Lang-45": {
    "id": "Lang-45",
    "project": "Lang",
    "number": "45",
    "buggy_function": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n    // initial parameter checks\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n\n    // if the lower value is greater than the length of the string,\n    // set to the length of the string\n    // if the upper value is -1 (i.e. no limit) or is greater\n    // than the length of the string, set to the length of the string\n    if (upper == -1 || upper > str.length()) {\n        upper = str.length();\n    }\n    // if upper is less than lower, raise it to lower\n    if (upper < lower) {\n        upper = lower;\n    }\n\n    StringBuffer result = new StringBuffer();\n    int index = StringUtils.indexOf(str, \" \", lower);\n    if (index == -1) {\n        result.append(str.substring(0, upper));\n        // only if abbreviation has occured do we append the appendToEnd value\n        if (upper != str.length()) {\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else if (index > upper) {\n        result.append(str.substring(0, upper));\n        result.append(StringUtils.defaultString(appendToEnd));\n    } else {\n        result.append(str.substring(0, index));\n        result.append(StringUtils.defaultString(appendToEnd));\n    }\n    return result.toString();\n}",
    "fixed_function": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n    // initial parameter checks\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n\n    // if the lower value is greater than the length of the string,\n    // set to the length of the string\n    if (lower > str.length()) {\n        lower = str.length();    \n    }\n    // if the upper value is -1 (i.e. no limit) or is greater\n    // than the length of the string, set to the length of the string\n    if (upper == -1 || upper > str.length()) {\n        upper = str.length();\n    }\n    // if upper is less than lower, raise it to lower\n    if (upper < lower) {\n        upper = lower;\n    }\n\n    StringBuffer result = new StringBuffer();\n    int index = StringUtils.indexOf(str, \" \", lower);\n    if (index == -1) {\n        result.append(str.substring(0, upper));\n        // only if abbreviation has occured do we append the appendToEnd value\n        if (upper != str.length()) {\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else if (index > upper) {\n        result.append(str.substring(0, upper));\n        result.append(StringUtils.defaultString(appendToEnd));\n    } else {\n        result.append(str.substring(0, index));\n        result.append(StringUtils.defaultString(appendToEnd));\n    }\n    return result.toString();\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/WordUtils.java",
      "first_line": 605,
      "last_line": 642
    },
    "javadoc": "/**\n* Abbreviates a string nicely.\n*\n* This method searches for the first space after the lower limit and abbreviates\n* the String there. It will also append any String passed as a parameter\n* to the end of the String. The upper limit can be specified to forcibly\n* abbreviate a String.\n*\n* @param str         the string to be abbreviated. If null is passed, null is returned.\n*                    If the empty String is passed, the empty string is returned.\n* @param lower       the lower limit.\n* @param upper       the upper limit; specify -1 if no limit is desired.\n*                    If the upper limit is lower than the lower limit, it will be\n*                    adjusted to be the same as the lower limit.\n* @param appendToEnd String to be appended to the end of the abbreviated string.\n*                    This is appended ONLY if the string was indeed abbreviated.\n*                    The append does not count towards the lower or upper limits.\n* @return the abbreviated String.\n* @since 2.4\n*/",
    "failing_tests": {
      "org.apache.commons.lang.WordUtilsTest::testAbbreviate": {
        "source": "    public void testAbbreviate() {\n\n        // check null and empty are returned respectively\n\n        assertNull(WordUtils.abbreviate(null, 1,-1,\"\"));\n\n        assertEquals(StringUtils.EMPTY, WordUtils.abbreviate(\"\", 1,-1,\"\"));\n\n\n\n        // test upper limit\n\n        assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 0,5,\"\"));\n\n        assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"\"));\n\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5,\"\"));\n\n        assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n\n\n\n        // test upper limit + append string\n\n        assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 0,5,\"-\"));\n\n        assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"-\"));\n\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5, null));\n\n        assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n\n\n\n        // test lower value\n\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n\n        assertEquals(\"01234\", WordUtils.abbreviate(\"01234 56789\", 5, 10, null));\n\n        assertEquals(\"01 23 45 67\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, null));\n\n        assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, null));\n\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 15, 20, null));\n\n\n\n        // test lower value + append\n\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n\n        assertEquals(\"01234-\", WordUtils.abbreviate(\"01234 56789\", 5, 10, \"-\"));\n\n        assertEquals(\"01 23 45 67abc\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, \"abc\"));\n\n        assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, \"\"));\n\n\n\n        // others\n\n        assertEquals(\"\", WordUtils.abbreviate(\"0123456790\", 0,0,\"\"));\n\n        assertEquals(\"\", WordUtils.abbreviate(\" 0123456790\", 0,-1,\"\"));\n\n    }\n"
      }
    }
  },
  "Lang-49": {
    "id": "Lang-49",
    "project": "Lang",
    "number": "49",
    "buggy_function": "public Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}",
    "fixed_function": "public Fraction reduce() {\n    if (numerator == 0) {\n        return equals(ZERO) ? this : ZERO;\n    }\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/math/Fraction.java",
      "first_line": 465,
      "last_line": 471
    },
    "javadoc": "/**\n* <p>Reduce the fraction to the smallest values for the numerator and\n* denominator, returning the result.</p>\n*\n* <p>For example, if this fraction represents 2/4, then the result\n* will be 1/2.</p>\n*\n* @return a new reduced fraction instance, or this if no simplification possible\n*/",
    "failing_tests": {
      "org.apache.commons.lang.math.FractionTest::testReduce": {
        "source": "    public void testReduce() {\n\n        Fraction f = null;\n\n        \n\n        f = Fraction.getFraction(50, 75);\n\n        Fraction result = f.reduce();\n\n        assertEquals(2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n\n\n        f = Fraction.getFraction(-2, -3);\n\n        result = f.reduce();\n\n        assertEquals(2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n\n\n        f = Fraction.getFraction(2, -3);\n\n        result = f.reduce();\n\n        assertEquals(-2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n\n\n        f = Fraction.getFraction(-2, 3);\n\n        result = f.reduce();\n\n        assertEquals(-2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n        assertSame(f, result);\n\n\n\n        f = Fraction.getFraction(2, 3);\n\n        result = f.reduce();\n\n        assertEquals(2, result.getNumerator());\n\n        assertEquals(3, result.getDenominator());\n\n        assertSame(f, result);\n\n\n\n        f = Fraction.getFraction(0, 1);\n\n        result = f.reduce();\n\n        assertEquals(0, result.getNumerator());\n\n        assertEquals(1, result.getDenominator());\n\n        assertSame(f, result);\n\n\n\n        f = Fraction.getFraction(0, 100);\n\n        result = f.reduce();\n\n        assertEquals(0, result.getNumerator());\n\n        assertEquals(1, result.getDenominator());\n\n        assertSame(result, Fraction.ZERO);\n\n    }\n"
      }
    }
  },
  "Lang-5": {
    "id": "Lang-5",
    "project": "Lang",
    "number": "5",
    "buggy_function": "public static Locale toLocale(final String str) {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len < 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 = str.charAt(0);\n        final char ch1 = str.charAt(1);\n        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str);\n        }\n        if (len < 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(2) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch3 = str.charAt(3);\n        if (ch3 == '_') {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        final char ch4 = str.charAt(4);\n        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        }\n        if (len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(5) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
    "fixed_function": "public static Locale toLocale(final String str) {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len < 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 = str.charAt(0);\n    if (ch0 == '_') {\n        if (len < 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 = str.charAt(1);\n        final char ch2 = str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len < 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    } else {\n        final char ch1 = str.charAt(1);\n        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str);\n        }\n        if (len < 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(2) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch3 = str.charAt(3);\n        if (ch3 == '_') {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        final char ch4 = str.charAt(4);\n        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        }\n        if (len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(5) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "first_line": 88,
      "last_line": 128
    },
    "javadoc": "/**\n* <p>Converts a String to a Locale.</p>\n*\n* <p>This method takes the string format of a locale and creates the\n* locale object from it.</p>\n*\n* <pre>\n*   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n*   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n*   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n* </pre>\n*\n* <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n* In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n* Thus, the result from getVariant() may vary depending on your JDK.</p>\n*\n* <p>This method validates the input strictly.\n* The language code must be lowercase.\n* The country code must be uppercase.\n* The separator must be an underscore.\n* The length must be correct.\n* </p>\n*\n* @param str  the locale String to convert, null returns null\n* @return a Locale, null if null input\n* @throws IllegalArgumentException if the string is an invalid format\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.LocaleUtilsTest::testLang865": {
        "source": "    public void testLang865() {\n\n        assertValidToLocale(\"_GB\", \"\", \"GB\", \"\");\n\n        assertValidToLocale(\"_GB_P\", \"\", \"GB\", \"P\");\n\n        assertValidToLocale(\"_GB_POSIX\", \"\", \"GB\", \"POSIX\");\n\n        try {\n\n            LocaleUtils.toLocale(\"_G\");\n\n            fail(\"Must be at least 3 chars if starts with underscore\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n        try {\n\n            LocaleUtils.toLocale(\"_Gb\");\n\n            fail(\"Must be uppercase if starts with underscore\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n        try {\n\n            LocaleUtils.toLocale(\"_gB\");\n\n            fail(\"Must be uppercase if starts with underscore\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n        try {\n\n            LocaleUtils.toLocale(\"_1B\");\n\n            fail(\"Must be letter if starts with underscore\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n        try {\n\n            LocaleUtils.toLocale(\"_G1\");\n\n            fail(\"Must be letter if starts with underscore\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n        try {\n\n            LocaleUtils.toLocale(\"_GB_\");\n\n            fail(\"Must be at least 5 chars if starts with underscore\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n        try {\n\n            LocaleUtils.toLocale(\"_GBAP\");\n\n            fail(\"Must have underscore after the country if starts with underscore and is at least 5 chars\");\n\n        } catch (final IllegalArgumentException iae) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Lang-51": {
    "id": "Lang-51",
    "project": "Lang",
    "number": "51",
    "buggy_function": "public static boolean toBoolean(String str) {\n    // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n    // Non interned 'true' matched 15 times slower.\n    // \n    // Optimisation provides same performance as before for interned 'true'.\n    // Similar performance for null, 'false', and other strings not length 2/3/4.\n    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n        }\n    }\n    return false;\n}",
    "fixed_function": "public static boolean toBoolean(String str) {\n    // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n    // Non interned 'true' matched 15 times slower.\n    // \n    // Optimisation provides same performance as before for interned 'true'.\n    // Similar performance for null, 'false', and other strings not length 2/3/4.\n    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }\n            return false;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n        }\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/BooleanUtils.java",
      "first_line": 649,
      "last_line": 700
    },
    "javadoc": "/**\n* <p>Converts a String to a boolean (optimised for performance).</p>\n*\n* <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n* (case insensitive) will return <code>true</code>. Otherwise,\n* <code>false</code> is returned.</p>\n*\n* <p>This method performs 4 times faster (JDK1.4) than\n* <code>Boolean.valueOf(String)</code>. However, this method accepts\n* 'on' and 'yes' as true values.\n*\n* <pre>\n*   BooleanUtils.toBoolean(null)    = false\n*   BooleanUtils.toBoolean(\"true\")  = true\n*   BooleanUtils.toBoolean(\"TRUE\")  = true\n*   BooleanUtils.toBoolean(\"tRUe\")  = true\n*   BooleanUtils.toBoolean(\"on\")    = true\n*   BooleanUtils.toBoolean(\"yes\")   = true\n*   BooleanUtils.toBoolean(\"false\") = false\n*   BooleanUtils.toBoolean(\"x gti\") = false\n* </pre>\n*\n* @param str  the String to check\n* @return the boolean value of the string, <code>false</code> if no match\n*/",
    "failing_tests": {
      "org.apache.commons.lang.BooleanUtilsTest::test_toBoolean_String": {
        "source": "    public void test_toBoolean_String() {\n\n        assertEquals(false, BooleanUtils.toBoolean((String) null));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"off\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"oof\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"yep\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"trux\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"false\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"a\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"true\")); // interned handled differently\n\n        assertEquals(true, BooleanUtils.toBoolean(new StringBuffer(\"tr\").append(\"ue\").toString()));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"truE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"trUe\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"trUE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"tRue\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"tRuE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"tRUe\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"tRUE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TRUE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TRUe\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TRuE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TRue\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TrUE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TrUe\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"TruE\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"True\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"on\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"oN\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"On\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"ON\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"yes\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"yeS\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"yEs\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"yES\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"Yes\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"YeS\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"YEs\"));\n\n        assertEquals(true, BooleanUtils.toBoolean(\"YES\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"yes?\"));\n\n        assertEquals(false, BooleanUtils.toBoolean(\"tru\"));\n\n    }\n"
      }
    }
  },
  "Lang-52": {
    "id": "Lang-52",
    "project": "Lang",
    "number": "52",
    "buggy_function": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n        return;\n    }\n    int sz;\n    sz = str.length();\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n\n        // handle unicode\n        if (ch > 0xfff) {\n            out.write(\"\\\\u\" + hex(ch));\n        } else if (ch > 0xff) {\n            out.write(\"\\\\u0\" + hex(ch));\n        } else if (ch > 0x7f) {\n            out.write(\"\\\\u00\" + hex(ch));\n        } else if (ch < 32) {\n            switch (ch) {\n                case '\\b':\n                    out.write('\\\\');\n                    out.write('b');\n                    break;\n                case '\\n':\n                    out.write('\\\\');\n                    out.write('n');\n                    break;\n                case '\\t':\n                    out.write('\\\\');\n                    out.write('t');\n                    break;\n                case '\\f':\n                    out.write('\\\\');\n                    out.write('f');\n                    break;\n                case '\\r':\n                    out.write('\\\\');\n                    out.write('r');\n                    break;\n                default :\n                    if (ch > 0xf) {\n                        out.write(\"\\\\u00\" + hex(ch));\n                    } else {\n                        out.write(\"\\\\u000\" + hex(ch));\n                    }\n                    break;\n            }\n        } else {\n            switch (ch) {\n                case '\\'':\n                    if (escapeSingleQuote) {\n                      out.write('\\\\');\n                    }\n                    out.write('\\'');\n                    break;\n                case '\"':\n                    out.write('\\\\');\n                    out.write('\"');\n                    break;\n                case '\\\\':\n                    out.write('\\\\');\n                    out.write('\\\\');\n                    break;\n                default :\n                    out.write(ch);\n                    break;\n            }\n        }\n    }\n}",
    "fixed_function": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n        return;\n    }\n    int sz;\n    sz = str.length();\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n\n        // handle unicode\n        if (ch > 0xfff) {\n            out.write(\"\\\\u\" + hex(ch));\n        } else if (ch > 0xff) {\n            out.write(\"\\\\u0\" + hex(ch));\n        } else if (ch > 0x7f) {\n            out.write(\"\\\\u00\" + hex(ch));\n        } else if (ch < 32) {\n            switch (ch) {\n                case '\\b':\n                    out.write('\\\\');\n                    out.write('b');\n                    break;\n                case '\\n':\n                    out.write('\\\\');\n                    out.write('n');\n                    break;\n                case '\\t':\n                    out.write('\\\\');\n                    out.write('t');\n                    break;\n                case '\\f':\n                    out.write('\\\\');\n                    out.write('f');\n                    break;\n                case '\\r':\n                    out.write('\\\\');\n                    out.write('r');\n                    break;\n                default :\n                    if (ch > 0xf) {\n                        out.write(\"\\\\u00\" + hex(ch));\n                    } else {\n                        out.write(\"\\\\u000\" + hex(ch));\n                    }\n                    break;\n            }\n        } else {\n            switch (ch) {\n                case '\\'':\n                    if (escapeSingleQuote) {\n                      out.write('\\\\');\n                    }\n                    out.write('\\'');\n                    break;\n                case '\"':\n                    out.write('\\\\');\n                    out.write('\"');\n                    break;\n                case '\\\\':\n                    out.write('\\\\');\n                    out.write('\\\\');\n                    break;\n                case '/':\n                    out.write('\\\\');\n                    out.write('/');\n                    break;\n                default :\n                    out.write(ch);\n                    break;\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/StringEscapeUtils.java",
      "first_line": 171,
      "last_line": 242
    },
    "javadoc": "/**\n* <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n*\n* @param out write to receieve the escaped string\n* @param str String to escape values in, may be null\n* @param escapeSingleQuote escapes single quotes if <code>true</code>\n* @throws IOException if an IOException occurs\n*/",
    "failing_tests": {
      "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript": {
        "source": "    public void testEscapeJavaScript() {\n\n        assertEquals(null, StringEscapeUtils.escapeJavaScript(null));\n\n        try {\n\n            StringEscapeUtils.escapeJavaScript(null, null);\n\n            fail();\n\n        } catch (IOException ex) {\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {\n\n        }\n\n        try {\n\n            StringEscapeUtils.escapeJavaScript(null, \"\");\n\n            fail();\n\n        } catch (IOException ex) {\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {\n\n        }\n\n        \n\n        assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeJavaScript(\"He didn't say, \\\"stop!\\\"\"));\n\n        assertEquals(\"document.getElementById(\\\\\\\"test\\\\\\\").value = \\\\'<script>alert(\\\\'aaa\\\\');<\\\\/script>\\\\';\", \n\n                StringEscapeUtils.escapeJavaScript(\"document.getElementById(\\\"test\\\").value = '<script>alert('aaa');</script>';\"));\n\n    }\n"
      }
    }
  },
  "Lang-53": {
    "id": "Lang-53",
    "project": "Lang",
    "number": "53",
    "buggy_function": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n    if (field == Calendar.MILLISECOND) {\n        return;\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n    Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n\n    // truncate milliseconds\n    int millisecs = val.get(Calendar.MILLISECOND);\n    if (!round || millisecs < 500) {\n        time = time - millisecs;\n    if (field == Calendar.SECOND) {\n        done = true;\n        }\n    }\n\n    // truncate seconds\n    int seconds = val.get(Calendar.SECOND);\n    if (!done && (!round || seconds < 30)) {\n        time = time - (seconds * 1000L);\n    if (field == Calendar.MINUTE) {\n        done = true;\n        }\n    }\n\n    // truncate minutes\n    int minutes = val.get(Calendar.MINUTE);\n    if (!done && (!round || minutes < 30)) {\n        time = time - (minutes * 60000L);\n    }\n\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        if (offset != 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}",
    "fixed_function": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n    if (field == Calendar.MILLISECOND) {\n        return;\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n    Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n\n    // truncate milliseconds\n    int millisecs = val.get(Calendar.MILLISECOND);\n    if (!round || millisecs < 500) {\n        time = time - millisecs;\n    }\n    if (field == Calendar.SECOND) {\n        done = true;\n    }\n\n    // truncate seconds\n    int seconds = val.get(Calendar.SECOND);\n    if (!done && (!round || seconds < 30)) {\n        time = time - (seconds * 1000L);\n    }\n    if (field == Calendar.MINUTE) {\n        done = true;\n    }\n\n    // truncate minutes\n    int minutes = val.get(Calendar.MINUTE);\n    if (!done && (!round || minutes < 30)) {\n        time = time - (minutes * 60000L);\n    }\n\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        if (offset != 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "first_line": 620,
      "last_line": 744
    },
    "javadoc": "/**\n* <p>Internal calculation method.</p>\n*\n* @param val  the calendar\n* @param field  the field constant\n* @param round  true to round, false to truncate\n* @throws ArithmeticException if the year is over 280 million\n*/",
    "failing_tests": {
      "org.apache.commons.lang.time.DateUtilsTest::testRoundLang346": {
        "source": "    public void testRoundLang346() throws Exception\n\n    {\n\n        TimeZone.setDefault(defaultZone);\n\n        dateTimeParser.setTimeZone(defaultZone);\n\n        Calendar testCalendar = Calendar.getInstance();\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n\n        Date date = testCalendar.getTime();\n\n        assertEquals(\"Minute Round Up Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\n\n                     DateUtils.round(date, Calendar.MINUTE));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 8, 20);\n\n        date = testCalendar.getTime();\n\n        assertEquals(\"Minute No Round Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:08:00.000\"),\n\n                     DateUtils.round(date, Calendar.MINUTE));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n\n        testCalendar.set(Calendar.MILLISECOND, 600);\n\n        date = testCalendar.getTime();\n\n\n\n        assertEquals(\"Second Round Up with 600 Milli Seconds Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:08:51.000\"),\n\n                     DateUtils.round(date, Calendar.SECOND));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n\n        testCalendar.set(Calendar.MILLISECOND, 200);\n\n        date = testCalendar.getTime();\n\n        assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:08:50.000\"),\n\n                     DateUtils.round(date, Calendar.SECOND));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 8, 20);\n\n        testCalendar.set(Calendar.MILLISECOND, 600);\n\n        date = testCalendar.getTime();\n\n        assertEquals(\"Second Round Up with 200 Milli Seconds Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:08:21.000\"),\n\n                     DateUtils.round(date, Calendar.SECOND));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 8, 20);\n\n        testCalendar.set(Calendar.MILLISECOND, 200);\n\n        date = testCalendar.getTime();\n\n        assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:08:20.000\"),\n\n                     DateUtils.round(date, Calendar.SECOND));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n\n        date = testCalendar.getTime();\n\n        assertEquals(\"Hour Round Down Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 08:00:00.000\"),\n\n                     DateUtils.round(date, Calendar.HOUR));\n\n\n\n        testCalendar.set(2007, 6, 2, 8, 31, 50);\n\n        date = testCalendar.getTime();\n\n        assertEquals(\"Hour Round Up Failed\",\n\n                     dateTimeParser.parse(\"July 2, 2007 09:00:00.000\"),\n\n                     DateUtils.round(date, Calendar.HOUR));\n\n    }\n"
      }
    }
  },
  "Lang-54": {
    "id": "Lang-54",
    "project": "Lang",
    "number": "54",
    "buggy_function": "public static Locale toLocale(String str) {\n    if (str == null) {\n        return null;\n    }\n    int len = str.length();\n    if (len != 2 && len != 5 && len < 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 = str.charAt(0);\n    char ch1 = str.charAt(1);\n    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len == 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 = str.charAt(3);\n        char ch4 = str.charAt(4);\n        if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
    "fixed_function": "public static Locale toLocale(String str) {\n    if (str == null) {\n        return null;\n    }\n    int len = str.length();\n    if (len != 2 && len != 5 && len < 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 = str.charAt(0);\n    char ch1 = str.charAt(1);\n    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len == 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 = str.charAt(3);\n        if (ch3 == '_') {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        char ch4 = str.charAt(4);\n        if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/LocaleUtils.java",
      "first_line": 94,
      "last_line": 127
    },
    "javadoc": "/**\n* <p>Converts a String to a Locale.</p>\n*\n* <p>This method takes the string format of a locale and creates the\n* locale object from it.</p>\n*\n* <pre>\n*   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n*   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n*   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n* </pre>\n*\n* <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n* In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n* Thus, the result from getVariant() may vary depending on your JDK.</p>\n*\n* <p>This method validates the input strictly.\n* The language code must be lowercase.\n* The country code must be uppercase.\n* The separator must be an underscore.\n* The length must be correct.\n* </p>\n*\n* @param str  the locale String to convert, null returns null\n* @return a Locale, null if null input\n* @throws IllegalArgumentException if the string is an invalid format\n*/",
    "failing_tests": {
      "org.apache.commons.lang.LocaleUtilsTest::testLang328": {
        "source": "    public void testLang328() {\n\n        assertValidToLocale(\"fr__POSIX\", \"fr\", \"\", \"POSIX\");\n\n    }\n"
      }
    }
  },
  "Lang-55": {
    "id": "Lang-55",
    "project": "Lang",
    "number": "55",
    "buggy_function": "public void stop() {\n    if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n        stopTime = System.currentTimeMillis();\n    this.runningState = STATE_STOPPED;\n}",
    "fixed_function": "public void stop() {\n    if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n    if(this.runningState == STATE_RUNNING) {\n        stopTime = System.currentTimeMillis();\n    }\n    this.runningState = STATE_STOPPED;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/time/StopWatch.java",
      "first_line": 114,
      "last_line": 120
    },
    "javadoc": "/**\n* <p>Stop the stopwatch.</p>\n*\n* <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n*\n* @throws IllegalStateException if the StopWatch is not running.\n*/",
    "failing_tests": {
      "org.apache.commons.lang.time.StopWatchTest::testLang315": {
        "source": "    public void testLang315() {\n\n        StopWatch watch = new StopWatch();\n\n        watch.start();\n\n            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n\n        watch.suspend();\n\n        long suspendTime = watch.getTime();\n\n            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n\n        watch.stop();\n\n        long totalTime = watch.getTime();\n\n        assertTrue( suspendTime == totalTime );\n\n    }\n"
      }
    }
  },
  "Lang-57": {
    "id": "Lang-57",
    "project": "Lang",
    "number": "57",
    "buggy_function": "public static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}",
    "fixed_function": "public static boolean isAvailableLocale(Locale locale) {\n    return availableLocaleList().contains(locale);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/LocaleUtils.java",
      "first_line": 222,
      "last_line": 224
    },
    "javadoc": "/**\n* <p>Checks if the locale specified is in the list of available locales.</p>\n*\n* @param locale the Locale object to check if it is available\n* @return true if the locale is a known locale\n*/",
    "failing_tests": {
      "org.apache.commons.lang.LocaleUtilsTest::testAvailableLocaleSet": {
        "source": "    public void testAvailableLocaleSet() {\n\n        Set set = LocaleUtils.availableLocaleSet();\n\n        Set set2 = LocaleUtils.availableLocaleSet();\n\n        assertNotNull(set);\n\n        assertSame(set, set2);\n\n        assertUnmodifiableCollection(set);\n\n        \n\n        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n\n        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n\n        Set jdkLocaleSet = new HashSet(jdkLocaleList);\n\n        assertEquals(jdkLocaleSet, set);\n\n    }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testIsAvailableLocale": {
        "source": "    public void testIsAvailableLocale() {\n\n        Set set = LocaleUtils.availableLocaleSet();\n\n        assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n\n        assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n\n        assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n\n        assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n\n        assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n\n        assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n\n        assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n\n    }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testAvailableLocaleList": {
        "source": "    public void testAvailableLocaleList() {\n\n        List list = LocaleUtils.availableLocaleList();\n\n        List list2 = LocaleUtils.availableLocaleList();\n\n        assertNotNull(list);\n\n        assertSame(list, list2);\n\n        assertUnmodifiableCollection(list);\n\n        \n\n        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n\n        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n\n        assertEquals(jdkLocaleList, list);\n\n    }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testCountriesByLanguage": {
        "source": "    public void testCountriesByLanguage() {}\n\n//     public void testCountriesByLanguage() {\n\n//         assertCountriesByLanguage(null, new String[0]);\n\n//         assertCountriesByLanguage(\"de\", new String[]{\"DE\", \"CH\", \"AT\", \"LU\"});\n\n//         assertCountriesByLanguage(\"zz\", new String[0]);\n\n//         assertCountriesByLanguage(\"it\", new String[]{\"IT\", \"CH\"});\n\n//     }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testLocaleLookupList_LocaleLocale": {
        "source": "    public void testLocaleLookupList_LocaleLocale() {\n\n        assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, \n\n                new Locale[]{LOCALE_QQ});\n\n        assertLocaleLookupList(LOCALE_EN, LOCALE_EN, \n\n                new Locale[]{LOCALE_EN});\n\n        \n\n        assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, \n\n            new Locale[]{\n\n                LOCALE_EN_US,\n\n                LOCALE_EN});\n\n        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,\n\n            new Locale[] {\n\n                LOCALE_EN_US,\n\n                LOCALE_EN,\n\n                LOCALE_QQ});\n\n        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,\n\n            new Locale[] {\n\n                LOCALE_EN_US,\n\n                LOCALE_EN,\n\n                LOCALE_QQ_ZZ});\n\n        \n\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n\n            new Locale[] {\n\n                LOCALE_EN_US_ZZZZ,\n\n                LOCALE_EN_US,\n\n                LOCALE_EN});\n\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,\n\n            new Locale[] {\n\n                LOCALE_EN_US_ZZZZ,\n\n                LOCALE_EN_US,\n\n                LOCALE_EN});\n\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,\n\n            new Locale[] {\n\n                LOCALE_EN_US_ZZZZ,\n\n                LOCALE_EN_US,\n\n                LOCALE_EN,\n\n                LOCALE_QQ});\n\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,\n\n            new Locale[] {\n\n                LOCALE_EN_US_ZZZZ,\n\n                LOCALE_EN_US,\n\n                LOCALE_EN,\n\n                LOCALE_QQ_ZZ});\n\n        assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,\n\n            new Locale[] {\n\n                LOCALE_FR_CA,\n\n                LOCALE_FR,\n\n                LOCALE_EN});\n\n    }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testLanguagesByCountry": {
        "source": "    public void testLanguagesByCountry() {\n\n        assertLanguageByCountry(null, new String[0]);\n\n        assertLanguageByCountry(\"GB\", new String[]{\"en\"});\n\n        assertLanguageByCountry(\"ZZ\", new String[0]);\n\n        assertLanguageByCountry(\"CH\", new String[]{\"fr\", \"de\", \"it\"});\n\n    }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testToLocale_1Part": {
        "source": "    public void testToLocale_1Part() {\n\n        assertEquals(null, LocaleUtils.toLocale((String) null));\n\n        \n\n        assertValidToLocale(\"us\");\n\n        assertValidToLocale(\"fr\");\n\n        assertValidToLocale(\"de\");\n\n        assertValidToLocale(\"zh\");\n\n        // Valid format but lang doesnt exist, should make instance anyway\n\n        assertValidToLocale(\"qq\");\n\n        \n\n        try {\n\n            LocaleUtils.toLocale(\"Us\");\n\n            fail(\"Should fail if not lowercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"US\");\n\n            fail(\"Should fail if not lowercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"uS\");\n\n            fail(\"Should fail if not lowercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"u#\");\n\n            fail(\"Should fail if not lowercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        \n\n        try {\n\n            LocaleUtils.toLocale(\"u\");\n\n            fail(\"Must be 2 chars if less than 5\");\n\n        } catch (IllegalArgumentException iae) {}\n\n       \n\n        try {\n\n            LocaleUtils.toLocale(\"uuu\");\n\n            fail(\"Must be 2 chars if less than 5\");\n\n        } catch (IllegalArgumentException iae) {}\n\n\n\n        try {\n\n            LocaleUtils.toLocale(\"uu_U\");\n\n            fail(\"Must be 2 chars if less than 5\");\n\n        } catch (IllegalArgumentException iae) {}\n\n    }        \n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testToLocale_2Part": {
        "source": "    public void testToLocale_2Part() {\n\n        assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n\n        //valid though doesnt exist\n\n        assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n\n        \n\n        try {\n\n            LocaleUtils.toLocale(\"us-EN\");\n\n            fail(\"Should fail as not underscore\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"us_En\");\n\n            fail(\"Should fail second part not uppercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"us_en\");\n\n            fail(\"Should fail second part not uppercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"us_eN\");\n\n            fail(\"Should fail second part not uppercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"uS_EN\");\n\n            fail(\"Should fail first part not lowercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"us_E3\");\n\n            fail(\"Should fail second part not uppercase\");\n\n        } catch (IllegalArgumentException iae) {}\n\n    }        \n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testToLocale_3Part": {
        "source": "    public void testToLocale_3Part() {\n\n        assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n\n        // this isn't pretty, but was caused by a jdk bug it seems\n\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525\n\n        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n\n            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n\n            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n\n        } else {\n\n            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"A\");\n\n            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFSAFDFDSDFF\");\n\n        }\n\n        \n\n        try {\n\n            LocaleUtils.toLocale(\"us_EN-a\");\n\n            fail(\"Should fail as not underscore\");\n\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n\n            LocaleUtils.toLocale(\"uu_UU_\");\n\n            fail(\"Must be 3, 5 or 7+ in length\");\n\n        } catch (IllegalArgumentException iae) {}\n\n    }\n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testLocaleLookupList_Locale": {
        "source": "    public void testLocaleLookupList_Locale() {\n\n        assertLocaleLookupList(null, null, new Locale[0]);\n\n        assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});\n\n        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n\n        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n\n        assertLocaleLookupList(LOCALE_EN_US, null,\n\n            new Locale[] {\n\n                LOCALE_EN_US,\n\n                LOCALE_EN});\n\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n\n            new Locale[] {\n\n                LOCALE_EN_US_ZZZZ,\n\n                LOCALE_EN_US,\n\n                LOCALE_EN});\n\n    }        \n"
      },
      "org.apache.commons.lang.LocaleUtilsTest::testConstructor": {
        "source": "    public void testConstructor() {\n\n        assertNotNull(new LocaleUtils());\n\n        Constructor[] cons = LocaleUtils.class.getDeclaredConstructors();\n\n        assertEquals(1, cons.length);\n\n        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n\n        assertEquals(true, Modifier.isPublic(LocaleUtils.class.getModifiers()));\n\n        assertEquals(false, Modifier.isFinal(LocaleUtils.class.getModifiers()));\n\n    }\n"
      }
    }
  },
  "Lang-58": {
    "id": "Lang-58",
    "project": "Lang",
    "number": "58",
    "buggy_function": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && isDigits(numeric.substring(1))\n                    && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
    "fixed_function": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "first_line": 397,
      "last_line": 545
    },
    "javadoc": "/**\n* <p>Turns a string value into a java.lang.Number.</p>\n*\n* <p>First, the value is examined for a type qualifier on the end\n* (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n* trying to create successively larger types from the type specified\n* until one is found that can represent the value.</p>\n*\n* <p>If a type specifier is not found, it will check for a decimal point\n* and then try successively larger types from <code>Integer</code> to\n* <code>BigInteger</code> and from <code>Float</code> to\n* <code>BigDecimal</code>.</p>\n*\n* <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n* will be interpreted as a hexadecimal integer.  Values with leading\n* <code>0</code>'s will not be interpreted as octal.</p>\n*\n* <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n*\n* <p>This method does not trim the input string, i.e., strings with leading\n* or trailing spaces will generate NumberFormatExceptions.</p>\n*\n* @param str  String containing a number, may be null\n* @return Number created from the string\n* @throws NumberFormatException if the value cannot be converted\n*/",
    "failing_tests": {
      "org.apache.commons.lang.math.NumberUtilsTest::testLang300": {
        "source": "    public void testLang300() {\n\n        NumberUtils.createNumber(\"-1l\");\n\n        NumberUtils.createNumber(\"01l\");\n\n        NumberUtils.createNumber(\"1l\");\n\n    }\n"
      }
    }
  },
  "Lang-59": {
    "id": "Lang-59",
    "project": "Lang",
    "number": "59",
    "buggy_function": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
    "fixed_function": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/text/StrBuilder.java",
      "first_line": 878,
      "last_line": 895
    },
    "javadoc": "/**\n* Appends an object to the builder padding on the right to a fixed length.\n* The <code>toString</code> of the object is used.\n* If the object is larger than the length, the right hand side is lost.\n* If the object is null, null text value is used.\n*\n* @param obj  the object to append, null uses null text\n* @param width  the fixed field width, zero or negative has no effect\n* @param padChar  the pad character to use\n* @return this, to enable chaining\n*/",
    "failing_tests": {
      "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299": {
        "source": "    public void testLang299() {\n\n        StrBuilder sb = new StrBuilder(1);\n\n        sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n\n        assertEquals(\"f\", sb.toString());\n\n    }\n"
      }
    }
  },
  "Lang-6": {
    "id": "Lang-6",
    "project": "Lang",
    "number": "6",
    "buggy_function": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        // contract with translators is that they have to understand codepoints \n        // and they just took care of a surrogate pair\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
    "fixed_function": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        // contract with translators is that they have to understand codepoints \n        // and they just took care of a surrogate pair\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pt));\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java",
      "first_line": 75,
      "last_line": 98
    },
    "javadoc": "/**\n* Translate an input onto a Writer. This is intentionally final as its algorithm is\n* tightly coupled with the abstract method of this class.\n*\n* @param input CharSequence that is being translated\n* @param out Writer to translate the text to\n* @throws IOException if and only if the Writer produces an IOException\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs": {
        "source": "    public void testEscapeSurrogatePairs() throws Exception {\n\n        assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\"));\n\n        // Examples from https://en.wikipedia.org/wiki/UTF-16\n\n        assertEquals(\"\\uD800\\uDC00\", StringEscapeUtils.escapeCsv(\"\\uD800\\uDC00\"));\n\n        assertEquals(\"\\uD834\\uDD1E\", StringEscapeUtils.escapeCsv(\"\\uD834\\uDD1E\"));\n\n        assertEquals(\"\\uDBFF\\uDFFD\", StringEscapeUtils.escapeCsv(\"\\uDBFF\\uDFFD\"));\n\n        \n\n    }\n"
      }
    }
  },
  "Lang-61": {
    "id": "Lang-61",
    "project": "Lang",
    "number": "61",
    "buggy_function": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = thisBuf.length - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j) != thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
    "fixed_function": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j) != thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/text/StrBuilder.java",
      "first_line": 1760,
      "last_line": 1787
    },
    "javadoc": "/**\n* Searches the string builder to find the first reference to the specified\n* string starting searching from the given index.\n* <p>\n* Note that a null input string will return -1, whereas the JDK throws an exception.\n*\n* @param str  the string to find, null returns -1\n* @param startIndex  the index to start at, invalid index rounded to edge\n* @return the first index of the string, or -1 if not found\n*/",
    "failing_tests": {
      "org.apache.commons.lang.text.StrBuilderTest::testIndexOfLang294": {
        "source": "    public void testIndexOfLang294() {\n\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n\n        sb.deleteFirst(\"three\");\n\n        assertEquals(-1, sb.indexOf(\"three\"));\n\n    }\n"
      },
      "org.apache.commons.lang.text.StrBuilderTest::testLang294": {
        "source": "    public void testLang294() {\n\n        StrBuilder sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n\n        sb.deleteAll(\"\\n%BLAH%\");\n\n        assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString()); \n\n    }\n"
      }
    }
  },
  "Lang-65": {
    "id": "Lang-65",
    "project": "Lang",
    "number": "65",
    "buggy_function": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n\n    // truncate milliseconds\n\n    // truncate seconds\n\n    // truncate minutes\n\n    // reset time\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}",
    "fixed_function": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n    if (field == Calendar.MILLISECOND) {\n        return;\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n    Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n\n    // truncate milliseconds\n    int millisecs = val.get(Calendar.MILLISECOND);\n    if (!round || millisecs < 500) {\n        time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n    }\n\n    // truncate seconds\n    int seconds = val.get(Calendar.SECOND);\n    if (!done && (!round || seconds < 30)) {\n        time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n    }\n\n    // truncate minutes\n    int minutes = val.get(Calendar.MINUTE);\n    if (!done && (!round || minutes < 30)) {\n        time = time - (minutes * 60000L);\n    }\n\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        if (offset != 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "first_line": 619,
      "last_line": 713
    },
    "javadoc": "/**\n* <p>Internal calculation method.</p>\n*\n* @param val  the calendar\n* @param field  the field constant\n* @param round  true to round, false to truncate\n* @throws ArithmeticException if the year is over 280 million\n*/",
    "failing_tests": {
      "org.apache.commons.lang.time.DateUtilsTest::testTruncateLang59": {
        "source": "    public void testTruncateLang59() throws Exception {\n\n\n\n        // Set TimeZone to Mountain Time\n\n        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n\n        TimeZone.setDefault(MST_MDT);\n\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n\n        format.setTimeZone(MST_MDT);\n\n\n\n        Date oct31_01MDT = new Date(1099206000000L); \n\n\n\n        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n\n        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n\n        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n\n        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n\n\n\n        assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n\n        assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n\n        assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n\n        assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n\n        assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n\n\n\n        // ------- Demonstrate Problem -------\n\n        Calendar gval = Calendar.getInstance();\n\n        gval.setTime(new Date(oct31_01MDT.getTime()));\n\n        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n\n        assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n\n\n\n        // ---------- Test Truncate ----------\n\n        assertEquals(\"Truncate Calendar.MILLISECOND\",\n\n                oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n\n\n        assertEquals(\"Truncate Calendar.SECOND\",\n\n                   oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n\n\n        assertEquals(\"Truncate Calendar.MINUTE\",\n\n                      oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n\n\n        assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n\n                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n\n\n        assertEquals(\"Truncate Calendar.HOUR\",\n\n                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n\n\n        assertEquals(\"Truncate Calendar.DATE\",\n\n                            oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n\n\n\n\n\n        // ---------- Test Round (down) ----------\n\n        assertEquals(\"Round Calendar.MILLISECOND\",\n\n                oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n\n\n        assertEquals(\"Round Calendar.SECOND\",\n\n                   oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n\n\n        assertEquals(\"Round Calendar.MINUTE\",\n\n                      oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n\n\n        assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n\n                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n\n\n        assertEquals(\"Round Calendar.HOUR\",\n\n                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n\n\n        assertEquals(\"Round Calendar.DATE\",\n\n                            oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n\n\n\n        // restore default time zone\n\n        TimeZone.setDefault(defaultZone);\n\n    }\n"
      }
    }
  },
  "Lang-9": {
    "id": "Lang-9",
    "project": "Lang",
    "number": "9",
    "buggy_function": "private void init() {\n    thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n    nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n    StringBuilder regex= new StringBuilder();\n    List<Strategy> collector = new ArrayList<Strategy>();\n\n    Matcher patternMatcher= formatPattern.matcher(pattern);\n    if(!patternMatcher.lookingAt()) {\n        throw new IllegalArgumentException(\"Invalid pattern\");\n    }\n\n    currentFormatField= patternMatcher.group();\n    Strategy currentStrategy= getStrategy(currentFormatField);\n    for(;;) {\n        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n        if(!patternMatcher.lookingAt()) {\n            nextStrategy = null;\n            break;\n        }\n        String nextFormatField= patternMatcher.group();\n        nextStrategy = getStrategy(nextFormatField);\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= nextFormatField;\n        currentStrategy= nextStrategy;\n    }\n    if(currentStrategy.addRegex(this, regex)) {\n        collector.add(currentStrategy);\n    }\n    currentFormatField= null;\n    strategies= collector.toArray(new Strategy[collector.size()]);\n    parsePattern= Pattern.compile(regex.toString());\n}",
    "fixed_function": "private void init() {\n    thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n    nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n    StringBuilder regex= new StringBuilder();\n    List<Strategy> collector = new ArrayList<Strategy>();\n\n    Matcher patternMatcher= formatPattern.matcher(pattern);\n    if(!patternMatcher.lookingAt()) {\n        throw new IllegalArgumentException(\"Invalid pattern\");\n    }\n\n    currentFormatField= patternMatcher.group();\n    Strategy currentStrategy= getStrategy(currentFormatField);\n    for(;;) {\n        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n        if(!patternMatcher.lookingAt()) {\n            nextStrategy = null;\n            break;\n        }\n        String nextFormatField= patternMatcher.group();\n        nextStrategy = getStrategy(nextFormatField);\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= nextFormatField;\n        currentStrategy= nextStrategy;\n    }\n    if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n        throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n    }\n    if(currentStrategy.addRegex(this, regex)) {\n        collector.add(currentStrategy);\n    }\n    currentFormatField= null;\n    strategies= collector.toArray(new Strategy[collector.size()]);\n    parsePattern= Pattern.compile(regex.toString());\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/lang3/time/FastDateParser.java",
      "first_line": 115,
      "last_line": 150
    },
    "javadoc": "/**\n* Initialize derived fields from defining fields.\n* This is called from constructor and from readObject (de-serialization)\n*/",
    "failing_tests": {
      "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_832": {
        "source": "    public void testLANG_832() throws Exception {\n\n        testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n\n        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n\n    }\n"
      },
      "org.apache.commons.lang3.time.FastDateParserTest::testLANG_832": {
        "source": "    public void testLANG_832() throws Exception {\n\n        testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n\n        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n\n    }\n"
      }
    }
  },
  "Math-10": {
    "id": "Math-10",
    "project": "Math",
    "number": "10",
    "buggy_function": "public void atan2(final double[] y, final int yOffset,\n                  final double[] x, final int xOffset,\n                  final double[] result, final int resultOffset) {\n\n    // compute r = sqrt(x^2+y^2)\n    double[] tmp1 = new double[getSize()];\n    multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n    double[] tmp2 = new double[getSize()];\n    multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n    add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n    rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n\n    if (x[xOffset] >= 0) {\n\n        // compute atan2(y, x) = 2 atan(y / (r + x))\n        add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n        for (int i = 0; i < tmp2.length; ++i) {\n            result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n        }\n\n    } else {\n\n        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n        subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n        result[resultOffset] =\n                ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n        for (int i = 1; i < tmp2.length; ++i) {\n            result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n        }\n\n    }\n\n    // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n\n}",
    "fixed_function": "public void atan2(final double[] y, final int yOffset,\n                  final double[] x, final int xOffset,\n                  final double[] result, final int resultOffset) {\n\n    // compute r = sqrt(x^2+y^2)\n    double[] tmp1 = new double[getSize()];\n    multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n    double[] tmp2 = new double[getSize()];\n    multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n    add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n    rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n\n    if (x[xOffset] >= 0) {\n\n        // compute atan2(y, x) = 2 atan(y / (r + x))\n        add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n        for (int i = 0; i < tmp2.length; ++i) {\n            result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n        }\n\n    } else {\n\n        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n        subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n        divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n        atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n        result[resultOffset] =\n                ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n        for (int i = 1; i < tmp2.length; ++i) {\n            result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n        }\n\n    }\n\n    // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n    result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
      "first_line": 1382,
      "last_line": 1420
    },
    "javadoc": "/** Compute two arguments arc tangent of a derivative structure.\n* @param y array holding the first operand\n* @param yOffset offset of the first operand in its array\n* @param x array holding the second operand\n* @param xOffset offset of the second operand in its array\n* @param result array where result must be stored (for\n* two arguments arc tangent the result array <em>cannot</em>\n* be the input array)\n* @param resultOffset offset of the result in its array\n*/",
    "failing_tests": {
      "org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest::testAtan2SpecialCases": {
        "source": "    public void testAtan2SpecialCases() {\n\n\n\n        DerivativeStructure pp =\n\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n\n                                          new DerivativeStructure(2, 2, 1, +0.0));\n\n        Assert.assertEquals(0, pp.getValue(), 1.0e-15);\n\n        Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);\n\n\n\n        DerivativeStructure pn =\n\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n\n                                          new DerivativeStructure(2, 2, 1, -0.0));\n\n        Assert.assertEquals(FastMath.PI, pn.getValue(), 1.0e-15);\n\n\n\n        DerivativeStructure np =\n\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),\n\n                                          new DerivativeStructure(2, 2, 1, +0.0));\n\n        Assert.assertEquals(0, np.getValue(), 1.0e-15);\n\n        Assert.assertEquals(-1, FastMath.copySign(1, np.getValue()), 1.0e-15);\n\n\n\n        DerivativeStructure nn =\n\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),\n\n                                          new DerivativeStructure(2, 2, 1, -0.0));\n\n        Assert.assertEquals(-FastMath.PI, nn.getValue(), 1.0e-15);\n\n\n\n    }\n"
      }
    }
  },
  "Math-101": {
    "id": "Math-101",
    "project": "Math",
    "number": "101",
    "buggy_function": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        // no sign\n        // return real only complex number\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        // invalid sign\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (\n        source.substring(startIndex, endIndex).compareTo(\n        getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}",
    "fixed_function": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        // no sign\n        // return real only complex number\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        // invalid sign\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if ((startIndex >= source.length()) ||\n        (endIndex > source.length()) ||\n        source.substring(startIndex, endIndex).compareTo(\n        getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/complex/ComplexFormat.java",
      "first_line": 320,
      "last_line": 389
    },
    "javadoc": "/**\n* Parses a string to produce a {@link Complex} object.\n*\n* @param source the string to parse\n* @param pos input/ouput parsing parameter.\n* @return the parsed {@link Complex} object.\n*/",
    "failing_tests": {
      "org.apache.commons.math.complex.ComplexFormatTest::testForgottenImaginaryCharacter": {
        "source": "    public void testForgottenImaginaryCharacter() {\n\n        ParsePosition pos = new ParsePosition(0);\n\n        assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n\n        assertEquals(5, pos.getErrorIndex());\n\n    }\n"
      },
      "org.apache.commons.math.complex.FrenchComplexFormatTest::testForgottenImaginaryCharacter": {
        "source": "    public void testForgottenImaginaryCharacter() {\n\n        ParsePosition pos = new ParsePosition(0);\n\n        assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n\n        assertEquals(5, pos.getErrorIndex());\n\n    }\n"
      }
    }
  },
  "Math-102": {
    "id": "Math-102",
    "project": "Math",
    "number": "102",
    "buggy_function": "public double chiSquare(double[] expected, long[] observed)\n    throws IllegalArgumentException {\n    if ((expected.length < 2) || (expected.length != observed.length)) {\n        throw new IllegalArgumentException(\n                \"observed, expected array lengths incorrect\");\n    }\n    if (!isPositive(expected) || !isNonNegative(observed)) {\n        throw new IllegalArgumentException(\n            \"observed counts must be non-negative and expected counts must be postive\");\n    }\n    double sumSq = 0.0d;\n    double dev = 0.0d;\n    for (int i = 0; i < observed.length; i++) {\n            dev = ((double) observed[i] - expected[i]);\n            sumSq += dev * dev / expected[i];\n    }\n    return sumSq;\n}",
    "fixed_function": "public double chiSquare(double[] expected, long[] observed)\n    throws IllegalArgumentException {\n    if ((expected.length < 2) || (expected.length != observed.length)) {\n        throw new IllegalArgumentException(\n                \"observed, expected array lengths incorrect\");\n    }\n    if (!isPositive(expected) || !isNonNegative(observed)) {\n        throw new IllegalArgumentException(\n            \"observed counts must be non-negative and expected counts must be postive\");\n    }\n    double sumExpected = 0d;\n    double sumObserved = 0d;\n    for (int i = 0; i < observed.length; i++) {\n        sumExpected += expected[i];\n        sumObserved += observed[i];\n    }\n    double ratio = 1.0d;\n    boolean rescale = false;\n    if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n        ratio = sumObserved / sumExpected;\n        rescale = true;\n    }\n    double sumSq = 0.0d;\n    double dev = 0.0d;\n    for (int i = 0; i < observed.length; i++) {\n        if (rescale) {\n            dev = ((double) observed[i] - ratio * expected[i]);\n            sumSq += dev * dev / (ratio * expected[i]);\n        } else {\n            dev = ((double) observed[i] - expected[i]);\n            sumSq += dev * dev / expected[i];\n        }\n    }\n    return sumSq;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java",
      "first_line": 64,
      "last_line": 81
    },
    "javadoc": "/**\n* {@inheritDoc}\n* <p><strong>Note: </strong>This implementation rescales the\n* <code>expected</code> array if necessary to ensure that the sum of the\n* expected and observed counts are equal.</p>\n*\n* @param observed array of observed frequency counts\n* @param expected array of expected frequency counts\n* @return chi-square test statistic\n* @throws IllegalArgumentException if preconditions are not met\n* or length is less than 2\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.inference.ChiSquareFactoryTest::testChiSquareLargeTestStatistic": {
        "source": "    public void testChiSquareLargeTestStatistic() throws Exception {\n\n        double[] exp = new double[] {\n\n                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n\n                232921.0, 437665.75\n\n        };\n\n\n\n        long[] obs = new long[] {\n\n                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n\n        };\n\n        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n\n            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n\n        double cst = csti.chiSquareTest(exp, obs); \n\n        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n\n        assertEquals( \"chi-square test statistic\", \n\n                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n\n    }\n"
      },
      "org.apache.commons.math.stat.inference.ChiSquareFactoryTest::testChiSquare": {
        "source": "    public void testChiSquare() throws Exception {\n\n        \n\n        // Target values computed using R version 1.8.1 \n\n        // Some assembly required ;-)  \n\n        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n\n        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n\n        \n\n        long[] observed = {10, 9, 11};\n\n        double[] expected = {10, 10, 10};\n\n        assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n\n        assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n\n        \n\n        long[] observed1 = { 500, 623, 72, 70, 31 };\n\n        double[] expected1 = { 485, 541, 82, 61, 37 };\n\n        assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n\n        assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n\n        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n\n        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n\n\n\n        try {\n\n            TestUtils.chiSquareTest(expected1, observed1, 95);\n\n            fail(\"alpha out of range, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }  \n\n        \n\n        long[] tooShortObs = { 0 };\n\n        double[] tooShortEx = { 1 };\n\n        try {\n\n            TestUtils.chiSquare(tooShortEx, tooShortObs);\n\n            fail(\"arguments too short, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n\n\n        // unmatched arrays\n\n        long[] unMatchedObs = { 0, 1, 2, 3 };\n\n        double[] unMatchedEx = { 1, 1, 2 };\n\n        try {\n\n            TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n\n            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n        \n\n        // 0 expected count\n\n        expected[0] = 0;\n\n        try {\n\n            TestUtils.chiSquareTest(expected, observed, .01);\n\n            fail(\"bad expected count, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        } \n\n        \n\n        // negative observed count\n\n        expected[0] = 1;\n\n        observed[0] = -1;\n\n        try {\n\n            TestUtils.chiSquareTest(expected, observed, .01);\n\n            fail(\"bad expected count, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        } \n\n        \n\n    }\n"
      },
      "org.apache.commons.math.stat.inference.ChiSquareTestTest::testChiSquareLargeTestStatistic": {
        "source": "    public void testChiSquareLargeTestStatistic() throws Exception {\n\n        double[] exp = new double[] {\n\n                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n\n                232921.0, 437665.75\n\n        };\n\n\n\n        long[] obs = new long[] {\n\n                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n\n        };\n\n        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n\n            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n\n        double cst = csti.chiSquareTest(exp, obs); \n\n        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n\n        assertEquals( \"chi-square test statistic\", \n\n                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n\n    }\n"
      },
      "org.apache.commons.math.stat.inference.ChiSquareTestTest::testChiSquare": {
        "source": "    public void testChiSquare() throws Exception {\n\n        \n\n        // Target values computed using R version 1.8.1 \n\n        // Some assembly required ;-)  \n\n        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n\n        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n\n        \n\n        long[] observed = {10, 9, 11};\n\n        double[] expected = {10, 10, 10};\n\n        assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n\n        assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n\n        \n\n        long[] observed1 = { 500, 623, 72, 70, 31 };\n\n        double[] expected1 = { 485, 541, 82, 61, 37 };\n\n        assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n\n        assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n\n        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n\n        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n\n\n\n        try {\n\n            TestUtils.chiSquareTest(expected1, observed1, 95);\n\n            fail(\"alpha out of range, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }  \n\n        \n\n        long[] tooShortObs = { 0 };\n\n        double[] tooShortEx = { 1 };\n\n        try {\n\n            TestUtils.chiSquare(tooShortEx, tooShortObs);\n\n            fail(\"arguments too short, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n\n\n        // unmatched arrays\n\n        long[] unMatchedObs = { 0, 1, 2, 3 };\n\n        double[] unMatchedEx = { 1, 1, 2 };\n\n        try {\n\n            TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n\n            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n        \n\n        // 0 expected count\n\n        expected[0] = 0;\n\n        try {\n\n            TestUtils.chiSquareTest(expected, observed, .01);\n\n            fail(\"bad expected count, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        } \n\n        \n\n        // negative observed count\n\n        expected[0] = 1;\n\n        observed[0] = -1;\n\n        try {\n\n            TestUtils.chiSquareTest(expected, observed, .01);\n\n            fail(\"bad expected count, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        } \n\n        \n\n    }\n"
      },
      "org.apache.commons.math.stat.inference.TestUtilsTest::testChiSquareLargeTestStatistic": {
        "source": "    public void testChiSquareLargeTestStatistic() throws Exception {\n\n        double[] exp = new double[] {\n\n                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n\n                232921.0, 437665.75\n\n        };\n\n\n\n        long[] obs = new long[] {\n\n                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n\n        };\n\n        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n\n            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n\n        double cst = csti.chiSquareTest(exp, obs); \n\n        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n\n        assertEquals( \"chi-square test statistic\", \n\n                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n\n    }\n"
      },
      "org.apache.commons.math.stat.inference.TestUtilsTest::testChiSquare": {
        "source": "    public void testChiSquare() throws Exception {\n\n        \n\n        // Target values computed using R version 1.8.1 \n\n        // Some assembly required ;-)  \n\n        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n\n        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n\n        \n\n        long[] observed = {10, 9, 11};\n\n        double[] expected = {10, 10, 10};\n\n        assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n\n        assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n\n        \n\n        long[] observed1 = { 500, 623, 72, 70, 31 };\n\n        double[] expected1 = { 485, 541, 82, 61, 37 };\n\n        assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n\n        assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n\n        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n\n        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n\n\n\n        try {\n\n            TestUtils.chiSquareTest(expected1, observed1, 95);\n\n            fail(\"alpha out of range, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }  \n\n        \n\n        long[] tooShortObs = { 0 };\n\n        double[] tooShortEx = { 1 };\n\n        try {\n\n            TestUtils.chiSquare(tooShortEx, tooShortObs);\n\n            fail(\"arguments too short, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n\n\n        // unmatched arrays\n\n        long[] unMatchedObs = { 0, 1, 2, 3 };\n\n        double[] unMatchedEx = { 1, 1, 2 };\n\n        try {\n\n            TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n\n            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n        \n\n        // 0 expected count\n\n        expected[0] = 0;\n\n        try {\n\n            TestUtils.chiSquareTest(expected, observed, .01);\n\n            fail(\"bad expected count, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        } \n\n        \n\n        // negative observed count\n\n        expected[0] = 1;\n\n        observed[0] = -1;\n\n        try {\n\n            TestUtils.chiSquareTest(expected, observed, .01);\n\n            fail(\"bad expected count, IllegalArgumentException expected\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        } \n\n        \n\n    }\n"
      }
    }
  },
  "Math-103": {
    "id": "Math-103",
    "project": "Math",
    "number": "103",
    "buggy_function": "public double cumulativeProbability(double x) throws MathException {\n        return 0.5 * (1.0 + Erf.erf((x - mean) /\n                (standardDeviation * Math.sqrt(2.0))));\n}",
    "fixed_function": "public double cumulativeProbability(double x) throws MathException {\n    try {\n        return 0.5 * (1.0 + Erf.erf((x - mean) /\n                (standardDeviation * Math.sqrt(2.0))));\n    } catch (MaxIterationsExceededException ex) {\n        if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n            return 0.0d;\n        } else if (x > (mean + 20 * standardDeviation)) {\n            return 1.0d;\n        } else {\n            throw ex;\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java",
      "first_line": 108,
      "last_line": 111
    },
    "javadoc": "/**\n* For this disbution, X, this method returns P(X &lt; <code>x</code>).\n* @param x the value at which the CDF is evaluated.\n* @return CDF evaluted at <code>x</code>.\n* @throws MathException if the algorithm fails to converge; unless\n* x is more than 20 standard deviations from the mean, in which case the\n* convergence exception is caught and 0 or 1 is returned.\n*/",
    "failing_tests": {
      "org.apache.commons.math.distribution.NormalDistributionTest::testExtremeValues": {
        "source": "    public void testExtremeValues() throws Exception {\n\n        NormalDistribution distribution = (NormalDistribution) getDistribution();\n\n        distribution.setMean(0);\n\n        distribution.setStandardDeviation(1);\n\n        for (int i = 0; i < 100; i+=5) { // make sure no convergence exception\n\n            double lowerTail = distribution.cumulativeProbability((double)-i);\n\n            double upperTail = distribution.cumulativeProbability((double) i);\n\n            if (i < 10) { // make sure not top-coded\n\n                assertTrue(lowerTail > 0.0d);\n\n                assertTrue(upperTail < 1.0d);\n\n            }\n\n            else { // make sure top coding not reversed\n\n                assertTrue(lowerTail < 0.00001);\n\n                assertTrue(upperTail > 0.99999);\n\n            }\n\n        } \n\n   }\n"
      }
    }
  },
  "Math-105": {
    "id": "Math-105",
    "project": "Math",
    "number": "105",
    "buggy_function": "public double getSumSquaredErrors() {\n    return sumYY - sumXY * sumXY / sumXX;\n}",
    "fixed_function": "public double getSumSquaredErrors() {\n    return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
      "first_line": 263,
      "last_line": 265
    },
    "javadoc": "/**\n* Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n* sum of squared errors</a> (SSE) associated with the regression\n* model.\n* <p>\n* The sum is computed using the computational formula\n* <p>\n* <code>SSE = SYY - (SXY * SXY / SXX)</code>\n* <p>\n* where <code>SYY</code> is the sum of the squared deviations of the y\n* values about their mean, <code>SXX</code> is similarly defined and\n* <code>SXY</code> is the sum of the products of x and y mean deviations.\n* <p>\n* The sums are accumulated using the updating algorithm referenced in\n* {@link #addData}.\n* <p>\n* The return value is constrained to be non-negative - i.e., if due to\n* rounding errors the computational formula returns a negative result,\n* 0 is returned.\n* <p>\n* <strong>Preconditions</strong>: <ul>\n* <li>At least two observations (with at least two different x values)\n* must have been added before invoking this method. If this method is\n* invoked before a model can be estimated, <code>Double,NaN</code> is\n* returned.\n* </li></ul>\n*\n* @return sum of squared errors associated with the regression model\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.regression.SimpleRegressionTest::testSSENonNegative": {
        "source": "    public void testSSENonNegative() {\n\n        double[] y = { 8915.102, 8919.302, 8923.502 };\n\n        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };\n\n        SimpleRegression reg = new SimpleRegression();\n\n        for (int i = 0; i < x.length; i++) {\n\n            reg.addData(x[i], y[i]);\n\n        }\n\n        assertTrue(reg.getSumSquaredErrors() >= 0.0);\n\n    } \n"
      }
    }
  },
  "Math-106": {
    "id": "Math-106",
    "project": "Math",
    "number": "106",
    "buggy_function": "public Fraction parse(String source, ParsePosition pos) {\n    // try to parse improper fraction\n    Fraction ret = super.parse(source, pos);\n    if (ret != null) {\n        return ret;\n    }\n    \n    int initialIndex = pos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse whole\n    Number whole = getWholeFormat().parse(source, pos);\n    if (whole == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    \n    // parse numerator\n    Number num = getNumeratorFormat().parse(source, pos);\n    if (num == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    \n        // minus signs should be leading, invalid expression\n\n    // parse '/'\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    switch (c) {\n    case 0 :\n        // no '/'\n        // return num as a fraction\n        return new Fraction(num.intValue(), 1);\n    case '/' :\n        // found '/', continue parsing denominator\n        break;\n    default :\n        // invalid '/'\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse denominator\n    Number den = getDenominatorFormat().parse(source, pos);\n    if (den == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    \n        // minus signs must be leading, invalid\n\n    int w = whole.intValue();\n    int n = num.intValue();\n    int d = den.intValue();\n    return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n}",
    "fixed_function": "public Fraction parse(String source, ParsePosition pos) {\n    // try to parse improper fraction\n    Fraction ret = super.parse(source, pos);\n    if (ret != null) {\n        return ret;\n    }\n    \n    int initialIndex = pos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse whole\n    Number whole = getWholeFormat().parse(source, pos);\n    if (whole == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    \n    // parse numerator\n    Number num = getNumeratorFormat().parse(source, pos);\n    if (num == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    \n    if (num.intValue() < 0) {\n        // minus signs should be leading, invalid expression\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse '/'\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    switch (c) {\n    case 0 :\n        // no '/'\n        // return num as a fraction\n        return new Fraction(num.intValue(), 1);\n    case '/' :\n        // found '/', continue parsing denominator\n        break;\n    default :\n        // invalid '/'\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse denominator\n    Number den = getDenominatorFormat().parse(source, pos);\n    if (den == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    \n    if (den.intValue() < 0) {\n        // minus signs must be leading, invalid\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    int w = whole.intValue();\n    int n = num.intValue();\n    int d = den.intValue();\n    return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/fraction/ProperFractionFormat.java",
      "first_line": 130,
      "last_line": 206
    },
    "javadoc": "/**\n* Parses a string to produce a {@link Fraction} object.  This method\n* expects the string to be formatted as a proper fraction.\n* <p>\n* Minus signs are only allowed in the whole number part - i.e.,\n* \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n* will result in a <code>ParseException</code>.\n*\n* @param source the string to parse\n* @param pos input/ouput parsing parameter.\n* @return the parsed {@link Fraction} object.\n*/",
    "failing_tests": {
      "org.apache.commons.math.fraction.FractionFormatTest::testParseProperInvalidMinus": {
        "source": "    public void testParseProperInvalidMinus() {\n\n        String source = \"2 -2 / 3\";\n\n        try {\n\n            Fraction c = properFormat.parse(source);\n\n            fail(\"invalid minus in improper fraction.\");\n\n        } catch (ParseException ex) {\n\n            // expected\n\n        }\n\n        source = \"2 2 / -3\";\n\n        try {\n\n            Fraction c = properFormat.parse(source);\n\n            fail(\"invalid minus in improper fraction.\");\n\n        } catch (ParseException ex) {\n\n            // expected\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-11": {
    "id": "Math-11",
    "project": "Math",
    "number": "11",
    "buggy_function": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}",
    "fixed_function": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
      "first_line": 177,
      "last_line": 186
    },
    "javadoc": "/**\n* Gets the covariance matrix.\n*\n* @return the covariance matrix.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.distribution.MultivariateNormalDistributionTest::testUnivariateDistribution": {
        "source": "    public void testUnivariateDistribution() {\n\n        final double[] mu = { -1.5 };\n\n        final double[][] sigma = { { 1 } };\n\n \n\n        final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);\n\n\n\n        final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);\n\n        final Random rng = new Random();\n\n        final int numCases = 100;\n\n        final double tol = Math.ulp(1d);\n\n        for (int i = 0; i < numCases; i++) {\n\n            final double v = rng.nextDouble() * 10 - 5;\n\n            Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-13": {
    "id": "Math-13",
    "project": "Math",
    "number": "13",
    "buggy_function": "private RealMatrix squareRoot(RealMatrix m) {\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n}",
    "fixed_function": "private RealMatrix squareRoot(RealMatrix m) {\n    if (m instanceof DiagonalMatrix) {\n        final int dim = m.getRowDimension();\n        final RealMatrix sqrtM = new DiagonalMatrix(dim);\n        for (int i = 0; i < dim; i++) {\n           sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n        }\n        return sqrtM;\n    } else {\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java",
      "first_line": 561,
      "last_line": 564
    },
    "javadoc": "/**\n* Computes the square-root of the weight matrix.\n*\n* @param m Symmetric, positive-definite (weight) matrix.\n* @return the square-root of the weight matrix.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.fitting.PolynomialFitterTest::testLargeSample": {
        "source": "    public void testLargeSample() {\n\n        Random randomizer = new Random(0x5551480dca5b369bl);\n\n        double maxError = 0;\n\n        for (int degree = 0; degree < 10; ++degree) {\n\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n\n            for (int i = 0; i < 40000; ++i) {\n\n                double x = -1.0 + i / 20000.0;\n\n                fitter.addObservedPoint(1.0, x,\n\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n\n            }\n\n\n\n            final double[] init = new double[degree + 1];\n\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n\n                              (1.0 + FastMath.abs(p.value(x)));\n\n                maxError = FastMath.max(maxError, error);\n\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n\n            }\n\n        }\n\n        Assert.assertTrue(maxError > 0.001);\n\n    }\n"
      }
    }
  },
  "Math-17": {
    "id": "Math-17",
    "project": "Math",
    "number": "17",
    "buggy_function": "public Dfp multiply(final int x) {\n        return multiplyFast(x);\n}",
    "fixed_function": "public Dfp multiply(final int x) {\n    if (x >= 0 && x < RADIX) {\n        return multiplyFast(x);\n    } else {\n        return multiply(newInstance(x));\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/dfp/Dfp.java",
      "first_line": 1602,
      "last_line": 1604
    },
    "javadoc": "/** Multiply this by a single digit x.\n* @param x multiplicand\n* @return product of this and x\n*/",
    "failing_tests": {
      "org.apache.commons.math3.dfp.DfpTest::testMultiply": {
        "source": "    public void testMultiply()\n\n    {\n\n        test(field.newDfp(\"1\").multiply(field.newDfp(\"1\")),      // Basic tests   1*1 = 1\n\n             field.newDfp(\"1\"),\n\n             0, \"Multiply #1\");\n\n\n\n        test(field.newDfp(\"1\").multiply(1),             // Basic tests   1*1 = 1\n\n             field.newDfp(\"1\"),\n\n             0, \"Multiply #2\");\n\n\n\n        test(field.newDfp(\"-1\").multiply(field.newDfp(\"1\")),     // Basic tests   -1*1 = -1\n\n             field.newDfp(\"-1\"),\n\n             0, \"Multiply #3\");\n\n\n\n        test(field.newDfp(\"-1\").multiply(1),            // Basic tests   -1*1 = -1\n\n             field.newDfp(\"-1\"),\n\n             0, \"Multiply #4\");\n\n\n\n        // basic tests with integers\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"3\")),\n\n             field.newDfp(\"6\"),\n\n             0, \"Multiply #5\");\n\n\n\n        test(field.newDfp(\"2\").multiply(3),\n\n             field.newDfp(\"6\"),\n\n             0, \"Multiply #6\");\n\n\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"3\")),\n\n             field.newDfp(\"-6\"),\n\n             0, \"Multiply #7\");\n\n\n\n        test(field.newDfp(\"-2\").multiply(3),\n\n             field.newDfp(\"-6\"),\n\n             0, \"Multiply #8\");\n\n\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"-3\")),\n\n             field.newDfp(\"-6\"),\n\n             0, \"Multiply #9\");\n\n\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"-3\")),\n\n             field.newDfp(\"6\"),\n\n             0, \"Multiply #10\");\n\n\n\n        //multiply by zero\n\n\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"0\")),\n\n             field.newDfp(\"-0\"),\n\n             0, \"Multiply #11\");\n\n\n\n        test(field.newDfp(\"-2\").multiply(0),\n\n             field.newDfp(\"-0\"),\n\n             0, \"Multiply #12\");\n\n\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"0\")),\n\n             field.newDfp(\"0\"),\n\n             0, \"Multiply #13\");\n\n\n\n        test(field.newDfp(\"2\").multiply(0),\n\n             field.newDfp(\"0\"),\n\n             0, \"Multiply #14\");\n\n\n\n        test(field.newDfp(\"2\").multiply(pinf),\n\n             pinf,\n\n             0, \"Multiply #15\");\n\n\n\n        test(field.newDfp(\"2\").multiply(ninf),\n\n             ninf,\n\n             0, \"Multiply #16\");\n\n\n\n        test(field.newDfp(\"-2\").multiply(pinf),\n\n             ninf,\n\n             0, \"Multiply #17\");\n\n\n\n        test(field.newDfp(\"-2\").multiply(ninf),\n\n             pinf,\n\n             0, \"Multiply #18\");\n\n\n\n        test(ninf.multiply(field.newDfp(\"-2\")),\n\n             pinf,\n\n             0, \"Multiply #18.1\");\n\n\n\n        test(field.newDfp(\"5e131071\").multiply(2),\n\n             pinf,\n\n             DfpField.FLAG_OVERFLOW, \"Multiply #19\");\n\n\n\n        test(field.newDfp(\"5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n\n             field.newDfp(\"9.9999999999999950000e131071\"),\n\n             0, \"Multiply #20\");\n\n\n\n        test(field.newDfp(\"-5e131071\").multiply(2),\n\n             ninf,\n\n             DfpField.FLAG_OVERFLOW, \"Multiply #22\");\n\n\n\n        test(field.newDfp(\"-5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n\n             field.newDfp(\"-9.9999999999999950000e131071\"),\n\n             0, \"Multiply #23\");\n\n\n\n        test(field.newDfp(\"1e-65539\").multiply(field.newDfp(\"1e-65539\")),\n\n             field.newDfp(\"1e-131078\"),\n\n             DfpField.FLAG_UNDERFLOW, \"Multiply #24\");\n\n\n\n        test(field.newDfp(\"1\").multiply(nan),\n\n             nan,\n\n             0, \"Multiply #25\");\n\n\n\n        test(nan.multiply(field.newDfp(\"1\")),\n\n             nan,\n\n             0, \"Multiply #26\");\n\n\n\n        test(nan.multiply(pinf),\n\n             nan,\n\n             0, \"Multiply #27\");\n\n\n\n        test(pinf.multiply(nan),\n\n             nan,\n\n             0, \"Multiply #27\");\n\n\n\n        test(pinf.multiply(field.newDfp(\"0\")),\n\n             nan,\n\n             DfpField.FLAG_INVALID, \"Multiply #28\");\n\n\n\n        test(field.newDfp(\"0\").multiply(pinf),\n\n             nan,\n\n             DfpField.FLAG_INVALID, \"Multiply #29\");\n\n\n\n        test(pinf.multiply(pinf),\n\n             pinf,\n\n             0, \"Multiply #30\");\n\n\n\n        test(ninf.multiply(pinf),\n\n             ninf,\n\n             0, \"Multiply #31\");\n\n\n\n        test(pinf.multiply(ninf),\n\n             ninf,\n\n             0, \"Multiply #32\");\n\n\n\n        test(ninf.multiply(ninf),\n\n             pinf,\n\n             0, \"Multiply #33\");\n\n\n\n        test(pinf.multiply(1),\n\n             pinf,\n\n             0, \"Multiply #34\");\n\n\n\n        test(pinf.multiply(0),\n\n             nan,\n\n             DfpField.FLAG_INVALID, \"Multiply #35\");\n\n\n\n        test(nan.multiply(1),\n\n             nan,\n\n             0, \"Multiply #36\");\n\n\n\n        test(field.newDfp(\"1\").multiply(10000),\n\n             field.newDfp(\"10000\"),\n\n             0, \"Multiply #37\");\n\n\n\n        test(field.newDfp(\"2\").multiply(1000000),\n\n             field.newDfp(\"2000000\"),\n\n             0, \"Multiply #38\");\n\n\n\n        test(field.newDfp(\"1\").multiply(-1),\n\n             field.newDfp(\"-1\"),\n\n             0, \"Multiply #39\");\n\n    }\n"
      }
    }
  },
  "Math-19": {
    "id": "Math-19",
    "project": "Math",
    "number": "19",
    "buggy_function": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) ||\n            !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) ||\n                Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}",
    "fixed_function": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) ||\n            !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) ||\n                Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                    final double max = Double.MAX_VALUE + boundaries[0][i];\n                    final NumberIsTooLargeException e\n                        = new NumberIsTooLargeException(boundaries[1][i],\n                                                        max,\n                                                        true);\n                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                    e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                    throw e;\n                }\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
      "first_line": 504,
      "last_line": 561
    },
    "javadoc": "/**\n* Checks dimensions and values of boundaries and inputSigma if defined.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest::testBoundaryRangeTooLarge": {
        "source": "    public void testBoundaryRangeTooLarge() {\n\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n\n                public double value(double[] parameters) {\n\n                    if (Double.isNaN(parameters[0])) {\n\n                        throw new MathIllegalStateException();\n\n                    }\n\n                    final double target = 1;\n\n                    final double error = target - parameters[0];\n\n                    return error * error;\n\n                }\n\n            };\n\n\n\n        final double[] start = { 0 };\n\n\n\n        // The difference between upper and lower bounds is used to used\n\n        // normalize the variables: In case of overflow, NaN is produced.\n\n        final double max = Double.MAX_VALUE / 2;\n\n        final double tooLarge = FastMath.nextUp(max);\n\n        final double[] lower = { -tooLarge };\n\n        final double[] upper = { tooLarge };\n\n        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n\n                                                   start, lower, upper).getPoint();\n\n    }\n"
      }
    }
  },
  "Math-2": {
    "id": "Math-2",
    "project": "Math",
    "number": "2",
    "buggy_function": "public double getNumericalMean() {\n    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n}",
    "fixed_function": "public double getNumericalMean() {\n    return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java",
      "first_line": 267,
      "last_line": 269
    },
    "javadoc": "/**\n* {@inheritDoc}\n*\n* For population size {@code N}, number of successes {@code m}, and sample\n* size {@code n}, the mean is {@code n * m / N}.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.distribution.HypergeometricDistributionTest::testMath1021": {
        "source": "    public void testMath1021() {\n\n        final int N = 43130568;\n\n        final int m = 42976365;\n\n        final int n = 50;\n\n        final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n);\n\n\n\n        for (int i = 0; i < 100; i++) {\n\n            final int sample = dist.sample();\n\n            Assert.assertTrue(\"sample=\" + sample, 0 <= sample);\n\n            Assert.assertTrue(\"sample=\" + sample, sample <= n);\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-20": {
    "id": "Math-20",
    "project": "Math",
    "number": "20",
    "buggy_function": "public double[] repairAndDecode(final double[] x) {\n    return\n        decode(x);\n}",
    "fixed_function": "public double[] repairAndDecode(final double[] x) {\n    return boundaries != null && isRepairMode ?\n        decode(repair(x)) :\n        decode(x);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
      "first_line": 920,
      "last_line": 923
    },
    "javadoc": "/**\n* @param x Normalized objective variables.\n* @return the original objective variables, possibly repaired.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest::testMath864": {
        "source": "    public void testMath864() {\n\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n\n                @Override\n\n                public double value(double[] parameters) {\n\n                    final double target = 1;\n\n                    final double error = target - parameters[0];\n\n                    return error * error;\n\n                }\n\n            };\n\n\n\n        final double[] start = { 0 };\n\n        final double[] lower = { -1e6 };\n\n        final double[] upper = { 0.5 };\n\n        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n\n                                                   start, lower, upper).getPoint();\n\n        Assert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\n\n                          result[0] <= upper[0]);\n\n    }\n"
      }
    }
  },
  "Math-21": {
    "id": "Math-21",
    "project": "Math",
    "number": "21",
    "buggy_function": "public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n    throws NonPositiveDefiniteMatrixException {\n\n    final int order = matrix.getRowDimension();\n    final double[][] c = matrix.getData();\n    final double[][] b = new double[order][order];\n\n    int[] swap  = new int[order];\n    int[] index = new int[order];\n    for (int i = 0; i < order; ++i) {\n        index[i] = i;\n    }\n\n    int r = 0;\n    for (boolean loop = true; loop;) {\n\n        // find maximal diagonal element\n        swap[r] = r;\n        for (int i = r + 1; i < order; ++i) {\n            int ii  = index[i];\n            int isi = index[swap[i]];\n            if (c[ii][ii] > c[isi][isi]) {\n                swap[r] = i;\n            }\n        }\n\n\n        // swap elements\n        if (swap[r] != r) {\n            int tmp = index[r];\n            index[r] = index[swap[r]];\n            index[swap[r]] = tmp;\n        }\n\n        // check diagonal element\n        int ir = index[r];\n        if (c[ir][ir] < small) {\n\n            if (r == 0) {\n                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n            }\n\n            // check remaining diagonal elements\n            for (int i = r; i < order; ++i) {\n                if (c[index[i]][index[i]] < -small) {\n                    // there is at least one sufficiently negative diagonal element,\n                    // the symmetric positive semidefinite matrix is wrong\n                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                }\n            }\n\n            // all remaining diagonal elements are close to zero, we consider we have\n            // found the rank of the symmetric positive semidefinite matrix\n            ++r;\n            loop = false;\n\n        } else {\n\n            // transform the matrix\n            final double sqrt = FastMath.sqrt(c[ir][ir]);\n            b[r][r] = sqrt;\n            final double inverse  = 1 / sqrt;\n            for (int i = r + 1; i < order; ++i) {\n                final int ii = index[i];\n                final double e = inverse * c[ii][ir];\n                b[i][r] = e;\n                c[ii][ii] -= e * e;\n                for (int j = r + 1; j < i; ++j) {\n                    final int ij = index[j];\n                    final double f = c[ii][ij] - e * b[j][r];\n                    c[ii][ij] = f;\n                    c[ij][ii] = f;\n                }\n            }\n\n            // prepare next iteration\n            loop = ++r < order;\n        }\n    }\n\n    // build the root matrix\n    rank = r;\n    root = MatrixUtils.createRealMatrix(order, r);\n    for (int i = 0; i < order; ++i) {\n        for (int j = 0; j < r; ++j) {\n            root.setEntry(index[i], j, b[i][j]);\n        }\n    }\n\n}",
    "fixed_function": "public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n    throws NonPositiveDefiniteMatrixException {\n\n    final int order = matrix.getRowDimension();\n    final double[][] c = matrix.getData();\n    final double[][] b = new double[order][order];\n\n    int[] index = new int[order];\n    for (int i = 0; i < order; ++i) {\n        index[i] = i;\n    }\n\n    int r = 0;\n    for (boolean loop = true; loop;) {\n\n        // find maximal diagonal element\n        int swapR = r;\n        for (int i = r + 1; i < order; ++i) {\n            int ii  = index[i];\n            int isr = index[swapR];\n            if (c[ii][ii] > c[isr][isr]) {\n                swapR = i;\n            }\n        }\n\n\n        // swap elements\n        if (swapR != r) {\n            final int tmpIndex    = index[r];\n            index[r]              = index[swapR];\n            index[swapR]          = tmpIndex;\n            final double[] tmpRow = b[r];\n            b[r]                  = b[swapR];\n            b[swapR]              = tmpRow;\n        }\n\n        // check diagonal element\n        int ir = index[r];\n        if (c[ir][ir] < small) {\n\n            if (r == 0) {\n                throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n            }\n\n            // check remaining diagonal elements\n            for (int i = r; i < order; ++i) {\n                if (c[index[i]][index[i]] < -small) {\n                    // there is at least one sufficiently negative diagonal element,\n                    // the symmetric positive semidefinite matrix is wrong\n                    throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                }\n            }\n\n            // all remaining diagonal elements are close to zero, we consider we have\n            // found the rank of the symmetric positive semidefinite matrix\n            ++r;\n            loop = false;\n\n        } else {\n\n            // transform the matrix\n            final double sqrt = FastMath.sqrt(c[ir][ir]);\n            b[r][r] = sqrt;\n            final double inverse  = 1 / sqrt;\n            final double inverse2 = 1 / c[ir][ir];\n            for (int i = r + 1; i < order; ++i) {\n                final int ii = index[i];\n                final double e = inverse * c[ii][ir];\n                b[i][r] = e;\n                c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                for (int j = r + 1; j < i; ++j) {\n                    final int ij = index[j];\n                    final double f = c[ii][ij] - e * b[j][r];\n                    c[ii][ij] = f;\n                    c[ij][ii] = f;\n                }\n            }\n\n            // prepare next iteration\n            loop = ++r < order;\n        }\n    }\n\n    // build the root matrix\n    rank = r;\n    root = MatrixUtils.createRealMatrix(order, r);\n    for (int i = 0; i < order; ++i) {\n        for (int j = 0; j < r; ++j) {\n            root.setEntry(index[i], j, b[i][j]);\n        }\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java",
      "first_line": 62,
      "last_line": 151
    },
    "javadoc": "/**\n* Decompose a symmetric positive semidefinite matrix.\n*\n* @param matrix Symmetric positive semidefinite matrix.\n* @param small Diagonal elements threshold under which  column are\n* considered to be dependent on previous ones and are discarded.\n* @exception NonPositiveDefiniteMatrixException if the matrix is not\n* positive semidefinite.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest::testMath789": {
        "source": "    public void testMath789() {\n\n\n\n        final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{\n\n            {0.013445532, 0.010394690, 0.009881156, 0.010499559},\n\n            {0.010394690, 0.023006616, 0.008196856, 0.010732709},\n\n            {0.009881156, 0.008196856, 0.019023866, 0.009210099},\n\n            {0.010499559, 0.010732709, 0.009210099, 0.019107243}\n\n        });\n\n        RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix();\n\n        RealMatrix rebuiltM1 = root1.multiply(root1.transpose());\n\n        Assert.assertEquals(0.0, m1.subtract(rebuiltM1).getNorm(), 1.0e-16);\n\n\n\n        final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{\n\n            {0.0, 0.0, 0.0, 0.0, 0.0},\n\n            {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},\n\n            {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},\n\n            {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},\n\n            {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}\n\n        });\n\n        RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix();\n\n        RealMatrix rebuiltM2 = root2.multiply(root2.transpose());\n\n        Assert.assertEquals(0.0, m2.subtract(rebuiltM2).getNorm(), 1.0e-16);\n\n\n\n        final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{\n\n            {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},\n\n            {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},\n\n            {0.0, 0.0, 0.0, 0.0, 0.0},\n\n            {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},\n\n            {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}\n\n        });\n\n        RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix();\n\n        RealMatrix rebuiltM3 = root3.multiply(root3.transpose());\n\n        Assert.assertEquals(0.0, m3.subtract(rebuiltM3).getNorm(), 1.0e-16);\n\n\n\n    }\n"
      },
      "org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest::testFullRank": {
        "source": "    public void testFullRank() {\n\n\n\n        RealMatrix base = MatrixUtils.createRealMatrix(new double[][] {\n\n            { 0.1159548705,      0.,           0.,           0.      },\n\n            { 0.0896442724, 0.1223540781,      0.,           0.      },\n\n            { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      },\n\n            { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 }\n\n        });\n\n\n\n        RealMatrix m = base.multiply(base.transpose());\n\n\n\n        RectangularCholeskyDecomposition d =\n\n                new RectangularCholeskyDecomposition(m, 1.0e-10);\n\n\n\n        RealMatrix root = d.getRootMatrix();\n\n        RealMatrix rebuiltM = root.multiply(root.transpose());\n\n        Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);\n\n\n\n        // the pivoted Cholesky decomposition is *not* unique. Here, the root is\n\n        // not equal to the original trianbular base matrix\n\n        Assert.assertTrue(root.subtract(base).getNorm() > 0.3);\n\n\n\n    }\n"
      }
    }
  },
  "Math-23": {
    "id": "Math-23",
    "project": "Math",
    "number": "23",
    "buggy_function": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker\n        = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current\n        = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    // Best point encountered so far (which is the initial guess).\n\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw ||\n                    Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else { // Default termination (Brent's criterion).\n            return\n                        best(current,\n                             previous,\n                        isMinim);\n        }\n        ++iter;\n    }\n}",
    "fixed_function": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker\n        = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current\n        = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    // Best point encountered so far (which is the initial guess).\n    UnivariatePointValuePair best = current;\n\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            best = best(best,\n                        best(current,\n                             previous,\n                             isMinim),\n                        isMinim);\n\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best;\n                }\n            }\n\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw ||\n                    Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else { // Default termination (Brent's criterion).\n            return best(best,\n                        best(current,\n                             previous,\n                             isMinim),\n                        isMinim);\n        }\n        ++iter;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "first_line": 115,
      "last_line": 281
    },
    "javadoc": "/**\n* The arguments are used for implementing the original stopping criterion\n* of Brent's algorithm.\n* {@code abs} and {@code rel} define a tolerance\n* {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n* <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n* where <em>macheps</em> is the relative machine precision. {@code abs} must\n* be positive.\n*\n* @param rel Relative threshold.\n* @param abs Absolute threshold.\n* @throws NotStrictlyPositiveException if {@code abs <= 0}.\n* @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest::testKeepInitIfBest": {
        "source": "    public void testKeepInitIfBest() {\n\n        final double minSin = 3 * Math.PI / 2;\n\n        final double offset = 1e-8;\n\n        final double delta = 1e-7;\n\n        final UnivariateFunction f1 = new Sin();\n\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\n\n                                                       new double[] { 0, -1, 0 });\n\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n\n        // A slightly less stringent tolerance would make the test pass\n\n        // even with the previous implementation.\n\n        final double relTol = 1e-8;\n\n        final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\n\n        final double init = minSin + 1.5 * offset;\n\n        final UnivariatePointValuePair result\n\n            = optimizer.optimize(200, f, GoalType.MINIMIZE,\n\n                                 minSin - 6.789 * delta,\n\n                                 minSin + 9.876 * delta,\n\n                                 init);\n\n        final int numEval = optimizer.getEvaluations();\n\n\n\n        final double sol = result.getPoint();\n\n        final double expected = init;\n\n\n\n//         System.out.println(\"numEval=\" + numEval);\n\n//         System.out.println(\"min=\" + init + \" f=\" + f.value(init));\n\n//         System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n\n//         System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n\n\n        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n\n    }\n"
      }
    }
  },
  "Math-24": {
    "id": "Math-24",
    "project": "Math",
    "number": "24",
    "buggy_function": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker\n        = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current\n        = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw ||\n                    Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else { // Default termination (Brent's criterion).\n            return current;\n        }\n        ++iter;\n    }\n}",
    "fixed_function": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker\n        = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current\n        = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw ||\n                    Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else { // Default termination (Brent's criterion).\n            return best(current, previous, isMinim);\n        }\n        ++iter;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "first_line": 109,
      "last_line": 271
    },
    "javadoc": "/**\n* The arguments are used for implementing the original stopping criterion\n* of Brent's algorithm.\n* {@code abs} and {@code rel} define a tolerance\n* {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n* <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n* where <em>macheps</em> is the relative machine precision. {@code abs} must\n* be positive.\n*\n* @param rel Relative threshold.\n* @param abs Absolute threshold.\n* @throws NotStrictlyPositiveException if {@code abs <= 0}.\n* @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest::testMath855": {
        "source": "    public void testMath855() {\n\n        final double minSin = 3 * Math.PI / 2;\n\n        final double offset = 1e-8;\n\n        final double delta = 1e-7;\n\n        final UnivariateFunction f1 = new Sin();\n\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset },\n\n                                                       new double[] { 0, -1, 0 });\n\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n\n        final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);\n\n        final UnivariatePointValuePair result\n\n            = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta);\n\n        final int numEval = optimizer.getEvaluations();\n\n\n\n        final double sol = result.getPoint();\n\n        final double expected = 4.712389027602411;\n\n\n\n        // System.out.println(\"min=\" + (minSin + offset) + \" f=\" + f.value(minSin + offset));\n\n        // System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n\n        // System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n\n\n        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n\n    }\n"
      }
    }
  },
  "Math-25": {
    "id": "Math-25",
    "project": "Math",
    "number": "25",
    "buggy_function": "private void guessAOmega() {\n    // initialize the sums for the linear model between the two integrals\n    double sx2 = 0;\n    double sy2 = 0;\n    double sxy = 0;\n    double sxz = 0;\n    double syz = 0;\n\n    double currentX = observations[0].getX();\n    double currentY = observations[0].getY();\n    double f2Integral = 0;\n    double fPrime2Integral = 0;\n    final double startX = currentX;\n    for (int i = 1; i < observations.length; ++i) {\n        // one step forward\n        final double previousX = currentX;\n        final double previousY = currentY;\n        currentX = observations[i].getX();\n        currentY = observations[i].getY();\n\n        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n        // considering a linear model for f (and therefore constant f')\n        final double dx = currentX - previousX;\n        final double dy = currentY - previousY;\n        final double f2StepIntegral =\n            dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n        final double fPrime2StepIntegral = dy * dy / dx;\n\n        final double x = currentX - startX;\n        f2Integral += f2StepIntegral;\n        fPrime2Integral += fPrime2StepIntegral;\n\n        sx2 += x * x;\n        sy2 += f2Integral * f2Integral;\n        sxy += x * f2Integral;\n        sxz += x * fPrime2Integral;\n        syz += f2Integral * fPrime2Integral;\n    }\n\n    // compute the amplitude and pulsation coefficients\n    double c1 = sy2 * sxz - sxy * syz;\n    double c2 = sxy * sxz - sx2 * syz;\n    double c3 = sx2 * sy2 - sxy * sxy;\n    if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n        final int last = observations.length - 1;\n        // Range of the observations, assuming that the\n        // observations are sorted.\n        final double xRange = observations[last].getX() - observations[0].getX();\n        if (xRange == 0) {\n            throw new ZeroException();\n        }\n        omega = 2 * Math.PI / xRange;\n\n        double yMin = Double.POSITIVE_INFINITY;\n        double yMax = Double.NEGATIVE_INFINITY;\n        for (int i = 1; i < observations.length; ++i) {\n            final double y = observations[i].getY();\n            if (y < yMin) {\n                yMin = y;\n            }\n            if (y > yMax) {\n                yMax = y;\n            }\n        }\n        a = 0.5 * (yMax - yMin);\n    } else {\n            // In some ill-conditioned cases (cf. MATH-844), the guesser\n            // procedure cannot produce sensible results.\n\n        a = FastMath.sqrt(c1 / c2);\n        omega = FastMath.sqrt(c2 / c3);\n    }\n}",
    "fixed_function": "private void guessAOmega() {\n    // initialize the sums for the linear model between the two integrals\n    double sx2 = 0;\n    double sy2 = 0;\n    double sxy = 0;\n    double sxz = 0;\n    double syz = 0;\n\n    double currentX = observations[0].getX();\n    double currentY = observations[0].getY();\n    double f2Integral = 0;\n    double fPrime2Integral = 0;\n    final double startX = currentX;\n    for (int i = 1; i < observations.length; ++i) {\n        // one step forward\n        final double previousX = currentX;\n        final double previousY = currentY;\n        currentX = observations[i].getX();\n        currentY = observations[i].getY();\n\n        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n        // considering a linear model for f (and therefore constant f')\n        final double dx = currentX - previousX;\n        final double dy = currentY - previousY;\n        final double f2StepIntegral =\n            dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n        final double fPrime2StepIntegral = dy * dy / dx;\n\n        final double x = currentX - startX;\n        f2Integral += f2StepIntegral;\n        fPrime2Integral += fPrime2StepIntegral;\n\n        sx2 += x * x;\n        sy2 += f2Integral * f2Integral;\n        sxy += x * f2Integral;\n        sxz += x * fPrime2Integral;\n        syz += f2Integral * fPrime2Integral;\n    }\n\n    // compute the amplitude and pulsation coefficients\n    double c1 = sy2 * sxz - sxy * syz;\n    double c2 = sxy * sxz - sx2 * syz;\n    double c3 = sx2 * sy2 - sxy * sxy;\n    if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n        final int last = observations.length - 1;\n        // Range of the observations, assuming that the\n        // observations are sorted.\n        final double xRange = observations[last].getX() - observations[0].getX();\n        if (xRange == 0) {\n            throw new ZeroException();\n        }\n        omega = 2 * Math.PI / xRange;\n\n        double yMin = Double.POSITIVE_INFINITY;\n        double yMax = Double.NEGATIVE_INFINITY;\n        for (int i = 1; i < observations.length; ++i) {\n            final double y = observations[i].getY();\n            if (y < yMin) {\n                yMin = y;\n            }\n            if (y > yMax) {\n                yMax = y;\n            }\n        }\n        a = 0.5 * (yMax - yMin);\n    } else {\n        if (c2 == 0) {\n            // In some ill-conditioned cases (cf. MATH-844), the guesser\n            // procedure cannot produce sensible results.\n            throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n        }\n\n        a = FastMath.sqrt(c1 / c2);\n        omega = FastMath.sqrt(c2 / c3);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java",
      "first_line": 257,
      "last_line": 329
    },
    "javadoc": "/**\n* Estimate a first guess of the amplitude and angular frequency.\n* This method assumes that the {@link #sortObservations()} method\n* has been called previously.\n*\n* @throws ZeroException if the abscissa range is zero.\n* @throws MathIllegalStateException when the guessing procedure cannot\n* produce sensible results.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.fitting.HarmonicFitterTest::testMath844": {
        "source": "    public void testMath844() {\n\n        final double[] y = { 0, 1, 2, 3, 2, 1,\n\n                             0, -1, -2, -3, -2, -1,\n\n                             0, 1, 2, 3, 2, 1,\n\n                             0, -1, -2, -3, -2, -1,\n\n                             0, 1, 2, 3, 2, 1, 0 };\n\n        final int len = y.length;\n\n        final WeightedObservedPoint[] points = new WeightedObservedPoint[len];\n\n        for (int i = 0; i < len; i++) {\n\n            points[i] = new WeightedObservedPoint(1, i, y[i]);\n\n        }\n\n\n\n        final HarmonicFitter.ParameterGuesser guesser\n\n            = new HarmonicFitter.ParameterGuesser(points);\n\n\n\n        // The guesser fails because the function is far from an harmonic\n\n        // function: It is a triangular periodic function with amplitude 3\n\n        // and period 12, and all sample points are taken at integer abscissae\n\n        // so function values all belong to the integer subset {-3, -2, -1, 0,\n\n        // 1, 2, 3}.\n\n        guesser.guess();\n\n    }\n"
      }
    }
  },
  "Math-26": {
    "id": "Math-26",
    "project": "Math",
    "number": "26",
    "buggy_function": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n    throws FractionConversionException\n{\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long)FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n\n    long p2 = 0;\n    long q2 = 1;\n\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long)FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n\n        double convergent = (double)p2 / (double)q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n\n}",
    "fixed_function": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n    throws FractionConversionException\n{\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long)FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n\n    long p2 = 0;\n    long q2 = 1;\n\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long)FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n\n        double convergent = (double)p2 / (double)q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/fraction/Fraction.java",
      "first_line": 175,
      "last_line": 238
    },
    "javadoc": "/**\n* Create a fraction given the double value and either the maximum error\n* allowed or the maximum number of denominator digits.\n* <p>\n*\n* NOTE: This constructor is called with EITHER\n*   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n*     (that way the maxDenominator has no effect).\n* OR\n*   - a valid maxDenominator value and the epsilon value set to zero\n*     (that way epsilon only has effect if there is an exact match before\n*     the maxDenominator value is reached).\n* </p><p>\n*\n* It has been done this way so that the same code can be (re)used for both\n* scenarios. However this could be confusing to users if it were part of\n* the public API and this constructor should therefore remain PRIVATE.\n* </p>\n*\n* See JIRA issue ticket MATH-181 for more details:\n*\n*     https://issues.apache.org/jira/browse/MATH-181\n*\n* @param value the double value to convert to a fraction.\n* @param epsilon maximum error allowed.  The resulting fraction is within\n*        {@code epsilon} of {@code value}, in absolute terms.\n* @param maxDenominator maximum denominator value allowed.\n* @param maxIterations maximum number of convergents\n* @throws FractionConversionException if the continued fraction failed to\n*         converge.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.fraction.FractionTest::testIntegerOverflow": {
        "source": "    public void testIntegerOverflow() {\n\n        checkIntegerOverflow(0.75000000001455192);\n\n        checkIntegerOverflow(1.0e10);\n\n        checkIntegerOverflow(-1.0e10);\n\n        checkIntegerOverflow(-43979.60679604749);\n\n    }\n"
      }
    }
  },
  "Math-27": {
    "id": "Math-27",
    "project": "Math",
    "number": "27",
    "buggy_function": "public double percentageValue() {\n    return multiply(100).doubleValue();\n}",
    "fixed_function": "public double percentageValue() {\n    return 100 * doubleValue();\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/fraction/Fraction.java",
      "first_line": 596,
      "last_line": 598
    },
    "javadoc": "/**\n* <p>\n* Gets the fraction percentage as a <tt>double</tt>. This calculates the\n* fraction as the numerator divided by denominator multiplied by 100.\n* </p>\n*\n* @return the fraction percentage as a <tt>double</tt>.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.fraction.FractionTest::testMath835": {
        "source": "    public void testMath835() {\n\n        final int numer = Integer.MAX_VALUE / 99;\n\n        final int denom = 1;\n\n        final double percentage = 100 * ((double) numer) / denom;\n\n        final Fraction frac = new Fraction(numer, denom);\n\n        // With the implementation that preceded the fix suggested in MATH-835,\n\n        // this test was failing, due to overflow.\n\n        Assert.assertEquals(percentage, frac.percentageValue(), Math.ulp(percentage));\n\n    }\n"
      }
    }
  },
  "Math-28": {
    "id": "Math-28",
    "project": "Math",
    "number": "28",
    "buggy_function": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n    // create a list of all the rows that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            final double ratio = rhs / entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n        // 1. check if there's an artificial variable that can be forced out of the basis\n            for (Integer row : minRatioPositions) {\n                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                    int column = i + tableau.getArtificialVariableOffset();\n                    final double entry = tableau.getEntry(row, column);\n                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                        return row;\n                    }\n                }\n            }\n\n        // 2. apply Bland's rule to prevent cycling:\n        //    take the row for which the corresponding basic variable has the smallest index\n        //\n        // see http://www.stanford.edu/class/msande310/blandrule.pdf\n        // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n        //\n        // Additional heuristic: if we did not get a solution after half of maxIterations\n        //                       revert to the simple case of just returning the top-most row\n        // This heuristic is based on empirical data gathered while investigating MATH-828.\n            Integer minRow = null;\n            int minIndex = tableau.getWidth();\n            for (Integer row : minRatioPositions) {\n                int i = tableau.getNumObjectiveFunctions();\n                for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                    if (row == tableau.getBasicRow(i)) {\n                        if (i < minIndex) {\n                            minIndex = i;\n                            minRow = row;\n                        }\n                    }\n                }\n            }\n            return minRow;\n    }\n    return minRatioPositions.get(0);\n}",
    "fixed_function": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n    // create a list of all the rows that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            final double ratio = rhs / entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n        // 1. check if there's an artificial variable that can be forced out of the basis\n        if (tableau.getNumArtificialVariables() > 0) {\n            for (Integer row : minRatioPositions) {\n                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                    int column = i + tableau.getArtificialVariableOffset();\n                    final double entry = tableau.getEntry(row, column);\n                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                        return row;\n                    }\n                }\n            }\n        }\n\n        // 2. apply Bland's rule to prevent cycling:\n        //    take the row for which the corresponding basic variable has the smallest index\n        //\n        // see http://www.stanford.edu/class/msande310/blandrule.pdf\n        // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n        //\n        // Additional heuristic: if we did not get a solution after half of maxIterations\n        //                       revert to the simple case of just returning the top-most row\n        // This heuristic is based on empirical data gathered while investigating MATH-828.\n        if (getIterations() < getMaxIterations() / 2) {\n            Integer minRow = null;\n            int minIndex = tableau.getWidth();\n            for (Integer row : minRatioPositions) {\n                int i = tableau.getNumObjectiveFunctions();\n                for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                    if (row == tableau.getBasicRow(i)) {\n                        if (i < minIndex) {\n                            minIndex = i;\n                            minRow = row;\n                        }\n                    }\n                }\n            }\n            return minRow;\n        }\n    }\n    return minRatioPositions.get(0);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java",
      "first_line": 90,
      "last_line": 154
    },
    "javadoc": "/**\n* Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n* @param tableau simple tableau for the problem\n* @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n* @return row with the minimum ratio\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.linear.SimplexSolverTest::testMath828Cycle": {
        "source": "    public void testMath828Cycle() {\n\n        LinearObjectiveFunction f = new LinearObjectiveFunction(\n\n                new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);\n\n        \n\n        ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>();\n\n\n\n        constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0));\n\n        constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0));\n\n        constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0));\n\n        constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0));\n\n        constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0));\n\n        constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0));\n\n        constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0));\n\n        \n\n        double epsilon = 1e-6;\n\n        PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true);\n\n        Assert.assertEquals(1.0d, solution.getValue(), epsilon);\n\n        Assert.assertTrue(validSolution(solution, constraints, epsilon));        \n\n    }\n"
      }
    }
  },
  "Math-3": {
    "id": "Math-3",
    "project": "Math",
    "number": "3",
    "buggy_function": "public static double linearCombination(final double[] a, final double[] b)\n    throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n\n        // Revert to scalar multiplication.\n\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                aHigh * bHigh) -\n                                               aLow * bHigh) -\n                                              aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n\n\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n\n    double result = sHighPrev + (prodLowSum + sLowSum);\n\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n\n    return result;\n}",
    "fixed_function": "public static double linearCombination(final double[] a, final double[] b)\n    throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n\n    if (len == 1) {\n        // Revert to scalar multiplication.\n        return a[0] * b[0];\n    }\n\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                aHigh * bHigh) -\n                                               aLow * bHigh) -\n                                              aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n\n\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n\n    double result = sHighPrev + (prodLowSum + sLowSum);\n\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
      "first_line": 814,
      "last_line": 872
    },
    "javadoc": "/**\n* Compute a linear combination accurately.\n* This method computes the sum of the products\n* <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n* It does so by using specific multiplication and addition algorithms to\n* preserve accuracy and reduce cancellation effects.\n* <br/>\n* It is based on the 2005 paper\n* <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n* Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n* and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n*\n* @param a Factors.\n* @param b Factors.\n* @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n* @throws DimensionMismatchException if arrays dimensions don't match\n*/",
    "failing_tests": {
      "org.apache.commons.math3.util.MathArraysTest::testLinearCombinationWithSingleElementArray": {
        "source": "    public void testLinearCombinationWithSingleElementArray() {\n\n        final double[] a = { 1.23456789 };\n\n        final double[] b = { 98765432.1 };\n\n\n\n        Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d);\n\n    }\n"
      }
    }
  },
  "Math-30": {
    "id": "Math-30",
    "project": "Math",
    "number": "30",
    "buggy_function": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n\n    final int n1n2prod = n1 * n2;\n\n    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n    final double EU = n1n2prod / 2.0;\n    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n    return 2 * standardNormal.cumulativeProbability(z);\n}",
    "fixed_function": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n\n    final double n1n2prod = n1 * n2;\n\n    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n    final double EU = n1n2prod / 2.0;\n    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n    return 2 * standardNormal.cumulativeProbability(z);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java",
      "first_line": 168,
      "last_line": 184
    },
    "javadoc": "/**\n* @param Umin smallest Mann-Whitney U value\n* @param n1 number of subjects in first sample\n* @param n2 number of subjects in second sample\n* @return two-sided asymptotic p-value\n* @throws ConvergenceException if the p-value can not be computed\n* due to a convergence error\n* @throws MaxCountExceededException if the maximum number of\n* iterations is exceeded\n*/",
    "failing_tests": {
      "org.apache.commons.math3.stat.inference.MannWhitneyUTestTest::testBigDataSet": {
        "source": "    public void testBigDataSet() throws Exception {\n\n        double[] d1 = new double[1500];\n\n        double[] d2 = new double[1500];\n\n        for (int i = 0; i < 1500; i++) {\n\n            d1[i] = 2 * i;\n\n            d2[i] = 2 * i + 1;\n\n        }\n\n        double result = testStatistic.mannWhitneyUTest(d1, d2);\n\n        Assert.assertTrue(result > 0.1);\n\n    }\n"
      }
    }
  },
  "Math-31": {
    "id": "Math-31",
    "project": "Math",
    "number": "31",
    "buggy_function": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a,b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}",
    "fixed_function": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double dN = a + b * dPrev;\n        if (Precision.equals(dN, 0.0, small)) {\n            dN = small;\n        }\n        double cN = a + b / cPrev;\n        if (Precision.equals(cN, 0.0, small)) {\n            cN = small;\n        }\n\n        dN = 1 / dN;\n        final double deltaN = cN * dN;\n        hN = hPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = dN;\n        cPrev = cN;\n        hPrev = hN;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/util/ContinuedFraction.java",
      "first_line": 123,
      "last_line": 199
    },
    "javadoc": "/**\n* <p>\n* Evaluates the continued fraction at the value x.\n* </p>\n*\n* <p>\n* The implementation of this method is based on the modified Lentz algorithm as described\n* on page 18 ff. in:\n* <ul>\n* <li>\n*   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n*   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n*   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n* </li>\n* </ul>\n* Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n* <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n* </p>\n*\n* @param x the evaluation point.\n* @param epsilon maximum error allowed.\n* @param maxIterations maximum number of convergents\n* @return the value of the continued fraction evaluated at x.\n* @throws ConvergenceException if the algorithm fails to converge.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.distribution.BinomialDistributionTest::testMath718": {
        "source": "    public void testMath718() {\n\n        // for large trials the evaluation of ContinuedFraction was inaccurate\n\n        // do a sweep over several large trials to test if the current implementation is\n\n        // numerically stable.\n\n\n\n        for (int trials = 500000; trials < 20000000; trials += 100000) {\n\n            BinomialDistribution dist = new BinomialDistribution(trials, 0.5);\n\n            int p = dist.inverseCumulativeProbability(0.5);\n\n            Assert.assertEquals(trials / 2, p);\n\n        }\n\n\n\n    }\n"
      },
      "org.apache.commons.math3.distribution.FDistributionTest::testMath785": {
        "source": "    public void testMath785() {\n\n        // this test was failing due to inaccurate results from ContinuedFraction.\n\n\n\n        try {\n\n            double prob = 0.01;\n\n            FDistribution f = new FDistribution(200000, 200000);\n\n            double result = f.inverseCumulativeProbability(prob);\n\n            Assert.assertTrue(result < 1.0);\n\n        } catch (Exception e) {\n\n            Assert.fail(\"Failing to calculate inverse cumulative probability\");\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-32": {
    "id": "Math-32",
    "project": "Math",
    "number": "32",
    "buggy_function": "protected void computeGeometricalProperties() {\n\n    final Vector2D[][] v = getVertices();\n\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if ((Boolean) tree.getAttribute()) {\n            // the instance covers the whole space\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        // there is at least one open-loop: the polygon is infinite\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        // all loops are closed, we compute some integrals around the shape\n\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n\n        if (sum < 0) {\n            // the polygon as a finite outside surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n\n    }\n\n}",
    "fixed_function": "protected void computeGeometricalProperties() {\n\n    final Vector2D[][] v = getVertices();\n\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n            // the instance covers the whole space\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        // there is at least one open-loop: the polygon is infinite\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        // all loops are closed, we compute some integrals around the shape\n\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n\n        if (sum < 0) {\n            // the polygon as a finite outside surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
      "first_line": 130,
      "last_line": 181
    },
    "javadoc": "/** Create a list of hyperplanes representing the boundary of a box.\n* @param xMin low bound along the x direction\n* @param xMax high bound along the x direction\n* @param yMin low bound along the y direction\n* @param yMax high bound along the y direction\n* @return boundary of the box\n*/",
    "failing_tests": {
      "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest::testIssue780": {
        "source": "    public void testIssue780() {\n\n        float[] coords = {\n\n            1.000000f, -1.000000f, -1.000000f, \n\n            1.000000f, -1.000000f, 1.000000f, \n\n            -1.000000f, -1.000000f, 1.000000f, \n\n            -1.000000f, -1.000000f, -1.000000f, \n\n            1.000000f, 1.000000f, -1f, \n\n            0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n\n            -1.000000f, 1.000000f, 1.000000f, \n\n            -1.000000f, 1.000000f, -1.000000f};\n\n        int[] indices = {\n\n            0, 1, 2, 0, 2, 3, \n\n            4, 7, 6, 4, 6, 5, \n\n            0, 4, 5, 0, 5, 1, \n\n            1, 5, 6, 1, 6, 2, \n\n            2, 6, 7, 2, 7, 3, \n\n            4, 0, 3, 4, 3, 7};\n\n        ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n\n        for (int idx = 0; idx < indices.length; idx += 3) {\n\n            int idxA = indices[idx] * 3;\n\n            int idxB = indices[idx + 1] * 3;\n\n            int idxC = indices[idx + 2] * 3;\n\n            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n\n            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n\n            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n\n            Vector3D[] vertices = {v_1, v_2, v_3};\n\n            Plane polyPlane = new Plane(v_1, v_2, v_3);\n\n            ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n\n\n\n            Vector2D[] projPts = new Vector2D[vertices.length];\n\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n\n                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n\n            }\n\n\n\n            SubLine lineInPlane = null;\n\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n\n                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n\n                lines.add(lineInPlane);\n\n            }\n\n            Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n\n            SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n\n            subHyperplaneList.add(polygon);\n\n        }\n\n        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n\n        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\n\n        Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\n\n    }\n"
      }
    }
  },
  "Math-33": {
    "id": "Math-33",
    "project": "Math",
    "number": "33",
    "buggy_function": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n\n    // positive cost non-artificial variables\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n\n    // non-basic artificial variables\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}",
    "fixed_function": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n\n    // positive cost non-artificial variables\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n\n    // non-basic artificial variables\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java",
      "first_line": 327,
      "last_line": 367
    },
    "javadoc": "/**\n* Removes the phase 1 objective function, positive cost non-artificial variables,\n* and the non-basic artificial variables from this tableau.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.optimization.linear.SimplexSolverTest::testMath781": {
        "source": "    public void testMath781() {\n\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0);\n\n\n\n        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2));\n\n        constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1));\n\n        constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1));\n\n\n\n        double epsilon = 1e-6;\n\n        SimplexSolver solver = new SimplexSolver();\n\n        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n\n\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) > 0);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[2], 0.0d, epsilon) < 0);\n\n        Assert.assertEquals(2.0d, solution.getValue(), epsilon);\n\n    }\n"
      }
    }
  },
  "Math-34": {
    "id": "Math-34",
    "project": "Math",
    "number": "34",
    "buggy_function": "public Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}",
    "fixed_function": "public Iterator<Chromosome> iterator() {\n    return getChromosomes().iterator();\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/genetics/ListPopulation.java",
      "first_line": 208,
      "last_line": 210
    },
    "javadoc": "/**\n* Returns an iterator over the unmodifiable list of chromosomes.\n* <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n*\n* @return chromosome iterator\n*/",
    "failing_tests": {
      "org.apache.commons.math3.genetics.ListPopulationTest::testIterator": {
        "source": "    public void testIterator() {\n\n        final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome>();\n\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n\n\n\n        final ListPopulation population = new ListPopulation(10) {\n\n            public Population nextGeneration() {\n\n                // not important\n\n                return null;\n\n            }\n\n        };\n\n\n\n        population.addChromosomes(chromosomes);\n\n\n\n        final Iterator<Chromosome> iter = population.iterator();\n\n        while (iter.hasNext()) {\n\n            iter.next();\n\n            iter.remove();\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-38": {
    "id": "Math-38",
    "project": "Math",
    "number": "38",
    "buggy_function": "private void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod(); // XXX\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n    do {\n        final int nfm = getEvaluations();\n        final int nfx = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 &&\n                nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else if (nfm > n) {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                    throw new PathIsExploredException(); // XXX\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n                throw new PathIsExploredException(); // XXX\n            }\n            final int iptMinus1 = ipt;\n            final int jptMinus1 = jpt;\n            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n        }\n\n        // Calculate the next value of F. The least function value so far and\n        // its index are required.\n\n        for (int j = 0; j < n; j++) {\n            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                      originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                             upperBound[j]));\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n\n        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        final double f = isMinimize ? objectiveValue : -objectiveValue;\n        final int numEval = getEvaluations(); // nfm + 1\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Set the nonzero initial elements of BMAT and the quadratic model in the\n        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n        // order that the function value at the first of them contributes to the\n        // off-diagonal second derivative terms of the initial quadratic model.\n\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 &&\n                numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                    throw new PathIsExploredException(); // XXX\n                }\n            } else if (numEval >= n + 2) {\n                final int ih = nfx * (nfx + 1) / 2 - 1;\n                final double tmp = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm,\n                              -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                zMatrix.setEntry(nfm - n, nfxm,\n                              -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n            }\n\n            // Set the off-diagonal second derivatives of the Lagrange functions and\n            // the initial quadratic model.\n\n        } else {\n            zMatrix.setEntry(0, nfxm, recip);\n            zMatrix.setEntry(nfm, nfxm, recip);\n            zMatrix.setEntry(ipt, nfxm, -recip);\n            zMatrix.setEntry(jpt, nfxm, -recip);\n\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n            throw new PathIsExploredException(); // XXX\n        }\n    } while (getEvaluations() < npt);\n} // prelim",
    "fixed_function": "private void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod(); // XXX\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n    do {\n        final int nfm = getEvaluations();\n        final int nfx = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 &&\n                nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else if (nfm > n) {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                    throw new PathIsExploredException(); // XXX\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n                   throw new PathIsExploredException(); // XXX\n            }\n            final int iptMinus1 = ipt - 1;\n            final int jptMinus1 = jpt - 1;\n            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n        }\n\n        // Calculate the next value of F. The least function value so far and\n        // its index are required.\n\n        for (int j = 0; j < n; j++) {\n            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                      originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                             upperBound[j]));\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n\n        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        final double f = isMinimize ? objectiveValue : -objectiveValue;\n        final int numEval = getEvaluations(); // nfm + 1\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Set the nonzero initial elements of BMAT and the quadratic model in the\n        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n        // order that the function value at the first of them contributes to the\n        // off-diagonal second derivative terms of the initial quadratic model.\n\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 &&\n                numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                    throw new PathIsExploredException(); // XXX\n                }\n            } else if (numEval >= n + 2) {\n                final int ih = nfx * (nfx + 1) / 2 - 1;\n                final double tmp = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm,\n                              -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                zMatrix.setEntry(nfm - n, nfxm,\n                              -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n            }\n\n            // Set the off-diagonal second derivatives of the Lagrange functions and\n            // the initial quadratic model.\n\n        } else {\n            zMatrix.setEntry(0, nfxm, recip);\n            zMatrix.setEntry(nfm, nfxm, recip);\n            zMatrix.setEntry(ipt, nfxm, -recip);\n            zMatrix.setEntry(jpt, nfxm, -recip);\n\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n               throw new PathIsExploredException(); // XXX\n        }\n    } while (getEvaluations() < npt);\n} // prelim",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java",
      "first_line": 1582,
      "last_line": 1755
    },
    "javadoc": "/**\n*     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n*     BMAT and ZMAT for the first iteration, and it maintains the values of\n*     NF and KOPT. The vector X is also changed by PRELIM.\n*\n*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n*       same as the corresponding arguments in SUBROUTINE BOBYQA.\n*     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n*       are the same as the corresponding arguments in BOBYQB, the elements\n*       of SL and SU being set in BOBYQA.\n*     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n*       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n*       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n*     NF is maintaned as the number of calls of CALFUN so far.\n*     KOPT will be such that the least calculated value of F so far is at\n*       the point XPT(KOPT,.)+XBASE in the space of the variables.\n*\n* @param lowerBound Lower bounds.\n* @param upperBound Upper bounds.\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest::testConstrainedRosenWithMoreInterpolationPoints": {
        "source": "    public void testConstrainedRosenWithMoreInterpolationPoints() {\n\n        final double[] startPoint = point(DIM, 0.1);\n\n        final double[][] boundaries = boundaries(DIM, -1, 2);\n\n        final RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n\n\n\n        // This should have been 78 because in the code the hard limit is\n\n        // said to be\n\n        //   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n\n        // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n\n        // 65, 66, ...\n\n        final int maxAdditionalPoints = 47;\n\n\n\n        for (int num = 1; num <= maxAdditionalPoints; num++) {\n\n            doTest(new Rosen(), startPoint, boundaries,\n\n                   GoalType.MINIMIZE,\n\n                   1e-12, 1e-6, 2000,\n\n                   num,\n\n                   expected,\n\n                   \"num=\" + num);\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-39": {
    "id": "Math-39",
    "project": "Math",
    "number": "39",
    "buggy_function": "public void integrate(final ExpandableStatefulODE equations, final double t)\n    throws MathIllegalStateException, MathIllegalArgumentException {\n\n  sanityChecks(equations, t);\n  setEquations(equations);\n  final boolean forward = t > equations.getTime();\n\n  // create some internal working arrays\n  final double[] y0  = equations.getCompleteState();\n  final double[] y = y0.clone();\n  final int stages = c.length + 1;\n  final double[][] yDotK = new double[stages][y.length];\n  final double[] yTmp    = y0.clone();\n  final double[] yDotTmp = new double[y.length];\n\n  // set up an interpolator sharing the integrator arrays\n  final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n  interpolator.reinitialize(this, yTmp, yDotK, forward,\n                            equations.getPrimaryMapper(), equations.getSecondaryMappers());\n  interpolator.storeTime(equations.getTime());\n\n  // set up integration control objects\n  stepStart         = equations.getTime();\n  double  hNew      = 0;\n  boolean firstTime = true;\n  initIntegration(equations.getTime(), y0, t);\n\n  // main integration loop\n  isLastStep = false;\n  do {\n\n    interpolator.shift();\n\n    // iterate over step size, ensuring local normalized error is smaller than 1\n    double error = 10;\n    while (error >= 1.0) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[mainSetDimension];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n            }\n        } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n            }\n        }\n        hNew = initializeStep(forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error >= 1.0) {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            FastMath.min(maxGrowth,\n                         FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // local error is small enough: accept the step, trigger events and step handlers\n    interpolator.storeTime(stepStart + stepSize);\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n    stepStart = acceptStep(interpolator, y, yDotTmp, t);\n    System.arraycopy(y, 0, yTmp, 0, y.length);\n\n    if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        if (fsal) {\n            // save the last evaluation for the next step\n            System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n        }\n\n        // stepsize control for next step\n        final double factor =\n            FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n\n        final double  filteredNextT      = stepStart + hNew;\n        final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n        if (filteredNextIsLast) {\n            hNew = t - stepStart;\n        }\n\n    }\n\n  } while (!isLastStep);\n\n  // dispatch results\n  equations.setTime(stepStart);\n  equations.setCompleteState(y);\n\n  resetInternalState();\n\n}",
    "fixed_function": "public void integrate(final ExpandableStatefulODE equations, final double t)\n    throws MathIllegalStateException, MathIllegalArgumentException {\n\n  sanityChecks(equations, t);\n  setEquations(equations);\n  final boolean forward = t > equations.getTime();\n\n  // create some internal working arrays\n  final double[] y0  = equations.getCompleteState();\n  final double[] y = y0.clone();\n  final int stages = c.length + 1;\n  final double[][] yDotK = new double[stages][y.length];\n  final double[] yTmp    = y0.clone();\n  final double[] yDotTmp = new double[y.length];\n\n  // set up an interpolator sharing the integrator arrays\n  final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n  interpolator.reinitialize(this, yTmp, yDotK, forward,\n                            equations.getPrimaryMapper(), equations.getSecondaryMappers());\n  interpolator.storeTime(equations.getTime());\n\n  // set up integration control objects\n  stepStart         = equations.getTime();\n  double  hNew      = 0;\n  boolean firstTime = true;\n  initIntegration(equations.getTime(), y0, t);\n\n  // main integration loop\n  isLastStep = false;\n  do {\n\n    interpolator.shift();\n\n    // iterate over step size, ensuring local normalized error is smaller than 1\n    double error = 10;\n    while (error >= 1.0) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[mainSetDimension];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n            }\n        } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n            }\n        }\n        hNew = initializeStep(forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n      if (forward) {\n          if (stepStart + stepSize >= t) {\n              stepSize = t - stepStart;\n          }\n      } else {\n          if (stepStart + stepSize <= t) {\n              stepSize = t - stepStart;\n          }\n      }\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error >= 1.0) {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            FastMath.min(maxGrowth,\n                         FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // local error is small enough: accept the step, trigger events and step handlers\n    interpolator.storeTime(stepStart + stepSize);\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n    stepStart = acceptStep(interpolator, y, yDotTmp, t);\n    System.arraycopy(y, 0, yTmp, 0, y.length);\n\n    if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        if (fsal) {\n            // save the last evaluation for the next step\n            System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n        }\n\n        // stepsize control for next step\n        final double factor =\n            FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n\n        final double  filteredNextT      = stepStart + hNew;\n        final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n        if (filteredNextIsLast) {\n            hNew = t - stepStart;\n        }\n\n    }\n\n  } while (!isLastStep);\n\n  // dispatch results\n  equations.setTime(stepStart);\n  equations.setCompleteState(y);\n\n  resetInternalState();\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
      "first_line": 191,
      "last_line": 328
    },
    "javadoc": "/** Set the safety factor for stepsize control.\n* @param safety safety factor\n*/",
    "failing_tests": {
      "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep": {
        "source": "  public void testTooLargeFirstStep() {\n\n\n\n      AdaptiveStepsizeIntegrator integ =\n\n              new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);\n\n      final double start = 0.0;\n\n      final double end   = 0.001;\n\n      FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {\n\n\n\n          public int getDimension() {\n\n              return 1;\n\n          }\n\n\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n\n              Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));\n\n              Assert.assertTrue(t <= FastMath.nextAfter(end,   Double.POSITIVE_INFINITY));\n\n              yDot[0] = -100.0 * y[0];\n\n          }\n\n\n\n      };\n\n\n\n      integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8);\n\n      integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);\n\n\n\n  }\n"
      }
    }
  },
  "Math-40": {
    "id": "Math-40",
    "project": "Math",
    "number": "40",
    "buggy_function": "protected double doSolve() {\n\n    // prepare arrays with the first points\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n    verifySequence(x[0], x[1], x[2]);\n\n    // evaluate initial guess\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, 1)) {\n        // return the initial guess if it is a perfect root.\n        return x[1];\n    }\n\n    // evaluate first  endpoint\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, 1)) {\n        // return the first endpoint if it is a perfect root.\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n\n        // reduce interval if it brackets the root\n        nbPoints        = 2;\n        signChangeIndex = 1;\n\n    } else {\n\n        // evaluate second endpoint\n        y[2] = computeObjectiveValue(x[2]);\n        if (Precision.equals(y[2], 0.0, 1)) {\n            // return the second endpoint if it is a perfect root.\n            return x[2];\n        }\n\n        if (y[1] * y[2] < 0) {\n            // use all computed point as a start sampling array for solving\n            nbPoints        = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n        }\n\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] tmpX = new double[x.length];\n\n    // current tightest bracketing of the root\n    double xA    = x[signChangeIndex - 1];\n    double yA    = y[signChangeIndex - 1];\n    double absYA = FastMath.abs(yA);\n    int agingA   = 0;\n    double xB    = x[signChangeIndex];\n    double yB    = y[signChangeIndex];\n    double absYB = FastMath.abs(yB);\n    int agingB   = 0;\n\n    // search loop\n    while (true) {\n\n        // check convergence of bracketing interval\n        final double xTol = getAbsoluteAccuracy() +\n                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n            case ANY_SIDE :\n                return absYA < absYB ? xA : xB;\n            case LEFT_SIDE :\n                return xA;\n            case RIGHT_SIDE :\n                return xB;\n            case BELOW_SIDE :\n                return (yA <= 0) ? xA : xB;\n            case ABOVE_SIDE :\n                return (yA <  0) ? xB : xA;\n            default :\n                // this should never happen\n                throw new MathInternalError(null);\n            }\n        }\n\n        // target for the next evaluation point\n        double targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            // we keep updating the high bracket, try to compensate this\n            targetY = -REDUCTION_FACTOR * yB;\n        } else if (agingB >= MAXIMAL_AGING) {\n            // we keep updating the low bracket, try to compensate this\n            targetY = -REDUCTION_FACTOR * yA;\n        } else {\n            // bracketing is balanced, try to find the root itself\n            targetY = 0;\n        }\n\n        // make a few attempts to guess a root,\n        double nextX;\n        int start = 0;\n        int end   = nbPoints;\n        do {\n\n            // guess a value for current target, using inverse polynomial interpolation\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end);\n\n            if (!((nextX > xA) && (nextX < xB))) {\n                // the guessed root is not strictly inside of the tightest bracketing interval\n\n                // the guessed root is either not strictly inside the interval or it\n                // is a NaN (which occurs when some sampling points share the same y)\n                // we try again with a lower interpolation order\n                if (signChangeIndex - start >= end - signChangeIndex) {\n                    // we have more points before the sign change, drop the lowest point\n                    ++start;\n                } else {\n                    // we have more points after sign change, drop the highest point\n                    --end;\n                }\n\n                // we need to do one more attempt\n                nextX = Double.NaN;\n\n            }\n\n        } while (Double.isNaN(nextX) && (end - start > 1));\n\n        if (Double.isNaN(nextX)) {\n            // fall back to bisection\n            nextX = xA + 0.5 * (xB - xA);\n            start = signChangeIndex - 1;\n            end   = signChangeIndex;\n        }\n\n        // evaluate the function at the guessed root\n        final double nextY = computeObjectiveValue(nextX);\n        if (Precision.equals(nextY, 0.0, 1)) {\n            // we have found an exact root, since it is not an approximation\n            // we don't need to bother about the allowed solutions setting\n            return nextX;\n        }\n\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n            // we have been forced to ignore some points to keep bracketing,\n            // they are probably too far from the root, drop them from now on\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n\n        } else  if (nbPoints == x.length) {\n\n            // we have to drop one point in order to insert the new one\n            nbPoints--;\n\n            // keep the tightest bracketing interval as centered as possible\n            if (signChangeIndex >= (x.length + 1) / 2) {\n                // we drop the lowest point, we have to shift the arrays and the index\n                System.arraycopy(x, 1, x, 0, nbPoints);\n                System.arraycopy(y, 1, y, 0, nbPoints);\n                --signChangeIndex;\n            }\n\n        }\n\n        // insert the last computed point\n        //(by construction, we know it lies inside the tightest bracketing interval)\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n        x[signChangeIndex] = nextX;\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n        y[signChangeIndex] = nextY;\n        ++nbPoints;\n\n        // update the bracketing interval\n        if (nextY * yA <= 0) {\n            // the sign change occurs before the inserted point\n            xB = nextX;\n            yB = nextY;\n            absYB = FastMath.abs(yB);\n            ++agingA;\n            agingB = 0;\n        } else {\n            // the sign change occurs after the inserted point\n            xA = nextX;\n            yA = nextY;\n            absYA = FastMath.abs(yA);\n            agingA = 0;\n            ++agingB;\n\n            // update the sign change index\n            signChangeIndex++;\n\n        }\n\n    }\n\n}",
    "fixed_function": "protected double doSolve() {\n\n    // prepare arrays with the first points\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n    verifySequence(x[0], x[1], x[2]);\n\n    // evaluate initial guess\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, 1)) {\n        // return the initial guess if it is a perfect root.\n        return x[1];\n    }\n\n    // evaluate first  endpoint\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, 1)) {\n        // return the first endpoint if it is a perfect root.\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n\n        // reduce interval if it brackets the root\n        nbPoints        = 2;\n        signChangeIndex = 1;\n\n    } else {\n\n        // evaluate second endpoint\n        y[2] = computeObjectiveValue(x[2]);\n        if (Precision.equals(y[2], 0.0, 1)) {\n            // return the second endpoint if it is a perfect root.\n            return x[2];\n        }\n\n        if (y[1] * y[2] < 0) {\n            // use all computed point as a start sampling array for solving\n            nbPoints        = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n        }\n\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] tmpX = new double[x.length];\n\n    // current tightest bracketing of the root\n    double xA    = x[signChangeIndex - 1];\n    double yA    = y[signChangeIndex - 1];\n    double absYA = FastMath.abs(yA);\n    int agingA   = 0;\n    double xB    = x[signChangeIndex];\n    double yB    = y[signChangeIndex];\n    double absYB = FastMath.abs(yB);\n    int agingB   = 0;\n\n    // search loop\n    while (true) {\n\n        // check convergence of bracketing interval\n        final double xTol = getAbsoluteAccuracy() +\n                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n            case ANY_SIDE :\n                return absYA < absYB ? xA : xB;\n            case LEFT_SIDE :\n                return xA;\n            case RIGHT_SIDE :\n                return xB;\n            case BELOW_SIDE :\n                return (yA <= 0) ? xA : xB;\n            case ABOVE_SIDE :\n                return (yA <  0) ? xB : xA;\n            default :\n                // this should never happen\n                throw new MathInternalError(null);\n            }\n        }\n\n        // target for the next evaluation point\n        double targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            // we keep updating the high bracket, try to compensate this\n            final int p = agingA - MAXIMAL_AGING;\n            final double weightA = (1 << p) - 1;\n            final double weightB = p + 1;\n            targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n        } else if (agingB >= MAXIMAL_AGING) {\n            // we keep updating the low bracket, try to compensate this\n            final int p = agingB - MAXIMAL_AGING;\n            final double weightA = p + 1;\n            final double weightB = (1 << p) - 1;\n            targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n        } else {\n            // bracketing is balanced, try to find the root itself\n            targetY = 0;\n        }\n\n        // make a few attempts to guess a root,\n        double nextX;\n        int start = 0;\n        int end   = nbPoints;\n        do {\n\n            // guess a value for current target, using inverse polynomial interpolation\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end);\n\n            if (!((nextX > xA) && (nextX < xB))) {\n                // the guessed root is not strictly inside of the tightest bracketing interval\n\n                // the guessed root is either not strictly inside the interval or it\n                // is a NaN (which occurs when some sampling points share the same y)\n                // we try again with a lower interpolation order\n                if (signChangeIndex - start >= end - signChangeIndex) {\n                    // we have more points before the sign change, drop the lowest point\n                    ++start;\n                } else {\n                    // we have more points after sign change, drop the highest point\n                    --end;\n                }\n\n                // we need to do one more attempt\n                nextX = Double.NaN;\n\n            }\n\n        } while (Double.isNaN(nextX) && (end - start > 1));\n\n        if (Double.isNaN(nextX)) {\n            // fall back to bisection\n            nextX = xA + 0.5 * (xB - xA);\n            start = signChangeIndex - 1;\n            end   = signChangeIndex;\n        }\n\n        // evaluate the function at the guessed root\n        final double nextY = computeObjectiveValue(nextX);\n        if (Precision.equals(nextY, 0.0, 1)) {\n            // we have found an exact root, since it is not an approximation\n            // we don't need to bother about the allowed solutions setting\n            return nextX;\n        }\n\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n            // we have been forced to ignore some points to keep bracketing,\n            // they are probably too far from the root, drop them from now on\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n\n        } else  if (nbPoints == x.length) {\n\n            // we have to drop one point in order to insert the new one\n            nbPoints--;\n\n            // keep the tightest bracketing interval as centered as possible\n            if (signChangeIndex >= (x.length + 1) / 2) {\n                // we drop the lowest point, we have to shift the arrays and the index\n                System.arraycopy(x, 1, x, 0, nbPoints);\n                System.arraycopy(y, 1, y, 0, nbPoints);\n                --signChangeIndex;\n            }\n\n        }\n\n        // insert the last computed point\n        //(by construction, we know it lies inside the tightest bracketing interval)\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n        x[signChangeIndex] = nextX;\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n        y[signChangeIndex] = nextY;\n        ++nbPoints;\n\n        // update the bracketing interval\n        if (nextY * yA <= 0) {\n            // the sign change occurs before the inserted point\n            xB = nextX;\n            yB = nextY;\n            absYB = FastMath.abs(yB);\n            ++agingA;\n            agingB = 0;\n        } else {\n            // the sign change occurs after the inserted point\n            xA = nextX;\n            yA = nextY;\n            absYA = FastMath.abs(yA);\n            agingA = 0;\n            ++agingB;\n\n            // update the sign change index\n            signChangeIndex++;\n\n        }\n\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
      "first_line": 143,
      "last_line": 345
    },
    "javadoc": "/**\n* {@inheritDoc}\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716": {
        "source": "    public void testIssue716() {\n\n        BracketingNthOrderBrentSolver solver =\n\n                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);\n\n        UnivariateFunction sharpTurn = new UnivariateFunction() {\n\n            public double value(double x) {\n\n                return (2 * x + 1) / (1.0e9 * (x + 1));\n\n            }\n\n        };\n\n        double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);\n\n        Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());\n\n        Assert.assertTrue(sharpTurn.value(result) >= 0);\n\n        Assert.assertEquals(-0.5, result, 1.0e-10);\n\n    }\n"
      }
    }
  },
  "Math-41": {
    "id": "Math-41",
    "project": "Math",
    "number": "41",
    "buggy_function": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n\n    double var = Double.NaN;\n\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}",
    "fixed_function": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n\n    double var = Double.NaN;\n\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java",
      "first_line": 501,
      "last_line": 532
    },
    "javadoc": "/**\n* Returns the weighted variance of the entries in the specified portion of\n* the input array, using the precomputed weighted mean value.  Returns\n* <code>Double.NaN</code> if the designated subarray is empty.\n* <p>\n* Uses the formula <pre>\n*   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n* </pre></p>\n* <p>\n* The formula used assumes that the supplied mean value is the weighted arithmetic\n* mean of the sample data, not a known population parameter. This method\n* is supplied only to save computation when the mean has already been\n* computed.</p>\n* <p>\n* This formula will not return the same result as the unweighted variance when all\n* weights are equal, unless all weights are equal to 1. The formula assumes that\n* weights are to be treated as \"expansion values,\" as will be the case if for example\n* the weights represent frequency counts. To normalize weights so that the denominator\n* in the variance computation equals the length of the input vector minus one, use <pre>\n*   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n* </pre>\n* <p>\n* Returns 0 for a single-value (i.e. length = 1) sample.</p>\n* <p>\n* Throws <code>IllegalArgumentException</code> if any of the following are true:\n* <ul><li>the values array is null</li>\n*     <li>the weights array is null</li>\n*     <li>the weights array does not have the same length as the values array</li>\n*     <li>the weights array contains one or more infinite values</li>\n*     <li>the weights array contains one or more NaN values</li>\n*     <li>the weights array contains negative values</li>\n*     <li>the start and length arguments do not determine a valid array</li>\n* </ul></p>\n* <p>\n* Does not change the internal state of the statistic.</p>\n*\n* @param values the input array\n* @param weights the weights array\n* @param mean the precomputed weighted mean value\n* @param begin index of the first array element to include\n* @param length the number of elements to include\n* @return the variance of the values or Double.NaN if length = 0\n* @throws IllegalArgumentException if the parameters are not valid\n* @since 2.1\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.descriptive.moment.VarianceTest::testEvaluateArraySegmentWeighted": {
        "source": "    public void testEvaluateArraySegmentWeighted() {\n\n        // See if this statistic computes weighted statistics\n\n        // If not, skip this test\n\n        UnivariateStatistic statistic = getUnivariateStatistic();\n\n        if (!(statistic instanceof WeightedEvaluation)) {\n\n            return;\n\n        }\n\n        final WeightedEvaluation stat = (WeightedEvaluation) getUnivariateStatistic();\n\n        final double[] arrayZero = new double[5];\n\n        final double[] weightZero = new double[5];\n\n        System.arraycopy(testArray, 0, arrayZero, 0, 5);\n\n        System.arraycopy(testWeightsArray, 0, weightZero, 0, 5);\n\n        Assert.assertEquals(stat.evaluate(arrayZero, weightZero),\n\n                stat.evaluate(testArray, testWeightsArray, 0, 5), 0);\n\n        final double[] arrayOne = new double[5];\n\n        final double[] weightOne = new double[5];\n\n        System.arraycopy(testArray, 5, arrayOne, 0, 5);\n\n        System.arraycopy(testWeightsArray, 5, weightOne, 0, 5);\n\n        Assert.assertEquals(stat.evaluate(arrayOne, weightOne),\n\n                stat.evaluate(testArray, testWeightsArray, 5, 5), 0);\n\n        final double[] arrayEnd = new double[5];\n\n        final double[] weightEnd = new double[5];\n\n        System.arraycopy(testArray, testArray.length - 5, arrayEnd, 0, 5);\n\n        System.arraycopy(testWeightsArray, testArray.length - 5, weightEnd, 0, 5);\n\n        Assert.assertEquals(stat.evaluate(arrayEnd, weightEnd),\n\n                stat.evaluate(testArray, testWeightsArray, testArray.length - 5, 5), 0);\n\n    }\n"
      }
    }
  },
  "Math-42": {
    "id": "Math-42",
    "project": "Math",
    "number": "42",
    "buggy_function": "protected RealPointValuePair getSolution() {\n  int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n  Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n  double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n  Set<Integer> basicRows = new HashSet<Integer>();\n  double[] coefficients = new double[getOriginalNumDecisionVariables()];\n  for (int i = 0; i < coefficients.length; i++) {\n      int colIndex = columnLabels.indexOf(\"x\" + i);\n      if (colIndex < 0) {\n        coefficients[i] = 0;\n        continue;\n      }\n      Integer basicRow = getBasicRow(colIndex);\n          // if the basic row is found to be the objective function row\n          // set the coefficient to 0 -> this case handles unconstrained \n          // variables that are still part of the objective function\n      if (basicRows.contains(basicRow)) {\n          // if multiple variables can take a given value\n          // then we choose the first and set the rest equal to 0\n          coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n      } else {\n          basicRows.add(basicRow);\n          coefficients[i] =\n              (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n              (restrictToNonNegative ? 0 : mostNegative);\n      }\n  }\n  return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}",
    "fixed_function": "protected RealPointValuePair getSolution() {\n  int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n  Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n  double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n  Set<Integer> basicRows = new HashSet<Integer>();\n  double[] coefficients = new double[getOriginalNumDecisionVariables()];\n  for (int i = 0; i < coefficients.length; i++) {\n      int colIndex = columnLabels.indexOf(\"x\" + i);\n      if (colIndex < 0) {\n        coefficients[i] = 0;\n        continue;\n      }\n      Integer basicRow = getBasicRow(colIndex);\n      if (basicRow != null && basicRow == 0) {\n          // if the basic row is found to be the objective function row\n          // set the coefficient to 0 -> this case handles unconstrained \n          // variables that are still part of the objective function\n          coefficients[i] = 0;\n      } else if (basicRows.contains(basicRow)) {\n          // if multiple variables can take a given value\n          // then we choose the first and set the rest equal to 0\n          coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n      } else {\n          basicRows.add(basicRow);\n          coefficients[i] =\n              (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n              (restrictToNonNegative ? 0 : mostNegative);\n      }\n  }\n  return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java",
      "first_line": 396,
      "last_line": 425
    },
    "javadoc": "/**\n* Get the current solution.\n*\n* @return current solution\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath713NegativeVariable": {
        "source": "    public void testMath713NegativeVariable() {\n\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d);\n\n        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1));\n\n\n\n        double epsilon = 1e-6;\n\n        SimplexSolver solver = new SimplexSolver();\n\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n\n\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);\n\n    }\n"
      }
    }
  },
  "Math-43": {
    "id": "Math-43",
    "project": "Math",
    "number": "43",
    "buggy_function": "public void addValue(double value) {\n    sumImpl.increment(value);\n    sumsqImpl.increment(value);\n    minImpl.increment(value);\n    maxImpl.increment(value);\n    sumLogImpl.increment(value);\n    secondMoment.increment(value);\n    // If mean, variance or geomean have been overridden,\n    // need to increment these\n    if (!(meanImpl instanceof Mean)) {\n        meanImpl.increment(value);\n    }\n    if (!(varianceImpl instanceof Variance)) {\n        varianceImpl.increment(value);\n    }\n    if (!(geoMeanImpl instanceof GeometricMean)) {\n        geoMeanImpl.increment(value);\n    }\n    n++;\n}",
    "fixed_function": "public void addValue(double value) {\n    sumImpl.increment(value);\n    sumsqImpl.increment(value);\n    minImpl.increment(value);\n    maxImpl.increment(value);\n    sumLogImpl.increment(value);\n    secondMoment.increment(value);\n    // If mean, variance or geomean have been overridden,\n    // need to increment these\n    if (meanImpl != mean) {\n        meanImpl.increment(value);\n    }\n    if (varianceImpl != variance) {\n        varianceImpl.increment(value);\n    }\n    if (geoMeanImpl != geoMean) {\n        geoMeanImpl.increment(value);\n    }\n    n++;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java",
      "first_line": 149,
      "last_line": 168
    },
    "javadoc": "/**\n* Add a value to the data\n* @param value the value to add\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.descriptive.SummaryStatisticsTest::testOverrideMeanWithMathClass": {
        "source": "    public void testOverrideMeanWithMathClass() throws Exception {\n\n        double[] scores = {1, 2, 3, 4};\n\n        SummaryStatistics stats = new SummaryStatistics();\n\n        stats.setMeanImpl(new Mean()); \n\n        for(double i : scores) {\n\n          stats.addValue(i);\n\n        }\n\n        Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0); \n\n    }\n"
      },
      "org.apache.commons.math.stat.descriptive.SummaryStatisticsTest::testOverrideGeoMeanWithMathClass": {
        "source": "    public void testOverrideGeoMeanWithMathClass() throws Exception {\n\n        double[] scores = {1, 2, 3, 4};\n\n        SummaryStatistics stats = new SummaryStatistics();\n\n        stats.setGeoMeanImpl(new GeometricMean()); \n\n        for(double i : scores) {\n\n          stats.addValue(i);\n\n        }\n\n        Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(), 0); \n\n    }\n"
      },
      "org.apache.commons.math.stat.descriptive.SummaryStatisticsTest::testOverrideVarianceWithMathClass": {
        "source": "    public void testOverrideVarianceWithMathClass() throws Exception {\n\n        double[] scores = {1, 2, 3, 4};\n\n        SummaryStatistics stats = new SummaryStatistics();\n\n        stats.setVarianceImpl(new Variance(false)); //use \"population variance\"\n\n        for(double i : scores) {\n\n          stats.addValue(i);\n\n        }\n\n        Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(), 0); \n\n    }\n"
      },
      "org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest::testOverrideMeanWithMathClass": {
        "source": "    public void testOverrideMeanWithMathClass() throws Exception {\n\n        double[] scores = {1, 2, 3, 4};\n\n        SummaryStatistics stats = new SummaryStatistics();\n\n        stats.setMeanImpl(new Mean()); \n\n        for(double i : scores) {\n\n          stats.addValue(i);\n\n        }\n\n        Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0); \n\n    }\n"
      },
      "org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest::testOverrideGeoMeanWithMathClass": {
        "source": "    public void testOverrideGeoMeanWithMathClass() throws Exception {\n\n        double[] scores = {1, 2, 3, 4};\n\n        SummaryStatistics stats = new SummaryStatistics();\n\n        stats.setGeoMeanImpl(new GeometricMean()); \n\n        for(double i : scores) {\n\n          stats.addValue(i);\n\n        }\n\n        Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(), 0); \n\n    }\n"
      },
      "org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest::testOverrideVarianceWithMathClass": {
        "source": "    public void testOverrideVarianceWithMathClass() throws Exception {\n\n        double[] scores = {1, 2, 3, 4};\n\n        SummaryStatistics stats = new SummaryStatistics();\n\n        stats.setVarianceImpl(new Variance(false)); //use \"population variance\"\n\n        for(double i : scores) {\n\n          stats.addValue(i);\n\n        }\n\n        Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(), 0); \n\n    }\n"
      }
    }
  },
  "Math-44": {
    "id": "Math-44",
    "project": "Math",
    "number": "44",
    "buggy_function": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MathIllegalStateException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n        resetOccurred = false;\n\n        // initialize the events states if needed\n        if (! statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n            /** {@inheritDoc} */\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n\n        });\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n        }\n\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // trigger the event\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState();\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                return eventT;\n            }\n\n            if (currentEvent.reset(eventT, eventY)) {\n                // some event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute them\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n                return eventT;\n            }\n\n            // prepare handling of the remaining part of the step\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // check if the same event occurs again in the remaining part of the step\n            if (currentEvent.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(currentEvent);\n            }\n\n        }\n\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        // handle the remaining part of the step, after all events if any\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n\n}",
    "fixed_function": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MathIllegalStateException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n\n        // initialize the events states if needed\n        if (! statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n            /** {@inheritDoc} */\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n\n        });\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n        }\n\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // trigger the event\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState();\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                for (final EventState remaining : occuringEvents) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n                return eventT;\n            }\n\n            if (currentEvent.reset(eventT, eventY)) {\n                // some event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute them\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n                for (final EventState remaining : occuringEvents) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n                return eventT;\n            }\n\n            // prepare handling of the remaining part of the step\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // check if the same event occurs again in the remaining part of the step\n            if (currentEvent.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(currentEvent);\n            }\n\n        }\n\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        // handle the remaining part of the step, after all events if any\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
      "first_line": 274,
      "last_line": 374
    },
    "javadoc": "/** Accept a step, triggering events and step handlers.\n* @param interpolator step interpolator\n* @param y state vector at step end time, must be reset if an event\n* asks for resetting or if an events stops integration during the step\n* @param yDot placeholder array where to put the time derivative of the state vector\n* @param tEnd final integration time\n* @return time at end of step\n* @exception MathIllegalStateException if the value of one event state cannot be evaluated\n* @since 2.2\n*/",
    "failing_tests": {
      "org.apache.commons.math.ode.events.EventStateTest::testIssue695": {
        "source": "    public void testIssue695() {\n\n\n\n        FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n\n            \n\n            public int getDimension() {\n\n                return 1;\n\n            }\n\n            \n\n            public void computeDerivatives(double t, double[] y, double[] yDot) {\n\n                yDot[0] = 1.0;\n\n            }\n\n        };\n\n\n\n        DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n\n        integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\n\n        integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\n\n        integrator.setInitialStepSize(3.0);\n\n\n\n        double target = 30.0;\n\n        double[] y = new double[1];\n\n        double tEnd = integrator.integrate(equation, 0.0, y, target, y);\n\n        Assert.assertEquals(target, tEnd, 1.0e-10);\n\n        Assert.assertEquals(32.0, y[0], 1.0e-10);\n\n\n\n    }\n"
      }
    }
  },
  "Math-45": {
    "id": "Math-45",
    "project": "Math",
    "number": "45",
    "buggy_function": "public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n    super(rowDimension, columnDimension);\n    this.rows = rowDimension;\n    this.columns = columnDimension;\n    this.entries = new OpenIntToDoubleHashMap(0.0);\n}",
    "fixed_function": "public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n    super(rowDimension, columnDimension);\n    long lRow = (long) rowDimension;\n    long lCol = (long) columnDimension;\n    if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n        throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n    }\n    this.rows = rowDimension;\n    this.columns = columnDimension;\n    this.entries = new OpenIntToDoubleHashMap(0.0);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java",
      "first_line": 48,
      "last_line": 53
    },
    "javadoc": "/**\n* Build a sparse matrix with the supplied row and column dimensions.\n*\n* @param rowDimension Number of rows of the matrix.\n* @param columnDimension Number of columns of the matrix.\n*/",
    "failing_tests": {
      "org.apache.commons.math.linear.OpenMapRealMatrixTest::testMath679": {
        "source": "    public void testMath679() {\n\n        new OpenMapRealMatrix(3, Integer.MAX_VALUE);\n\n    }\n"
      }
    }
  },
  "Math-48": {
    "id": "Math-48",
    "project": "Math",
    "number": "48",
    "buggy_function": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                // Detect early that algorithm is stuck, instead of waiting\n                // for the maximum number of iterations to be exceeded.\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "fixed_function": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                // Detect early that algorithm is stuck, instead of waiting\n                // for the maximum number of iterations to be exceeded.\n                if (x == x1) {\n                    throw new ConvergenceException();\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "first_line": 129,
      "last_line": 251
    },
    "javadoc": "/**\n* Construct a solver.\n*\n* @param relativeAccuracy Maximum relative error.\n* @param absoluteAccuracy Maximum absolute error.\n* @param functionValueAccuracy Maximum function value error.\n* @param method <em>Secant</em>-based root-finding method to use\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest::testIssue631": {
        "source": "    public void testIssue631() {\n\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n                /** {@inheritDoc} */\n\n                public double value(double x) {\n\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n\n                }\n\n            };\n\n\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n\n        final double root = solver.solve(3624, f, 1, 10);\n\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\n\t}\n"
      }
    }
  },
  "Math-5": {
    "id": "Math-5",
    "project": "Math",
    "number": "5",
    "buggy_function": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n\n    if (isInfinite) {\n        return ZERO;\n    }\n\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}",
    "fixed_function": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n\n    if (real == 0.0 && imaginary == 0.0) {\n        return INF;\n    }\n\n    if (isInfinite) {\n        return ZERO;\n    }\n\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/complex/Complex.java",
      "first_line": 299,
      "last_line": 321
    },
    "javadoc": "/**\n* Returns a {@code Complex} whose value is {@code (this / divisor)},\n* with {@code divisor} interpreted as a real number.\n*\n* @param  divisor Value by which this {@code Complex} is to be divided.\n* @return {@code this / divisor}.\n* @see #divide(Complex)\n*/",
    "failing_tests": {
      "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero": {
        "source": "    public void testReciprocalZero() {\n\n        Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.INF);\n\n    }\n"
      }
    }
  },
  "Math-50": {
    "id": "Math-50",
    "project": "Math",
    "number": "50",
    "buggy_function": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                // Nothing.\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "fixed_function": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                // Nothing.\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "first_line": 128,
      "last_line": 253
    },
    "javadoc": "/**\n* Construct a solver.\n*\n* @param relativeAccuracy Maximum relative error.\n* @param absoluteAccuracy Maximum absolute error.\n* @param functionValueAccuracy Maximum function value error.\n* @param method <em>Secant</em>-based root-finding method to use\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest::testIssue631": {
        "source": "    public void testIssue631() {\n\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n                /** {@inheritDoc} */\n\n                public double value(double x) {\n\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n\n                }\n\n            };\n\n\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n\n        final double root = solver.solve(3624, f, 1, 10);\n\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\n\t}\n"
      }
    }
  },
  "Math-51": {
    "id": "Math-51",
    "project": "Math",
    "number": "51",
    "buggy_function": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n                    // Update formula cannot make any progress: Update the\n                    // search interval.\n            default:\n                // Should never happen.\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "fixed_function": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                if (x == x1) {\n                    final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                      atol);\n                    // Update formula cannot make any progress: Update the\n                    // search interval.\n                    x0 = 0.5 * (x0 + x1 - delta);\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "first_line": 128,
      "last_line": 247
    },
    "javadoc": "/**\n* Construct a solver.\n*\n* @param relativeAccuracy Maximum relative error.\n* @param absoluteAccuracy Maximum absolute error.\n* @param functionValueAccuracy Maximum function value error.\n* @param method <em>Secant</em>-based root-finding method to use\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest::testIssue631": {
        "source": "    public void testIssue631() {\n\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n                @Override\n\n                public double value(double x) {\n\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n\n                }\n\n            };\n\n\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n\n        final double root = solver.solve(3624, f, 1, 10);\n\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\n\t}\n"
      }
    }
  },
  "Math-52": {
    "id": "Math-52",
    "project": "Math",
    "number": "52",
    "buggy_function": "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n// norms computation\ndouble u1u1 = u1.getNormSq();\ndouble u2u2 = u2.getNormSq();\ndouble v1v1 = v1.getNormSq();\ndouble v2v2 = v2.getNormSq();\nif ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n}\n\n// normalize v1 in order to have (v1'|v1') = (u1|u1)\nv1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n// adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\ndouble u1u2   = u1.dotProduct(u2);\ndouble v1v2   = v1.dotProduct(v2);\ndouble coeffU = u1u2 / u1u1;\ndouble coeffV = v1v2 / u1u1;\ndouble beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\ndouble alpha  = coeffU - beta * coeffV;\nv2 = new Vector3D(alpha, v1, beta, v2);\n\n// preliminary computation\nVector3D uRef  = u1;\nVector3D vRef  = v1;\nVector3D v1Su1 = v1.subtract(u1);\nVector3D v2Su2 = v2.subtract(u2);\nVector3D k     = v1Su1.crossProduct(v2Su2);\nVector3D u3    = u1.crossProduct(u2);\ndouble c       = k.dotProduct(u3);\nif (c == 0) {\n  // the (q1, q2, q3) vector is close to the (u1, u2) plane\n  // we try other vectors\n  Vector3D v3 = Vector3D.crossProduct(v1, v2);\n  Vector3D v3Su3 = v3.subtract(u3);\n  k = v1Su1.crossProduct(v3Su3);\n  Vector3D u2Prime = u1.crossProduct(u3);\n  c = k.dotProduct(u2Prime);\n\n  if (c == 0) {\n    // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n    // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n    k = v2Su2.crossProduct(v3Su3);;\n    c = k.dotProduct(u2.crossProduct(u3));;\n\n    if (c == 0) {\n      // the (q1, q2, q3) vector is aligned with everything\n      // this is really the identity rotation\n      q0 = 1.0;\n      q1 = 0.0;\n      q2 = 0.0;\n      q3 = 0.0;\n      return;\n    }\n\n    // we will have to use u2 and v2 to compute the scalar part\n    uRef = u2;\n    vRef = v2;\n\n  }\n\n}\n\n// compute the vectorial part\nc = FastMath.sqrt(c);\ndouble inv = 1.0 / (c + c);\nq1 = inv * k.getX();\nq2 = inv * k.getY();\nq3 = inv * k.getZ();\n\n// compute the scalar part\n k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                  uRef.getZ() * q1 - uRef.getX() * q3,\n                  uRef.getX() * q2 - uRef.getY() * q1);\nq0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n}",
    "fixed_function": "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n// norms computation\ndouble u1u1 = u1.getNormSq();\ndouble u2u2 = u2.getNormSq();\ndouble v1v1 = v1.getNormSq();\ndouble v2v2 = v2.getNormSq();\nif ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n}\n\n// normalize v1 in order to have (v1'|v1') = (u1|u1)\nv1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n// adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\ndouble u1u2   = u1.dotProduct(u2);\ndouble v1v2   = v1.dotProduct(v2);\ndouble coeffU = u1u2 / u1u1;\ndouble coeffV = v1v2 / u1u1;\ndouble beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\ndouble alpha  = coeffU - beta * coeffV;\nv2 = new Vector3D(alpha, v1, beta, v2);\n\n// preliminary computation\nVector3D uRef  = u1;\nVector3D vRef  = v1;\nVector3D v1Su1 = v1.subtract(u1);\nVector3D v2Su2 = v2.subtract(u2);\nVector3D k     = v1Su1.crossProduct(v2Su2);\nVector3D u3    = u1.crossProduct(u2);\ndouble c       = k.dotProduct(u3);\nfinal double inPlaneThreshold = 0.001;\nif (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n  // the (q1, q2, q3) vector is close to the (u1, u2) plane\n  // we try other vectors\n  Vector3D v3 = Vector3D.crossProduct(v1, v2);\n  Vector3D v3Su3 = v3.subtract(u3);\n  k = v1Su1.crossProduct(v3Su3);\n  Vector3D u2Prime = u1.crossProduct(u3);\n  c = k.dotProduct(u2Prime);\n\n  if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n    // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n    // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n    k = v2Su2.crossProduct(v3Su3);;\n    c = k.dotProduct(u2.crossProduct(u3));;\n\n    if (c <= 0) {\n      // the (q1, q2, q3) vector is aligned with everything\n      // this is really the identity rotation\n      q0 = 1.0;\n      q1 = 0.0;\n      q2 = 0.0;\n      q3 = 0.0;\n      return;\n    }\n\n    // we will have to use u2 and v2 to compute the scalar part\n    uRef = u2;\n    vRef = v2;\n\n  }\n\n}\n\n// compute the vectorial part\nc = FastMath.sqrt(c);\ndouble inv = 1.0 / (c + c);\nq1 = inv * k.getX();\nq2 = inv * k.getY();\nq3 = inv * k.getZ();\n\n// compute the scalar part\n k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                  uRef.getZ() * q1 - uRef.getX() * q3,\n                  uRef.getX() * q2 - uRef.getY() * q1);\nq0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java",
      "first_line": 313,
      "last_line": 390
    },
    "javadoc": "/** Build the rotation that transforms a pair of vector into another pair.\n\n* <p>Except for possible scale factors, if the instance were applied to\n* the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n* (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n* <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n* not the same as the angular separation between v<sub>1</sub> and\n* v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n* v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n* v<sub>2</sub>) plane.</p>\n\n* @param u1 first vector of the origin pair\n* @param u2 second vector of the origin pair\n* @param v1 desired image of u1 by the rotation\n* @param v2 desired image of u2 by the rotation\n* @exception IllegalArgumentException if the norm of one of the vectors is zero\n*/",
    "failing_tests": {
      "org.apache.commons.math.geometry.euclidean.threed.RotationTest::testIssue639": {
        "source": "  public void testIssue639(){\n\n      Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n\n                                 -5774608829631843.0 /  268435456.0,\n\n                                 -3822921525525679.0 / 4294967296.0);\n\n      Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0,\n\n                                 -2275058564560979.0 /    1048576.0,\n\n                                  4423475992255071.0 /      65536.0);\n\n      Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);\n\n      Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);\n\n      Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);\n\n      Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);\n\n      Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);\n\n  }\n"
      }
    }
  },
  "Math-53": {
    "id": "Math-53",
    "project": "Math",
    "number": "53",
    "buggy_function": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n        imaginary + rhs.getImaginary());\n}",
    "fixed_function": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    if (isNaN || rhs.isNaN) {\n        return NaN;\n    }\n    return createComplex(real + rhs.getReal(),\n        imaginary + rhs.getImaginary());\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/complex/Complex.java",
      "first_line": 150,
      "last_line": 155
    },
    "javadoc": "/**\n* Return the sum of this complex number and the given complex number.\n* <p>\n* Uses the definitional formula\n* <pre>\n* (a + bi) + (c + di) = (a+c) + (b+d)i\n* </pre></p>\n* <p>\n* If either this or <code>rhs</code> has a NaN value in either part,\n* {@link #NaN} is returned; otherwise Infinite and NaN values are\n* returned in the parts of the result according to the rules for\n* {@link java.lang.Double} arithmetic.</p>\n*\n* @param rhs the other complex number\n* @return the complex number sum\n* @throws NullArgumentException if <code>rhs</code> is null\n*/",
    "failing_tests": {
      "org.apache.commons.math.complex.ComplexTest::testAddNaN": {
        "source": "    public void testAddNaN() {\n\n        Complex x = new Complex(3.0, 4.0);\n\n        Complex z = x.add(Complex.NaN);\n\n        Assert.assertTrue(z.isNaN());\n\n        z = new Complex(1, nan);\n\n        Complex w = x.add(z);\n\n        Assert.assertTrue(Double.isNaN(w.getReal()));\n\n        Assert.assertTrue(Double.isNaN(w.getImaginary()));\n\n    }\n"
      }
    }
  },
  "Math-55": {
    "id": "Math-55",
    "project": "Math",
    "number": "55",
    "buggy_function": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n    // rescale both vectors without losing precision,\n    // to ensure their norm are the same order of magnitude\n\n    // we reduce cancellation errors by preconditioning,\n    // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n    // v3 without loss of precision. See Kahan lecture\n    // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n    // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n    // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n    // compute cross product from v3 and v2 instead of v1 and v2\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n}",
    "fixed_function": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n    final double n1 = v1.getNormSq();\n    final double n2 = v2.getNormSq();\n    if ((n1 * n2) < MathUtils.SAFE_MIN) {\n        return ZERO;\n    }\n\n    // rescale both vectors without losing precision,\n    // to ensure their norm are the same order of magnitude\n    final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n    final double x1    = FastMath.scalb(v1.x, -deltaExp);\n    final double y1    = FastMath.scalb(v1.y, -deltaExp);\n    final double z1    = FastMath.scalb(v1.z, -deltaExp);\n    final double x2    = FastMath.scalb(v2.x,  deltaExp);\n    final double y2    = FastMath.scalb(v2.y,  deltaExp);\n    final double z2    = FastMath.scalb(v2.z,  deltaExp);\n\n    // we reduce cancellation errors by preconditioning,\n    // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n    // v3 without loss of precision. See Kahan lecture\n    // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n    // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n    // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n    final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n    final double rho   = FastMath.rint(256 * ratio) / 256;\n\n    final double x3 = x1 - rho * x2;\n    final double y3 = y1 - rho * y2;\n    final double z3 = z1 - rho * z2;\n\n    // compute cross product from v3 and v2 instead of v1 and v2\n    return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/geometry/Vector3D.java",
      "first_line": 457,
      "last_line": 475
    },
    "javadoc": "/** Compute the cross-product of two vectors.\n* @param v1 first vector\n* @param v2 second vector\n* @return the cross product v1 ^ v2 as a new Vector\n*/",
    "failing_tests": {
      "org.apache.commons.math.geometry.Vector3DTest::testCrossProductCancellation": {
        "source": "    public void testCrossProductCancellation() {\n\n        Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);\n\n        Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);\n\n        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);\n\n\n\n        double scale    = FastMath.scalb(1.0, 100);\n\n        Vector3D big1   = new Vector3D(scale, v1);\n\n        Vector3D small2 = new Vector3D(1 / scale, v2);\n\n        checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1);\n\n\n\n    }\n"
      }
    }
  },
  "Math-56": {
    "id": "Math-56",
    "project": "Math",
    "number": "56",
    "buggy_function": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    final int[] indices = new int[dimension];\n\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n\n    int idx = 1;\n    while (count < index) {\n        count += idx;\n        ++idx;\n    }\n    --idx;\n    indices[last] = idx;\n\n    return indices;\n}",
    "fixed_function": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    final int[] indices = new int[dimension];\n\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n\n    indices[last] = index - count;\n\n    return indices;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java",
      "first_line": 216,
      "last_line": 246
    },
    "javadoc": "/**\n* Convert to multidimensional counter.\n*\n* @param index Index in unidimensional counter.\n* @return the multidimensional counts.\n* @throws OutOfRangeException if {@code index} is not between\n* {@code 0} and the value returned by {@link #getSize()} (excluded).\n*/",
    "failing_tests": {
      "org.apache.commons.math.util.MultidimensionalCounterTest::testIterationConsistency": {
        "source": "    public void testIterationConsistency() {\n\n        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4);\n\n        final int[][] expected = new int[][] {\n\n            { 0, 0, 0 },\n\n            { 0, 0, 1 },\n\n            { 0, 0, 2 },\n\n            { 0, 0, 3 },\n\n            { 0, 1, 0 },\n\n            { 0, 1, 1 },\n\n            { 0, 1, 2 },\n\n            { 0, 1, 3 },\n\n            { 0, 2, 0 },\n\n            { 0, 2, 1 },\n\n            { 0, 2, 2 },\n\n            { 0, 2, 3 },\n\n            { 1, 0, 0 },\n\n            { 1, 0, 1 },\n\n            { 1, 0, 2 },\n\n            { 1, 0, 3 },\n\n            { 1, 1, 0 },\n\n            { 1, 1, 1 },\n\n            { 1, 1, 2 },\n\n            { 1, 1, 3 },\n\n            { 1, 2, 0 },\n\n            { 1, 2, 1 },\n\n            { 1, 2, 2 },\n\n            { 1, 2, 3 }\n\n        };\n\n\n\n        final int totalSize = c.getSize();\n\n        final int nDim = c.getDimension();\n\n        final MultidimensionalCounter.Iterator iter = c.iterator();\n\n        for (int i = 0; i < totalSize; i++) {\n\n            if (!iter.hasNext()) {\n\n                Assert.fail(\"Too short\");\n\n            }\n\n            final int uniDimIndex = iter.next();\n\n            Assert.assertEquals(\"Wrong iteration at \" + i, i, uniDimIndex);\n\n\n\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n\n                                    expected[i][dimIndex], iter.getCount(dimIndex));\n\n            }\n\n\n\n            Assert.assertEquals(\"Wrong unidimensional index for [\" + i + \"]\",\n\n                                c.getCount(expected[i]), uniDimIndex);\n\n\n\n            final int[] indices = c.getCounts(uniDimIndex);\n\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n\n                                    expected[i][dimIndex], indices[dimIndex]);\n\n            }\n\n        }\n\n\n\n        if (iter.hasNext()) {\n\n            Assert.fail(\"Too long\");\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-57": {
    "id": "Math-57",
    "project": "Math",
    "number": "57",
    "buggy_function": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n    // Choose one center uniformly at random from among the data points.\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        // For each data point x, compute D(x), the distance between x and\n        // the nearest center that has already been chosen.\n        int sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n\n        // Add one new data point as a center. Each point x is chosen with\n        // probability proportional to D(x)2\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n\n    return resultSet;\n\n}",
    "fixed_function": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n    // Choose one center uniformly at random from among the data points.\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        // For each data point x, compute D(x), the distance between x and\n        // the nearest center that has already been chosen.\n        double sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n\n        // Add one new data point as a center. Each point x is chosen with\n        // probability proportional to D(x)2\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n\n    return resultSet;\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
      "first_line": 161,
      "last_line": 198
    },
    "javadoc": "/**\n* Use K-means++ to choose the initial centers.\n*\n* @param <T> type of the points to cluster\n* @param points the points to choose the initial centers from\n* @param k the number of centers to choose\n* @param random random generator to use\n* @return the initial centers\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testSmallDistances": {
        "source": "     * A helper class for testSmallDistances(). This class is similar to EuclideanIntegerPoint, but\n\n     * it defines a different distanceFrom() method that tends to return distances less than 1.\n\n     */\n\n    private class CloseIntegerPoint implements Clusterable<CloseIntegerPoint> {\n\n        public CloseIntegerPoint(EuclideanIntegerPoint point) {\n\n            euclideanPoint = point;\n\n        }\n\n\n\n        public double distanceFrom(CloseIntegerPoint p) {\n\n            return euclideanPoint.distanceFrom(p.euclideanPoint) * 0.001;\n\n        }\n\n\n\n        public CloseIntegerPoint centroidOf(Collection<CloseIntegerPoint> p) {\n\n            Collection<EuclideanIntegerPoint> euclideanPoints =\n\n                new ArrayList<EuclideanIntegerPoint>();\n\n            for (CloseIntegerPoint point : p) {\n\n                euclideanPoints.add(point.euclideanPoint);\n\n            }\n\n            return new CloseIntegerPoint(euclideanPoint.centroidOf(euclideanPoints));\n\n        }\n\n\n\n        @Override\n\n        public boolean equals(Object o) {\n\n            if (!(o instanceof CloseIntegerPoint)) {\n\n                return false;\n\n            }\n\n            CloseIntegerPoint p = (CloseIntegerPoint) o;\n\n\n\n            return euclideanPoint.equals(p.euclideanPoint);\n\n        }\n\n\n\n        @Override\n\n        public int hashCode() {\n\n            return euclideanPoint.hashCode();\n\n        }\n\n\n\n        private EuclideanIntegerPoint euclideanPoint;\n\n    }\n\n    public void testSmallDistances() {\n\n        // Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a\n\n        // small distance.\n\n        int[] repeatedArray = { 0 };\n\n        int[] uniqueArray = { 1 };\n\n        CloseIntegerPoint repeatedPoint =\n\n            new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));\n\n        CloseIntegerPoint uniquePoint =\n\n            new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));\n\n\n\n        Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();\n\n        final int NUM_REPEATED_POINTS = 10 * 1000;\n\n        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\n\n            points.add(repeatedPoint);\n\n        }\n\n        points.add(uniquePoint);\n\n\n\n        // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\n\n        // cluster centers).\n\n        final long RANDOM_SEED = 0;\n\n        final int NUM_CLUSTERS = 2;\n\n        final int NUM_ITERATIONS = 0;\n\n        KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =\n\n            new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));\n\n        List<Cluster<CloseIntegerPoint>> clusters =\n\n            clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);\n\n\n\n        // Check that one of the chosen centers is the unique point.\n\n        boolean uniquePointIsCenter = false;\n\n        for (Cluster<CloseIntegerPoint> cluster : clusters) {\n\n            if (cluster.getCenter().equals(uniquePoint)) {\n\n                uniquePointIsCenter = true;\n\n            }\n\n        }\n\n        assertTrue(uniquePointIsCenter);\n\n    }\n"
      }
    }
  },
  "Math-58": {
    "id": "Math-58",
    "project": "Math",
    "number": "58",
    "buggy_function": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(), guess);\n}",
    "fixed_function": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(guess);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java",
      "first_line": 119,
      "last_line": 122
    },
    "javadoc": "/**\n* Fits a Gaussian function to the observed points.\n*\n* @return the parameters of the Gaussian function that best fits the\n* observed points (in the same order as above).\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.fitting.GaussianFitterTest::testMath519": {
        "source": "    public void testMath519() {\n\n        // The optimizer will try negative sigma values but \"GaussianFitter\"\n\n        // will catch the raised exceptions and return NaN values instead.\n\n\n\n        final double[] data = { \n\n            1.1143831578403364E-29,\n\n            4.95281403484594E-28,\n\n            1.1171347211930288E-26,\n\n            1.7044813962636277E-25,\n\n            1.9784716574832164E-24,\n\n            1.8630236407866774E-23,\n\n            1.4820532905097742E-22,\n\n            1.0241963854632831E-21,\n\n            6.275077366673128E-21,\n\n            3.461808994532493E-20,\n\n            1.7407124684715706E-19,\n\n            8.056687953553974E-19,\n\n            3.460193945992071E-18,\n\n            1.3883326374011525E-17,\n\n            5.233894983671116E-17,\n\n            1.8630791465263745E-16,\n\n            6.288759227922111E-16,\n\n            2.0204433920597856E-15,\n\n            6.198768938576155E-15,\n\n            1.821419346860626E-14,\n\n            5.139176445538471E-14,\n\n            1.3956427429045787E-13,\n\n            3.655705706448139E-13,\n\n            9.253753324779779E-13,\n\n            2.267636001476696E-12,\n\n            5.3880460095836855E-12,\n\n            1.2431632654852931E-11\n\n        };\n\n\n\n        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n\n        for (int i = 0; i < data.length; i++) {\n\n            fitter.addObservedPoint(i, data[i]);\n\n        }\n\n        final double[] p = fitter.fit();\n\n\n\n        Assert.assertEquals(53.1572792, p[1], 1e-7);\n\n        Assert.assertEquals(5.75214622, p[2], 1e-8);\n\n    }\n"
      }
    }
  },
  "Math-59": {
    "id": "Math-59",
    "project": "Math",
    "number": "59",
    "buggy_function": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}",
    "fixed_function": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/util/FastMath.java",
      "first_line": 3481,
      "last_line": 3483
    },
    "javadoc": "/** Compute the maximum of two values\n* @param a first value\n* @param b second value\n* @return b if a is lesser or equal to b, a otherwise\n*/",
    "failing_tests": {
      "org.apache.commons.math.util.FastMathTest::testMinMaxFloat": {
        "source": "    public void testMinMaxFloat() {\n\n        float[][] pairs = {\n\n            { -50.0f, 50.0f },\n\n            {  Float.POSITIVE_INFINITY, 1.0f },\n\n            {  Float.NEGATIVE_INFINITY, 1.0f },\n\n            {  Float.NaN, 1.0f },\n\n            {  Float.POSITIVE_INFINITY, 0.0f },\n\n            {  Float.NEGATIVE_INFINITY, 0.0f },\n\n            {  Float.NaN, 0.0f },\n\n            {  Float.NaN, Float.NEGATIVE_INFINITY },\n\n            {  Float.NaN, Float.POSITIVE_INFINITY }\n\n        };\n\n        for (float[] pair : pairs) {\n\n            Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n\n                                Math.min(pair[0], pair[1]),\n\n                                FastMath.min(pair[0], pair[1]),\n\n                                MathUtils.EPSILON);\n\n            Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n\n                                Math.min(pair[1], pair[0]),\n\n                                FastMath.min(pair[1], pair[0]),\n\n                                MathUtils.EPSILON);\n\n            Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n\n                                Math.max(pair[0], pair[1]),\n\n                                FastMath.max(pair[0], pair[1]),\n\n                                MathUtils.EPSILON);\n\n            Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n\n                                Math.max(pair[1], pair[0]),\n\n                                FastMath.max(pair[1], pair[0]),\n\n                                MathUtils.EPSILON);\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-60": {
    "id": "Math-60",
    "project": "Math",
    "number": "60",
    "buggy_function": "public double cumulativeProbability(double x) throws MathException {\n    final double dev = x - mean;\n    try {\n    return 0.5 * (1.0 + Erf.erf((dev) /\n                (standardDeviation * FastMath.sqrt(2.0))));\n    } catch (MaxIterationsExceededException ex) {\n        if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n            return 0;\n        } else if (x > (mean + 20 * standardDeviation)) {\n            return 1;\n        } else {\n            throw ex;\n        }\n    }\n}",
    "fixed_function": "public double cumulativeProbability(double x) throws MathException {\n    final double dev = x - mean;\n    if (FastMath.abs(dev) > 40 * standardDeviation) { \n        return dev < 0 ? 0.0d : 1.0d;\n    }\n    return 0.5 * (1.0 + Erf.erf((dev) /\n                (standardDeviation * FastMath.sqrt(2.0))));\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java",
      "first_line": 124,
      "last_line": 138
    },
    "javadoc": "/**\n* For this distribution, {@code X}, this method returns {@code P(X < x)}.\n* If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n* as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n*\n* @param x Value at which the CDF is evaluated.\n* @return CDF evaluated at {@code x}.\n* @throws MathException if the algorithm fails to converge\n*/",
    "failing_tests": {
      "org.apache.commons.math.distribution.NormalDistributionTest::testExtremeValues": {
        "source": "    public void testExtremeValues() throws Exception {\n\n        NormalDistribution distribution = new NormalDistributionImpl(0, 1);\n\n        for (int i = 0; i < 100; i++) { // make sure no convergence exception\n\n            double lowerTail = distribution.cumulativeProbability(-i);\n\n            double upperTail = distribution.cumulativeProbability(i);\n\n            if (i < 9) { // make sure not top-coded \n\n                // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned\n\n                // TODO: once MATH-364 is resolved, replace 9 with 30\n\n                assertTrue(lowerTail > 0.0d);\n\n                assertTrue(upperTail < 1.0d);\n\n            }\n\n            else { // make sure top coding not reversed\n\n                assertTrue(lowerTail < 0.00001);\n\n                assertTrue(upperTail > 0.99999);\n\n            }\n\n        }\n\n        \n\n        assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n\n        assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n\n        assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n\n        assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n\n        \n\n   }\n"
      }
    }
  },
  "Math-63": {
    "id": "Math-63",
    "project": "Math",
    "number": "63",
    "buggy_function": "public static boolean equals(double x, double y) {\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n}",
    "fixed_function": "public static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "first_line": 416,
      "last_line": 418
    },
    "javadoc": "/**\n* Returns true iff they are equal as defined by\n* {@link #equals(double,double,int) equals(x, y, 1)}.\n*\n* @param x first value\n* @param y second value\n* @return {@code true} if the values are equal.\n*/",
    "failing_tests": {
      "org.apache.commons.math.util.MathUtilsTest::testArrayEquals": {
        "source": "    public void testArrayEquals() {\n\n        assertFalse(MathUtils.equals(new double[] { 1d }, null));\n\n        assertFalse(MathUtils.equals(null, new double[] { 1d }));\n\n        assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n\n\n\n        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n\n        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n\n        assertTrue(MathUtils.equals(new double[] {\n\n                                      Double.POSITIVE_INFINITY,\n\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n\n                                    }, new double[] {\n\n                                      Double.POSITIVE_INFINITY,\n\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n\n                                    }));\n\n        assertFalse(MathUtils.equals(new double[] { Double.NaN },\n\n                                     new double[] { Double.NaN }));\n\n        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n\n                                     new double[] { Double.NEGATIVE_INFINITY }));\n\n        assertFalse(MathUtils.equals(new double[] { 1d },\n\n                                     new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n\n\n\n    }\n"
      }
    }
  },
  "Math-64": {
    "id": "Math-64",
    "project": "Math",
    "number": "64",
    "buggy_function": "protected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}",
    "fixed_function": "protected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] oldObj  = new double[rows];\n    double[] qtf     = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        for (int i=0;i<rows;i++) {\n            qtf[i]=residuals[i];\n        }\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(qtf);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n        \tupdateResidualsAndCost();\n        \tcurrent = new VectorialPointValuePair(point, objective);\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n            tmpVec    = objective;\n            objective = oldObj;\n            oldObj    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n                current = new VectorialPointValuePair(point, objective);\n\n                // tests for convergence.\n                if (checker != null) {\n                // we use the vectorial convergence checker\n                \tif (checker.converged(getIterations(), previous, current)) {\n                \t\treturn current;\n                \t}\n                }\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "first_line": 241,
      "last_line": 464
    },
    "javadoc": "/**\n* Set the desired threshold for QR ranking.\n* <p>\n* If the squared norm of a column vector is smaller or equal to this threshold\n* during QR decomposition, it is considered to be a zero vector and hence the\n* rank of the matrix is reduced.\n* </p>\n* @param threshold threshold for QR ranking\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson": {
        "source": "  public void testMinpackJennrichSampson() {\n\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n\n                                            64.5856498144943, 11.1517793413499,\n\n                                            new double[] {\n\n //                                            0.2578330049, 0.257829976764542\n\n                                               0.2578199266368004, 0.25782997676455244\n\n                                            }), false);\n\n  }\n"
      },
      "org.apache.commons.math.optimization.general.MinpackTest::testMinpackFreudensteinRoth": {
        "source": "  public void testMinpackFreudensteinRoth() {\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n\n                                             20.0124960961895, 6.99887517584575,\n\n                                             new double[] {\n\n                                               11.4124844654993,\n\n                                               -0.896827913731509\n\n                                             }), false);\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n\n                                             12432.833948863, 6.9988751744895,\n\n                                             new double[] {\n\n                                                11.41300466147456,\n\n                                                -0.896796038685959\n\n                                             }), false);\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n\n                                             11426454.595762, 6.99887517242903,\n\n                                             new double[] {\n\n                                                 11.412781785788564,\n\n                                                 -0.8968051074920405\n\n                                             }), false);\n\n  }\n"
      }
    }
  },
  "Math-69": {
    "id": "Math-69",
    "project": "Math",
    "number": "69",
    "buggy_function": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}",
    "fixed_function": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
      "first_line": 160,
      "last_line": 176
    },
    "javadoc": "/**\n* Returns a matrix of p-values associated with the (two-sided) null\n* hypothesis that the corresponding correlation coefficient is zero.\n* <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n* that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n* a value with absolute value greater than or equal to <br>\n* <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n* <p>The values in the matrix are sometimes referred to as the\n* <i>significance</i> of the corresponding correlation coefficients.</p>\n*\n* @return matrix of p-values\n* @throws MathException if an error occurs estimating probabilities\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.correlation.PearsonsCorrelationTest::testPValueNearZero": {
        "source": "    public void testPValueNearZero() throws Exception {\n\n        /*\n\n         * Create a dataset that has r -> 1, p -> 0 as dimension increases.\n\n         * Prior to the fix for MATH-371, p vanished for dimension >= 14.\n\n         * Post fix, p-values diminish smoothly, vanishing at dimension = 127.\n\n         * Tested value is ~1E-303.\n\n         */\n\n        int dimension = 120; \n\n        double[][] data = new double[dimension][2];\n\n        for (int i = 0; i < dimension; i++) {\n\n            data[i][0] = i;\n\n            data[i][1] = i + 1/((double)i + 1);\n\n        }\n\n        PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);\n\n        assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);\n\n    }\n"
      },
      "org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest::testPValueNearZero": {
        "source": "    public void testPValueNearZero() throws Exception {\n\n        /*\n\n         * Create a dataset that has r -> 1, p -> 0 as dimension increases.\n\n         * Prior to the fix for MATH-371, p vanished for dimension >= 14.\n\n         * Post fix, p-values diminish smoothly, vanishing at dimension = 127.\n\n         * Tested value is ~1E-303.\n\n         */\n\n        int dimension = 120; \n\n        double[][] data = new double[dimension][2];\n\n        for (int i = 0; i < dimension; i++) {\n\n            data[i][0] = i;\n\n            data[i][1] = i + 1/((double)i + 1);\n\n        }\n\n        PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);\n\n        assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);\n\n    }\n"
      }
    }
  },
  "Math-7": {
    "id": "Math-7",
    "project": "Math",
    "number": "7",
    "buggy_function": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n\n        // initialize the events states if needed\n        if (! statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n            /** {@inheritDoc} */\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n\n        });\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n        }\n\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // get state at event time\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState().clone();\n\n            // advance all event states to current time\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                for (final EventState remaining : occuringEvents) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n                return eventT;\n            }\n\n            boolean needReset = currentEvent.reset(eventT, eventY);\n            if (needReset) {\n                // some event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute them\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n                for (final EventState remaining : occuringEvents) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n                return eventT;\n            }\n\n            // prepare handling of the remaining part of the step\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // check if the same event occurs again in the remaining part of the step\n            if (currentEvent.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(currentEvent);\n            }\n\n        }\n\n        // last part of the step, after the last event\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        // handle the remaining part of the step, after all events if any\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n\n}",
    "fixed_function": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n\n        // initialize the events states if needed\n        if (! statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n            /** {@inheritDoc} */\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n\n        });\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n        }\n\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // get state at event time\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState().clone();\n\n            // advance all event states to current time\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(eventT, eventY);\n                isLastStep = isLastStep || state.stop();\n            }\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                return eventT;\n            }\n\n            boolean needReset = false;\n            for (final EventState state : eventsStates) {\n                needReset =  needReset || state.reset(eventT, eventY);\n            }\n            if (needReset) {\n                // some event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute them\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n                return eventT;\n            }\n\n            // prepare handling of the remaining part of the step\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // check if the same event occurs again in the remaining part of the step\n            if (currentEvent.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(currentEvent);\n            }\n\n        }\n\n        // last part of the step, after the last event\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        // handle the remaining part of the step, after all events if any\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java",
      "first_line": 296,
      "last_line": 405
    },
    "javadoc": "/** Accept a step, triggering events and step handlers.\n* @param interpolator step interpolator\n* @param y state vector at step end time, must be reset if an event\n* asks for resetting or if an events stops integration during the step\n* @param yDot placeholder array where to put the time derivative of the state vector\n* @param tEnd final integration time\n* @return time at end of step\n* @exception MaxCountExceededException if the interpolator throws one because\n* the number of functions evaluations is exceeded\n* @exception NoBracketingException if the location of an event cannot be bracketed\n* @exception DimensionMismatchException if arrays dimensions do not match equations settings\n* @since 2.2\n*/",
    "failing_tests": {
      "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest::testEventsScheduling": {
        "source": "  public void testEventsScheduling() {\n\n\n\n      FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n\n\n\n          public int getDimension() {\n\n              return 2;\n\n          }\n\n\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n\n              yDot[0] =  y[1];\n\n              yDot[1] = -y[0];\n\n          }\n\n\n\n      };\n\n\n\n      SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\n\n      SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n\n\n\n      FirstOrderIntegrator integ =\n\n              new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\n\n      integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\n\n      integ.addStepHandler(sinChecker);\n\n      integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\n\n      integ.addStepHandler(cosChecker);\n\n      double   t0 = 0.5;\n\n      double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\n\n      double   t  = 10.0;\n\n      double[] y  = new double[2];\n\n      integ.integrate(sincos, t0, y0, t, y);\n\n\n\n  }\n"
      }
    }
  },
  "Math-70": {
    "id": "Math-70",
    "project": "Math",
    "number": "70",
    "buggy_function": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}",
    "fixed_function": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(f, min, max);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java",
      "first_line": 70,
      "last_line": 73
    },
    "javadoc": "/**\n* Construct a solver.\n*\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.BisectionSolverTest::testMath369": {
        "source": "    public void testMath369() throws Exception {\n\n        UnivariateRealFunction f = new SinFunction();\n\n        UnivariateRealSolver solver = new BisectionSolver();\n\n        assertEquals(Math.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n\n    }\n"
      }
    }
  },
  "Math-72": {
    "id": "Math-72",
    "project": "Math",
    "number": "72",
    "buggy_function": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}",
    "fixed_function": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java",
      "first_line": 98,
      "last_line": 144
    },
    "javadoc": "/**\n* Find a zero in the given interval with an initial guess.\n* <p>Throws <code>IllegalArgumentException</code> if the values of the\n* function at the three points have the same sign (note that it is\n* allowed to have endpoints with the same sign if the initial point has\n* opposite sign function-wise).</p>\n*\n* @param f function to solve.\n* @param min the lower bound for the interval.\n* @param max the upper bound for the interval.\n* @param initial the start value to use (must be set to min if no\n* initial point is known).\n* @return the value where the function is zero\n* @throws MaxIterationsExceededException the maximum iteration count\n* is exceeded\n* @throws FunctionEvaluationException if an error occurs evaluating\n*  the function\n* @throws IllegalArgumentException if initial is not between min and max\n* (even if it <em>is</em> a root)\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.BrentSolverTest::testRootEndpoints": {
        "source": "    public void testRootEndpoints() throws Exception {\n\n        UnivariateRealFunction f = new SinFunction();\n\n        UnivariateRealSolver solver = new BrentSolver();\n\n\n\n        // endpoint is root\n\n        double result = solver.solve(f, Math.PI, 4);\n\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n\n\n        result = solver.solve(f, 3, Math.PI);\n\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n\n\n        result = solver.solve(f, Math.PI, 4, 3.5);\n\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n\n\n        result = solver.solve(f, 3, Math.PI, 3.07);\n\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n\n\n    }\n"
      }
    }
  },
  "Math-73": {
    "id": "Math-73",
    "project": "Math",
    "number": "73",
    "buggy_function": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}",
    "fixed_function": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java",
      "first_line": 98,
      "last_line": 140
    },
    "javadoc": "/**\n* Find a zero in the given interval with an initial guess.\n* <p>Throws <code>IllegalArgumentException</code> if the values of the\n* function at the three points have the same sign (note that it is\n* allowed to have endpoints with the same sign if the initial point has\n* opposite sign function-wise).</p>\n*\n* @param f function to solve.\n* @param min the lower bound for the interval.\n* @param max the upper bound for the interval.\n* @param initial the start value to use (must be set to min if no\n* initial point is known).\n* @return the value where the function is zero\n* @throws MaxIterationsExceededException the maximum iteration count\n* is exceeded\n* @throws FunctionEvaluationException if an error occurs evaluating\n*  the function\n* @throws IllegalArgumentException if initial is not between min and max\n* (even if it <em>is</em> a root)\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.solvers.BrentSolverTest::testBadEndpoints": {
        "source": "    public void testBadEndpoints() throws Exception {\n\n        UnivariateRealFunction f = new SinFunction();\n\n        UnivariateRealSolver solver = new BrentSolver();\n\n        try {  // bad interval\n\n            solver.solve(f, 1, -1);\n\n            fail(\"Expecting IllegalArgumentException - bad interval\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n        try {  // no bracket\n\n            solver.solve(f, 1, 1.5);\n\n            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n        try {  // no bracket\n\n            solver.solve(f, 1, 1.5, 1.2);\n\n            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n\n        } catch (IllegalArgumentException ex) {\n\n            // expected\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-74": {
    "id": "Math-74",
    "project": "Math",
    "number": "74",
    "buggy_function": "public double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart         = t0;\n  double  hNew      = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale;\n        if (vecAbsoluteTolerance == null) {\n            scale = new double[y0.length];\n            java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n          } else {\n            scale = vecAbsoluteTolerance;\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // rejecting the step would lead to a too small next step, we accept it\n                loop = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n        stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}",
    "fixed_function": "public double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart         = t0;\n  double  hNew      = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // rejecting the step would lead to a too small next step, we accept it\n                loop = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n        stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
      "first_line": 192,
      "last_line": 359
    },
    "javadoc": "/** Set the safety factor for stepsize control.\n* @param safety safety factor\n*/",
    "failing_tests": {
      "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest::polynomial": {
        "source": "    public void polynomial() throws DerivativeException, IntegratorException {\n\n        TestProblem6 pb = new TestProblem6();\n\n        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n\n\n\n        for (int nSteps = 1; nSteps < 7; ++nSteps) {\n\n            AdamsMoultonIntegrator integ =\n\n                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n\n            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n\n            integ.addStepHandler(handler);\n\n            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n\n                            pb.getFinalTime(), new double[pb.getDimension()]);\n\n            if (nSteps < 4) {\n\n                assertTrue(integ.getEvaluations() > 140);\n\n            } else {\n\n                assertTrue(integ.getEvaluations() < 90);\n\n            }\n\n        }\n\n\n\n    }\n"
      }
    }
  },
  "Math-75": {
    "id": "Math-75",
    "project": "Math",
    "number": "75",
    "buggy_function": "public double getPct(Object v) {\n    return getCumPct((Comparable<?>) v);\n}",
    "fixed_function": "public double getPct(Object v) {\n    return getPct((Comparable<?>) v);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/stat/Frequency.java",
      "first_line": 302,
      "last_line": 304
    },
    "javadoc": "/**\n* Returns the percentage of values that are equal to v\n* (as a proportion between 0 and 1).\n* <p>\n* Returns <code>Double.NaN</code> if no values have been added.</p>\n*\n* @param v the value to lookup\n* @return the proportion of values equal to v\n* @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.FrequencyTest::testPcts": {
        "source": "    public void testPcts() {\n\n        f.addValue(oneL);\n\n        f.addValue(twoL);\n\n        f.addValue(oneI);\n\n        f.addValue(twoI);\n\n        f.addValue(threeL);\n\n        f.addValue(threeL);\n\n        f.addValue(3);\n\n        f.addValue(threeI);\n\n        assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n\n        assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n\n        assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n\n        // MATH-329\n\n        assertEquals(\"three (Object) pct\",0.5,f.getPct((Object) (Integer.valueOf(3))),tolerance);\n\n        assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n\n        assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n\n        assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n\n        assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n\n        assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n\n        assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n\n        assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n\n        assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n\n        assertEquals(\"foo cum pct\",0,f.getCumPct(\"foo\"),tolerance);\n\n    }\n"
      }
    }
  },
  "Math-78": {
    "id": "Math-78",
    "project": "Math",
    "number": "78",
    "buggy_function": "public boolean evaluateStep(final StepInterpolator interpolator)\n    throws DerivativeException, EventException, ConvergenceException {\n\n    try {\n\n        forward = interpolator.isForward();\n        final double t1 = interpolator.getCurrentTime();\n        final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n        final double h  = (t1 - t0) / n;\n\n        double ta = t0;\n        double ga = g0;\n        double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n        for (int i = 0; i < n; ++i) {\n\n            // evaluate handler value at the end of the substep\n            tb += h;\n            interpolator.setInterpolatedTime(tb);\n            final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n            // check events occurrence\n            if (g0Positive ^ (gb >= 0)) {\n                // there is a sign change: an event is expected during this step\n\n                    // this is a corner case:\n                    // - there was an event near ta,\n                    // - there is another event between ta and tb\n                    // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                    // this implies that the real sign of ga is the same as gb, so we need to slightly\n                    // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                    // about bracketing\n                        // this should never happen\n                     \n                // variation direction, with respect to the integration direction\n                increasing = gb >= ga;\n\n                final UnivariateRealFunction f = new UnivariateRealFunction() {\n                    public double value(final double t) throws FunctionEvaluationException {\n                        try {\n                            interpolator.setInterpolatedTime(t);\n                            return handler.g(t, interpolator.getInterpolatedState());\n                        } catch (DerivativeException e) {\n                            throw new FunctionEvaluationException(e, t);\n                        } catch (EventException e) {\n                            throw new FunctionEvaluationException(e, t);\n                        }\n                    }\n                };\n                final BrentSolver solver = new BrentSolver();\n                solver.setAbsoluteAccuracy(convergence);\n                solver.setMaximalIterationCount(maxIterationCount);\n                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                if ((Math.abs(root - ta) <= convergence) &&\n                     (Math.abs(root - previousEventTime) <= convergence)) {\n                    // we have either found nothing or found (again ?) a past event, we simply ignore it\n                    ta = tb;\n                    ga = gb;\n                } else if (Double.isNaN(previousEventTime) ||\n                           (Math.abs(previousEventTime - root) > convergence)) {\n                    pendingEventTime = root;\n                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                        // we were already waiting for this event which was\n                        // found during a previous call for a step that was\n                        // rejected, this step must now be accepted since it\n                        // properly ends exactly at the event occurrence\n                        return false;\n                    }\n                    // either we were not waiting for the event or it has\n                    // moved in such a way the step cannot be accepted\n                    pendingEvent = true;\n                    return true;\n                }\n\n            } else {\n                // no sign change: there is no event for now\n                ta = tb;\n                ga = gb;\n            }\n\n        }\n\n        // no event during the whole step\n        pendingEvent     = false;\n        pendingEventTime = Double.NaN;\n        return false;\n\n    } catch (FunctionEvaluationException e) {\n        final Throwable cause = e.getCause();\n        if ((cause != null) && (cause instanceof DerivativeException)) {\n            throw (DerivativeException) cause;\n        } else if ((cause != null) && (cause instanceof EventException)) {\n            throw (EventException) cause;\n        }\n        throw new EventException(e);\n    }\n\n}",
    "fixed_function": "public boolean evaluateStep(final StepInterpolator interpolator)\n    throws DerivativeException, EventException, ConvergenceException {\n\n    try {\n\n        forward = interpolator.isForward();\n        final double t1 = interpolator.getCurrentTime();\n        final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n        final double h  = (t1 - t0) / n;\n\n        double ta = t0;\n        double ga = g0;\n        double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n        for (int i = 0; i < n; ++i) {\n\n            // evaluate handler value at the end of the substep\n            tb += h;\n            interpolator.setInterpolatedTime(tb);\n            final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n            // check events occurrence\n            if (g0Positive ^ (gb >= 0)) {\n                // there is a sign change: an event is expected during this step\n\n                if (ga * gb > 0) {\n                    // this is a corner case:\n                    // - there was an event near ta,\n                    // - there is another event between ta and tb\n                    // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                    // this implies that the real sign of ga is the same as gb, so we need to slightly\n                    // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                    // about bracketing\n                    final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                    for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                        ta += epsilon;\n                        interpolator.setInterpolatedTime(ta);\n                        ga = handler.g(ta, interpolator.getInterpolatedState());\n                    }\n                    if (ga * gb > 0) {\n                        // this should never happen\n                        throw MathRuntimeException.createInternalError(null);\n                    }\n                }\n                     \n                // variation direction, with respect to the integration direction\n                increasing = gb >= ga;\n\n                final UnivariateRealFunction f = new UnivariateRealFunction() {\n                    public double value(final double t) throws FunctionEvaluationException {\n                        try {\n                            interpolator.setInterpolatedTime(t);\n                            return handler.g(t, interpolator.getInterpolatedState());\n                        } catch (DerivativeException e) {\n                            throw new FunctionEvaluationException(e, t);\n                        } catch (EventException e) {\n                            throw new FunctionEvaluationException(e, t);\n                        }\n                    }\n                };\n                final BrentSolver solver = new BrentSolver();\n                solver.setAbsoluteAccuracy(convergence);\n                solver.setMaximalIterationCount(maxIterationCount);\n                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                if ((Math.abs(root - ta) <= convergence) &&\n                     (Math.abs(root - previousEventTime) <= convergence)) {\n                    // we have either found nothing or found (again ?) a past event, we simply ignore it\n                    ta = tb;\n                    ga = gb;\n                } else if (Double.isNaN(previousEventTime) ||\n                           (Math.abs(previousEventTime - root) > convergence)) {\n                    pendingEventTime = root;\n                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                        // we were already waiting for this event which was\n                        // found during a previous call for a step that was\n                        // rejected, this step must now be accepted since it\n                        // properly ends exactly at the event occurrence\n                        return false;\n                    }\n                    // either we were not waiting for the event or it has\n                    // moved in such a way the step cannot be accepted\n                    pendingEvent = true;\n                    return true;\n                }\n\n            } else {\n                // no sign change: there is no event for now\n                ta = tb;\n                ga = gb;\n            }\n\n        }\n\n        // no event during the whole step\n        pendingEvent     = false;\n        pendingEventTime = Double.NaN;\n        return false;\n\n    } catch (FunctionEvaluationException e) {\n        final Throwable cause = e.getCause();\n        if ((cause != null) && (cause instanceof DerivativeException)) {\n            throw (DerivativeException) cause;\n        } else if ((cause != null) && (cause instanceof EventException)) {\n            throw (EventException) cause;\n        }\n        throw new EventException(e);\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
      "first_line": 167,
      "last_line": 263
    },
    "javadoc": "/** Evaluate the impact of the proposed step on the event handler.\n* @param interpolator step interpolator for the proposed step\n* @return true if the event handler triggers an event before\n* the end of the proposed step (this implies the step should be\n* rejected)\n* @exception DerivativeException if the interpolator fails to\n* compute the switching function somewhere within the step\n* @exception EventException if the switching function\n* cannot be evaluated\n* @exception ConvergenceException if an event cannot be located\n*/",
    "failing_tests": {
      "org.apache.commons.math.ode.events.EventStateTest::closeEvents": {
        "source": "    public void closeEvents()\n\n        throws EventException, ConvergenceException, DerivativeException {\n\n\n\n        final double r1  = 90.0;\n\n        final double r2  = 135.0;\n\n        final double gap = r2 - r1;\n\n        EventHandler closeEventsGenerator = new EventHandler() {\n\n            public void resetState(double t, double[] y) {\n\n            }\n\n            public double g(double t, double[] y) {\n\n                return (t - r1) * (r2 - t);\n\n            }\n\n            public int eventOccurred(double t, double[] y, boolean increasing) {\n\n                return CONTINUE;\n\n            }\n\n        };\n\n\n\n        final double tolerance = 0.1;\n\n        EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);\n\n\n\n        double t0 = r1 - 0.5 * gap;\n\n        es.reinitializeBegin(t0, new double[0]);\n\n        AbstractStepInterpolator interpolator =\n\n            new DummyStepInterpolator(new double[0], true);\n\n        interpolator.storeTime(t0);\n\n\n\n        interpolator.shift();\n\n        interpolator.storeTime(0.5 * (r1 + r2));\n\n        Assert.assertTrue(es.evaluateStep(interpolator));\n\n        Assert.assertEquals(r1, es.getEventTime(), tolerance);\n\n        es.stepAccepted(es.getEventTime(), new double[0]);\n\n\n\n        interpolator.shift();\n\n        interpolator.storeTime(r2 + 0.4 * gap);\n\n        Assert.assertTrue(es.evaluateStep(interpolator));\n\n        Assert.assertEquals(r2, es.getEventTime(), tolerance);\n\n\n\n    }\n"
      }
    }
  },
  "Math-79": {
    "id": "Math-79",
    "project": "Math",
    "number": "79",
    "buggy_function": "public static double distance(int[] p1, int[] p2) {\n  int sum = 0;\n  for (int i = 0; i < p1.length; i++) {\n      final int dp = p1[i] - p2[i];\n      sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n}",
    "fixed_function": "public static double distance(int[] p1, int[] p2) {\n  double sum = 0;\n  for (int i = 0; i < p1.length; i++) {\n      final double dp = p1[i] - p2[i];\n      sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "first_line": 1623,
      "last_line": 1630
    },
    "javadoc": "/**\n* Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n*\n* @param p1 the first point\n* @param p2 the second point\n* @return the L<sub>2</sub> distance between the two points\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate": {
        "source": "    public void testPerformClusterAnalysisDegenerate() {\n\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n\n                new Random(1746432956321l));\n\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n\n        assertEquals(1, clusters.size());\n\n        assertEquals(2, (clusters.get(0).getPoints().size()));\n\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n\n        assertTrue(clusters.get(0).getPoints().contains(pt1));\n\n        assertTrue(clusters.get(0).getPoints().contains(pt2));\n\n\n\n    } \n"
      }
    }
  },
  "Math-8": {
    "id": "Math-8",
    "project": "Math",
    "number": "8",
    "buggy_function": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n    if (sampleSize <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                sampleSize);\n    }\n\n    final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n    for (int i = 0; i < sampleSize; i++) {\n        out[i] = sample();\n    }\n\n    return out;\n\n}",
    "fixed_function": "public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n    if (sampleSize <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                sampleSize);\n    }\n\n    final Object[] out = new Object[sampleSize];\n\n    for (int i = 0; i < sampleSize; i++) {\n        out[i] = sample();\n    }\n\n    return out;\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java",
      "first_line": 181,
      "last_line": 195
    },
    "javadoc": "/**\n* Generate a random sample from the distribution.\n*\n* @param sampleSize the number of random values to generate.\n* @return an array representing the random sample.\n* @throws NotStrictlyPositiveException if {@code sampleSize} is not\n* positive.\n*/",
    "failing_tests": {
      "org.apache.commons.math3.distribution.DiscreteRealDistributionTest::testIssue942": {
        "source": "    public void testIssue942() {\n\n        List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>();\n\n        list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));\n\n        list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));\n\n        Assert.assertEquals(1, new DiscreteDistribution<Object>(list).sample(1).length);\n\n    }\n"
      }
    }
  },
  "Math-80": {
    "id": "Math-80",
    "project": "Math",
    "number": "80",
    "buggy_function": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        int j = 4 * n - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
    "fixed_function": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        int j = 4 * (n - 1);\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
      "first_line": 1132,
      "last_line": 1147
    },
    "javadoc": "/**\n* Flip qd array if warranted.\n* @param n number of rows in the block\n* @param step within the array (1 for flipping all elements, 2 for flipping\n* only every other element)\n* @return true if qd array was flipped\n*/",
    "failing_tests": {
      "org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02": {
        "source": "    public void testMathpbx02() {\n\n\n\n        double[] mainTridiagonal = {\n\n        \t  7484.860960227216, 18405.28129035345, 13855.225609560746,\n\n        \t 10016.708722343366, 559.8117399576674, 6750.190788301587, \n\n        \t    71.21428769782159\n\n        };\n\n        double[] secondaryTridiagonal = {\n\n        \t -4175.088570476366,1975.7955858241994,5193.178422374075, \n\n        \t  1995.286659169179,75.34535882933804,-234.0808002076056\n\n        };\n\n\n\n        // the reference values have been computed using routine DSTEMR\n\n        // from the fortran library LAPACK version 3.2.1\n\n        double[] refEigenValues = {\n\n        \t\t20654.744890306974412,16828.208208485466457,\n\n        \t\t6893.155912634994820,6757.083016675340332,\n\n        \t\t5887.799885688558788,64.309089923240379,\n\n        \t\t57.992628792736340\n\n        };\n\n        RealVector[] refEigenVectors = {\n\n        \t\tnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n\n        \t\tnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n\n        \t\tnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n\n        \t\tnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n\n        \t\tnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n\n        \t\tnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n\n        \t\tnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n\n        };\n\n\n\n        // the following line triggers the exception\n\n        EigenDecomposition decomposition =\n\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n\n        for (int i = 0; i < refEigenValues.length; ++i) {\n\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n\n            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n\n                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n\n            } else {\n\n                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n\n            }\n\n        }\n\n\n\n    }\n"
      }
    }
  },
  "Math-82": {
    "id": "Math-82",
    "project": "Math",
    "number": "82",
    "buggy_function": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i; \n            }\n        }\n    }\n    return minRatioPos;\n}",
    "fixed_function": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i; \n            }\n        }\n    }\n    return minRatioPos;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java",
      "first_line": 76,
      "last_line": 91
    },
    "javadoc": "/**\n* Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n* @param tableau simple tableau for the problem\n* @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n* @return row with the minimum ratio\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath288": {
        "source": "    public void testMath288() throws OptimizationException {\n\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );\n\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));\n\n        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));\n\n        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));\n\n        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));\n\n        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));\n\n\n\n        SimplexSolver solver = new SimplexSolver();\n\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n\n        assertEquals(10.0, solution.getValue(), .0000001);\n\n    }\n"
      }
    }
  },
  "Math-84": {
    "id": "Math-84",
    "project": "Math",
    "number": "84",
    "buggy_function": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    while (true) {\n\n        incrementIterationsCounter();\n\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // accept the reflected simplex\n                simplex = reflectedSimplex;\n            }\n\n            return;\n\n        }\n\n        // compute the contracted simplex\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n            // accept the contracted simplex\n\n        // check convergence\n            return;\n        }\n\n    }\n\n}",
    "fixed_function": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    final RealConvergenceChecker checker = getConvergenceChecker();\n    while (true) {\n\n        incrementIterationsCounter();\n\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // accept the reflected simplex\n                simplex = reflectedSimplex;\n            }\n\n            return;\n\n        }\n\n        // compute the contracted simplex\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n            // accept the contracted simplex\n            return;\n        }\n\n        // check convergence\n        final int iter = getIterations();\n        boolean converged = true;\n        for (int i = 0; i < simplex.length; ++i) {\n            converged &= checker.converged(iter, original[i], simplex[i]);\n        }\n        if (converged) {\n            return;\n        }\n\n    }\n\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java",
      "first_line": 61,
      "last_line": 99
    },
    "javadoc": "/** Build a multi-directional optimizer with specified coefficients.\n* @param khi expansion coefficient\n* @param gamma contraction coefficient\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize": {
        "source": "  public void testMinimizeMaximize()\n\n      throws FunctionEvaluationException, ConvergenceException {\n\n\n\n      // the following function has 4 local extrema:\n\n      final double xM        = -3.841947088256863675365;\n\n      final double yM        = -1.391745200270734924416;\n\n      final double xP        =  0.2286682237349059125691;\n\n      final double yP        = -yM;\n\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n\n      final double valueXmYp = -valueXmYm;                // local  minimum\n\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n\n      final double valueXpYp = -valueXpYm;                // global maximum\n\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n\n          private static final long serialVersionUID = -7039124064449091152L;\n\n          public double value(double[] variables) throws FunctionEvaluationException {\n\n              final double x = variables[0];\n\n              final double y = variables[1];\n\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n\n          }\n\n      };\n\n\n\n      MultiDirectional optimizer = new MultiDirectional();\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n\n      optimizer.setMaxIterations(200);\n\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n\n      RealPointValuePair optimum;\n\n\n\n      // minimization\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n\n      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n\n      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n\n\n      // maximization\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n\n      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n\n      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n\n      Assert.assertTrue(optimizer.getEvaluations() > 180);\n\n      Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n\n\n  }\n"
      },
      "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283": {
        "source": "  public void testMath283()\n\n      throws FunctionEvaluationException, OptimizationException {\n\n      // fails because MultiDirectional.iterateSimplex is looping forever\n\n      // the while(true) should be replaced with a convergence check\n\n      MultiDirectional multiDirectional = new MultiDirectional();\n\n      multiDirectional.setMaxIterations(100);\n\n      multiDirectional.setMaxEvaluations(1000);\n\n\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n\n\n      final double EPSILON = 1e-5;\n\n\n\n      final double expectedMaximum = function.getMaximum();\n\n      final double actualMaximum = estimate.getValue();\n\n      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);\n\n\n\n      final double[] expectedPosition = function.getMaximumPosition();\n\n      final double[] actualPosition = estimate.getPoint();\n\n      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n\n      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n\n      \n\n  }\n"
      }
    }
  },
  "Math-85": {
    "id": "Math-85",
    "project": "Math",
    "number": "85",
    "buggy_function": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    \n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        \n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n\n    if (fa * fb >= 0.0 ) {\n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n    \n    return new double[]{a, b};\n}",
    "fixed_function": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    \n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        \n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n\n    if (fa * fb > 0.0 ) {\n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n    \n    return new double[]{a, b};\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
      "first_line": 165,
      "last_line": 208
    },
    "javadoc": "/**\n* This method attempts to find two values a and b satisfying <ul>\n* <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n* <li> <code> f(a) * f(b) <= 0 </code> </li>\n* </ul>\n* If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n* and <code>b</code> bracket a root of f.\n* <p>\n* The algorithm starts by setting\n* <code>a := initial -1; b := initial +1,</code> examines the value of the\n* function at <code>a</code> and <code>b</code> and keeps moving\n* the endpoints out by one unit each time through a loop that terminates\n* when one of the following happens: <ul>\n* <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n* <li> <code> a = lower </code> and <code> b = upper</code>\n* -- ConvergenceException </li>\n* <li> <code> maximumIterations</code> iterations elapse\n* -- ConvergenceException </li></ul></p>\n*\n* @param function the function\n* @param initial initial midpoint of interval being expanded to\n* bracket a root\n* @param lowerBound lower bound (a is never lower than this value)\n* @param upperBound upper bound (b never is greater than this\n* value)\n* @param maximumIterations maximum number of iterations to perform\n* @return a two element array holding {a, b}.\n* @throws ConvergenceException if the algorithm fails to find a and b\n* satisfying the desired conditions\n* @throws FunctionEvaluationException if an error occurs evaluating the\n* function\n* @throws IllegalArgumentException if function is null, maximumIterations\n* is not positive, or initial is not between lowerBound and upperBound\n*/",
    "failing_tests": {
      "org.apache.commons.math.distribution.NormalDistributionTest::testMath280": {
        "source": "    public void testMath280() throws MathException {\n\n        NormalDistribution normal = new NormalDistributionImpl(0,1);\n\n        double result = normal.inverseCumulativeProbability(0.9772498680518209);\n\n        assertEquals(2.0, result, 1.0e-12);\n\n    }\n"
      }
    }
  },
  "Math-86": {
    "id": "Math-86",
    "project": "Math",
    "number": "86",
    "buggy_function": "public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                 final double relativeSymmetryThreshold,\n                                 final double absolutePositivityThreshold)\n    throws NonSquareMatrixException,\n           NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                           matrix.getColumnDimension());\n    }\n\n    final int order = matrix.getRowDimension();\n    lTData   = matrix.getData();\n    cachedL  = null;\n    cachedLT = null;\n\n    // check the matrix before transformation\n    for (int i = 0; i < order; ++i) {\n\n        final double[] lI = lTData[i];\n\n        if (lTData[i][i] < absolutePositivityThreshold) {\n            throw new NotPositiveDefiniteMatrixException();\n        }\n        // check off-diagonal elements (and reset them to 0)\n        for (int j = i + 1; j < order; ++j) {\n            final double[] lJ = lTData[j];\n            final double lIJ = lI[j];\n            final double lJI = lJ[i];\n            final double maxDelta =\n                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n            if (Math.abs(lIJ - lJI) > maxDelta) {\n                throw new NotSymmetricMatrixException();\n            }\n            lJ[i] = 0;\n       }\n    }\n\n    // transform the matrix\n    for (int i = 0; i < order; ++i) {\n\n        final double[] ltI = lTData[i];\n\n        // check diagonal element\n\n        ltI[i] = Math.sqrt(ltI[i]);\n        final double inverse = 1.0 / ltI[i];\n\n        for (int q = order - 1; q > i; --q) {\n            ltI[q] *= inverse;\n            final double[] ltQ = lTData[q];\n            for (int p = q; p < order; ++p) {\n                ltQ[p] -= ltI[q] * ltI[p];\n            }\n        }\n\n    }\n\n}",
    "fixed_function": "public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                 final double relativeSymmetryThreshold,\n                                 final double absolutePositivityThreshold)\n    throws NonSquareMatrixException,\n           NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                           matrix.getColumnDimension());\n    }\n\n    final int order = matrix.getRowDimension();\n    lTData   = matrix.getData();\n    cachedL  = null;\n    cachedLT = null;\n\n    // check the matrix before transformation\n    for (int i = 0; i < order; ++i) {\n\n        final double[] lI = lTData[i];\n\n        // check off-diagonal elements (and reset them to 0)\n        for (int j = i + 1; j < order; ++j) {\n            final double[] lJ = lTData[j];\n            final double lIJ = lI[j];\n            final double lJI = lJ[i];\n            final double maxDelta =\n                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n            if (Math.abs(lIJ - lJI) > maxDelta) {\n                throw new NotSymmetricMatrixException();\n            }\n            lJ[i] = 0;\n       }\n    }\n\n    // transform the matrix\n    for (int i = 0; i < order; ++i) {\n\n        final double[] ltI = lTData[i];\n\n        // check diagonal element\n        if (ltI[i] < absolutePositivityThreshold) {\n            throw new NotPositiveDefiniteMatrixException();\n        }\n\n        ltI[i] = Math.sqrt(ltI[i]);\n        final double inverse = 1.0 / ltI[i];\n\n        for (int q = order - 1; q > i; --q) {\n            ltI[q] *= inverse;\n            final double[] ltQ = lTData[q];\n            for (int p = q; p < order; ++p) {\n                ltQ[p] -= ltI[q] * ltI[p];\n            }\n        }\n\n    }\n\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java",
      "first_line": 93,
      "last_line": 151
    },
    "javadoc": "/**\n* Calculates the Cholesky decomposition of the given matrix.\n* @param matrix the matrix to decompose\n* @param relativeSymmetryThreshold threshold above which off-diagonal\n* elements are considered too different and matrix not symmetric\n* @param absolutePositivityThreshold threshold below which diagonal\n* elements are considered null and matrix not positive definite\n* @exception NonSquareMatrixException if matrix is not square\n* @exception NotSymmetricMatrixException if matrix is not symmetric\n* @exception NotPositiveDefiniteMatrixException if the matrix is not\n* strictly positive definite\n* @see #CholeskyDecompositionImpl(RealMatrix)\n* @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n* @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n*/",
    "failing_tests": {
      "org.apache.commons.math.linear.CholeskyDecompositionImplTest::testMath274": {
        "source": "    public void testMath274() throws MathException {\n\n        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n\n                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n\n                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n\n                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n\n                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n\n            \n\n        }));\n\n    }\n"
      },
      "org.apache.commons.math.linear.CholeskyDecompositionImplTest::testNotPositiveDefinite": {
        "source": "    public void testNotPositiveDefinite() throws MathException {\n\n        CholeskyDecomposition cd = new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n\n                { 14, 11, 13, 15, 24 },\n\n                { 11, 34, 13, 8,  25 },\n\n                { 13, 13, 14, 15, 21 },\n\n                { 15, 8,  15, 18, 23 },\n\n                { 24, 25, 21, 23, 45 }\n\n        }));\n\n        System.out.println(cd.getL().multiply(cd.getLT()));\n\n    }\n"
      }
    }
  },
  "Math-87": {
    "id": "Math-87",
    "project": "Math",
    "number": "87",
    "buggy_function": "private Integer getBasicRow(final int col) {\n    Integer row = null;\n    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n        if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n            if (row == null) {\n            row = i;\n            } else {\n            return null;\n            }\n        }\n    }\n    return row;\n}",
    "fixed_function": "private Integer getBasicRow(final int col) {\n    Integer row = null;\n    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n            row = i;\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n            return null;\n        }\n    }\n    return row;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java",
      "first_line": 272,
      "last_line": 284
    },
    "javadoc": "/**\n* Checks whether the given column is basic.\n* @param col index of the column to check\n* @return the row that the variable is basic in.  null if the column is not basic\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.linear.SimplexSolverTest::testSingleVariableAndConstraint": {
        "source": "    public void testSingleVariableAndConstraint() throws OptimizationException {\n\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);\n\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));\n\n\n\n        SimplexSolver solver = new SimplexSolver();\n\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n\n        assertEquals(10.0, solution.getPoint()[0], 0.0);\n\n        assertEquals(30.0, solution.getValue(), 0.0);\n\n    }\n"
      }
    }
  },
  "Math-88": {
    "id": "Math-88",
    "project": "Math",
    "number": "88",
    "buggy_function": "protected RealPointValuePair getSolution() {\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\n    Integer basicRow =\n        getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n    for (int i = 0; i < coefficients.length; i++) {\n        basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            // if multiple variables can take a given value \n            // then we choose the first and set the rest equal to 0\n            coefficients[i] =\n                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                (restrictToNonNegative ? 0 : mostNegative);\n        if (basicRow != null) {\n            for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                if (tableau.getEntry(basicRow, j) == 1) {\n                     coefficients[i] = 0;\n                }\n            }\n        }\n    }\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}",
    "fixed_function": "protected RealPointValuePair getSolution() {\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\n    Integer basicRow =\n        getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n    Set<Integer> basicRows = new HashSet<Integer>();\n    for (int i = 0; i < coefficients.length; i++) {\n        basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n        if (basicRows.contains(basicRow)) {\n            // if multiple variables can take a given value \n            // then we choose the first and set the rest equal to 0\n            coefficients[i] = 0;\n        } else {\n            basicRows.add(basicRow);\n            coefficients[i] =\n                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                (restrictToNonNegative ? 0 : mostNegative);\n        }\n    }\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java",
      "first_line": 324,
      "last_line": 345
    },
    "javadoc": "/**\n* Get the current solution.\n* <p>\n* {@link #solve} should be called first for this to be the optimal solution.\n* </p>\n* @return current solution\n*/",
    "failing_tests": {
      "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath272": {
        "source": "    public void testMath272() throws OptimizationException {\n\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);\n\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));\n\n        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));\n\n        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));\n\n\n\n        SimplexSolver solver = new SimplexSolver();\n\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n\n        \n\n        assertEquals(0.0, solution.getPoint()[0], .0000001);\n\n        assertEquals(1.0, solution.getPoint()[1], .0000001);\n\n        assertEquals(1.0, solution.getPoint()[2], .0000001);\n\n        assertEquals(3.0, solution.getValue(), .0000001);\n\n      }\n"
      }
    }
  },
  "Math-89": {
    "id": "Math-89",
    "project": "Math",
    "number": "89",
    "buggy_function": "public void addValue(Object v) {\n        addValue((Comparable<?>) v);            \n}",
    "fixed_function": "public void addValue(Object v) {\n    if (v instanceof Comparable<?>){\n        addValue((Comparable<?>) v);            \n    } else {\n        throw new IllegalArgumentException(\"Object must implement Comparable\");\n    }\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/stat/Frequency.java",
      "first_line": 109,
      "last_line": 111
    },
    "javadoc": "/**\n* Adds 1 to the frequency count for v.\n* <p>\n* If other objects have already been added to this Frequency, v must\n* be comparable to those that have already been added.\n* </p>\n*\n* @param v the value to add.\n* @throws IllegalArgumentException if <code>v</code> is not Comparable,\n*         or is not comparable with previous entries\n* @deprecated use {@link #addValue(Comparable)} instead\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable": {
        "source": "    public void testAddNonComparable(){\n\n        try {\n\n            f.addValue(new Object()); // This was previously OK\n\n            fail(\"Expected IllegalArgumentException\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n        f.clear();\n\n        f.addValue(1);\n\n        try {\n\n            f.addValue(new Object());\n\n            fail(\"Expected IllegalArgumentException\");\n\n        } catch (IllegalArgumentException expected) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-9": {
    "id": "Math-9",
    "project": "Math",
    "number": "9",
    "buggy_function": "public Line revert() {\n    final Line reverted = new Line(zero, zero.subtract(direction));\n    return reverted;\n}",
    "fixed_function": "public Line revert() {\n    final Line reverted = new Line(this);\n    reverted.direction = reverted.direction.negate();\n    return reverted;\n}",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
      "first_line": 86,
      "last_line": 89
    },
    "javadoc": "/** Get a line with reversed direction.\n* @return a new instance, with reversed direction\n*/",
    "failing_tests": {
      "org.apache.commons.math3.geometry.euclidean.threed.LineTest::testRevert": {
        "source": "    public void testRevert() {\n\n        \n\n        // setup\n\n        Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000),\n\n                             new Vector3D(1650757.5050732433, 6160710.879908984, 0.9));\n\n        Vector3D expected = line.getDirection().negate();\n\n\n\n        // action\n\n        Line reverted = line.revert();\n\n\n\n        // verify\n\n        Assert.assertArrayEquals(expected.toArray(), reverted.getDirection().toArray(), 0);\n\n\n\n    }\n"
      }
    }
  },
  "Math-90": {
    "id": "Math-90",
    "project": "Math",
    "number": "90",
    "buggy_function": "public void addValue(Object v) {\n\n/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n * \n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n */\n    Object obj = v;\n    if (v instanceof Integer) {\n       obj = Long.valueOf(((Integer) v).longValue());\n    }\n    try {\n        Long count = (Long) freqTable.get(obj);\n        if (count == null) {\n            freqTable.put(obj, Long.valueOf(1));\n        } else {\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n        }\n    } catch (ClassCastException ex) {   \n        //TreeMap will throw ClassCastException if v is not comparable\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}",
    "fixed_function": "public void addValue(Object v) {\n    addValue((Comparable<?>) v);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/stat/Frequency.java",
      "first_line": 109,
      "last_line": 136
    },
    "javadoc": "/**\n* Adds 1 to the frequency count for v.\n* <p>\n* If other objects have already been added to this Frequency, v must\n* be comparable to those that have already been added.\n* </p>\n*\n* @param v the value to add.\n* @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n* @throws ClassCastException if <code>v</code> is not Comparable\n* @deprecated use {@link #addValue(Comparable)} instead\n*/",
    "failing_tests": {
      "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable": {
        "source": "    public void testAddNonComparable(){\n\n        try {\n\n            f.addValue(new Object()); // This was OK\n\n            fail(\"Expected ClassCastException\");\n\n        } catch (ClassCastException expected) {\n\n        }\n\n        f.clear();\n\n        f.addValue(1);\n\n        try {\n\n            f.addValue(new Object());\n\n            fail(\"Expected ClassCastException\"); // Previously would have been IllegalArgument\n\n        } catch (ClassCastException expected) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Math-91": {
    "id": "Math-91",
    "project": "Math",
    "number": "91",
    "buggy_function": "public int compareTo(Fraction object) {\n    double nOd = doubleValue();\n    double dOn = object.doubleValue();\n    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}",
    "fixed_function": "public int compareTo(Fraction object) {\n    long nOd = ((long) numerator) * object.denominator;\n    long dOn = ((long) denominator) * object.numerator;\n    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/fraction/Fraction.java",
      "first_line": 258,
      "last_line": 262
    },
    "javadoc": "/**\n* Compares this object to another based on size.\n* @param object the object to compare to\n* @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n*         than <tt>object</tt>, 0 if they are equal.\n*/",
    "failing_tests": {
      "org.apache.commons.math.fraction.FractionTest::testCompareTo": {
        "source": "    public void testCompareTo() {\n\n        Fraction first = new Fraction(1, 2);\n\n        Fraction second = new Fraction(1, 3);\n\n        Fraction third = new Fraction(1, 2);\n\n        \n\n        assertEquals(0, first.compareTo(first));\n\n        assertEquals(0, first.compareTo(third));\n\n        assertEquals(1, first.compareTo(second));\n\n        assertEquals(-1, second.compareTo(first));\n\n\n\n        // these two values are different approximations of PI\n\n        // the first  one is approximately PI - 3.07e-18\n\n        // the second one is approximately PI + 1.936e-17\n\n        Fraction pi1 = new Fraction(1068966896, 340262731);\n\n        Fraction pi2 = new Fraction( 411557987, 131002976);\n\n        assertEquals(-1, pi1.compareTo(pi2));\n\n        assertEquals( 1, pi2.compareTo(pi1));\n\n        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n\n    }\n"
      }
    }
  },
  "Math-94": {
    "id": "Math-94",
    "project": "Math",
    "number": "94",
    "buggy_function": "public static int gcd(int u, int v) {\n    if (u * v == 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    } // make u negative\n    if (v > 0) {\n        v = -v;\n    } // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                        // both even...\n        u /= 2;\n        v /= 2;\n        k++; // cast out twos.\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) { // while t is even..\n            t /= 2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    return -u * (1 << k); // gcd is u*2^k\n}",
    "fixed_function": "public static int gcd(int u, int v) {\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    } // make u negative\n    if (v > 0) {\n        v = -v;\n    } // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                        // both even...\n        u /= 2;\n        v /= 2;\n        k++; // cast out twos.\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) { // while t is even..\n            t /= 2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    return -u * (1 << k); // gcd is u*2^k\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/util/MathUtils.java",
      "first_line": 411,
      "last_line": 460
    },
    "javadoc": "/**\n* <p>\n* Gets the greatest common divisor of the absolute value of two numbers,\n* using the \"binary gcd\" method which avoids division and modulo\n* operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n* Stein (1961).\n* </p>\n*\n* @param u a non-zero number\n* @param v a non-zero number\n* @return the greatest common divisor, never zero\n* @since 1.1\n*/",
    "failing_tests": {
      "org.apache.commons.math.util.MathUtilsTest::testGcd": {
        "source": "    public void testGcd() {\n\n        int a = 30;\n\n        int b = 50;\n\n        int c = 77;\n\n\n\n        assertEquals(0, MathUtils.gcd(0, 0));\n\n\n\n        assertEquals(b, MathUtils.gcd(0, b));\n\n        assertEquals(a, MathUtils.gcd(a, 0));\n\n        assertEquals(b, MathUtils.gcd(0, -b));\n\n        assertEquals(a, MathUtils.gcd(-a, 0));\n\n\n\n        assertEquals(10, MathUtils.gcd(a, b));\n\n        assertEquals(10, MathUtils.gcd(-a, b));\n\n        assertEquals(10, MathUtils.gcd(a, -b));\n\n        assertEquals(10, MathUtils.gcd(-a, -b));\n\n\n\n        assertEquals(1, MathUtils.gcd(a, c));\n\n        assertEquals(1, MathUtils.gcd(-a, c));\n\n        assertEquals(1, MathUtils.gcd(a, -c));\n\n        assertEquals(1, MathUtils.gcd(-a, -c));\n\n\n\n        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n\n\n\n    }\n"
      }
    }
  },
  "Math-95": {
    "id": "Math-95",
    "project": "Math",
    "number": "95",
    "buggy_function": "protected double getInitialDomain(double p) {\n    double ret;\n    double d = getDenominatorDegreesOfFreedom();\n        // use mean\n        ret = d / (d - 2.0);\n    return ret;\n}",
    "fixed_function": "protected double getInitialDomain(double p) {\n    double ret = 1.0;\n    double d = getDenominatorDegreesOfFreedom();\n    if (d > 2.0) {\n        // use mean\n        ret = d / (d - 2.0);\n    }\n    return ret;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/distribution/FDistributionImpl.java",
      "first_line": 143,
      "last_line": 149
    },
    "javadoc": "/**\n* Access the initial domain value, based on <code>p</code>, used to\n* bracket a CDF root.  This method is used by\n* {@link #inverseCumulativeProbability(double)} to find critical values.\n*\n* @param p the desired probability for the critical value\n* @return initial domain value\n*/",
    "failing_tests": {
      "org.apache.commons.math.distribution.FDistributionTest::testSmallDegreesOfFreedom": {
        "source": "    public void testSmallDegreesOfFreedom() throws Exception {\n\n        org.apache.commons.math.distribution.FDistributionImpl fd =\n\n            new org.apache.commons.math.distribution.FDistributionImpl(\n\n                1.0, 1.0);\n\n        double p = fd.cumulativeProbability(0.975);\n\n        double x = fd.inverseCumulativeProbability(p);\n\n        assertEquals(0.975, x, 1.0e-5);\n\n\n\n        fd.setDenominatorDegreesOfFreedom(2.0);\n\n        p = fd.cumulativeProbability(0.975);\n\n        x = fd.inverseCumulativeProbability(p);\n\n        assertEquals(0.975, x, 1.0e-5);\n\n    }\n"
      }
    }
  },
  "Math-96": {
    "id": "Math-96",
    "project": "Math",
    "number": "96",
    "buggy_function": "public boolean equals(Object other) {\n    boolean ret;\n    \n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException ex) {\n            // ignore exception\n            ret = false;\n        }\n    }\n  \n    return ret;\n}",
    "fixed_function": "public boolean equals(Object other) {\n    boolean ret;\n    \n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n            }\n        } catch (ClassCastException ex) {\n            // ignore exception\n            ret = false;\n        }\n    }\n  \n    return ret;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/complex/Complex.java",
      "first_line": 245,
      "last_line": 267
    },
    "javadoc": "/**\n* Test for the equality of two Complex objects.\n* <p>\n* If both the real and imaginary parts of two Complex numbers\n* are exactly the same, and neither is <code>Double.NaN</code>, the two\n* Complex objects are considered to be equal.</p>\n* <p>\n* All <code>NaN</code> values are considered to be equal - i.e, if either\n* (or both) real and imaginary parts of the complex number are equal\n* to <code>Double.NaN</code>, the complex number is equal to\n* <code>Complex.NaN</code>.</p>\n*\n* @param other Object to test for equality to this\n* @return true if two Complex objects are equal, false if\n*         object is null, not an instance of Complex, or\n*         not equal to this Complex instance\n*\n*/",
    "failing_tests": {
      "org.apache.commons.math.complex.ComplexTest::testMath221": {
        "source": "    public void testMath221() {\n\n        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n\n    }\n"
      }
    }
  },
  "Math-97": {
    "id": "Math-97",
    "project": "Math",
    "number": "97",
    "buggy_function": "public double solve(double min, double max) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n    \n    clearResult();\n    verifyInterval(min, max);\n    \n    double ret = Double.NaN;\n    \n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    \n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException\n            (\"Function values at endpoints do not have different signs.\" +\n                    \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n\n    return ret;\n}",
    "fixed_function": "public double solve(double min, double max) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n    \n    clearResult();\n    verifyInterval(min, max);\n    \n    double ret = Double.NaN;\n    \n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    \n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign > 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            ret = min;\n        } else if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException\n            (\"Function values at endpoints do not have different signs.\" +\n                    \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else if (sign < 0){\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n    } else {\n        // either min or max is a root\n        if (yMin == 0.0) {\n            ret = min;\n        } else {\n            ret = max;\n        }\n    }\n\n    return ret;\n}",
    "replacement_info": {
      "file": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "first_line": 125,
      "last_line": 152
    },
    "javadoc": "/**\n* Find a zero in the given interval.\n* <p>\n* Requires that the values of the function at the endpoints have opposite\n* signs. An <code>IllegalArgumentException</code> is thrown if this is not\n* the case.</p>\n*\n* @param min the lower bound for the interval.\n* @param max the upper bound for the interval.\n* @return the value where the function is zero\n* @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n* @throws FunctionEvaluationException if an error occurs evaluating the\n* function\n* @throws IllegalArgumentException if min is not less than max or the\n* signs of the values of the function at the endpoints are not opposites\n*/",
    "failing_tests": {
      "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints": {
        "source": "    public void testRootEndpoints() throws Exception {\n\n        UnivariateRealFunction f = new SinFunction();\n\n        UnivariateRealSolver solver = new BrentSolver(f);\n\n        \n\n        // endpoint is root\n\n        double result = solver.solve(Math.PI, 4);\n\n        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n\n\n\n        result = solver.solve(3, Math.PI);\n\n        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n\n    }\n"
      }
    }
  },
  "Mockito-1": {
    "id": "Mockito-1",
    "project": "Mockito",
    "number": "1",
    "buggy_function": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        throw new UnsupportedOperationException();\n\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n\n      for (int position = 0; position < matchers.size(); position++) {\n          Matcher m = matchers.get(position);\n          if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n              //TODO SF - this whole lot can be moved captureFrom implementation\n              if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                  Object array = invocation.getRawArguments()[position];\n                  for (int i = 0; i < Array.getLength(array); i++) {\n                      ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                  }\n                  //since we've captured all varargs already, it does not make sense to process other matchers.\n                  return;\n              } else {\n                  ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n              }\n          }\n      }\n}",
    "fixed_function": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < indexOfVararg; position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n        for (int position = indexOfVararg; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n            }\n        }\n\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n\n      for (int position = 0; position < matchers.size(); position++) {\n          Matcher m = matchers.get(position);\n          if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n              //TODO SF - this whole lot can be moved captureFrom implementation\n              if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                  Object array = invocation.getRawArguments()[position];\n                  for (int i = 0; i < Array.getLength(array); i++) {\n                      ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                  }\n                  //since we've captured all varargs already, it does not make sense to process other matchers.\n                  return;\n              } else {\n                  ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n              }\n          }\n      }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/invocation/InvocationMatcher.java",
      "first_line": 120,
      "last_line": 150
    },
    "javadoc": "//sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest",
    "failing_tests": {
      "org.mockito.internal.invocation.InvocationMatcherTest::should_capture_arguments_when_args_count_does_NOT_match": {
        "source": "    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {\n\n        //given\n\n        mock.varargs();\n\n        Invocation invocation = getLastInvocation();\n\n\n\n        //when\n\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n\n\n        //then\n\n        invocationMatcher.captureArgumentsFrom(invocation);\n\n    }\n"
      },
      "org.mockito.internal.util.reflection.FieldInitializerTest::can_instantiate_class_with_parameterized_constructor": {
        "source": "    public void can_instantiate_class_with_parameterized_constructor() throws Exception {\n\n        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))\n\n                        .willReturn(new Object[]{null}).getMock();\n\n\n\n        new FieldInitializer(this, field(\"noDefaultConstructor\"), resolver).initialize();\n\n\n\n        assertNotNull(noDefaultConstructor);\n\n    }\n"
      },
      "org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest::should_report_failure_if_constructor_throws_exception": {
        "source": "    public void should_report_failure_if_constructor_throws_exception() throws Exception {\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ null });\n\n\n\n        try {\n\n            new ParameterizedConstructorInstantiator(this, field(\"withThrowingConstructor\"), resolver).instantiate();\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertThat(e.getMessage()).contains(\"constructor\").contains(\"raised an exception\");\n\n        }\n\n    }\n"
      },
      "org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest::should_fail_if_an_argument_instance_type_do_not_match_wanted_type": {
        "source": "    public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type() throws Exception {\n\n        Observer observer = mock(Observer.class);\n\n        Set wrongArg = mock(Set.class);\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, wrongArg });\n\n\n\n        try {\n\n            new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertThat(e.getMessage()).contains(\"argResolver\").contains(\"incorrect types\");\n\n        }\n\n    }\n"
      },
      "org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest::should_instantiate_type_with_vararg_constructor": {
        "source": "    public void should_instantiate_type_with_vararg_constructor() throws Exception {\n\n        Observer[] vararg = new Observer[] {  };\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ \"\", vararg});\n\n\n\n        new ParameterizedConstructorInstantiator(this, field(\"withVarargConstructor\"), resolver).instantiate();\n\n\n\n        assertNotNull(withVarargConstructor);\n\n    }\n"
      },
      "org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest::should_instantiate_type_if_resolver_provide_matching_types": {
        "source": "    public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {\n\n        Observer observer = mock(Observer.class);\n\n        Map map = mock(Map.class);\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, map });\n\n\n\n        new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n\n\n\n        assertNotNull(withMultipleConstructor);\n\n        assertNotNull(withMultipleConstructor.observer);\n\n        assertNotNull(withMultipleConstructor.map);\n\n    }\n"
      },
      "org.mockitousage.basicapi.ResetTest::shouldRemoveAllStubbing": {
        "source": "    public void shouldRemoveAllStubbing() throws Exception {\n\n        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n\n        when(mock.objectReturningMethod(200)).thenReturn(200);\n\n        reset(mock);\n\n        assertNull(mock.objectReturningMethod(200));\n\n        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldVerifyWithNullVarArgArray": {
        "source": "    public void shouldVerifyWithNullVarArgArray() {\n\n        Foo foo = Mockito.mock(Foo.class);\n\n        foo.varArgs((String[]) null);    \n\n        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n\n        Mockito.verify(foo).varArgs((String[]) null);\n\n    }  \n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldVerifyWithAnyObject": {
        "source": "    public void shouldVerifyWithAnyObject() {\n\n        Foo foo = Mockito.mock(Foo.class);\n\n        foo.varArgs(\"\");        \n\n        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n\n        Mockito.verify(foo).varArgs((String) Mockito.anyObject());\n\n    }   \n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldStubBooleanVarargs": {
        "source": "    public void shouldStubBooleanVarargs() {\n\n        when(mock.withBooleanVarargs(1)).thenReturn(true);\n\n        when(mock.withBooleanVarargs(1, true, false)).thenReturn(true);\n\n        \n\n        assertEquals(true, mock.withBooleanVarargs(1));\n\n        assertEquals(false, mock.withBooleanVarargs(9999));\n\n        \n\n        assertEquals(true, mock.withBooleanVarargs(1, true, false));\n\n        assertEquals(false, mock.withBooleanVarargs(1, true, false, true));\n\n        assertEquals(false, mock.withBooleanVarargs(2, true, false));\n\n        assertEquals(false, mock.withBooleanVarargs(1, true));\n\n        assertEquals(false, mock.withBooleanVarargs(1, false, false));\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldMatchEasilyEmptyVararg": {
        "source": "    public void shouldMatchEasilyEmptyVararg() throws Exception {\n\n        //when\n\n        when(mock.foo(anyVararg())).thenReturn(-1);\n\n\n\n        //then\n\n        assertEquals(-1, mock.foo());\n\n    } \n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldVerifyBooleanVarargs": {
        "source": "    public void shouldVerifyBooleanVarargs() {\n\n        mock.withBooleanVarargs(1);\n\n        mock.withBooleanVarargs(2, true, false, true);\n\n        mock.withBooleanVarargs(3, true, true, true);\n\n\n\n        verify(mock).withBooleanVarargs(1);\n\n        verify(mock).withBooleanVarargs(2, true, false, true);\n\n        try {\n\n            verify(mock).withBooleanVarargs(3, true, true, true, true);\n\n            fail();\n\n        } catch (ArgumentsAreDifferent e) {}\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldStubCorrectlyWhenMixedVarargsUsed": {
        "source": "    public void shouldStubCorrectlyWhenMixedVarargsUsed() {\n\n        MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n\n        when(mixedVarargs.doSomething(\"hello\", (String[])null)).thenReturn(\"hello\");\n\n        when(mixedVarargs.doSomething(\"goodbye\", (String[])null)).thenReturn(\"goodbye\");\n\n\n\n        String result = mixedVarargs.doSomething(\"hello\",(String[]) null);\n\n        assertEquals(\"hello\", result);\n\n        \n\n        verify(mixedVarargs).doSomething(\"hello\", (String[])null);\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldStubStringVarargs": {
        "source": "    public void shouldStubStringVarargs() {\n\n        when(mock.withStringVarargsReturningString(1)).thenReturn(\"1\");\n\n        when(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).thenReturn(\"2\");\n\n        \n\n        RuntimeException expected = new RuntimeException();\n\n        stubVoid(mock).toThrow(expected).on().withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n\n\n\n        assertEquals(\"1\", mock.withStringVarargsReturningString(1));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2));\n\n        \n\n        assertEquals(\"2\", mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\"));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\"));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\", \"4\"));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"9999\"));\n\n        \n\n        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"9999\");\n\n        mock.withStringVarargs(9999, \"1\", \"2\", \"3\", \"4\");\n\n        \n\n        try {\n\n            mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n\n            fail();\n\n        } catch (Exception e) {\n\n            assertEquals(expected, e);\n\n        }\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed": {
        "source": "    public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed() {\n\n        MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n\n        when(mixedVarargs.doSomething(\"one\", \"two\", (String[])null)).thenReturn(\"hello\");\n\n        when(mixedVarargs.doSomething(\"1\", \"2\", (String[])null)).thenReturn(\"goodbye\");\n\n\n\n        String result = mixedVarargs.doSomething(\"one\", \"two\", (String[])null);\n\n        assertEquals(\"hello\", result);\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldVerifyStringVarargs": {
        "source": "    public void shouldVerifyStringVarargs() {\n\n        mock.withStringVarargs(1);\n\n        mock.withStringVarargs(2, \"1\", \"2\", \"3\");\n\n        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n\n\n\n        verify(mock).withStringVarargs(1);\n\n        verify(mock).withStringVarargs(2, \"1\", \"2\", \"3\");\n\n        try {\n\n            verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n\n            fail();\n\n        } catch (ArgumentsAreDifferent e) {}\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldVerifyObjectVarargs": {
        "source": "    public void shouldVerifyObjectVarargs() {\n\n        mock.withObjectVarargs(1);\n\n        mock.withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n\n        mock.withObjectVarargs(3, new Integer(1));\n\n\n\n        verify(mock).withObjectVarargs(1);\n\n        verify(mock).withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n\n        try {\n\n            verifyNoMoreInteractions(mock);\n\n            fail();\n\n        } catch (NoInteractionsWanted e) {}\n\n    }\n"
      },
      "org.mockitousage.bugs.VarargsErrorWhenCallingRealMethodTest::shouldNotThrowAnyException": {
        "source": "    public void shouldNotThrowAnyException() throws Exception {\n\n        Foo foo = mock(Foo.class);\n\n\n\n        when(foo.blah(anyString(), anyString())).thenCallRealMethod();\n\n\n\n        assertEquals(1, foo.blah(\"foo\", \"bar\"));\n\n    }\n"
      },
      "org.mockitousage.bugs.varargs.VarargsAndAnyObjectPicksUpExtraInvocationsTest::shouldVerifyCorrectlyWithAnyVarargs": {
        "source": "    public void shouldVerifyCorrectlyWithAnyVarargs() {\n\n        //when\n\n        table.newRow(\"qux\", \"foo\", \"bar\", \"baz\");\n\n        table.newRow(\"abc\", \"def\");\n\n        \n\n        //then\n\n        verify(table, times(2)).newRow(anyString(), (String[]) anyVararg());\n\n    }\n"
      },
      "org.mockitousage.bugs.varargs.VarargsAndAnyObjectPicksUpExtraInvocationsTest::shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument": {
        "source": "    public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument() {\n\n        //when\n\n        table.newRow(\"x\", \"foo\", \"bar\", \"baz\");\n\n        table.newRow(\"x\", \"def\");\n\n\n\n        //then\n\n        verify(table, times(2)).newRow(eq(\"x\"), (String[]) anyVararg());\n\n    }\n"
      },
      "org.mockitousage.bugs.varargs.VarargsNotPlayingWithAnyObjectTest::shouldStubUsingAnyVarargs": {
        "source": "    public void shouldStubUsingAnyVarargs() {\n\n        when(mock.run((String[]) anyVararg())).thenReturn(\"foo\");\n\n        \n\n        assertEquals(\"foo\", mock.run(\"a\", \"b\"));\n\n    }\n"
      },
      "org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest::shouldVerifyUsingMatchers": {
        "source": "    public void shouldVerifyUsingMatchers() {\n\n        stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);\n\n        when(three.varargsObject(5, \"first arg\", \"second arg\")).thenReturn(\"stubbed\");\n\n\n\n        try {\n\n            one.oneArg(true);\n\n            fail();\n\n        } catch (RuntimeException e) {}\n\n\n\n        one.simpleMethod(100);\n\n        two.simpleMethod(\"test Mockito\");\n\n        three.varargsObject(10, \"first arg\", \"second arg\");\n\n        \n\n        assertEquals(\"stubbed\", three.varargsObject(5, \"first arg\", \"second arg\"));\n\n\n\n        verify(one).oneArg(eq(true));\n\n        verify(one).simpleMethod(anyInt());\n\n        verify(two).simpleMethod(startsWith(\"test\"));\n\n        verify(three).varargsObject(5, \"first arg\", \"second arg\");\n\n        verify(three).varargsObject(eq(10), eq(\"first arg\"), startsWith(\"second\"));\n\n        \n\n        verifyNoMoreInteractions(one, two, three);\n\n        \n\n        try {\n\n            verify(three).varargsObject(eq(10), eq(\"first arg\"), startsWith(\"third\"));\n\n            fail();\n\n        } catch (WantedButNotInvoked e) {}\n\n    }\n"
      },
      "org.mockitousage.stubbing.BasicStubbingTest::test_stub_only_not_verifiable": {
        "source": "    public void test_stub_only_not_verifiable() throws Exception {\n\n        IMethods localMock = mock(IMethods.class, withSettings().stubOnly());\n\n\n\n        when(localMock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n\n        when(localMock.objectReturningMethod(200)).thenReturn(200);\n\n\n\n        assertEquals(200, localMock.objectReturningMethod(200));\n\n        assertEquals(100, localMock.objectReturningMethod(666));\n\n        assertEquals(\"default behavior should return null\", null, localMock.objectReturningMethod(\"blah\"));\n\n\n\n        try {\n\n            verify(localMock, atLeastOnce()).objectReturningMethod(eq(200));\n\n            fail();\n\n        } catch (CannotVerifyStubOnlyMock e) {}\n\n    }\n"
      },
      "org.mockitousage.stubbing.BasicStubbingTest::should_evaluate_latest_stubbing_first": {
        "source": "    public void should_evaluate_latest_stubbing_first() throws Exception {\n\n        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n\n        when(mock.objectReturningMethod(200)).thenReturn(200);\n\n        \n\n        assertEquals(200, mock.objectReturningMethod(200));\n\n        assertEquals(100, mock.objectReturningMethod(666));\n\n        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n\n    }\n"
      },
      "org.mockitousage.stubbing.DeprecatedStubbingTest::shouldEvaluateLatestStubbingFirst": {
        "source": "    public void shouldEvaluateLatestStubbingFirst() throws Exception {\n\n        stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);\n\n        stub(mock.objectReturningMethod(200)).toReturn(200);\n\n        \n\n        assertEquals(200, mock.objectReturningMethod(200));\n\n        assertEquals(100, mock.objectReturningMethod(666));\n\n        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n\n    }\n"
      },
      "org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest::shouldUseEqualsToVerifyMethodVarargs": {
        "source": "    public void shouldUseEqualsToVerifyMethodVarargs() {\n\n        mockOne = mock(IMethods.class);\n\n        \n\n        String textOne = \"test\";\n\n        String textTwo = new String(textOne);\n\n        \n\n        assertEquals(textOne, textTwo);\n\n        assertNotSame(textOne, textTwo);\n\n        \n\n        mockOne.varargsObject(1, textOne, textOne);\n\n        mockOne.varargsObject(1, textTwo, textTwo);\n\n        \n\n        verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n\n        \n\n        inOrder = inOrder(mockOne);\n\n        inOrder.verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n\n    } \n"
      }
    }
  },
  "Mockito-12": {
    "id": "Mockito-12",
    "project": "Mockito",
    "number": "12",
    "buggy_function": "public Class getGenericType(Field field) {        \n    Type generic = field.getGenericType();\n    if (generic != null && generic instanceof ParameterizedType) {\n        Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            return (Class) actual;\n            //in case of nested generics we don't go deep\n    }\n    \n    return Object.class;\n}",
    "fixed_function": "public Class getGenericType(Field field) {        \n    Type generic = field.getGenericType();\n    if (generic != null && generic instanceof ParameterizedType) {\n        Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n        if (actual instanceof Class) {\n            return (Class) actual;\n        } else if (actual instanceof ParameterizedType) {\n            //in case of nested generics we don't go deep\n            return (Class) ((ParameterizedType) actual).getRawType();\n        }\n    }\n    \n    return Object.class;\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/util/reflection/GenericMaster.java",
      "first_line": 16,
      "last_line": 25
    },
    "javadoc": "/**\n* Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n*\n* @param field\n* @return\n*/",
    "failing_tests": {
      "org.mockito.internal.util.reflection.GenericMasterTest::shouldDealWithNestedGenerics": {
        "source": "    public void shouldDealWithNestedGenerics() throws Exception {\n\n        assertEquals(Set.class, m.getGenericType(field(\"nested\")));\n\n        assertEquals(Set.class, m.getGenericType(field(\"multiNested\")));\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationBasicTest::shouldUseAnnotatedCaptor": {
        "source": "    public void shouldUseAnnotatedCaptor() {\n\n        //when\n\n        createPerson(\"Wes\", \"Williams\");\n\n        \n\n        //then\n\n        verify(peopleRepository).save(captor.capture());\n\n        assertEquals(\"Wes\", captor.getValue().getName());\n\n        assertEquals(\"Williams\", captor.getValue().getSurname());\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationBasicTest::shouldUseCaptorInOrdinaryWay": {
        "source": "    public void shouldUseCaptorInOrdinaryWay() {\n\n        //when\n\n        createPerson(\"Wes\", \"Williams\");\n\n        \n\n        //then\n\n        ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);\n\n        verify(peopleRepository).save(captor.capture());\n\n        assertEquals(\"Wes\", captor.getValue().getName());\n\n        assertEquals(\"Williams\", captor.getValue().getSurname());\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationBasicTest::shouldCaptureGenericList": {
        "source": "    public void shouldCaptureGenericList() {\n\n        //given\n\n        List<String> list = new LinkedList<String>();\n\n        mock.listArgMethod(list);\n\n                \n\n        //when\n\n        verify(mock).listArgMethod(genericListCaptor.capture());\n\n        \n\n        //then\n\n        assertSame(list, genericListCaptor.getValue());\n\n    } \n"
      },
      "org.mockitousage.annotation.CaptorAnnotationBasicTest::shouldUseGenericlessAnnotatedCaptor": {
        "source": "    public void shouldUseGenericlessAnnotatedCaptor() {\n\n        //when\n\n        createPerson(\"Wes\", \"Williams\");\n\n        \n\n        //then\n\n        verify(peopleRepository).save((Person) genericLessCaptor.capture());\n\n        assertEquals(\"Wes\", ((Person) genericLessCaptor.getValue()).getName());\n\n        assertEquals(\"Williams\", ((Person) genericLessCaptor.getValue()).getSurname());\n\n    }  \n"
      },
      "org.mockitousage.annotation.CaptorAnnotationTest::shouldScreamWhenWrongTypeForCaptor": {
        "source": "    public void shouldScreamWhenWrongTypeForCaptor() {\n\n        try {\n\n            MockitoAnnotations.initMocks(new WrongType());\n\n            fail();\n\n        } catch (MockitoException e) {}\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationTest::testNormalUsage": {
        "source": "    public void testNormalUsage() {\n\n\n\n        MockitoAnnotations.initMocks(this);\n\n\n\n        // check if assigned correctly\n\n        assertNotNull(finalCaptor);\n\n        assertNotNull(genericsCaptor);\n\n        assertNotNull(nonGenericCaptorIsAllowed);\n\n        assertNull(notAMock);\n\n\n\n        // use captors in the field to be sure they are cool\n\n        String argForFinalCaptor = \"Hello\";\n\n        ArrayList<List<String>> argForGenericsCaptor = new ArrayList<List<String>>();\n\n\n\n        mockInterface.testMe(argForFinalCaptor, argForGenericsCaptor);\n\n\n\n        Mockito.verify(mockInterface).testMe(finalCaptor.capture(), genericsCaptor.capture());\n\n\n\n        assertEquals(argForFinalCaptor, finalCaptor.getValue());\n\n        assertEquals(argForGenericsCaptor, genericsCaptor.getValue());\n\n\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationTest::shouldScreamWhenMoreThanOneMockitoAnnotaton": {
        "source": "    public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {\n\n        try {\n\n            MockitoAnnotations.initMocks(new ToManyAnnotations());\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertContains(\"missingGenericsField\", e.getMessage());\n\n            assertContains(\"multiple Mockito annotations\", e.getMessage());            \n\n        }\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationTest::shouldScreamWhenInitializingCaptorsForNullClass": {
        "source": "    public void shouldScreamWhenInitializingCaptorsForNullClass() throws Exception {\n\n        try {\n\n            MockitoAnnotations.initMocks(null);\n\n            fail();\n\n        } catch (MockitoException e) {\n\n        }\n\n    }\n"
      },
      "org.mockitousage.annotation.CaptorAnnotationTest::shouldLookForAnnotatedCaptorsInSuperClasses": {
        "source": "    public void shouldLookForAnnotatedCaptorsInSuperClasses() throws Exception {\n\n        Sub sub = new Sub();\n\n        MockitoAnnotations.initMocks(sub);\n\n\n\n        assertNotNull(sub.getCaptor());\n\n        assertNotNull(sub.getBaseCaptor());\n\n        assertNotNull(sub.getSuperBaseCaptor());\n\n    }\n"
      }
    }
  },
  "Mockito-13": {
    "id": "Mockito-13",
    "project": "Mockito",
    "number": "13",
    "buggy_function": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}",
    "fixed_function": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/MockHandler.java",
      "first_line": 58,
      "last_line": 106
    },
    "javadoc": "// for tests",
    "failing_tests": {
      "org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest::shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine": {
        "source": "    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n\n        //given\n\n        when(mock.otherMethod()).thenReturn(\"foo\");\n\n        \n\n        //when\n\n        mockTwo.simpleMethod(\"foo\");\n\n        \n\n        //then\n\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n\n        try {\n\n            verify(mockTwo, never()).simpleMethod(mock.otherMethod());\n\n            fail();\n\n        } catch (NeverWantedButInvoked e) {}\n\n    }\n"
      }
    }
  },
  "Mockito-18": {
    "id": "Mockito-18",
    "project": "Mockito",
    "number": "18",
    "buggy_function": "Object returnValueFor(Class<?> type) {\n    if (Primitives.isPrimitiveOrWrapper(type)) {\n        return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n    } else if (type == Collection.class) {\n        return new LinkedList<Object>();\n    } else if (type == Set.class) {\n        return new HashSet<Object>();\n    } else if (type == HashSet.class) {\n        return new HashSet<Object>();\n    } else if (type == SortedSet.class) {\n        return new TreeSet<Object>();\n    } else if (type == TreeSet.class) {\n        return new TreeSet<Object>();\n    } else if (type == LinkedHashSet.class) {\n        return new LinkedHashSet<Object>();\n    } else if (type == List.class) {\n        return new LinkedList<Object>();\n    } else if (type == LinkedList.class) {\n        return new LinkedList<Object>();\n    } else if (type == ArrayList.class) {\n        return new ArrayList<Object>();\n    } else if (type == Map.class) {\n        return new HashMap<Object, Object>();\n    } else if (type == HashMap.class) {\n        return new HashMap<Object, Object>();\n    } else if (type == SortedMap.class) {\n        return new TreeMap<Object, Object>();\n    } else if (type == TreeMap.class) {\n        return new TreeMap<Object, Object>();\n    } else if (type == LinkedHashMap.class) {\n        return new LinkedHashMap<Object, Object>();\n    }\n    //Let's not care about the rest of collections.\n    return null;\n}",
    "fixed_function": "Object returnValueFor(Class<?> type) {\n    if (Primitives.isPrimitiveOrWrapper(type)) {\n        return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n    } else if (type == Iterable.class) {\n        return new ArrayList<Object>(0);\n    } else if (type == Collection.class) {\n        return new LinkedList<Object>();\n    } else if (type == Set.class) {\n        return new HashSet<Object>();\n    } else if (type == HashSet.class) {\n        return new HashSet<Object>();\n    } else if (type == SortedSet.class) {\n        return new TreeSet<Object>();\n    } else if (type == TreeSet.class) {\n        return new TreeSet<Object>();\n    } else if (type == LinkedHashSet.class) {\n        return new LinkedHashSet<Object>();\n    } else if (type == List.class) {\n        return new LinkedList<Object>();\n    } else if (type == LinkedList.class) {\n        return new LinkedList<Object>();\n    } else if (type == ArrayList.class) {\n        return new ArrayList<Object>();\n    } else if (type == Map.class) {\n        return new HashMap<Object, Object>();\n    } else if (type == HashMap.class) {\n        return new HashMap<Object, Object>();\n    } else if (type == SortedMap.class) {\n        return new TreeMap<Object, Object>();\n    } else if (type == TreeMap.class) {\n        return new TreeMap<Object, Object>();\n    } else if (type == LinkedHashMap.class) {\n        return new LinkedHashMap<Object, Object>();\n    }\n    //Let's not care about the rest of collections.\n    return null;\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
      "first_line": 82,
      "last_line": 118
    },
    "javadoc": "//Only for compareTo() method by the Comparable interface",
    "failing_tests": {
      "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest::should_return_empty_iterable": {
        "source": "    public void should_return_empty_iterable() throws Exception {\n\n        assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());\n\n    }\n"
      }
    }
  },
  "Mockito-20": {
    "id": "Mockito-20",
    "project": "Mockito",
    "number": "20",
    "buggy_function": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n    );\n    T mockInstance = null;\n    try {\n        mockInstance = classInstantiator.instantiate(mockedProxyType);\n        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(mockedProxyType),\n                \"  created class : \" + describeClass(settings.getTypeToMock()),\n                \"  proxy instance class : \" + describeClass(mockInstance),\n                \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ),cce);\n    } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n        throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n    }\n}",
    "fixed_function": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n    );\n    Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n    T mockInstance = null;\n    try {\n        mockInstance = instantiator.newInstance(mockedProxyType);\n        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(mockedProxyType),\n                \"  created class : \" + describeClass(settings.getTypeToMock()),\n                \"  proxy instance class : \" + describeClass(mockInstance),\n                \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ),cce);\n    } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n        throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java",
      "first_line": 24,
      "last_line": 53
    },
    "javadoc": "",
    "failing_tests": {
      "org.mockitousage.annotation.SpyAnnotationTest::should_spy_inner_class": {
        "source": "    public void should_spy_inner_class() throws Exception {\n\n    \t \n\n     class WithMockAndSpy {\n\n    \t\t@Spy private InnerStrength strength;\n\n    \t\t@Mock private List<String> list;\n\n\n\n            abstract class InnerStrength {\n\n            \tprivate final String name;\n\n\n\n            \tInnerStrength() {\n\n            \t\t// Make sure that @Mock fields are always injected before @Spy fields.\n\n            \t\tassertNotNull(list);\n\n            \t\t// Make sure constructor is indeed called.\n\n            \t\tthis.name = \"inner\";\n\n            \t}\n\n            \t\n\n            \tabstract String strength();\n\n            \t\n\n            \tString fullStrength() {\n\n            \t\treturn name + \" \" + strength();\n\n            \t}\n\n            }\n\n    \t}\n\n\t\tWithMockAndSpy outer = new WithMockAndSpy();\n\n        MockitoAnnotations.initMocks(outer);\n\n        when(outer.strength.strength()).thenReturn(\"strength\");\n\n        assertEquals(\"inner strength\", outer.strength.fullStrength());\n\n    }\n"
      },
      "org.mockitousage.annotation.SpyAnnotationTest::should_report_when_constructor_is_explosive": {
        "source": "    public void should_report_when_constructor_is_explosive() throws Exception {\n\n\t\tclass FailingSpy {\n\n\t        @Spy\n\n            ThrowingConstructor throwingConstructor;\n\n\t\t}\n\n\n\n        try {\n\n            MockitoAnnotations.initMocks(new FailingSpy());\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            Assertions.assertThat(e.getMessage()).contains(\"Unable to create mock instance\");\n\n        }\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::can_spy_abstract_classes": {
        "source": "    public void can_spy_abstract_classes() {\n\n        AbstractMessage mock = spy(AbstractMessage.class);\n\n        assertEquals(\"hey!\", mock.getMessage());\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::exception_message_when_constructor_not_found": {
        "source": "    public void exception_message_when_constructor_not_found() {\n\n        try {\n\n            //when\n\n            spy(HasConstructor.class);\n\n            //then\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertEquals(\"Unable to create mock instance of type 'HasConstructor'\", e.getMessage());\n\n            assertContains(\"0-arg constructor\", e.getCause().getMessage());\n\n        }\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::can_create_mock_with_constructor": {
        "source": "    public void can_create_mock_with_constructor() {\n\n        Message mock = mock(Message.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n\n        //the message is a part of state of the mocked type that gets initialized in constructor\n\n        assertEquals(\"hey!\", mock.getMessage());\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::can_mock_inner_classes": {
        "source": "    public void can_mock_inner_classes() {\n\n        InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));\n\n        assertEquals(\"hey!\", mock.getMessage());\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::mocking_inner_classes_with_wrong_outer_instance": {
        "source": "    public void mocking_inner_classes_with_wrong_outer_instance() {\n\n        try {\n\n            //when\n\n            mock(InnerClass.class, withSettings().useConstructor().outerInstance(\"foo\").defaultAnswer(CALLS_REAL_METHODS));\n\n            //then\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertEquals(\"Unable to create mock instance of type 'InnerClass'\", e.getMessage());\n\n            assertContains(\"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.\", e.getCause().getMessage());\n\n        }\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::can_mock_abstract_classes": {
        "source": "    public void can_mock_abstract_classes() {\n\n        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n\n        assertEquals(\"hey!\", mock.getMessage());\n\n    }\n"
      }
    }
  },
  "Mockito-22": {
    "id": "Mockito-22",
    "project": "Mockito",
    "number": "22",
    "buggy_function": "public static boolean areEqual(Object o1, Object o2) {\n    if (o1 == null || o2 == null) {\n        return o1 == null && o2 == null;\n    } else if (isArray(o1)) {\n        return isArray(o2) && areArraysEqual(o1, o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
    "fixed_function": "public static boolean areEqual(Object o1, Object o2) {\n    if (o1 == o2 ) {\n        return true;\nlse if (o1 == null || o2 == null) {\n        return o1 == null && o2 == null;\n    } else if (isArray(o1)) {\n        return isArray(o2) && areArraysEqual(o1, o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/matchers/Equality.java",
      "first_line": 12,
      "last_line": 20
    },
    "javadoc": "//stolen from hamcrest because I didn't want to have more dependency than Matcher class",
    "failing_tests": {
      "org.mockito.internal.matchers.EqualityTest::shouldKnowIfObjectsAreEqual": {
        "source": "    public void shouldKnowIfObjectsAreEqual() throws Exception {\n\n        int[] arr = new int[] {1, 2};\n\n        assertTrue(areEqual(arr, arr));\n\n        assertTrue(areEqual(new int[] {1, 2}, new int[] {1, 2}));\n\n        assertTrue(areEqual(new Double[] {1.0}, new Double[] {1.0}));\n\n        assertTrue(areEqual(new String[0], new String[0]));\n\n        assertTrue(areEqual(new Object[10], new Object[10]));\n\n        assertTrue(areEqual(new int[] {1}, new Integer[] {1}));\n\n        assertTrue(areEqual(new Object[] {\"1\"}, new String[] {\"1\"}));\n\n\tObject badequals=new BadEquals();\n\n\tassertTrue(areEqual(badequals,badequals));\n\n\n\n        assertFalse(areEqual(new Object[9], new Object[10]));\n\n        assertFalse(areEqual(new int[] {1, 2}, new int[] {1}));\n\n        assertFalse(areEqual(new int[] {1}, new double[] {1.0}));\n\n    }\n"
      }
    }
  },
  "Mockito-24": {
    "id": "Mockito-24",
    "project": "Mockito",
    "number": "24",
    "buggy_function": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        //see issue 184.\n        //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n        //Only for compareTo() method by the Comparable interface\n        return 1;\n    }\n    \n    Class<?> returnType = invocation.getMethod().getReturnType();\n    return returnValueFor(returnType);\n}",
    "fixed_function": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        //see issue 184.\n        //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n        //Only for compareTo() method by the Comparable interface\n        return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n    }\n    \n    Class<?> returnType = invocation.getMethod().getReturnType();\n    return returnValueFor(returnType);\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
      "first_line": 63,
      "last_line": 81
    },
    "javadoc": "/**\n* Default answer of every Mockito mock.\n* <ul>\n* <li>\n*  Returns appropriate primitive for primitive-returning methods\n* </li>\n* <li>\n*  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n* </li>\n* <li>\n*  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n* </li>\n* <li>\n*  Returns description of mock for toString() method\n* </li>\n* <li>\n*  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n* </li>\n* <li>\n*  Returns null for everything else\n* </li>\n* </ul>\n*/\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n\nprivate static final long serialVersionUID = 1998191268711234347L;\nObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\nMockUtil mockUtil = new MockUtil();\n\n/* (non-Javadoc)\n* @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n*/",
    "failing_tests": {
      "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest::should_return_zero_if_mock_is_compared_to_itself": {
        "source": "    @Test public void should_return_zero_if_mock_is_compared_to_itself() {\n\n        //given\n\n        Date d = mock(Date.class);\n\n        d.compareTo(d);\n\n        Invocation compareTo = this.getLastInvocation();\n\n\n\n        //when\n\n        Object result = values.answer(compareTo);\n\n\n\n        //then\n\n        assertEquals(0, result);\n\n    }\n"
      },
      "org.mockitousage.bugs.ShouldMocksCompareToBeConsistentWithEqualsTest::should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference": {
        "source": "    public void should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference() {\n\n        //given\n\n        Date today    = mock(Date.class);\n\n\n\n        //when\n\n        Set<Date> set = new TreeSet<Date>();\n\n        set.add(today);\n\n        set.add(today);\n\n\n\n        //then\n\n        assertEquals(1, set.size());\n\n    }\n"
      }
    }
  },
  "Mockito-27": {
    "id": "Mockito-27",
    "project": "Mockito",
    "number": "27",
    "buggy_function": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    ((Factory) mock).setCallback(0, newFilter);\n}",
    "fixed_function": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n    ((Factory) mock).setCallback(0, newFilter);\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/util/MockUtil.java",
      "first_line": 62,
      "last_line": 67
    },
    "javadoc": "/*\n* Copyright (c) 2007 Mockito contributors\n* This program is made available under the terms of the MIT License.\n*/",
    "failing_tests": {
      "org.mockitousage.bugs.ListenersLostOnResetMockTest::listener": {
        "source": "    public void listener() throws Exception {\n\n        InvocationListener invocationListener = mock(InvocationListener.class);\n\n\n\n        List mockedList = mock(List.class, withSettings().invocationListeners(invocationListener));\n\n        reset(mockedList);\n\n\n\n        mockedList.clear();\n\n\n\n        verify(invocationListener).reportInvocation(any(MethodInvocationReport.class));\n\n    }\n"
      }
    }
  },
  "Mockito-28": {
    "id": "Mockito-28",
    "project": "Mockito",
    "number": "28",
    "buggy_function": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n}",
    "fixed_function": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        mocks.remove(injected);\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/configuration/DefaultInjectionEngine.java",
      "first_line": 91,
      "last_line": 95
    },
    "javadoc": "// for each field in the class hierarchy",
    "failing_tests": {
      "org.mockitousage.bugs.InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest::mock_should_be_injected_once_and_in_the_best_matching_type": {
        "source": "    public void mock_should_be_injected_once_and_in_the_best_matching_type() {\n\n        assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);\n\n        assertSame(mockedBean, illegalInjectionExample.mockShouldGoInHere);\n\n    }\n"
      }
    }
  },
  "Mockito-29": {
    "id": "Mockito-29",
    "project": "Mockito",
    "number": "29",
    "buggy_function": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}",
    "fixed_function": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted == null ? \"null\" : wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/matchers/Same.java",
      "first_line": 26,
      "last_line": 32
    },
    "javadoc": "/*\n* Copyright (c) 2007 Mockito contributors\n* This program is made available under the terms of the MIT License.\n*/",
    "failing_tests": {
      "org.mockitousage.bugs.NPEWithCertainMatchersTest::shouldNotThrowNPEWhenNullPassedToSame": {
        "source": "    public void shouldNotThrowNPEWhenNullPassedToSame() {\n\n        mock.objectArgMethod(\"not null\");\n\n\n\n        verify(mock).objectArgMethod(same(null));\n\n    }\n"
      }
    }
  },
  "Mockito-33": {
    "id": "Mockito-33",
    "project": "Mockito",
    "number": "33",
    "buggy_function": "public boolean hasSameMethod(Invocation candidate) {        \n    //not using method.equals() for 1 good reason:\n    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n    \n    \t/* Avoid unnecessary cloning */\n    return m1.equals(m2);\n}",
    "fixed_function": "public boolean hasSameMethod(Invocation candidate) {        \n    //not using method.equals() for 1 good reason:\n    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n    \n    if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n    \t/* Avoid unnecessary cloning */\n    \tClass[] params1 = m1.getParameterTypes();\n    \tClass[] params2 = m2.getParameterTypes();\n    \tif (params1.length == params2.length) {\n    \t    for (int i = 0; i < params1.length; i++) {\n    \t\tif (params1[i] != params2[i])\n    \t\t    return false;\n    \t    }\n    \t    return true;\n    \t}\n    }\n    return false;\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/invocation/InvocationMatcher.java",
      "first_line": 92,
      "last_line": 100
    },
    "javadoc": "/**\n* similar means the same method name, same mock, unverified\n* and: if arguments are the same cannot be overloaded\n*/",
    "failing_tests": {
      "org.mockitousage.bugs.InheritedGenericsPolimorphicCallTest::shouldStubbingWork": {
        "source": "    public void shouldStubbingWork() {\n\n        Mockito.when(iterable.iterator()).thenReturn(myIterator);\n\n        Assert.assertNotNull(((Iterable) iterable).iterator());\n\n        Assert.assertNotNull(iterable.iterator());\n\n    }\n"
      },
      "org.mockitousage.bugs.InheritedGenericsPolimorphicCallTest::shouldVerificationWorks": {
        "source": "    public void shouldVerificationWorks() {\n\n        iterable.iterator();\n\n        \n\n        verify(iterable).iterator();\n\n        verify((Iterable) iterable).iterator();\n\n    }\n"
      }
    }
  },
  "Mockito-34": {
    "id": "Mockito-34",
    "project": "Mockito",
    "number": "34",
    "buggy_function": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n        if (m instanceof CapturesArguments) {\n            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}",
    "fixed_function": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n        if (m instanceof CapturesArguments && i.getArguments().length > k) {\n            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/invocation/InvocationMatcher.java",
      "first_line": 103,
      "last_line": 111
    },
    "javadoc": "/**\n* similar means the same method name, same mock, unverified\n* and: if arguments are the same cannot be overloaded\n*/",
    "failing_tests": {
      "org.mockito.internal.invocation.InvocationMatcherTest::shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch": {
        "source": "    public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n\n        //given\n\n        mock.varargs();\n\n        Invocation invocation = getLastInvocation();\n\n\n\n        //when\n\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n\n\n        //then\n\n        invocationMatcher.captureArgumentsFrom(invocation);\n\n    }\n"
      },
      "org.mockitousage.basicapi.UsingVarargsTest::shouldMatchEasilyEmptyVararg": {
        "source": "    public void shouldMatchEasilyEmptyVararg() throws Exception {\n\n        //when\n\n        when(mock.foo(anyVararg())).thenReturn(-1);\n\n\n\n        //then\n\n        assertEquals(-1, mock.foo());\n\n    } \n"
      }
    }
  },
  "Mockito-38": {
    "id": "Mockito-38",
    "project": "Mockito",
    "number": "38",
    "buggy_function": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg.toString());\n}",
    "fixed_function": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java",
      "first_line": 47,
      "last_line": 49
    },
    "javadoc": "/**\n* Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n*/",
    "failing_tests": {
      "org.mockito.internal.verification.argumentmatching.ArgumentMatchingToolTest::shouldWorkFineWhenGivenArgIsNull": {
        "source": "    public void shouldWorkFineWhenGivenArgIsNull() {\n\n        //when\n\n        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] {null});\n\n        \n\n        //then\n\n        assertEquals(0, suspicious.length);\n\n    }\n"
      },
      "org.mockitousage.bugs.ActualInvocationHasNullArgumentNPEBugTest::shouldAllowPassingNullArgument": {
        "source": "    public void shouldAllowPassingNullArgument() {\n\n        //given\n\n        Fun mockFun = mock(Fun.class);\n\n        when(mockFun.doFun((String) anyObject())).thenReturn(\"value\");\n\n\n\n        //when\n\n        mockFun.doFun(null);\n\n\n\n        //then\n\n        try {\n\n            verify(mockFun).doFun(\"hello\");\n\n        } catch(AssertionError r) {\n\n            //it's ok, we just want to reproduce the bug\n\n        }\n\n    }\n"
      }
    }
  },
  "Mockito-5": {
    "id": "Mockito-5",
    "project": "Mockito",
    "number": "5",
    "buggy_function": "public void verify(VerificationData data) {\n    AssertionError error = null;\n\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n            error = handleVerifyException(e);\n        }\n    }\n\n    if (error != null) {\n        throw error;\n    }\n}",
    "fixed_function": "public void verify(VerificationData data) {\n    AssertionError error = null;\n\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n        catch (AssertionError e) {\n            error = handleVerifyException(e);\n        }\n    }\n\n    if (error != null) {\n        throw error;\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
      "first_line": 75,
      "last_line": 99
    },
    "javadoc": "/**\n* Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n* before the full duration has passed.\n*\n* In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n* the full duration has passed, the last error returned by the delegate verification mode will be thrown\n* here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n* to never recover from this situation (e.g. {@link AtMost}).\n*\n* If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n* given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n* false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n*\n* @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n*/",
    "failing_tests": {
      "org.mockitointegration.NoJUnitDependenciesTest::pure_mockito_should_not_depend_JUnit": {
        "source": "    public void pure_mockito_should_not_depend_JUnit() throws Exception {\n\n        ClassLoader classLoader_without_JUnit = ClassLoaders.excludingClassLoader()\n\n                .withCodeSourceUrlOf(\n\n                        Mockito.class,\n\n                        Matcher.class,\n\n                        Enhancer.class,\n\n                        Objenesis.class\n\n                )\n\n                .without(\"junit\", \"org.junit\")\n\n                .build();\n\n\n\n        Set<String> pureMockitoAPIClasses = ClassLoaders.in(classLoader_without_JUnit).omit(\"runners\", \"junit\", \"JUnit\").listOwnedClasses();\n\n\n\n        for (String pureMockitoAPIClass : pureMockitoAPIClasses) {\n\n            checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);\n\n        }\n\n    }\n"
      }
    }
  },
  "Mockito-7": {
    "id": "Mockito-7",
    "project": "Mockito",
    "number": "7",
    "buggy_function": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n}",
    "fixed_function": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n    registerTypeParametersOn(new TypeVariable[] { typeVariable });\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
      "first_line": 375,
      "last_line": 380
    },
    "javadoc": "/**\n* Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n*/",
    "failing_tests": {
      "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest::discoverDeepMockingOfGenerics": {
        "source": "  public void discoverDeepMockingOfGenerics() {\n\n    MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);\n\n    when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");\n\n  }\n"
      }
    }
  },
  "Mockito-8": {
    "id": "Mockito-8",
    "project": "Mockito",
    "number": "8",
    "buggy_function": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n        // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n    }\n}",
    "fixed_function": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (typeParameter != actualTypeArgument) {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n        // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n    }\n}",
    "replacement_info": {
      "file": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
      "first_line": 66,
      "last_line": 84
    },
    "javadoc": "/**\n* Represents actual type variables resolved for current class.\n*/",
    "failing_tests": {
      "org.mockito.internal.util.reflection.GenericMetadataSupportTest::typeVariable_of_self_type": {
        "source": "    public void typeVariable_of_self_type() {\n\n        GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod(\"self\", GenericsSelfReference.class));\n\n\n\n        assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);\n\n    }\n"
      }
    }
  },
  "Time-14": {
    "id": "Time-14",
    "project": "Time",
    "number": "14",
    "buggy_function": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n        // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n        }\n        instant = add(instant, valueToAdd);\n        return iChronology.get(partial, instant);\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "fixed_function": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n        // month is largest field and being added to, such as month-day\n        int curMonth0 = partial.getValue(0) - 1;\n        int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n        return set(partial, 0, values, newMonth);\n    }\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n        }\n        instant = add(instant, valueToAdd);\n        return iChronology.get(partial, instant);\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
      "first_line": 203,
      "last_line": 220
    },
    "javadoc": "//-----------------------------------------------------------------------",
    "failing_tests": {
      "org.joda.time.TestMonthDay_Basics::testPlusMonths_int_negativeFromLeap": {
        "source": "    public void testPlusMonths_int_negativeFromLeap() {\n\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.plusMonths(-1);\n\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testMinusDays_int_negativeFromLeap": {
        "source": "    public void testMinusDays_int_negativeFromLeap() {\n\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.minusDays(-1);\n\n        MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testPlusMonths_int_fromLeap": {
        "source": "    public void testPlusMonths_int_fromLeap() {\n\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.plusMonths(1);\n\n        MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testPlusMonths_int_negativeEndOfMonthAdjust": {
        "source": "    public void testPlusMonths_int_negativeEndOfMonthAdjust() {\n\n        MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.plusMonths(-1);\n\n        MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testMinusMonths_int_endOfMonthAdjust": {
        "source": "    public void testMinusMonths_int_endOfMonthAdjust() {\n\n        MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.minusMonths(1);\n\n        MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testMinusMonths_int_negativeFromLeap": {
        "source": "    public void testMinusMonths_int_negativeFromLeap() {\n\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.minusMonths(-1);\n\n        MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testMinusMonths_int_fromLeap": {
        "source": "    public void testMinusMonths_int_fromLeap() {\n\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.minusMonths(1);\n\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      },
      "org.joda.time.TestMonthDay_Basics::testPlusDays_int_fromLeap": {
        "source": "    public void testPlusDays_int_fromLeap() {\n\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n\n        MonthDay result = test.plusDays(1);\n\n        MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n\n        assertEquals(expected, result);\n\n    }\n"
      }
    }
  },
  "Time-15": {
    "id": "Time-15",
    "project": "Time",
    "number": "15",
    "buggy_function": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n    }\n    long total = val1 * val2;\n    if (total / val2 != val1) {\n      throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return total;\n}",
    "fixed_function": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            if (val1 == Long.MIN_VALUE) {\n                throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n            }\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n    }\n    long total = val1 * val2;\n    if (total / val2 != val1) {\n      throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return total;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/field/FieldUtils.java",
      "first_line": 135,
      "last_line": 149
    },
    "javadoc": "/**\n* Multiply two values throwing an exception if overflow occurs.\n*\n* @param val1  the first value\n* @param val2  the second value\n* @return the new total\n* @throws ArithmeticException if the value is too big or too small\n* @since 1.2\n*/",
    "failing_tests": {
      "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt": {
        "source": "    public void testSafeMultiplyLongInt() {\n\n        assertEquals(0L, FieldUtils.safeMultiply(0L, 0));\n\n        \n\n        assertEquals(1L, FieldUtils.safeMultiply(1L, 1));\n\n        assertEquals(3L, FieldUtils.safeMultiply(1L, 3));\n\n        assertEquals(3L, FieldUtils.safeMultiply(3L, 1));\n\n        \n\n        assertEquals(6L, FieldUtils.safeMultiply(2L, 3));\n\n        assertEquals(-6L, FieldUtils.safeMultiply(2L, -3));\n\n        assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3));\n\n        assertEquals(6L, FieldUtils.safeMultiply(-2L, -3));\n\n        \n\n        assertEquals(-1L * Integer.MIN_VALUE, FieldUtils.safeMultiply(-1L, Integer.MIN_VALUE));\n\n        \n\n        assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1));\n\n        assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1));\n\n        assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1));\n\n        \n\n        try {\n\n            FieldUtils.safeMultiply(Long.MIN_VALUE, -1);\n\n            fail();\n\n        } catch (ArithmeticException e) {\n\n        }\n\n        \n\n        try {\n\n            FieldUtils.safeMultiply(Long.MIN_VALUE, 100);\n\n            fail();\n\n        } catch (ArithmeticException e) {\n\n        }\n\n        \n\n        try {\n\n            FieldUtils.safeMultiply(Long.MIN_VALUE, Integer.MAX_VALUE);\n\n            fail();\n\n        } catch (ArithmeticException e) {\n\n        }\n\n        \n\n        try {\n\n            FieldUtils.safeMultiply(Long.MAX_VALUE, Integer.MIN_VALUE);\n\n            fail();\n\n        } catch (ArithmeticException e) {\n\n        }\n\n    }\n"
      }
    }
  },
  "Time-16": {
    "id": "Time-16",
    "project": "Time",
    "number": "16",
    "buggy_function": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
    "fixed_function": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "first_line": 697,
      "last_line": 724
    },
    "javadoc": "/**\n* Parses a datetime from the given text, at the given position, saving the\n* result into the fields of the given ReadWritableInstant. If the parse\n* succeeds, the return value is the new text position. Note that the parse\n* may succeed without fully reading the text and in this case those fields\n* that were read will be set.\n* <p>\n* Only those fields present in the string will be changed in the specified\n* instant. All other fields will remain unaltered. Thus if the string only\n* contains a year and a month, then the day and time will be retained from\n* the input instant. If this is not the behaviour you want, then reset the\n* fields before calling this method, or use {@link #parseDateTime(String)}\n* or {@link #parseMutableDateTime(String)}.\n* <p>\n* If it fails, the return value is negative, but the instant may still be\n* modified. To determine the position where the parse failed, apply the\n* one's complement operator (~) on the return value.\n* <p>\n* This parse method ignores the {@link #getDefaultYear() default year} and\n* parses using the year from the supplied instant as the default.\n* <p>\n* The parse will use the chronology of the instant.\n*\n* @param instant  an instant that will be modified, not null\n* @param text  the text to parse\n* @param position  position to start parsing from\n* @return new position, negative value means parse failed -\n*  apply complement operator (~) to get position of failure\n* @throws UnsupportedOperationException if parsing is not supported\n* @throws IllegalArgumentException if the instant is null\n* @throws IllegalArgumentException if any field is out of range\n*/",
    "failing_tests": {
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthOnly_baseStartYear": {
        "source": "    public void testParseInto_monthOnly_baseStartYear() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO);\n\n        assertEquals(1, f.parseInto(result, \"5\", 0));\n\n        assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result);\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthOnly_parseStartYear": {
        "source": "    public void testParseInto_monthOnly_parseStartYear() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 2, 1, 12, 20, 30, 0, TOKYO);\n\n        assertEquals(1, f.parseInto(result, \"1\", 0));\n\n        assertEquals(new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO), result);\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthOnly_baseEndYear": {
        "source": "    public void testParseInto_monthOnly_baseEndYear() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO);\n\n        assertEquals(1, f.parseInto(result, \"5\", 0));\n\n        assertEquals(new MutableDateTime(2004, 5, 31, 12, 20, 30, 0, TOKYO), result);\n\n   }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthOnly": {
        "source": "    public void testParseInto_monthOnly() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n\n        assertEquals(1, f.parseInto(result, \"5\", 0));\n\n        assertEquals(new MutableDateTime(2004, 5, 9, 12, 20, 30, 0, LONDON), result);\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthDay_withDefaultYear_feb29": {
        "source": "    public void testParseInto_monthDay_withDefaultYear_feb29() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withDefaultYear(2012);\n\n        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n\n        assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthDay_feb29": {
        "source": "    public void testParseInto_monthDay_feb29() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n\n        assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthOnly_parseEndYear": {
        "source": "    public void testParseInto_monthOnly_parseEndYear() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 1, 31, 12, 20, 30, 0,TOKYO);\n\n        assertEquals(2, f.parseInto(result, \"12\", 0));\n\n        assertEquals(new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO), result);\n\n    }\n"
      }
    }
  },
  "Time-17": {
    "id": "Time-17",
    "project": "Time",
    "number": "17",
    "buggy_function": "public long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n    \n    // calculate result\n      // currently in later offset\n      // currently in earlier offset\n}",
    "fixed_function": "public long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long offsetBefore = getOffset(instantBefore);\n    long offsetAfter = getOffset(instantAfter);\n    if (offsetBefore <= offsetAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long diff = offsetBefore - offsetAfter;\n    long transition = nextTransition(instantBefore);\n    long overlapStart = transition - diff;\n    long overlapEnd = transition + diff;\n    if (instant < overlapStart || instant >= overlapEnd) {\n      return instant;  // not an overlap\n    }\n    \n    // calculate result\n    long afterStart = instant - overlapStart;\n    if (afterStart >= diff) {\n      // currently in later offset\n      return earlierOrLater ? instant : instant - diff;\n    } else {\n      // currently in earlier offset\n      return earlierOrLater ? instant + diff : instant;\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/DateTimeZone.java",
      "first_line": 1163,
      "last_line": 1180
    },
    "javadoc": "/**\n* Adjusts the offset to be the earlier or later one during an overlap.\n*\n* @param instant  the instant to adjust\n* @param earlierOrLater  false for earlier, true for later\n* @return the adjusted instant millis\n*/",
    "failing_tests": {
      "org.joda.time.TestDateTimeZoneCutover::testBug3476684_adjustOffset": {
        "source": "    public void testBug3476684_adjustOffset() {\n\n        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n\n        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n\n        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n\n        \n\n        assertSame(base, base.withEarlierOffsetAtOverlap());\n\n        assertSame(base, base.withLaterOffsetAtOverlap());\n\n        \n\n        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n\n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n\n        \n\n        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n\n        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n\n    }\n"
      }
    }
  },
  "Time-18": {
    "id": "Time-18",
    "project": "Time",
    "number": "18",
    "buggy_function": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                              int hourOfDay, int minuteOfHour,\n                              int secondOfMinute, int millisOfSecond)\n    throws IllegalArgumentException\n{\n    Chronology base;\n    if ((base = getBase()) != null) {\n        return base.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n\n    // Assume date is Gregorian.\n    long instant;\n        instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    if (instant < iCutoverMillis) {\n        // Maybe it's Julian.\n        instant = iJulianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant >= iCutoverMillis) {\n            // Okay, it's in the illegal cutover gap.\n            throw new IllegalArgumentException(\"Specified date does not exist\");\n        }\n    }\n    return instant;\n}",
    "fixed_function": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                              int hourOfDay, int minuteOfHour,\n                              int secondOfMinute, int millisOfSecond)\n    throws IllegalArgumentException\n{\n    Chronology base;\n    if ((base = getBase()) != null) {\n        return base.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n\n    // Assume date is Gregorian.\n    long instant;\n    try {\n        instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    } catch (IllegalFieldValueException ex) {\n        if (monthOfYear != 2 || dayOfMonth != 29) {\n            throw ex;\n        }\n        instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, 28,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant >= iCutoverMillis) {\n            throw ex;\n        }\n    }\n    if (instant < iCutoverMillis) {\n        // Maybe it's Julian.\n        instant = iJulianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant >= iCutoverMillis) {\n            // Okay, it's in the illegal cutover gap.\n            throw new IllegalArgumentException(\"Specified date does not exist\");\n        }\n    }\n    return instant;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/chrono/GJChronology.java",
      "first_line": 350,
      "last_line": 378
    },
    "javadoc": "// Okay, it's in the illegal cutover gap.",
    "failing_tests": {
      "org.joda.time.chrono.TestGJChronology::testLeapYearRulesConstruction": {
        "source": "    public void testLeapYearRulesConstruction() {\n\n        // 1500 not leap in Gregorian, but is leap in Julian\n\n        DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC());\n\n        assertEquals(dt.getYear(), 1500);\n\n        assertEquals(dt.getMonthOfYear(), 2);\n\n        assertEquals(dt.getDayOfMonth(), 29);\n\n    }\n"
      }
    }
  },
  "Time-19": {
    "id": "Time-19",
    "project": "Time",
    "number": "19",
    "buggy_function": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal > 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
    "fixed_function": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal >= 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/DateTimeZone.java",
      "first_line": 880,
      "last_line": 911
    },
    "javadoc": "/**\n* Gets the millisecond offset to subtract from local time to get UTC time.\n* This offset can be used to undo adding the offset obtained by getOffset.\n*\n* <pre>\n* millisLocal == millisUTC   + getOffset(millisUTC)\n* millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n* </pre>\n*\n* NOTE: After calculating millisLocal, some error may be introduced. At\n* offset transitions (due to DST or other historical changes), ranges of\n* local times may map to different UTC times.\n* <p>\n* This method will return an offset suitable for calculating an instant\n* after any DST gap. For example, consider a zone with a cutover\n* from 01:00 to 01:59:<br />\n* Input: 00:00  Output: 00:00<br />\n* Input: 00:30  Output: 00:30<br />\n* Input: 01:00  Output: 02:00<br />\n* Input: 01:30  Output: 02:30<br />\n* Input: 02:00  Output: 02:00<br />\n* Input: 02:30  Output: 02:30<br />\n* <p>\n* During a DST overlap (where the local time is ambiguous) this method will return\n* the earlier instant. The combination of these two rules is to always favour\n* daylight (summer) time over standard (winter) time.\n* <p>\n* NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n* Prior to v1.5, the DST gap behaviour was also not defined.\n*\n* @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n* @return the millisecond offset to subtract from local time to get UTC time\n*/",
    "failing_tests": {
      "org.joda.time.TestDateTimeZoneCutover::testDateTimeCreation_london": {
        "source": "    public void testDateTimeCreation_london() {\n\n        DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");\n\n        DateTime base = new DateTime(2011, 10, 30, 1, 15, zone);\n\n        assertEquals(\"2011-10-30T01:15:00.000+01:00\", base.toString());\n\n        assertEquals(\"2011-10-30T01:15:00.000Z\", base.plusHours(1).toString());\n\n    }\n"
      }
    }
  },
  "Time-20": {
    "id": "Time-20",
    "project": "Time",
    "number": "20",
    "buggy_function": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n    String str = text.substring(position);\n    for (String id : ALL_IDS) {\n        if (str.startsWith(id)) {\n            bucket.setZone(DateTimeZone.forID(id));\n            return position + id.length();\n        }\n    }\n    return ~position;\n}",
    "fixed_function": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n    String str = text.substring(position);\n    String best = null;\n    for (String id : ALL_IDS) {\n        if (str.startsWith(id)) {\n        \tif (best == null || id.length() > best.length()) {\n        \t\tbest = id;\n        \t}\n        }\n    }\n    if (best != null) {\n        bucket.setZone(DateTimeZone.forID(best));\n        return position + best.length();\n    }\n    return ~position;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
      "first_line": 2540,
      "last_line": 2549
    },
    "javadoc": "// no zone info",
    "failing_tests": {
      "org.joda.time.format.TestDateTimeFormatterBuilder::test_printParseZoneDawsonCreek": {
        "source": "    public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\n\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n\n            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n\n        DateTimeFormatter f = bld.toFormatter();\n\n        \n\n        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\n\n        assertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\n\n        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n\n    }\n"
      }
    }
  },
  "Time-22": {
    "id": "Time-22",
    "project": "Time",
    "number": "22",
    "buggy_function": "protected BasePeriod(long duration) {\n    this(duration, null, null);\n    // bug [3264409]\n}",
    "fixed_function": "protected BasePeriod(long duration) {\n    super();\n    // bug [3264409]\n    iType = PeriodType.time();\n    int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n    iType = PeriodType.standard();\n    iValues = new int[8];\n    System.arraycopy(values, 0, iValues, 4, 4);\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/base/BasePeriod.java",
      "first_line": 221,
      "last_line": 224
    },
    "javadoc": "/**\n* Creates a period from the given millisecond duration with the standard period type\n* and ISO rules, ensuring that the calculation is performed with the time-only period type.\n* <p>\n* The calculation uses the hour, minute, second and millisecond fields.\n*\n* @param duration  the duration, in milliseconds\n*/",
    "failing_tests": {
      "org.joda.time.TestDuration_Basics::testToPeriod_fixedZone": {
        "source": "    public void testToPeriod_fixedZone() throws Throwable {\n\n        DateTimeZone zone = DateTimeZone.getDefault();\n\n        try {\n\n            DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n\n            long length =\n\n                (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n\n                5L * DateTimeConstants.MILLIS_PER_HOUR +\n\n                6L * DateTimeConstants.MILLIS_PER_MINUTE +\n\n                7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n\n            Duration dur = new Duration(length);\n\n            Period test = dur.toPeriod();\n\n            assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n\n            assertEquals(0, test.getMonths());\n\n            assertEquals(0, test.getWeeks());\n\n            assertEquals(0, test.getDays());\n\n            assertEquals((450 * 24) + 5, test.getHours());\n\n            assertEquals(6, test.getMinutes());\n\n            assertEquals(7, test.getSeconds());\n\n            assertEquals(8, test.getMillis());\n\n        } finally {\n\n            DateTimeZone.setDefault(zone);\n\n        }\n\n    }\n"
      },
      "org.joda.time.TestPeriod_Constructors::testConstructor_long_fixedZone": {
        "source": "    public void testConstructor_long_fixedZone() throws Throwable {\n\n        DateTimeZone zone = DateTimeZone.getDefault();\n\n        try {\n\n            DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n\n            long length =\n\n                (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n\n                5L * DateTimeConstants.MILLIS_PER_HOUR +\n\n                6L * DateTimeConstants.MILLIS_PER_MINUTE +\n\n                7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n\n            Period test = new Period(length);\n\n            assertEquals(PeriodType.standard(), test.getPeriodType());\n\n            // only time fields are precise in AllType\n\n            assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n\n            assertEquals(0, test.getMonths());\n\n            assertEquals(0, test.getWeeks());\n\n            assertEquals(0, test.getDays());\n\n            assertEquals((450 * 24) + 5, test.getHours());\n\n            assertEquals(6, test.getMinutes());\n\n            assertEquals(7, test.getSeconds());\n\n            assertEquals(8, test.getMillis());\n\n        } finally {\n\n            DateTimeZone.setDefault(zone);\n\n        }\n\n    }\n"
      }
    }
  },
  "Time-23": {
    "id": "Time-23",
    "project": "Time",
    "number": "23",
    "buggy_function": "private static synchronized String getConvertedId(String id) {\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        // Backwards compatibility with TimeZone.\n        map = new HashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n        map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n        map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n        map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n        map.put(\"IET\", \"America/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"WET\", \"Europe/London\");\n        map.put(\"ECT\", \"Europe/Paris\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EET\", \"Europe/Bucharest\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"MET\", \"Asia/Tehran\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Calcutta\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Saigon\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
    "fixed_function": "private static synchronized String getConvertedId(String id) {\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        // Backwards compatibility with TimeZone.\n        map = new HashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"WET\", \"WET\");\n        map.put(\"CET\", \"CET\");\n        map.put(\"MET\", \"CET\");\n        map.put(\"ECT\", \"CET\");\n        map.put(\"EET\", \"EET\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n        map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n        map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n        map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n        map.put(\"IET\", \"America/Indiana/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Kolkata\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/DateTimeZone.java",
      "first_line": 558,
      "last_line": 598
    },
    "javadoc": "/**\n* Converts an old style id to a new style id.\n*\n* @param id  the old style id\n* @return the new style id, null if not found\n*/",
    "failing_tests": {
      "org.joda.time.TestDateTimeZone::testForID_String_old": {
        "source": "    public void testForID_String_old() {\n\n        Map<String, String> map = new LinkedHashMap<String, String>();\n\n        map.put(\"GMT\", \"UTC\");\n\n        map.put(\"WET\", \"WET\");\n\n        map.put(\"CET\", \"CET\");\n\n        map.put(\"MET\", \"CET\");\n\n        map.put(\"ECT\", \"CET\");\n\n        map.put(\"EET\", \"EET\");\n\n        map.put(\"MIT\", \"Pacific/Apia\");\n\n        map.put(\"HST\", \"Pacific/Honolulu\");\n\n        map.put(\"AST\", \"America/Anchorage\");\n\n        map.put(\"PST\", \"America/Los_Angeles\");\n\n        map.put(\"MST\", \"America/Denver\");\n\n        map.put(\"PNT\", \"America/Phoenix\");\n\n        map.put(\"CST\", \"America/Chicago\");\n\n        map.put(\"EST\", \"America/New_York\");\n\n        map.put(\"IET\", \"America/Indiana/Indianapolis\");\n\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n\n        map.put(\"CNT\", \"America/St_Johns\");\n\n        map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n\n        map.put(\"BET\", \"America/Sao_Paulo\");\n\n        map.put(\"ART\", \"Africa/Cairo\");\n\n        map.put(\"CAT\", \"Africa/Harare\");\n\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n\n        map.put(\"NET\", \"Asia/Yerevan\");\n\n        map.put(\"PLT\", \"Asia/Karachi\");\n\n        map.put(\"IST\", \"Asia/Kolkata\");\n\n        map.put(\"BST\", \"Asia/Dhaka\");\n\n        map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n\n        map.put(\"CTT\", \"Asia/Shanghai\");\n\n        map.put(\"JST\", \"Asia/Tokyo\");\n\n        map.put(\"ACT\", \"Australia/Darwin\");\n\n        map.put(\"AET\", \"Australia/Sydney\");\n\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n\n        map.put(\"NST\", \"Pacific/Auckland\");\n\n        for (String key : map.keySet()) {\n\n            String value = map.get(key);\n\n            TimeZone juZone = TimeZone.getTimeZone(key);\n\n            DateTimeZone zone = DateTimeZone.forTimeZone(juZone);\n\n            assertEquals(value, zone.getID());\n\n//            System.out.println(juZone);\n\n//            System.out.println(juZone.getDisplayName());\n\n//            System.out.println(zone);\n\n//            System.out.println(\"------\");\n\n        }\n\n    }\n"
      }
    }
  },
  "Time-24": {
    "id": "Time-24",
    "project": "Time",
    "number": "24",
    "buggy_function": "public long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}",
    "fixed_function": "public long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n        if (resetFields) {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, i == (count - 1));\n            }\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
      "first_line": 331,
      "last_line": 378
    },
    "javadoc": "/**\n* Computes the parsed datetime by setting the saved fields.\n* This method is idempotent, but it is not thread-safe.\n*\n* @param resetFields false by default, but when true, unsaved field values are cleared\n* @param text optional text being parsed, to be included in any error message\n* @return milliseconds since 1970-01-01T00:00:00Z\n* @throws IllegalArgumentException if any field is out of range\n* @since 1.3\n*/",
    "failing_tests": {
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_weekyear_month_week_2010": {
        "source": "    public void testParseLocalDate_weekyear_month_week_2010() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_weekyear_month_week_2011": {
        "source": "    public void testParseLocalDate_weekyear_month_week_2011() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_weekyear_month_week_2012": {
        "source": "    public void testParseLocalDate_weekyear_month_week_2012() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_year_month_week_2010": {
        "source": "    public void testParseLocalDate_year_month_week_2010() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_year_month_week_2011": {
        "source": "    public void testParseLocalDate_year_month_week_2011() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_year_month_week_2012": {
        "source": "    public void testParseLocalDate_year_month_week_2012() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_year_month_week_2016": {
        "source": "    public void testParseLocalDate_year_month_week_2016() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));\n\n    }\n"
      }
    }
  },
  "Time-25": {
    "id": "Time-25",
    "project": "Time",
    "number": "25",
    "buggy_function": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
    "fixed_function": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal > 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/DateTimeZone.java",
      "first_line": 879,
      "last_line": 901
    },
    "javadoc": "/**\n* Gets the millisecond offset to subtract from local time to get UTC time.\n* This offset can be used to undo adding the offset obtained by getOffset.\n*\n* <pre>\n* millisLocal == millisUTC   + getOffset(millisUTC)\n* millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n* </pre>\n*\n* NOTE: After calculating millisLocal, some error may be introduced. At\n* offset transitions (due to DST or other historical changes), ranges of\n* local times may map to different UTC times.\n* <p>\n* This method will return an offset suitable for calculating an instant\n* after any DST gap. For example, consider a zone with a cutover\n* from 01:00 to 01:59:<br />\n* Input: 00:00  Output: 00:00<br />\n* Input: 00:30  Output: 00:30<br />\n* Input: 01:00  Output: 02:00<br />\n* Input: 01:30  Output: 02:30<br />\n* Input: 02:00  Output: 02:00<br />\n* Input: 02:30  Output: 02:30<br />\n* <p>\n* During a DST overlap (where the local time is ambiguous) this method will return\n* the earlier instant. The combination of these two rules is to always favour\n* daylight (summer) time over standard (winter) time.\n* <p>\n* NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n* Prior to v1.5, the DST gap behaviour was also not defined.\n*\n* @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n* @return the millisecond offset to subtract from local time to get UTC time\n*/",
    "failing_tests": {
      "org.joda.time.TestDateTimeZoneCutover::test_DateTime_constructor_Moscow_Autumn": {
        "source": "    public void test_DateTime_constructor_Moscow_Autumn() {\n\n        DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\n\n        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());\n\n    }\n"
      },
      "org.joda.time.TestDateTimeZoneCutover::test_getOffsetFromLocal_Moscow_Autumn_overlap_mins": {
        "source": "    public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\n\n        for (int min = 0; min < 60; min++) {\n\n            if (min < 10) {\n\n                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n\n            } else {\n\n                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n\n            }\n\n        }\n\n    }\n"
      },
      "org.joda.time.TestDateTimeZoneCutover::test_getOffsetFromLocal_Moscow_Autumn": {
        "source": "    public void test_getOffsetFromLocal_Moscow_Autumn() {\n\n        doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n\n        \n\n        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 2,30,59,999, \"2007-10-28T02:30:59.999+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 2,59,59,998, \"2007-10-28T02:59:59.998+04:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 2,59,59,999, \"2007-10-28T02:59:59.999+04:00\", ZONE_MOSCOW);\n\n        \n\n        doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n\n        doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n\n    }\n"
      }
    }
  },
  "Time-27": {
    "id": "Time-27",
    "project": "Time",
    "number": "27",
    "buggy_function": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n    if (notPrinter && notParser) {\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    int size = elementPairs.size();\n    if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n        Separator sep = (Separator) elementPairs.get(0);\n            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n            sep = sep.finish(f.getPrinter(), f.getParser());\n            return new PeriodFormatter(sep, sep);\n    }\n    Object[] comp = createComposite(elementPairs);\n    if (notPrinter) {\n        return new PeriodFormatter(null, (PeriodParser) comp[1]);\n    } else if (notParser) {\n        return new PeriodFormatter((PeriodPrinter) comp[0], null);\n    } else {\n        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n    }\n}",
    "fixed_function": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n    if (notPrinter && notParser) {\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    int size = elementPairs.size();\n    if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n        Separator sep = (Separator) elementPairs.get(0);\n        if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n            sep = sep.finish(f.getPrinter(), f.getParser());\n            return new PeriodFormatter(sep, sep);\n        }\n    }\n    Object[] comp = createComposite(elementPairs);\n    if (notPrinter) {\n        return new PeriodFormatter(null, (PeriodParser) comp[1]);\n    } else if (notParser) {\n        return new PeriodFormatter((PeriodPrinter) comp[0], null);\n    } else {\n        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n    }\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java",
      "first_line": 794,
      "last_line": 813
    },
    "javadoc": "//-----------------------------------------------------------------------",
    "failing_tests": {
      "org.joda.time.format.TestPeriodFormatterBuilder::testBug2495455": {
        "source": "    public void testBug2495455() {\n\n        PeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n\n            .appendLiteral(\"P\")\n\n            .appendYears()\n\n            .appendSuffix(\"Y\")\n\n            .appendMonths()\n\n            .appendSuffix(\"M\")\n\n            .appendWeeks()\n\n            .appendSuffix(\"W\")\n\n            .appendDays()\n\n            .appendSuffix(\"D\")\n\n            .appendSeparatorIfFieldsAfter(\"T\")\n\n            .appendHours()\n\n            .appendSuffix(\"H\")\n\n            .appendMinutes()\n\n            .appendSuffix(\"M\")\n\n            .appendSecondsWithOptionalMillis()\n\n            .appendSuffix(\"S\")\n\n            .toFormatter();\n\n        PeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n\n            .append(ISOPeriodFormat.standard())\n\n            .toFormatter();\n\n        pfmt1.parsePeriod(\"PT1003199059S\");\n\n        pfmt2.parsePeriod(\"PT1003199059S\");\n\n    }\n"
      }
    }
  },
  "Time-4": {
    "id": "Time-4",
    "project": "Time",
    "number": "4",
    "buggy_function": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        \n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        // use public constructor to ensure full validation\n        // this isn't overly efficient, but is safe\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}",
    "fixed_function": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        \n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        // use public constructor to ensure full validation\n        // this isn't overly efficient, but is safe\n        Partial newPartial = new Partial(newTypes, newValues, iChronology);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/Partial.java",
      "first_line": 426,
      "last_line": 474
    },
    "javadoc": "/**\n* Gets a copy of this date with the specified field set to a new value.\n* <p>\n* If this partial did not previously support the field, the new one will.\n* Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n* <p>\n* For example, if the field type is <code>dayOfMonth</code> then the day\n* would be changed/added in the returned instance.\n*\n* @param fieldType  the field type to set, not null\n* @param value  the value to set\n* @return a copy of this instance with the field set\n* @throws IllegalArgumentException if the value is null or invalid\n*/",
    "failing_tests": {
      "org.joda.time.TestPartial_Basics::testWith3": {
        "source": "    public void testWith3() {\n\n        Partial test = createHourMinPartial();\n\n        try {\n\n            test.with(DateTimeFieldType.clockhourOfDay(), 6);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        check(test, 10, 20);\n\n    }\n"
      }
    }
  },
  "Time-5": {
    "id": "Time-5",
    "project": "Time",
    "number": "5",
    "buggy_function": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n    int years = getYears();\n    int months = getMonths();\n    if (years != 0 || months != 0) {\n        years = FieldUtils.safeAdd(years, months / 12);\n        months = months % 12;\n        if (years != 0) {\n            result = result.withYears(years);\n        }\n        if (months != 0) {\n            result = result.withMonths(months);\n        }\n    }\n    return result;\n}",
    "fixed_function": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n    int years = getYears();\n    int months = getMonths();\n    if (years != 0 || months != 0) {\n        long totalMonths = years * 12L + months;\n        if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n            int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n            result = result.withYears(normalizedYears);\n            totalMonths = totalMonths - (normalizedYears * 12);\n        }\n        if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n            int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n            result = result.withMonths(normalizedMonths);\n            totalMonths = totalMonths - normalizedMonths;\n        }\n        if (totalMonths != 0) {\n            throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n        }\n    }\n    return result;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/Period.java",
      "first_line": 1616,
      "last_line": 1638
    },
    "javadoc": "/**\n* Normalizes this period using standard rules, assuming a 12 month year,\n* 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n* providing control over how the result is split into fields.\n* <p>\n* This method allows you to normalize a period.\n* However to achieve this it makes the assumption that all years are\n* 12 months, all weeks are 7 days, all days are 24 hours,\n* all hours are 60 minutes and all minutes are 60 seconds. This is not\n* true when daylight savings time is considered, and may also not be true\n* for some chronologies. However, it is included as it is a useful operation\n* for many applications and business rules.\n* <p>\n* If the period contains years or months, then the months will be\n* normalized to be between 0 and 11. The days field and below will be\n* normalized as necessary, however this will not overflow into the months\n* field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n* But a period of 1 month 40 days will remain as 1 month 40 days.\n* <p>\n* The PeriodType parameter controls how the result is created. It allows\n* you to omit certain fields from the result if desired. For example,\n* you may not want the result to include weeks, in which case you pass\n* in <code>PeriodType.yearMonthDayTime()</code>.\n*\n* @param type  the period type of the new period, null means standard type\n* @return a normalized period equivalent to this period\n* @throws ArithmeticException if any field is too large to be represented\n* @throws UnsupportedOperationException if this period contains non-zero\n*  years or months but the specified period type does not support them\n* @since 1.5\n*/",
    "failing_tests": {
      "org.joda.time.TestPeriod_Basics::testNormalizedStandard_periodType_months1": {
        "source": "    public void testNormalizedStandard_periodType_months1() {\n\n        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n\n        Period result = test.normalizedStandard(PeriodType.months());\n\n        assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);\n\n        assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n\n    }\n"
      },
      "org.joda.time.TestPeriod_Basics::testNormalizedStandard_periodType_months2": {
        "source": "    public void testNormalizedStandard_periodType_months2() {\n\n        Period test = new Period(-2, 15, 0, 0, 0, 0, 0, 0);\n\n        Period result = test.normalizedStandard(PeriodType.months());\n\n        assertEquals(new Period(-2, 15, 0, 0, 0, 0, 0, 0), test);\n\n        assertEquals(new Period(0, -9, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n\n    }\n"
      },
      "org.joda.time.TestPeriod_Basics::testNormalizedStandard_periodType_monthsWeeks": {
        "source": "    public void testNormalizedStandard_periodType_monthsWeeks() {\n\n        PeriodType type = PeriodType.forFields(new DurationFieldType[]{\n\n                        DurationFieldType.months(),\n\n                        DurationFieldType.weeks(),\n\n                        DurationFieldType.days()});\n\n        Period test = new Period(2, 4, 6, 0, 0, 0, 0, 0);\n\n        Period result = test.normalizedStandard(type);\n\n        assertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test);\n\n        assertEquals(new Period(0, 28, 6, 0, 0, 0, 0, 0, type), result);\n\n    }\n"
      }
    }
  },
  "Time-7": {
    "id": "Time-7",
    "project": "Time",
    "number": "7",
    "buggy_function": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    int defaultYear = chrono.year().get(instantLocal);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
    "fixed_function": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "first_line": 700,
      "last_line": 728
    },
    "javadoc": "/**\n* Parses a datetime from the given text, at the given position, saving the\n* result into the fields of the given ReadWritableInstant. If the parse\n* succeeds, the return value is the new text position. Note that the parse\n* may succeed without fully reading the text and in this case those fields\n* that were read will be set.\n* <p>\n* Only those fields present in the string will be changed in the specified\n* instant. All other fields will remain unaltered. Thus if the string only\n* contains a year and a month, then the day and time will be retained from\n* the input instant. If this is not the behaviour you want, then reset the\n* fields before calling this method, or use {@link #parseDateTime(String)}\n* or {@link #parseMutableDateTime(String)}.\n* <p>\n* If it fails, the return value is negative, but the instant may still be\n* modified. To determine the position where the parse failed, apply the\n* one's complement operator (~) on the return value.\n* <p>\n* This parse method ignores the {@link #getDefaultYear() default year} and\n* parses using the year from the supplied instant based on the chronology\n* and time-zone of the supplied instant.\n* <p>\n* The parse will use the chronology of the instant.\n*\n* @param instant  an instant that will be modified, not null\n* @param text  the text to parse\n* @param position  position to start parsing from\n* @return new position, negative value means parse failed -\n*  apply complement operator (~) to get position of failure\n* @throws UnsupportedOperationException if parsing is not supported\n* @throws IllegalArgumentException if the instant is null\n* @throws IllegalArgumentException if any field is out of range\n*/",
    "failing_tests": {
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthDay_feb29_newYork_startOfYear": {
        "source": "    public void testParseInto_monthDay_feb29_newYork_startOfYear() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK);\n\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n\n        assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n\n    }\n"
      },
      "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthDay_feb29_tokyo_endOfYear": {
        "source": "    public void testParseInto_monthDay_feb29_tokyo_endOfYear() {\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n\n        MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, TOKYO);\n\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n\n        assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, TOKYO), result);\n\n    }\n"
      }
    }
  },
  "Time-8": {
    "id": "Time-8",
    "project": "Time",
    "number": "8",
    "buggy_function": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < 0 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - minutesOffset;\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
    "fixed_function": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
    "replacement_info": {
      "file": "src/main/java/org/joda/time/DateTimeZone.java",
      "first_line": 272,
      "last_line": 295
    },
    "javadoc": "/**\n* Gets a time zone instance for the specified offset to UTC in hours and minutes.\n* This method assumes 60 minutes in an hour, and standard length minutes.\n* <p>\n* This factory is a convenient way of constructing zones with a fixed offset.\n* The hours value must be in the range -23 to +23.\n* The minutes value must be in the range -59 to +59.\n* The following combinations of sign for the hour and minute are possible:\n* <pre>\n*  Hour    Minute    Example    Result\n*\n*  +ve     +ve       (2, 15)    +02:15\n*  +ve     zero      (2, 0)     +02:00\n*  +ve     -ve       (2, -15)   IllegalArgumentException\n*\n*  zero    +ve       (0, 15)    +00:15\n*  zero    zero      (0, 0)     +00:00\n*  zero    -ve       (0, -15)   -00:15\n*\n*  -ve     +ve       (-2, 15)   -02:15\n*  -ve     zero      (-2, 0)    -02:00\n*  -ve     -ve       (-2, -15)  -02:15\n* </pre>\n* Note that in versions before 2.3, the minutes had to be zero or positive.\n*\n* @param hoursOffset  the offset in hours from UTC, from -23 to +23\n* @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n* @return the DateTimeZone object for the offset\n* @throws IllegalArgumentException if any value is out of range, the minutes are negative\n*  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n*/",
    "failing_tests": {
      "org.joda.time.TestDateTimeZone::testForOffsetHoursMinutes_int_int": {
        "source": "    public void testForOffsetHoursMinutes_int_int() {\n\n        assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\n\n        assertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\n\n        \n\n        assertEquals(DateTimeZone.forID(\"+02:15\"), DateTimeZone.forOffsetHoursMinutes(2, 15));\n\n        assertEquals(DateTimeZone.forID(\"+02:00\"), DateTimeZone.forOffsetHoursMinutes(2, 0));\n\n        try {\n\n            DateTimeZone.forOffsetHoursMinutes(2, -15);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        \n\n        assertEquals(DateTimeZone.forID(\"+00:15\"), DateTimeZone.forOffsetHoursMinutes(0, 15));\n\n        assertEquals(DateTimeZone.forID(\"+00:00\"), DateTimeZone.forOffsetHoursMinutes(0, 0));\n\n        assertEquals(DateTimeZone.forID(\"-00:15\"), DateTimeZone.forOffsetHoursMinutes(0, -15));\n\n        \n\n        assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\n\n        assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, -15));\n\n        assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, 15));\n\n        \n\n        assertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\n\n        try {\n\n            DateTimeZone.forOffsetHoursMinutes(2, 60);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            DateTimeZone.forOffsetHoursMinutes(-2, 60);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            DateTimeZone.forOffsetHoursMinutes(24, 0);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n        try {\n\n            DateTimeZone.forOffsetHoursMinutes(-24, 0);\n\n            fail();\n\n        } catch (IllegalArgumentException ex) {}\n\n    }        \n"
      }
    }
  },
  "JacksonDatabind-50": {
    "id": "JacksonDatabind-50",
    "project": "JacksonDatabind",
    "number": "50",
    "buggy_function": "@Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }",
    "fixed_function": "@Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        List<BeanReferring> referrings = null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                } catch (UnresolvedForwardReference reference) {\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                    BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference);\n                    if (referrings == null) {\n                        referrings = new ArrayList<BeanReferring>();\n                    }\n                    referrings.add(referring);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (referrings != null) {\n            for (BeanReferring referring : referrings) {\n               referring.setBean(bean);\n            }\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
      "first_line": 376,
      "last_line": 474
    },
    "javadoc": "/**\n* Method called to deserialize bean using \"property-based creator\":\n* this means that a non-default constructor or factory method is\n* called, and then possibly other setters. The trick is that\n* values for creator method need to be buffered, first; and\n* due to non-guaranteed ordering possibly some other properties\n* as well.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.objectid.ObjectWithCreator1261Test::testObjectIds1261": {
        "source": "    public void testObjectIds1261() throws Exception\n\n    {\n\n         ObjectMapper mapper = new ObjectMapper();\n\n         mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n         mapper.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n\n\n\n         Answer initialAnswer = createInitialAnswer();\n\n         String initialAnswerString = mapper.writeValueAsString(initialAnswer);\n\n// System.out.println(\"Initial answer:\\n\"+initialAnswerString);\n\n         JsonNode tree = mapper.readTree(initialAnswerString);\n\n         Answer deserializedAnswer = mapper.readValue(initialAnswerString,\n\n               Answer.class);\n\n         String reserializedAnswerString = mapper\n\n               .writeValueAsString(deserializedAnswer);\n\n         JsonNode newTree = mapper.readTree(reserializedAnswerString);\n\n         if (!tree.equals(newTree)) {\n\n                  fail(\"Original and recovered Json are different. Recovered = \\n\"\n\n                        + reserializedAnswerString + \"\\n\");\n\n         }\n\n   }\n"
      }
    }
  },
  "Math-15": {
    "id": "Math-15",
    "project": "Math",
    "number": "15",
    "buggy_function": "public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }",
    "fixed_function": "public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math3/util/FastMath.java",
      "first_line": 1441,
      "last_line": 1599
    },
    "javadoc": "/**\n* Power function.  Compute x^y.\n*\n* @param x   a double\n* @param y   a double\n* @return double\n*/",
    "failing_tests": {
      "org.apache.commons.math3.util.FastMathTest::testMath904": {
        "source": "    public void testMath904() {\n\n        final double x = -1;\n\n        final double y = (5 + 1e-15) * 1e15;\n\n        Assert.assertEquals(Math.pow(x, y),\n\n                            FastMath.pow(x, y), 0);\n\n        Assert.assertEquals(Math.pow(x, -y),\n\n                            FastMath.pow(x, -y), 0);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-66": {
    "id": "JacksonDatabind-66",
    "project": "JacksonDatabind",
    "number": "66",
    "buggy_function": "@SuppressWarnings(\"resource\")\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt)\n            throws IOException\n        {\n            if (key == null) { // is this even legal call?\n                return null;\n            }\n            try {\n                // Ugh... should not have to give parser which may or may not be correct one...\n                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n                if (result != null) {\n                    return result;\n                }\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n            } catch (Exception re) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n            }\n        }",
    "fixed_function": "@SuppressWarnings(\"resource\")\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt)\n            throws IOException\n        {\n            if (key == null) { // is this even legal call?\n                return null;\n            }\n            TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n            tb.writeString(key);\n            try {\n                // Ugh... should not have to give parser which may or may not be correct one...\n                JsonParser p = tb.asParser();\n                p.nextToken();\n                Object result = _delegate.deserialize(p, ctxt);\n                if (result != null) {\n                    return result;\n                }\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n            } catch (Exception re) {\n                return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n            }\n        }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
      "first_line": 306,
      "last_line": 324
    },
    "javadoc": "/**\n* Key deserializer that wraps a \"regular\" deserializer (but one\n* that must recognize FIELD_NAMEs as text!) to reuse existing\n* handlers as key handlers.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer::testCustomEnumKeySerializerWithPolymorphic": {
        "source": "    public void testCustomEnumKeySerializerWithPolymorphic() throws IOException\n\n    {\n\n        SimpleModule simpleModule = new SimpleModule();\n\n        simpleModule.addDeserializer(SuperTypeEnum.class, new JsonDeserializer<SuperTypeEnum>() {\n\n            @Override\n\n            public SuperTypeEnum deserialize(JsonParser p, DeserializationContext deserializationContext)\n\n                    throws IOException\n\n            {\n\n                return SuperTypeEnum.valueOf(p.getText());\n\n            }\n\n        });\n\n        ObjectMapper mapper = new ObjectMapper()\n\n                .registerModule(simpleModule);\n\n\n\n        SuperType superType = mapper.readValue(\"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\",\n\n                SuperType.class);\n\n        assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\",\n\n                superType.someMap.get(SuperTypeEnum.FOO));\n\n    }\n"
      }
    }
  },
  "Mockito-9": {
    "id": "Mockito-9",
    "project": "Mockito",
    "number": "9",
    "buggy_function": "public Object answer(InvocationOnMock invocation) throws Throwable {\n        return invocation.callRealMethod();\n    }",
    "fixed_function": "public Object answer(InvocationOnMock invocation) throws Throwable {\n    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n    \t}\n        return invocation.callRealMethod();\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/stubbing/answers/CallsRealMethods.java",
      "first_line": 35,
      "last_line": 37
    },
    "javadoc": "/**\n* Optional Answer that adds partial mocking support\n* <p>\n* {@link Answer} can be used to define the return values of unstubbed invocations.\n* <p>\n* This implementation can be helpful when working with legacy code.\n* When this implementation is used, unstubbed methods will delegate to the real implementation.\n* This is a way to create a partial mock object that calls real methods by default.\n* <p>\n* As usual you are going to read <b>the partial mock warning</b>:\n* Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n* How does partial mock fit into this paradigm? Well, it just doesn't...\n* Partial mock usually means that the complexity has been moved to a different method on the same object.\n* In most cases, this is not the way you want to design your application.\n* <p>\n* However, there are rare cases when partial mocks come handy:\n* dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n* However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n* <p>\n*/",
    "failing_tests": {
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::abstractMethodStubbed": {
        "source": "    public void abstractMethodStubbed() {\n\n    \tAbstractThing thing = spy(AbstractThing.class);\n\n    \twhen(thing.name()).thenReturn(\"me\");\n\n    \tassertEquals(\"abstract me\", thing.fullName());\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::testCallsRealInterfaceMethod": {
        "source": "    public void testCallsRealInterfaceMethod() {\n\n    \tList<String> list = mock(List.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));\n\n    \tassertNull(list.get(1));\n\n    }\n"
      },
      "org.mockitousage.constructor.CreatingMocksWithConstructorTest::abstractMethodReturnsDefault": {
        "source": "    public void abstractMethodReturnsDefault() {\n\n    \tAbstractThing thing = spy(AbstractThing.class);\n\n    \tassertEquals(\"abstract null\", thing.fullName());\n\n    }\n"
      }
    }
  },
  "Cli-39": {
    "id": "Cli-39",
    "project": "Cli",
    "number": "39",
    "buggy_function": "public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }",
    "fixed_function": "public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/TypeHandler.java",
      "first_line": 64,
      "last_line": 106
    },
    "javadoc": "/**\n* Returns the <code>Object</code> of type <code>clazz</code>\n* with the value of <code>str</code>.\n*\n* @param str the command line value\n* @param clazz the type of argument\n* @return The instance of <code>clazz</code> initialised with\n* the value of <code>str</code>.\n* @throws ParseException if the value creation for the given class failed\n*/",
    "failing_tests": {
      "org.apache.commons.cli.PatternOptionBuilderTest::testExistingFilePattern": {
        "source": "    public void testExistingFilePattern() throws Exception\n\n    {\n\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine line = parser.parse(options, new String[] { \"-g\", \"src/test/resources/existing-readable.file\" });\n\n\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n\n\n        assertNotNull(\"option g not parsed\", parsedReadableFileStream);\n\n        assertTrue(\"option g not FileInputStream\", parsedReadableFileStream instanceof FileInputStream);\n\n    }\n"
      },
      "org.apache.commons.cli.PatternOptionBuilderTest::testExistingFilePatternFileNotExist": {
        "source": "    public void testExistingFilePatternFileNotExist() throws Exception {\n\n        final Options options = PatternOptionBuilder.parsePattern(\"f<\");\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine line = parser.parse(options, new String[] { \"-f\", \"non-existing.file\" });\n\n\n\n        assertNull(\"option f parsed\", line.getOptionObject(\"f\"));\n\n    }\n"
      }
    }
  },
  "Mockito-31": {
    "id": "Mockito-31",
    "project": "Mockito",
    "number": "31",
    "buggy_function": "private String formatMethodCall() {\n\t\t\treturn invocation.getMethod().getName() + \"()\";\n\t\t}",
    "fixed_function": "private String formatMethodCall() {\n\t\t\tString args = Arrays.toString(invocation.getArguments());\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\n\t\t}",
    "replacement_info": {
      "file": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
      "first_line": 59,
      "last_line": 61
    },
    "javadoc": "/**\n* Optional Answer that can be used with\n* {@link Mockito#mock(Class, Answer)}\n* <p>\n* This implementation can be helpful when working with legacy code. Unstubbed\n* methods often return null. If your code uses the object returned by an\n* unstubbed call you get a NullPointerException. This implementation of\n* Answer returns SmartNulls instead of nulls.\n* SmartNull gives nicer exception message than NPE because it points out the\n* line where unstubbed method was called. You just click on the stack trace.\n* <p>\n* ReturnsSmartNulls first tries to return ordinary return values (see\n* {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n* return type is not mockable (e.g. final) then ordinary null is returned.\n* <p>\n* ReturnsSmartNulls will be probably the default return values strategy in\n* Mockito 2.0\n*/",
    "failing_tests": {
      "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest::shouldPrintTheParametersWhenCallingAMethodWithArgs": {
        "source": "    public void shouldPrintTheParametersWhenCallingAMethodWithArgs() throws Throwable {\n\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\n\n\n\n    \tFoo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n\n\n\n    \tassertEquals(\"SmartNull returned by unstubbed withArgs(oompa, lumpa) method on mock\", smartNull + \"\");\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-60": {
    "id": "JacksonDatabind-60",
    "project": "JacksonDatabind",
    "number": "60",
    "buggy_function": "@Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer0) throws IOException\n    {\n        // Regardless of other parts, first need to find value to serialize:\n        Object value = null;\n        try {\n            value = _accessorMethod.getValue(bean);\n            // and if we got null, can also just write it directly\n            if (value == null) {\n                provider.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) { // no serializer yet? Need to fetch\n//                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n                ser = provider.findValueSerializer(value.getClass(), _property);\n            } else {\n                /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n                 *    this (note: type is for the wrapper type, not enclosed value!)\n                 */\n                if (_forceTypeInformation) {\n                    typeSer0.writeTypePrefixForScalar(bean, gen);\n                    ser.serialize(value, gen, provider);\n                    typeSer0.writeTypeSuffixForScalar(bean, gen);\n                    return;\n                }\n            }\n            // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n            //    to use different Object for type id (logical type) and actual serialization\n            //    (delegat type).\n            ser.serializeWithType(value, gen, provider, typeSer0);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            // Need to unwrap this specific type, to see infinite recursion...\n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            // Errors shouldn't be wrapped (and often can't, as well)\n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            // let's try to indicate the path best we can...\n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }",
    "fixed_function": "@Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer0) throws IOException\n    {\n        // Regardless of other parts, first need to find value to serialize:\n        Object value = null;\n        try {\n            value = _accessorMethod.getValue(bean);\n            // and if we got null, can also just write it directly\n            if (value == null) {\n                provider.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) { // no serializer yet? Need to fetch\n//                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n                ser = provider.findValueSerializer(value.getClass(), _property);\n            } else {\n                /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n                 *    this (note: type is for the wrapper type, not enclosed value!)\n                 */\n                if (_forceTypeInformation) {\n                    typeSer0.writeTypePrefixForScalar(bean, gen);\n                    ser.serialize(value, gen, provider);\n                    typeSer0.writeTypeSuffixForScalar(bean, gen);\n                    return;\n                }\n            }\n            // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n            //    to use different Object for type id (logical type) and actual serialization\n            //    (delegat type).\n            TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean);\n            ser.serializeWithType(value, gen, provider, rr);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            // Need to unwrap this specific type, to see infinite recursion...\n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            // Errors shouldn't be wrapped (and often can't, as well)\n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            // let's try to indicate the path best we can...\n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java",
      "first_line": 195,
      "last_line": 242
    },
    "javadoc": "// let's try to indicate the path best we can...",
    "failing_tests": {
      "com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators::testWithCreatorAndJsonValue": {
        "source": "    public void testWithCreatorAndJsonValue() throws Exception\n\n    {\n\n        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.enableDefaultTyping();\n\n        String json = mapper.writeValueAsString(new Bean1385Wrapper(\n\n                new Bean1385(BYTES)\n\n        ));\n\n        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);\n\n        assertNotNull(result);\n\n        assertNotNull(result.value);\n\n        assertEquals(Bean1385.class, result.value.getClass());\n\n        Bean1385 b = (Bean1385) result.value;\n\n        Assert.assertArrayEquals(BYTES, b.raw);\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest::testWithAsValue": {
        "source": "    public void testWithAsValue() throws Exception\n\n    {\n\n        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));\n\n        String json = MAPPER.writeValueAsString(input);\n\n        assertNotNull(json);\n\n        assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);\n\n\n\n        // and get it back too:\n\n        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n\n        assertNotNull(result);\n\n        assertNotNull(result.value);\n\n        assertEquals(AsValueThingy.class, result.value.getClass());\n\n        assertEquals(12345L, ((AsValueThingy) result.value).rawDate);\n\n    }\n"
      }
    }
  },
  "Mockito-36": {
    "id": "Mockito-36",
    "project": "Mockito",
    "number": "36",
    "buggy_function": "public Object callRealMethod() throws Throwable {\n        return realMethod.invoke(mock, rawArguments);\n    }",
    "fixed_function": "public Object callRealMethod() throws Throwable {\n        if (this.getMethod().getDeclaringClass().isInterface()) {\n            new Reporter().cannotCallRealMethodOnInterface();\n        }\n        return realMethod.invoke(mock, rawArguments);\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/invocation/Invocation.java",
      "first_line": 201,
      "last_line": 203
    },
    "javadoc": "// in case someone deliberately passed null varArg array",
    "failing_tests": {
      "org.mockito.internal.invocation.InvocationTest::shouldScreamWhenCallingRealMethodOnInterface": {
        "source": "    public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n\n        //given\n\n        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n\n\n\n        try {\n\n            //when\n\n            invocationOnInterface.callRealMethod();\n\n            //then\n\n            fail();\n\n        } catch(MockitoException e) {}\n\n    }\n"
      },
      "org.mockitousage.spies.SpyingOnInterfacesTest::shouldFailInRuntimeWhenCallingRealMethodOnInterface": {
        "source": "    public void shouldFailInRuntimeWhenCallingRealMethodOnInterface() throws Exception {\n\n        //given\n\n        List list = mock(List.class);\n\n        when(list.get(0)).thenAnswer(\n\n            new Answer() {\n\n                public Object answer(InvocationOnMock invocation) throws Throwable {\n\n                    return invocation.callRealMethod();\n\n                }\n\n            }\n\n        );\n\n        try {\n\n            //when\n\n            list.get(0);            \n\n            //then\n\n            fail();\n\n        } catch (MockitoException e) {}\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-108": {
    "id": "JacksonDatabind-108",
    "project": "JacksonDatabind",
    "number": "108",
    "buggy_function": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTree(p);\n    }",
    "fixed_function": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTreeOrNull(p);\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
      "first_line": 1166,
      "last_line": 1170
    },
    "javadoc": "/**\n* Convenience method that binds content read using given parser, using\n* configuration of this reader, except that content is bound as\n* JSON tree instead of configured root value type.\n* Returns {@link JsonNode} that represents the root of the resulting tree, if there\n* was content to read, or {@code null} if no more content is accessible\n* via passed {@link JsonParser}.\n*<p>\n* NOTE! Behavior with end-of-input (no more content) differs between this\n* {@code readTree} method, and all other methods that take input source: latter\n* will return \"missing node\", NOT {@code null}\n*<p>\n* Note: if an object was specified with {@link #withValueToUpdate}, it\n* will be ignored.\n*<p>\n* NOTE: this method never tries to auto-detect format, since actual\n* (data-format specific) parser is given.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader": {
        "source": "    public void testNullFromEOFWithParserAndReader() throws Exception\n\n    {\n\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n\n\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n\n\n        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {\n\n            _assertNullTree(MAPPER.reader().readTree(p));\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-9": {
    "id": "Compress-9",
    "project": "Compress",
    "number": "9",
    "buggy_function": "@Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n        count(numToWrite);\n    }",
    "fixed_function": "@Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
      "first_line": 266,
      "last_line": 331
    },
    "javadoc": "/**\n* Writes bytes to the current tar archive entry. This method\n* is aware of the current entry and will throw an exception if\n* you attempt to write bytes past the length specified for the\n* current entry. The method is also (painfully) aware of the\n* record buffering required by TarBuffer, and manages buffers\n* that are not a multiple of recordsize in length, including\n* assembling records from small buffers.\n*\n* @param wBuf The buffer to write to the archive.\n* @param wOffset The offset in the buffer from which to get bytes.\n* @param numToWrite The number of bytes to write.\n* @throws IOException on error\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount": {
        "source": "    public void testCount() throws Exception {\n\n        File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n\n        f.deleteOnExit();\n\n        FileOutputStream fos = new FileOutputStream(f);\n\n\n\n        ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n\n            .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n\n\n\n        File file1 = getFile(\"test1.xml\");\n\n        TarArchiveEntry sEntry = new TarArchiveEntry(file1);\n\n        tarOut.putArchiveEntry(sEntry);\n\n\n\n        FileInputStream in = new FileInputStream(file1);\n\n        byte[] buf = new byte[8192];\n\n\n\n        int read = 0;\n\n        while ((read = in.read(buf)) > 0) {\n\n            tarOut.write(buf, 0, read);\n\n        }\n\n\n\n        in.close();\n\n        tarOut.closeArchiveEntry();\n\n        tarOut.close();\n\n\n\n        assertEquals(f.length(), tarOut.getBytesWritten());\n\n    }\n"
      }
    }
  },
  "Cli-2": {
    "id": "Cli-2",
    "project": "Cli",
    "number": "2",
    "buggy_function": "protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(\"-\" + ch);\n            }\n        }\n    }",
    "fixed_function": "protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/PosixParser.java",
      "first_line": 278,
      "last_line": 308
    },
    "javadoc": "/**\n* <p>Breaks <code>token</code> into its constituent parts\n* using the following algorithm.\n* <ul>\n*  <li>ignore the first character (\"<b>-</b>\")</li>\n*  <li>foreach remaining character check if an {@link Option}\n*  exists with that id.</li>\n*  <li>if an {@link Option} does exist then add that character\n*  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n*  <li>if the {@link Option} can have an argument value and there\n*  are remaining characters in the token then add the remaining\n*  characters as a token to the list of processed tokens.</li>\n*  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n*  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n*  \"<b>--</b>\" followed by the remaining characters and also\n*  the remaining tokens directly to the processed tokens list.</li>\n*  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n*  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n*  character prepended with \"<b>-</b>\".</li>\n* </ul>\n* </p>\n*\n* @param token The current token to be <b>burst</b>\n* @param stopAtNonOption Specifies whether to stop processing\n* at the first non-Option encountered.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.bug.BugCLI51Test::test": {
        "source": "    public void test() throws Exception\n\n    {\n\n        Options options = buildCommandLineOptions();\n\n        CommandLineParser parser = new PosixParser();\n\n        String[] args = new String[] {\"-t\", \"-something\" };\n\n        CommandLine commandLine;\n\n        commandLine = parser.parse( options, args );\n\n        assertEquals(\"-something\", commandLine.getOptionValue( 't'));\n\n    }\n"
      }
    }
  },
  "Mockito-3": {
    "id": "Mockito-3",
    "project": "Mockito",
    "number": "3",
    "buggy_function": "public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }",
    "fixed_function": "public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {\n                if (m instanceof CapturesArguments) {\n                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];\n                    for (int i = 0; i < Array.getLength(rawArgument); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));\n                    }\n                }\n            }\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/invocation/InvocationMatcher.java",
      "first_line": 118,
      "last_line": 141
    },
    "javadoc": "//sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest",
    "failing_tests": {
      "org.mockito.internal.invocation.InvocationMatcherTest::should_capture_varargs_as_vararg": {
        "source": "    public void should_capture_varargs_as_vararg() throws Exception {\n\n        //given\n\n        mock.mixedVarargs(1, \"a\", \"b\");\n\n        Invocation invocation = getLastInvocation();\n\n        CapturingMatcher m = new CapturingMatcher();\n\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));\n\n\n\n        //when\n\n        invocationMatcher.captureArgumentsFrom(invocation);\n\n\n\n        //then\n\n        Assertions.assertThat(m.getAllValues()).containsExactly(\"a\", \"b\");\n\n    }\n"
      },
      "org.mockitousage.bugs.varargs.VarargsAndAnyObjectPicksUpExtraInvocationsTest::shouldVerifyCorrectlyNumberOfInvocationsWithVarargs": {
        "source": "    public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs() {\n\n        //when\n\n        table.newRow(\"qux\", \"foo\", \"bar\", \"baz\");\n\n        table.newRow(\"abc\", \"def\");\n\n        \n\n        //then\n\n        verify(table).newRow(anyString(), eq(\"foo\"), anyString(), anyString());\n\n        verify(table).newRow(anyString(), anyString());\n\n    }\n"
      },
      "org.mockitousage.bugs.varargs.VarargsNotPlayingWithAnyObjectTest::shouldMatchAnyVararg": {
        "source": "    public void shouldMatchAnyVararg() {\n\n        mock.run(\"a\", \"b\");\n\n\n\n        verify(mock).run(anyString(), anyString());\n\n        verify(mock).run((String) anyObject(), (String) anyObject());\n\n\n\n        verify(mock).run((String[]) anyVararg());\n\n        \n\n        verify(mock, never()).run();\n\n        verify(mock, never()).run(anyString(), eq(\"f\"));\n\n    }\n"
      },
      "org.mockitousage.matchers.CapturingArgumentsTest::should_capture_all_vararg": {
        "source": "    public void should_capture_all_vararg() throws Exception {\n\n        // given\n\n        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n\n\n\n        // when\n\n        mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n\n        mock.mixedVarargs(42, \"again ?!\");\n\n\n\n        // then\n\n        verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.capture());\n\n\n\n        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\", \"b\", \"c\", \"again ?!\");\n\n    }\n"
      },
      "org.mockitousage.matchers.CapturingArgumentsTest::captures_correctly_when_captor_used_multiple_times": {
        "source": "    public void captures_correctly_when_captor_used_multiple_times() throws Exception {\n\n        // given\n\n        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n\n\n\n        // when\n\n        mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n\n\n\n        // then\n\n        // this is only for backwards compatibility. It does not make sense in real to do so.\n\n        verify(mock).mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture(), argumentCaptor.capture());\n\n        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\", \"b\", \"c\");\n\n    }\n"
      },
      "org.mockitousage.matchers.CapturingArgumentsTest::should_capture_vararg": {
        "source": "    public void should_capture_vararg() throws Exception {\n\n        // given\n\n        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n\n\n\n        // when\n\n        mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n\n\n\n        // then\n\n        verify(mock).mixedVarargs(any(), argumentCaptor.capture());\n\n        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\", \"b\", \"c\");\n\n    }\n"
      },
      "org.mockitousage.matchers.CapturingArgumentsTest::captures_correctly_when_captor_used_on_pure_vararg_method": {
        "source": "    public void captures_correctly_when_captor_used_on_pure_vararg_method() throws Exception {\n\n        // given\n\n        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n\n\n\n        // when\n\n        mock.varargs(42, \"capturedValue\");\n\n\n\n        // then\n\n        verify(mock).varargs(eq(42), argumentCaptor.capture());\n\n        Assertions.assertThat(argumentCaptor.getValue()).contains(\"capturedValue\");\n\n    }\n"
      },
      "org.mockitousage.matchers.CapturingArgumentsTest::should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper": {
        "source": "    public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper() throws Exception {\n\n        // given\n\n        ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(Byte.class);\n\n\n\n        // when\n\n        mock.varargsbyte((byte) 1, (byte) 2);\n\n\n\n        // then\n\n        verify(mock).varargsbyte(argumentCaptor.capture());\n\n        assertEquals((byte) 2, (byte) argumentCaptor.getValue());\n\n        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);\n\n    }\n"
      },
      "org.mockitousage.matchers.CapturingArgumentsTest::should_capture_byte_vararg_by_creating_captor_with_primitive": {
        "source": "    public void should_capture_byte_vararg_by_creating_captor_with_primitive() throws Exception {\n\n        // given\n\n        ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(byte.class);\n\n\n\n        // when\n\n        mock.varargsbyte((byte) 1, (byte) 2);\n\n\n\n        // then\n\n        verify(mock).varargsbyte(argumentCaptor.capture());\n\n        assertEquals((byte) 2, (byte) argumentCaptor.getValue());\n\n        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);\n\n    }\n"
      }
    }
  },
  "JxPath-15": {
    "id": "JxPath-15",
    "project": "JxPath",
    "number": "15",
    "buggy_function": "public boolean setPosition(int position) {\n        if (!prepared) {\n            prepared = true;\n            BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n            ArrayList pointers = new ArrayList();\n            for (int i = 0; i < contexts.length; i++) {\n                EvalContext ctx = (EvalContext) contexts[i];\n                while (ctx.nextSet()) {\n                    while (ctx.nextNode()) {\n                        NodePointer ptr = ctx.getCurrentNodePointer();\n                        if (!pointers.contains(ptr)) {\n                            nodeSet.add(ptr);\n                            pointers.add(ptr);\n                        }\n                    }\n                }\n            }\n        }\n        return super.setPosition(position);\n    }",
    "fixed_function": "public boolean setPosition(int position) {\n        if (!prepared) {\n            prepared = true;\n            BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n            ArrayList pointers = new ArrayList();\n            for (int i = 0; i < contexts.length; i++) {\n                EvalContext ctx = (EvalContext) contexts[i];\n                while (ctx.nextSet()) {\n                    while (ctx.nextNode()) {\n                        NodePointer ptr = ctx.getCurrentNodePointer();\n                        if (!pointers.contains(ptr)) {\n                            pointers.add(ptr);\n                        }\n                    }\n                }\n            }\n            sortPointers(pointers);\n\n            for (Iterator it = pointers.iterator(); it.hasNext();) {\n                nodeSet.add((Pointer) it.next());\n            }\n        }\n        return super.setPosition(position);\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java",
      "first_line": 45,
      "last_line": 64
    },
    "javadoc": "/**\n* EvalContext that represents a union between other contexts - result\n* of a union operation like (a | b)\n*\n* @author Dmitri Plotnikov\n* @version $Revision$ $Date$\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testUnion": {
        "source": "    public void testUnion() {\n\n        assertXPathValue(context, \"/vendor[1]/contact[1] | /vendor[1]/contact[4]\", \"John\");\n\n        assertXPathValue(context, \"/vendor[1]/contact[4] | /vendor[1]/contact[1]\", \"John\");\n\n    }\n"
      },
      "org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testUnion": {
        "source": "    public void testUnion() {\n\n        assertXPathValue(context, \"/vendor[1]/contact[1] | /vendor[1]/contact[4]\", \"John\");\n\n        assertXPathValue(context, \"/vendor[1]/contact[4] | /vendor[1]/contact[1]\", \"John\");\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-56": {
    "id": "JacksonDatabind-56",
    "project": "JacksonDatabind",
    "number": "56",
    "buggy_function": "@Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                // will throw IAE if unknown:\n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                // will throw IAE (or its subclass) if malformed\n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = value.indexOf('_');\n                    if (ix < 0) { // single argument\n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = value.indexOf('_');\n                    if (ix < 0) { // two pieces\n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    // bracketed IPv6 (with port number)\n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(ctxt.getParser(),\n                                \"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        // host:port\n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    // host or unbracketed IPv6, without port number\n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }",
    "fixed_function": "@Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                // will throw IAE if unknown:\n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                // will throw IAE (or its subclass) if malformed\n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = _firstHyphenOrUnderscore(value);\n                    if (ix < 0) { // single argument\n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = _firstHyphenOrUnderscore(value);\n                    if (ix < 0) { // two pieces\n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    // bracketed IPv6 (with port number)\n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(ctxt.getParser(),\n                                \"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        // host:port\n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    // host or unbracketed IPv6, without port number\n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java",
      "first_line": 205,
      "last_line": 276
    },
    "javadoc": "/**\n* \"Chameleon\" deserializer that works on simple types that are deserialized\n* from a simple String.\n*\n* @since 2.4\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestJdkTypes::testLocale": {
        "source": "    public void testLocale() throws IOException\n\n    {\n\n        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n\n        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n\n        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"),\n\n                MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n\n        assertEquals(new Locale(\"en\", \"US\"),\n\n                MAPPER.readValue(quote(\"en-US\"), Locale.class));\n\n\n\n        // [databind#1123]\n\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n\n        assertSame(Locale.ROOT, loc);\n\n    }\n"
      }
    }
  },
  "Mockito-2": {
    "id": "Mockito-2",
    "project": "Mockito",
    "number": "2",
    "buggy_function": "public Timer(long durationMillis) {\n        this.durationMillis = durationMillis;\n    }",
    "fixed_function": "public Timer(long durationMillis) {\n        validateInput(durationMillis);\n        this.durationMillis = durationMillis;\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/util/Timer.java",
      "first_line": 9,
      "last_line": 11
    },
    "javadoc": "",
    "failing_tests": {
      "org.mockito.internal.util.TimerTest::should_throw_friendly_reminder_exception_when_duration_is_negative": {
        "source": "    public void should_throw_friendly_reminder_exception_when_duration_is_negative() {\n\n        try {\n\n            new Timer(-1);\n\n            Assert.fail(\"It is forbidden to create timer with negative value of timer's duration.\");\n\n        } catch (FriendlyReminderException e) {\n\n            Assert.assertTrue(true);\n\n        }\n\n    }\n"
      },
      "org.mockito.verification.NegativeDurationTest::should_throw_exception_when_duration_is_negative_for_timeout_method": {
        "source": "    public void should_throw_exception_when_duration_is_negative_for_timeout_method() {\n\n        try {\n\n            Mockito.timeout(-1);\n\n            Assert.fail(\"It is forbidden to invoke Mockito.timeout() with negative value.\");\n\n        } catch (FriendlyReminderException e) {\n\n            Assert.assertTrue(true);\n\n        }\n\n    }\n"
      },
      "org.mockito.verification.NegativeDurationTest::should_throw_exception_when_duration_is_negative_for_after_method": {
        "source": "    public void should_throw_exception_when_duration_is_negative_for_after_method() {\n\n        try {\n\n            Mockito.after(-1);\n\n            Assert.fail(\"It is forbidden to invoke Mockito.after() with negative value.\");\n\n        } catch (FriendlyReminderException e) {\n\n            Assert.assertTrue(true);\n\n        }\n\n    }\n"
      }
    }
  },
  "Cli-33": {
    "id": "Cli-33",
    "project": "Cli",
    "number": "33",
    "buggy_function": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }",
    "fixed_function": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedTextBlock(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
      "first_line": 726,
      "last_line": 732
    },
    "javadoc": "/**\n* Print the specified text to the specified PrintWriter.\n*\n* @param pw The printWriter to write the help to\n* @param width The number of characters to display per line\n* @param nextLineTabStop The position on the next line for the first tab.\n* @param text The text to be written to the PrintWriter\n*/",
    "failing_tests": {
      "org.apache.commons.cli.HelpFormatterTest::testIndentedHeaderAndFooter": {
        "source": "    public void testIndentedHeaderAndFooter()\n\n    {\n\n        // related to CLI-207\n\n        Options options = new Options();\n\n        HelpFormatter formatter = new HelpFormatter();\n\n        String header = \"  Header1\\n  Header2\";\n\n        String footer = \"  Footer1\\n  Footer2\";\n\n        StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n\n\n\n        assertEquals(\n\n                \"usage: foobar\" + EOL +\n\n                \"  Header1\" + EOL +\n\n                \"  Header2\" + EOL +\n\n                \"\" + EOL +\n\n                \"  Footer1\" + EOL +\n\n                \"  Footer2\" + EOL\n\n                , out.toString());\n\n    }\n"
      }
    }
  },
  "Cli-3": {
    "id": "Cli-3",
    "project": "Cli",
    "number": "3",
    "buggy_function": "public static Number createNumber(String str)\n    {\n        try\n        {\n            return NumberUtils.createNumber(str);\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }",
    "fixed_function": "public static Number createNumber(String str)\n    {\n        try\n        {\n            if( str != null )\n            {\n                if( str.indexOf('.') != -1 )\n                {\n                    return Double.valueOf(str);\n                }\n                else\n                {\n                    return Long.valueOf(str);\n                }\n            }\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/TypeHandler.java",
      "first_line": 157,
      "last_line": 169
    },
    "javadoc": "/**\n* <p>Create a number from a String. If a . is present, it creates a\n*    Double, otherwise a Long. </p>\n*\n* @param str the value\n* @return the number represented by <code>str</code>, if <code>str</code>\n* is not a number, null is returned.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.PatternOptionBuilderTest::testSimplePattern": {
        "source": "   public void testSimplePattern()\n\n   {\n\n       try {\n\n           Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/\");\n\n           String[] args = new String[] { \"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://jakarta.apache.org/\" };\n\n      \n\n           CommandLineParser parser = new PosixParser();\n\n           CommandLine line = parser.parse(options,args);\n\n\n\n           // tests the char methods of CommandLine that delegate to\n\n           // the String methods\n\n           assertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\n\n           assertEquals(\"flag a\", \"foo\", line.getOptionValue('a'));\n\n           assertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\n\n           assertEquals(\"string flag a\", \"foo\", line.getOptionObject('a'));\n\n           assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject(\"b\"));\n\n           assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject('b'));\n\n           assertEquals(\"boolean true flag c\", true, line.hasOption(\"c\"));\n\n           assertEquals(\"boolean true flag c\", true, line.hasOption('c'));\n\n           assertEquals(\"boolean false flag d\", false, line.hasOption(\"d\"));\n\n           assertEquals(\"boolean false flag d\", false, line.hasOption('d'));\n\n           assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject(\"e\"));\n\n           assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject('e'));\n\n           assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject(\"f\"));\n\n           assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject('f'));\n\n           assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));\n\n           assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject('n'));\n\n           assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject(\"t\"));\n\n           assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject('t'));\n\n           /// DATES NOT SUPPORTED YET.\n\n           //      assertEquals(\"number flag t\", new java.util.Date(1023400137276L), line.getOptionObject('z'));\n\n           //     input is:  \"Thu Jun 06 17:48:57 EDT 2002\"\n\n       }\n\n       catch( ParseException exp ) {\n\n           fail( exp.getMessage() );\n\n       }\n\n       catch( java.net.MalformedURLException exp ) {\n\n           fail( exp.getMessage() );\n\n       }\n\n   }\n"
      }
    }
  },
  "JacksonDatabind-105": {
    "id": "JacksonDatabind-105",
    "project": "JacksonDatabind",
    "number": "105",
    "buggy_function": "public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n    {\n        if (_classNames.contains(clsName)) {\n            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);\n            if (d != null) {\n                return d;\n            }\n            if (rawType == UUID.class) {\n                return new UUIDDeserializer();\n            }\n            if (rawType == StackTraceElement.class) {\n                return new StackTraceElementDeserializer();\n            }\n            if (rawType == AtomicBoolean.class) {\n                // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n                return new AtomicBooleanDeserializer();\n            }\n            if (rawType == ByteBuffer.class) {\n                return new ByteBufferDeserializer();\n            }\n        }\n        return null;\n    }",
    "fixed_function": "public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n    {\n        if (_classNames.contains(clsName)) {\n            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);\n            if (d != null) {\n                return d;\n            }\n            if (rawType == UUID.class) {\n                return new UUIDDeserializer();\n            }\n            if (rawType == StackTraceElement.class) {\n                return new StackTraceElementDeserializer();\n            }\n            if (rawType == AtomicBoolean.class) {\n                // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n                return new AtomicBooleanDeserializer();\n            }\n            if (rawType == ByteBuffer.class) {\n                return new ByteBufferDeserializer();\n            }\n            if (rawType == Void.class) {\n                return NullifyingDeserializer.instance;\n            }\n        }\n        return null;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java",
      "first_line": 28,
      "last_line": 50
    },
    "javadoc": "// note: can skip primitive types; other ways to check them:",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.jdk.JDKScalarsTest::testVoidDeser": {
        "source": "    public void testVoidDeser() throws Exception\n\n    {\n\n        VoidBean bean = MAPPER.readValue(aposToQuotes(\"{'value' : 123 }\"),\n\n                VoidBean.class);\n\n        assertNull(bean.value);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-94": {
    "id": "JacksonDatabind-94",
    "project": "JacksonDatabind",
    "number": "94",
    "buggy_function": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }",
    "fixed_function": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java",
      "first_line": 71,
      "last_line": 111
    },
    "javadoc": "/**\n* Set of class names of types that are never to be deserialized.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testC3P0Types": {
        "source": "    public void testC3P0Types() throws Exception\n\n    {\n\n        _testIllegalType(ComboPooledDataSource.class); // [databind#1931]\n\n    }\n"
      }
    }
  },
  "Csv-7": {
    "id": "Csv-7",
    "project": "Csv",
    "number": "7",
    "buggy_function": "private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "fixed_function": "private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    if (hdrMap.containsKey(header[i])) {\n                        throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n                    }\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "first_line": 348,
      "last_line": 376
    },
    "javadoc": "/**\n* Initializes the name to index mapping if the format defines a header.\n*\n* @return null if the format has no header.\n*/",
    "failing_tests": {
      "org.apache.commons.csv.CSVParserTest::testDuplicateHeaderEntries": {
        "source": "    public void testDuplicateHeaderEntries() throws Exception {\n\n        CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(new String[]{}));\n\n    }\n"
      }
    }
  },
  "JxPath-18": {
    "id": "JxPath-18",
    "project": "JxPath",
    "number": "18",
    "buggy_function": "public boolean nextNode() {\n        super.setPosition(getCurrentPosition() + 1);\n        if (!setStarted) {\n            setStarted = true;\n            if (!(nodeTest instanceof NodeNameTest)) {\n                return false;\n            }\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            iterator =\n                parentContext.getCurrentNodePointer().attributeIterator(name);\n        }\n        if (iterator == null) {\n            return false;\n        }\n        if (!iterator.setPosition(iterator.getPosition() + 1)) {\n            return false;\n        }\n        currentNodePointer = iterator.getNodePointer();\n        return true;\n    }",
    "fixed_function": "public boolean nextNode() {\n        super.setPosition(getCurrentPosition() + 1);\n        if (!setStarted) {\n            setStarted = true;\n            NodeNameTest nodeNameTest = null;\n            if (nodeTest instanceof NodeTypeTest) {\n                if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {\n                    nodeNameTest = WILDCARD_TEST;\n                }\n            }\n            else if (nodeTest instanceof NodeNameTest) {\n                nodeNameTest = (NodeNameTest) nodeTest;\n            }\n            if (nodeNameTest == null) {\n                return false;\n            }\n            iterator = parentContext.getCurrentNodePointer().attributeIterator(\n                    nodeNameTest.getNodeName());\n        }\n        if (iterator == null) {\n            return false;\n        }\n        if (!iterator.setPosition(iterator.getPosition() + 1)) {\n            return false;\n        }\n        currentNodePointer = iterator.getNodePointer();\n        return true;\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java",
      "first_line": 71,
      "last_line": 90
    },
    "javadoc": "/**\n* @param parentContext represents the previous step on the path\n* @param nodeTest is the name of the attribute we are looking for\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute": {
        "source": "    public void testAxisAttribute() {\n\n        // attribute::\n\n        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n\n\n\n        // attribute:: produces the correct pointer\n\n        assertXPathPointer(\n\n            context,\n\n            \"vendor/location/@id\",\n\n            \"/vendor[1]/location[1]/@id\");\n\n\n\n        // iterate over attributes\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/location/@id\",\n\n            list(\"100\", \"101\"));\n\n\n\n        // Using different prefixes for the same namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"vendor/product/price:amount/@price:discount\",\n\n            \"10%\");\n\n        \n\n        // namespace uri for an attribute\n\n        assertXPathValue(\n\n            context,\n\n            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n\n            \"priceNS\");\n\n\n\n        // local name of an attribute\n\n        assertXPathValue(\n\n            context,\n\n            \"local-name(vendor/product/price:amount/@price:discount)\",\n\n            \"discount\");\n\n\n\n        // name for an attribute\n\n        assertXPathValue(\n\n            context,\n\n            \"name(vendor/product/price:amount/@price:discount)\",\n\n            \"price:discount\");\n\n\n\n        // attribute:: with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"vendor/product/price:amount/@discount\",\n\n            \"20%\");\n\n\n\n        // namespace uri of an attribute with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"namespace-uri(vendor/product/price:amount/@discount)\",\n\n            \"\");\n\n\n\n        // local name of an attribute with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"local-name(vendor/product/price:amount/@discount)\",\n\n            \"discount\");\n\n\n\n        // name of an attribute with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"name(vendor/product/price:amount/@discount)\",\n\n            \"discount\");\n\n\n\n        // attribute:: with a namespace and wildcard\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/product/price:amount/@price:*\",\n\n            list(\"10%\"));\n\n\n\n        // attribute:: with a wildcard\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/location[1]/@*\",\n\n            set(\"100\", \"\", \"local\"));\n\n\n\n        // attribute:: with default namespace and wildcard\n\n        assertXPathValueIterator(\n\n                context,\n\n                \"vendor/product/price:amount/@*\",\n\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n\n                set(\"10%\", \"20%\"));\n\n\n\n        // attribute::node()\n\n        assertXPathValueIterator(\n\n                context,\n\n                \"vendor/product/price:amount/attribute::node()\",\n\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n\n                set(\"10%\", \"20%\"));\n\n        \n\n        // attribute:: select non-ns'd attributes only\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/product/price:amount/@*[namespace-uri() = '']\",\n\n            list(\"20%\"));\n\n\n\n        // Empty attribute\n\n        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n\n\n\n        // Missing attribute\n\n        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n\n\n\n        // Missing attribute with namespace\n\n        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n\n\n\n        // Using attribute in a predicate\n\n        assertXPathValue(\n\n            context,\n\n            \"vendor/location[@id='101']//street\",\n\n            \"Tangerine Drive\");\n\n        \n\n        assertXPathValueIterator(\n\n            context,\n\n            \"/vendor/location[1]/@*[name()!= 'manager']\", list(\"100\",\n\n            \"local\"));\n\n    }\n"
      },
      "org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisAttribute": {
        "source": "    public void testAxisAttribute() {\n\n        // attribute::\n\n        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n\n\n\n        // attribute:: produces the correct pointer\n\n        assertXPathPointer(\n\n            context,\n\n            \"vendor/location/@id\",\n\n            \"/vendor[1]/location[1]/@id\");\n\n\n\n        // iterate over attributes\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/location/@id\",\n\n            list(\"100\", \"101\"));\n\n\n\n        // Using different prefixes for the same namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"vendor/product/price:amount/@price:discount\",\n\n            \"10%\");\n\n        \n\n        // namespace uri for an attribute\n\n        assertXPathValue(\n\n            context,\n\n            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n\n            \"priceNS\");\n\n\n\n        // local name of an attribute\n\n        assertXPathValue(\n\n            context,\n\n            \"local-name(vendor/product/price:amount/@price:discount)\",\n\n            \"discount\");\n\n\n\n        // name for an attribute\n\n        assertXPathValue(\n\n            context,\n\n            \"name(vendor/product/price:amount/@price:discount)\",\n\n            \"price:discount\");\n\n\n\n        // attribute:: with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"vendor/product/price:amount/@discount\",\n\n            \"20%\");\n\n\n\n        // namespace uri of an attribute with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"namespace-uri(vendor/product/price:amount/@discount)\",\n\n            \"\");\n\n\n\n        // local name of an attribute with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"local-name(vendor/product/price:amount/@discount)\",\n\n            \"discount\");\n\n\n\n        // name of an attribute with the default namespace\n\n        assertXPathValue(\n\n            context,\n\n            \"name(vendor/product/price:amount/@discount)\",\n\n            \"discount\");\n\n\n\n        // attribute:: with a namespace and wildcard\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/product/price:amount/@price:*\",\n\n            list(\"10%\"));\n\n\n\n        // attribute:: with a wildcard\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/location[1]/@*\",\n\n            set(\"100\", \"\", \"local\"));\n\n\n\n        // attribute:: with default namespace and wildcard\n\n        assertXPathValueIterator(\n\n                context,\n\n                \"vendor/product/price:amount/@*\",\n\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n\n                set(\"10%\", \"20%\"));\n\n\n\n        // attribute::node()\n\n        assertXPathValueIterator(\n\n                context,\n\n                \"vendor/product/price:amount/attribute::node()\",\n\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n\n                set(\"10%\", \"20%\"));\n\n        \n\n        // attribute:: select non-ns'd attributes only\n\n        assertXPathValueIterator(\n\n            context,\n\n            \"vendor/product/price:amount/@*[namespace-uri() = '']\",\n\n            list(\"20%\"));\n\n\n\n        // Empty attribute\n\n        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n\n\n\n        // Missing attribute\n\n        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n\n\n\n        // Missing attribute with namespace\n\n        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n\n\n\n        // Using attribute in a predicate\n\n        assertXPathValue(\n\n            context,\n\n            \"vendor/location[@id='101']//street\",\n\n            \"Tangerine Drive\");\n\n        \n\n        assertXPathValueIterator(\n\n            context,\n\n            \"/vendor/location[1]/@*[name()!= 'manager']\", list(\"100\",\n\n            \"local\"));\n\n    }\n"
      }
    }
  },
  "Mockito-37": {
    "id": "Mockito-37",
    "project": "Mockito",
    "number": "37",
    "buggy_function": "public void validate(Answer<?> answer, Invocation invocation) {\n        if (answer instanceof ThrowsException) {\n            validateException((ThrowsException) answer, invocation);\n        }\n        \n        if (answer instanceof Returns) {\n            validateReturnValue((Returns) answer, invocation);\n        }\n        \n        if (answer instanceof DoesNothing) {\n            validateDoNothing((DoesNothing) answer, invocation);\n        }\n        \n    }",
    "fixed_function": "public void validate(Answer<?> answer, Invocation invocation) {\n        if (answer instanceof ThrowsException) {\n            validateException((ThrowsException) answer, invocation);\n        }\n        \n        if (answer instanceof Returns) {\n            validateReturnValue((Returns) answer, invocation);\n        }\n        \n        if (answer instanceof DoesNothing) {\n            validateDoNothing((DoesNothing) answer, invocation);\n        }\n        \n        if (answer instanceof CallsRealMethods) {\n            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\n        }\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
      "first_line": 15,
      "last_line": 28
    },
    "javadoc": "/*\n* Copyright (c) 2007 Mockito contributors\n* This program is made available under the terms of the MIT License.\n*/",
    "failing_tests": {
      "org.mockito.internal.stubbing.answers.AnswersValidatorTest::shouldFailWhenCallingRealMethodOnIterface": {
        "source": "    public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\n\n        //given\n\n        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n\n        try {\n\n            //when\n\n            validator.validate(new CallsRealMethods(), inovcationOnIterface);\n\n            //then\n\n            fail();\n\n        } catch (MockitoException e) {}\n\n    }\n"
      },
      "org.mockitousage.spies.SpyingOnInterfacesTest::shouldFailFastWhenCallingRealMethodOnInterface": {
        "source": "    public void shouldFailFastWhenCallingRealMethodOnInterface() throws Exception {\n\n        List list = mock(List.class);\n\n        try {\n\n            //when\n\n            when(list.get(0)).thenCallRealMethod();\n\n            //then\n\n            fail();\n\n        } catch (MockitoException e) {}\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-36": {
    "id": "JacksonDatabind-36",
    "project": "JacksonDatabind",
    "number": "36",
    "buggy_function": "private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc, Boolean lenient)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }",
    "fixed_function": "private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc, Boolean lenient)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
      "first_line": 545,
      "last_line": 558
    },
    "javadoc": "// Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so",
    "failing_tests": {
      "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient": {
        "source": "    public void testLenient() throws Exception\n\n    {\n\n        StdDateFormat f = StdDateFormat.instance;\n\n\n\n        // default should be lenient\n\n        assertTrue(f.isLenient());\n\n\n\n        StdDateFormat f2 = f.clone();\n\n        assertTrue(f2.isLenient());\n\n\n\n        f2.setLenient(false);\n\n        assertFalse(f2.isLenient());\n\n\n\n        f2.setLenient(true);\n\n        assertTrue(f2.isLenient());\n\n\n\n        // and for testing, finally, leave as non-lenient\n\n        f2.setLenient(false);\n\n        assertFalse(f2.isLenient());\n\n        StdDateFormat f3 = f2.clone();\n\n        assertFalse(f3.isLenient());\n\n\n\n        // first, legal dates are... legal\n\n        Date dt = f3.parse(\"2015-11-30\");\n\n        assertNotNull(dt);\n\n\n\n        // but as importantly, when not lenient, do not allow\n\n        try {\n\n            f3.parse(\"2015-11-32\");\n\n            fail(\"Should not pass\");\n\n        } catch (ParseException e) {\n\n            verifyException(e, \"can not parse date\");\n\n        }\n\n\n\n        // ... yet, with lenient, do allow\n\n        f3.setLenient(true);\n\n        dt = f3.parse(\"2015-11-32\");\n\n        assertNotNull(dt);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-77": {
    "id": "JacksonDatabind-77",
    "project": "JacksonDatabind",
    "number": "77",
    "buggy_function": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }",
    "fixed_function": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "first_line": 96,
      "last_line": 145
    },
    "javadoc": "/**\n* Method that {@link DeserializerCache}s call to create a new\n* deserializer for types other than Collections, Maps, arrays and\n* enums.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testIssue1599": {
        "source": "    public void testIssue1599() throws Exception\n\n    {\n\n        final String JSON = aposToQuotes(\n\n \"{'id': 124,\\n\"\n\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n\n+\"  {\\n\"\n\n+\"    'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n\n+\"    'transletName' : 'a.b',\\n\"\n\n+\"    'outputProperties' : { }\\n\"\n\n+\"  }\\n\"\n\n+\" ]\\n\"\n\n+\"}\"\n\n        );\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.enableDefaultTyping();\n\n        try {\n\n            mapper.readValue(JSON, Bean1599.class);\n\n            fail(\"Should not pass\");\n\n        } catch (JsonMappingException e) {\n\n            verifyException(e, \"Illegal type\");\n\n            verifyException(e, \"to deserialize\");\n\n            verifyException(e, \"prevented for security reasons\");\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-20": {
    "id": "JacksonDatabind-20",
    "project": "JacksonDatabind",
    "number": "20",
    "buggy_function": "public JsonNode setAll(Map<String,? extends JsonNode> properties)\n    {\n        for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {\n            JsonNode n = en.getValue();\n            if (n == null) {\n                n = nullNode();\n            }\n            _children.put(en.getKey(), n);\n        }\n        return this;\n    }",
    "fixed_function": "@JsonIgnore // work-around for [databind#815]\n    public JsonNode setAll(Map<String,? extends JsonNode> properties)\n    {\n        for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {\n            JsonNode n = en.getValue();\n            if (n == null) {\n                n = nullNode();\n            }\n            _children.put(en.getKey(), n);\n        }\n        return this;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java",
      "first_line": 324,
      "last_line": 334
    },
    "javadoc": "/**\n* Method for adding given properties to this object node, overriding\n* any existing values for those properties.\n*\n* @param properties Properties to add\n*\n* @return This node after adding/replacing property values (to allow chaining)\n*\n* @since 2.1\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.introspect.TestNamingStrategyStd::testNamingWithObjectNode": {
        "source": "    public void testNamingWithObjectNode() throws Exception\n\n    {\n\n        ObjectMapper m = new ObjectMapper();\n\n        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);\n\n        ClassWithObjectNodeField result =\n\n            m.readValue(\n\n                \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\n\n                ClassWithObjectNodeField.class);\n\n        assertNotNull(result);\n\n        assertEquals(\"1\", result.id);\n\n        assertNotNull(result.json);\n\n        assertEquals(2, result.json.size());\n\n        assertEquals(\"bing\", result.json.path(\"baz\").asText());\n\n    }\n"
      }
    }
  },
  "JacksonXml-2": {
    "id": "JacksonXml-2",
    "project": "JacksonXml",
    "number": "2",
    "buggy_function": "private final int _next() throws XMLStreamException\n    {\n        switch (_currentState) {\n        case XML_ATTRIBUTE_VALUE:\n            ++_nextAttributeIndex;\n            // fall through\n        case XML_START_ELEMENT: // attributes to return?\n            if (_nextAttributeIndex < _attributeCount) {\n                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n                return (_currentState = XML_ATTRIBUTE_NAME);\n            }\n            // otherwise need to find START/END_ELEMENT or text\n            String text = _collectUntilTag();\n            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                    return _initStartElement();\n            }\n            // For END_ELEMENT we will return text, if any\n            if (text != null) {\n                _textValue = text;\n                return (_currentState = XML_TEXT);\n            }\n            return _handleEndElement();\n\n        case XML_ATTRIBUTE_NAME:\n            // if we just returned name, will need to just send value next\n            return (_currentState = XML_ATTRIBUTE_VALUE);\n        case XML_TEXT:\n            // mixed text with other elements\n            // text followed by END_ELEMENT\n            return _handleEndElement();\n        case XML_END:\n            return XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n        }\n\n        // Ok: must be END_ELEMENT; see what tag we get (or end)\n        switch (_skipUntilTag()) {\n        case XMLStreamConstants.END_DOCUMENT:\n            return (_currentState = XML_END);\n        case XMLStreamConstants.END_ELEMENT:\n            return _handleEndElement();\n        }\n        // START_ELEMENT...\n        return _initStartElement();\n    }",
    "fixed_function": "private final int _next() throws XMLStreamException\n    {\n        switch (_currentState) {\n        case XML_ATTRIBUTE_VALUE:\n            ++_nextAttributeIndex;\n            // fall through\n        case XML_START_ELEMENT: // attributes to return?\n            if (_nextAttributeIndex < _attributeCount) {\n                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n                return (_currentState = XML_ATTRIBUTE_NAME);\n            }\n            // otherwise need to find START/END_ELEMENT or text\n            String text = _collectUntilTag();\n            final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT;\n            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n            if (startElementNext) {\n                if (text == null || _allWs(text)) {\n                    _mixedText = false;\n                    return _initStartElement();\n                }\n                _mixedText = true;\n                _textValue = text;\n                return (_currentState = XML_TEXT);\n            }\n            // For END_ELEMENT we will return text, if any\n            if (text != null) {\n                _mixedText = false;\n                _textValue = text;\n                return (_currentState = XML_TEXT);\n            }\n            _mixedText = false;\n            return _handleEndElement();\n\n        case XML_ATTRIBUTE_NAME:\n            // if we just returned name, will need to just send value next\n            return (_currentState = XML_ATTRIBUTE_VALUE);\n        case XML_TEXT:\n            // mixed text with other elements\n            if (_mixedText){\n                _mixedText = false;\n                return _initStartElement();\n            }\n            // text followed by END_ELEMENT\n            return _handleEndElement();\n        case XML_END:\n            return XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n        }\n\n        // Ok: must be END_ELEMENT; see what tag we get (or end)\n        switch (_skipUntilTag()) {\n        case XMLStreamConstants.END_DOCUMENT:\n            return (_currentState = XML_END);\n        case XMLStreamConstants.END_ELEMENT:\n            return _handleEndElement();\n        }\n        // START_ELEMENT...\n        return _initStartElement();\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java",
      "first_line": 309,
      "last_line": 356
    },
    "javadoc": "/**********************************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.dataformat.xml.misc.XmlTextTest::testMixedContent": {
        "source": "    public void testMixedContent() throws Exception\n\n    {\n\n        WindSpeed result = MAPPER.readValue(\"<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>\",\n\n                WindSpeed.class);\n\n        assertEquals(27, result.value);\n\n        assertNotNull(result.radius);\n\n        assertEquals(20, result.radius.value);\n\n    }\n"
      }
    }
  },
  "Cli-10": {
    "id": "Cli-10",
    "project": "Cli",
    "number": "10",
    "buggy_function": "protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }",
    "fixed_function": "protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/Parser.java",
      "first_line": 44,
      "last_line": 47
    },
    "javadoc": "/**\n* <p><code>Parser</code> creates {@link CommandLine}s.</p>\n*\n* @author John Keyes (john at integralsource.com)\n* @see Parser\n* @version $Revision$\n*/",
    "failing_tests": {
      "org.apache.commons.cli.ParseRequiredTest::testReuseOptionsTwice": {
        "source": "    public void testReuseOptionsTwice() throws Exception\n\n    {\n\n        Options opts = new Options();\n\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\n\n\t\tGnuParser parser = new GnuParser();\n\n\n\n        // first parsing\n\n        parser.parse(opts, new String[] { \"-v\" });\n\n\n\n        try\n\n        {\n\n            // second parsing, with the same Options instance and an invalid command line\n\n            parser.parse(opts, new String[0]);\n\n            fail(\"MissingOptionException not thrown\");\n\n        }\n\n        catch (MissingOptionException e)\n\n        {\n\n            // expected\n\n        }\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-110": {
    "id": "JacksonDatabind-110",
    "project": "JacksonDatabind",
    "number": "110",
    "buggy_function": "public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JavaUtilCollectionsConverter conv;\n\n        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...\n        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n            conv = converter(TYPE_AS_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n            conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n            conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n        // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n            conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }",
    "fixed_function": "public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JavaUtilCollectionsConverter conv;\n\n        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...\n        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n            conv = converter(TYPE_AS_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n            conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n            conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n        // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {\n            conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java",
      "first_line": 64,
      "last_line": 86
    },
    "javadoc": "// for [databind#2265]",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.jdk.UtilCollectionsTypesTest::testUnmodifiableListFromLinkedList": {
        "source": "   public void testUnmodifiableListFromLinkedList() throws Exception {\n\n       final List<String> input = new LinkedList<>();\n\n       input.add(\"first\");\n\n       input.add(\"second\");\n\n\n\n       // Can't use simple \"_verifyCollection\" as type may change; instead use\n\n       // bit more flexible check:\n\n       Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input));\n\n       assertEquals(input, act);\n\n\n\n       // and this check may be bit fragile (may need to revisit), but is good enough for now:\n\n       assertEquals(Collections.unmodifiableList(new ArrayList<>(input)).getClass(), act.getClass());\n\n   }\n"
      }
    }
  },
  "JacksonDatabind-78": {
    "id": "JacksonDatabind-78",
    "project": "JacksonDatabind",
    "number": "78",
    "buggy_function": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }",
    "fixed_function": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "first_line": 110,
      "last_line": 158
    },
    "javadoc": "/**\n* Method that {@link DeserializerCache}s call to create a new\n* deserializer for types other than Collections, Maps, arrays and\n* enums.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testIssue1599": {
        "source": "    public void testIssue1599() throws Exception\n\n    {\n\n        final String JSON = aposToQuotes(\n\n \"{'id': 124,\\n\"\n\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n\n+\"  {\\n\"\n\n+\"    'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n\n+\"    'transletName' : 'a.b',\\n\"\n\n+\"    'outputProperties' : { }\\n\"\n\n+\"  }\\n\"\n\n+\" ]\\n\"\n\n+\"}\"\n\n        );\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.enableDefaultTyping();\n\n        try {\n\n            mapper.readValue(JSON, Bean1599.class);\n\n            fail(\"Should not pass\");\n\n        } catch (JsonMappingException e) {\n\n            verifyException(e, \"Illegal type\");\n\n            verifyException(e, \"to deserialize\");\n\n            verifyException(e, \"prevented for security reasons\");\n\n        }\n\n    }\n"
      }
    }
  },
  "Mockito-15": {
    "id": "Mockito-15",
    "project": "Mockito",
    "number": "15",
    "buggy_function": "public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public boolean thenInject() {\n                    try {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                    }\n                    return true;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public boolean thenInject() {\n                return false;\n            }\n        };\n\n    }",
    "fixed_function": "public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public boolean thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                    }\n                    return true;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public boolean thenInject() {\n                return false;\n            }\n        };\n\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java",
      "first_line": 18,
      "last_line": 40
    },
    "javadoc": "/**\n* This node returns an actual injecter which will be either :\n*\n* <ul>\n* <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n* <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n* </ul>\n*/",
    "failing_tests": {
      "org.mockitousage.bugs.InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest::shouldInjectUsingPropertySetterIfAvailable": {
        "source": "    public void shouldInjectUsingPropertySetterIfAvailable() {\n\n        assertTrue(awaitingInjection.propertySetterUsed);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-43": {
    "id": "JacksonDatabind-43",
    "project": "JacksonDatabind",
    "number": "43",
    "buggy_function": "@Override\n    public Object deserializeSetAndReturn(JsonParser p,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        Object id = _valueDeserializer.deserialize(p, ctxt);\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        if (id == null) {\n            return null;\n        }\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }",
    "fixed_function": "@Override\n    public Object deserializeSetAndReturn(JsonParser p,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        if (p.hasToken(JsonToken.VALUE_NULL)) {\n            return null;\n        }\n        Object id = _valueDeserializer.deserialize(p, ctxt);\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java",
      "first_line": 74,
      "last_line": 96
    },
    "javadoc": "/**********************************************************\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.objectid.TestObjectIdSerialization::testNullStringPropertyId": {
        "source": "    public void testNullStringPropertyId() throws Exception\n\n    {\n\n        IdentifiableStringId value = MAPPER.readValue\n\n                (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), IdentifiableStringId.class);\n\n        assertNotNull(value);\n\n        assertEquals(3, value.value);\n\n    }    \n"
      }
    }
  },
  "JacksonDatabind-14": {
    "id": "JacksonDatabind-14",
    "project": "JacksonDatabind",
    "number": "14",
    "buggy_function": "protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }",
    "fixed_function": "protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
      "first_line": 1468,
      "last_line": 1486
    },
    "javadoc": "// Need to consume the token too",
    "failing_tests": {
      "com.fasterxml.jackson.databind.convert.TestUpdateValue::testIssue744": {
        "source": "    public void testIssue744() throws IOException\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        SimpleModule module = new SimpleModule();\n\n        module.addDeserializer(DataA.class, new DataADeserializer());\n\n        mapper.registerModule(module);\n\n\n\n        DataB db = new DataB();\n\n        db.da.i = 11;\n\n        db.k = 13;\n\n        String jsonBString = mapper.writeValueAsString(db);\n\n        JsonNode jsonBNode = mapper.valueToTree(db);\n\n\n\n        // create parent\n\n        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n\n        assertEquals(5, dbNewViaString.da.i);\n\n        assertEquals(13, dbNewViaString.k);\n\n\n\n        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n\n        assertEquals(5, dbNewViaNode.da.i);\n\n        assertEquals(13, dbNewViaNode.k);\n\n\n\n        // update parent\n\n        DataB dbUpdViaString = new DataB();\n\n        DataB dbUpdViaNode = new DataB();\n\n\n\n        assertEquals(1, dbUpdViaString.da.i);\n\n        assertEquals(3, dbUpdViaString.k);\n\n        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n\n        assertEquals(5, dbUpdViaString.da.i);\n\n        assertEquals(13, dbUpdViaString.k);\n\n\n\n        assertEquals(1, dbUpdViaNode.da.i);\n\n        assertEquals(3, dbUpdViaNode.k);\n\n        \n\n        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);\n\n        assertEquals(5, dbUpdViaNode.da.i);\n\n        assertEquals(13, dbUpdViaNode.k);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-55": {
    "id": "JacksonDatabind-55",
    "project": "JacksonDatabind",
    "number": "55",
    "buggy_function": "@SuppressWarnings(\"unchecked\")\n    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType)\n    {\n        if (rawKeyType != null) {\n            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure\n            //   if that is a bug or feature. Regardless, it seems to require dynamic handling\n            //   (compared to getting actual fully typed Enum).\n            //  Note that this might even work from the earlier point, but let's play it safe for now\n            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because\n            //    then there is no static type\n            if (rawKeyType == Enum.class) {\n                return new Dynamic();\n            }\n            if (rawKeyType.isEnum()) {\n                return new Default(Default.TYPE_ENUM, rawKeyType);\n            }\n        }\n        return DEFAULT_KEY_SERIALIZER;\n    }",
    "fixed_function": "@SuppressWarnings(\"unchecked\")\n    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType)\n    {\n        if (rawKeyType != null) {\n            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure\n            //   if that is a bug or feature. Regardless, it seems to require dynamic handling\n            //   (compared to getting actual fully typed Enum).\n            //  Note that this might even work from the earlier point, but let's play it safe for now\n            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because\n            //    then there is no static type\n            if (rawKeyType == Enum.class) {\n                return new Dynamic();\n            }\n            if (rawKeyType.isEnum()) {\n                return EnumKeySerializer.construct(rawKeyType,\n                        EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType));\n            }\n        }\n        return DEFAULT_KEY_SERIALIZER;\n    }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java",
      "first_line": 67,
      "last_line": 86
    },
    "javadoc": "/**\n* Method called if no specified key serializer was located; will return a\n* \"default\" key serializer.\n*\n* @since 2.7\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.ser.TestEnumSerialization::testEnumsWithJsonPropertyAsKey": {
        "source": "    public void testEnumsWithJsonPropertyAsKey() throws Exception\n\n    {\n\n        EnumMap<EnumWithJsonProperty,String> input = new EnumMap<EnumWithJsonProperty,String>(EnumWithJsonProperty.class);\n\n        input.put(EnumWithJsonProperty.A, \"b\");\n\n        assertEquals(\"{\\\"aleph\\\":\\\"b\\\"}\", MAPPER.writeValueAsString(input));\n\n    }\n"
      }
    }
  },
  "JxPath-20": {
    "id": "JxPath-20",
    "project": "JxPath",
    "number": "20",
    "buggy_function": "private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }",
    "fixed_function": "private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch(left, (Iterator) right);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java",
      "first_line": 71,
      "last_line": 99
    },
    "javadoc": "/**\n* Compare left to right.\n* @param left left operand\n* @param right right operand\n* @return operation success/failure\n*/",
    "failing_tests": {
      "org.apache.commons.jxpath.ri.compiler.JXPath149Test::testComplexOperationWithVariables": {
        "source": "    public void testComplexOperationWithVariables() {\n\n        JXPathContext context = JXPathContext.newContext(null);\n\n        context.getVariables().declareVariable(\"a\", Integer.valueOf(0));\n\n        context.getVariables().declareVariable(\"b\", Integer.valueOf(0));\n\n        context.getVariables().declareVariable(\"c\", Integer.valueOf(1));\n\n        assertXPathValue(context, \"$a + $b <= $c\", Boolean.TRUE);\n\n    }\n"
      }
    }
  },
  "JacksonDatabind-63": {
    "id": "JacksonDatabind-63",
    "project": "JacksonDatabind",
    "number": "63",
    "buggy_function": "public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { // can this ever occur?\n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    // Hmmh. Although Class.getName() is mostly ok, it does look\n                    // butt-ugly for arrays.\n                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                    //   as it drops enclosing class. So let's try bit different approach\n                    String pkgName = ClassUtil.getPackageName(cls);\n                    if (pkgName != null) {\n                        sb.append(pkgName);\n                        sb.append('.');\n                    }\n                    sb.append(cls.getSimpleName());\n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }",
    "fixed_function": "public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { // can this ever occur?\n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    // Hmmh. Although Class.getName() is mostly ok, it does look\n                    // butt-ugly for arrays.\n                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                    //   as it drops enclosing class. So let's try bit different approach\n                    int arrays = 0;\n                    while (cls.isArray()) {\n                        cls = cls.getComponentType();\n                        ++arrays;\n                    }\n                    sb.append(cls.getName());\n                    while (--arrays >= 0) {\n                        sb.append(\"[]\");\n                    }\n                    /* was:\n                    String pkgName = ClassUtil.getPackageName(cls);\n                    if (pkgName != null) {\n                        sb.append(pkgName);\n                        sb.append('.');\n                    }\n                    */\n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java",
      "first_line": 118,
      "last_line": 151
    },
    "javadoc": "/**\n* Object through which reference was resolved. Can be either\n* actual instance (usually the case for serialization), or\n* Class (usually the case for deserialization).\n*<p>\n* Note that this value must be `transient` to allow serializability (as\n* often such Object is NOT serializable; or, in case of `Class`, may\n* not available at the point of deserialization). As such will return\n* `null` if instance has been passed using JDK serialization.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.exc.ExceptionPathTest::testReferenceChainForInnerClass": {
        "source": "    public void testReferenceChainForInnerClass() throws Exception\n\n    {\n\n        String json = MAPPER.writeValueAsString(new Outer());\n\n        try {\n\n            MAPPER.readValue(json, Outer.class);\n\n            fail(\"Should not pass\");\n\n        } catch (JsonMappingException e) {\n\n            JsonMappingException.Reference reference = e.getPath().get(0);\n\n            assertEquals(getClass().getName()+\"$Outer[\\\"inner\\\"]\",\n\n                    reference.toString());\n\n        }\n\n    }\n"
      },
      "com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithDefaultDeserialization::testShouldThrowJsonMappingExceptionWithPathReference": {
        "source": "    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {\n\n        // given\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        String input = \"{\\\"bar\\\":{\\\"baz\\\":{qux:\\\"quxValue\\\"))}\";\n\n        final String THIS = getClass().getName();\n\n\n\n        // when\n\n        try {\n\n            mapper.readValue(input, Foo.class);\n\n            fail(\"Upsss! Exception has not been thrown.\");\n\n        } catch (JsonMappingException ex) {\n\n            // then\n\n            assertEquals(THIS+\"$Foo[\\\"bar\\\"]->\"+THIS+\"$Bar[\\\"baz\\\"]\",\n\n                    ex.getPathReference());\n\n        }\n\n    }\n\n}\n"
      },
      "com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithJsonCreatorDeserialization::testShouldThrowJsonMappingExceptionWithPathReference": {
        "source": "    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {\n\n        // given\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        String input = \"{\\\"bar\\\":{\\\"baz\\\":{qux:\\\"quxValue\\\"))}\";\n\n        final String THIS = getClass().getName();\n\n\n\n        // when\n\n        try {\n\n            mapper.readValue(input, Foo.class);\n\n            fail(\"Upsss! Exception has not been thrown.\");\n\n        } catch (JsonMappingException ex) {\n\n            // then\n\n            assertEquals(THIS+\"$Foo[\\\"bar\\\"]->\"+THIS+\"$Bar[\\\"baz\\\"]\",\n\n                    ex.getPathReference());\n\n        }\n\n    }\n\n}\n"
      }
    }
  },
  "Compress-34": {
    "id": "Compress-34",
    "project": "Compress",
    "number": "34",
    "buggy_function": "public ZipShort getCentralDirectoryLength() {\n        return getLocalFileDataLength();\n    }",
    "fixed_function": "public ZipShort getCentralDirectoryLength() {\n        return ZERO;\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java",
      "first_line": 145,
      "last_line": 147
    },
    "javadoc": "/**\n* Length of the extra field in the central directory data - without\n* Header-ID or length specifier.\n*\n* @return a <code>ZipShort</code> for the length of the data of this extra field\n*/",
    "failing_tests": {
      "org.apache.commons.compress.archivers.zip.X7875_NewUnixTest::testParseReparse": {
        "source": "    public void testParseReparse() throws ZipException {\n\n\n\n        // Version=1, Len=0, Len=0.\n\n        final byte[] ZERO_LEN = {1, 0, 0};\n\n\n\n        // Version=1, Len=1, zero, Len=1, zero.\n\n        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n\n\n\n        // Version=1, Len=1, one, Len=1, one\n\n        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n\n\n\n        // Version=1, Len=2, one thousand, Len=2, one thousand\n\n        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n\n\n\n        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n\n        // two's complement, and -1 often has a special meaning.\n\n        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n\n\n\n        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n\n        // Esoteric test:  can we handle 40 bit numbers?\n\n        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n\n\n\n        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n\n        // Esoteric test:  can we handle 64 bit numbers?\n\n        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n\n\n\n        final long TWO_TO_32 = 0x100000000L;\n\n        final long MAX = TWO_TO_32 - 2;\n\n\n\n        parseReparse(0, 0, ZERO_LEN, 0, 0);\n\n        parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n\n        parseReparse(1, 1, ONE_UID_GID, 1, 1);\n\n        parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n\n        parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\n\n        parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\n\n        parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\n\n        parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\n\n\n\n        // We never emit this, but we should be able to parse it:\n\n        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};\n\n        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};\n\n        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\n\n\n\n        assertEquals(255, xf.getUID());\n\n        assertEquals(128, xf.getGID());\n\n        assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));\n\n\n\n        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};\n\n        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};\n\n        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\n\n\n\n        assertEquals(65535, xf.getUID());\n\n        assertEquals(513, xf.getGID());\n\n        assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));\n\n    }\n"
      }
    }
  },
  "Mockito-32": {
    "id": "Mockito-32",
    "project": "Mockito",
    "number": "32",
    "buggy_function": "@SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class)) {\n                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                boolean wasAccessible = field.isAccessible();\n                field.setAccessible(true);\n                try {\n                    Object instance = field.get(testClass);\n                    if (instance == null) {\n                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n                        \t\t  \"The instance must be created *before* initMocks();\\n\" +\n                                  \"Example of correct usage of @Spy:\\n\" +\n                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n\n                    }\n                    if (new MockUtil().isMock(instance)) { \n                        // instance has been spied earlier\n                        Mockito.reset(instance);\n                    } else {\n                        field.set(testClass, Mockito.spy(instance));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                } finally {\n                    field.setAccessible(wasAccessible);\n                }\n            }\n        }\n    }",
    "fixed_function": "@SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class)) {\n                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                boolean wasAccessible = field.isAccessible();\n                field.setAccessible(true);\n                try {\n                    Object instance = field.get(testClass);\n                    if (instance == null) {\n                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n                        \t\t  \"The instance must be created *before* initMocks();\\n\" +\n                                  \"Example of correct usage of @Spy:\\n\" +\n                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n\n                    }\n                    if (new MockUtil().isMock(instance)) { \n                        // instance has been spied earlier\n                        Mockito.reset(instance);\n                    } else {\n                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                } finally {\n                    field.setAccessible(wasAccessible);\n                }\n            }\n        }\n    }",
    "replacement_info": {
      "file": "src/org/mockito/internal/configuration/SpyAnnotationEngine.java",
      "first_line": 27,
      "last_line": 58
    },
    "javadoc": "/*\n* Copyright (c) 2007 Mockito contributors\n* This program is made available under the terms of the MIT License.\n*/",
    "failing_tests": {
      "org.mockitousage.bugs.SpyShouldHaveNiceNameTest::shouldPrintNiceName": {
        "source": "    public void shouldPrintNiceName() {\n\n        //when\n\n        veryCoolSpy.add(1);\n\n\n\n        try {\n\n            verify(veryCoolSpy).add(2);\n\n            fail();\n\n        } catch(AssertionError e) {\n\n            Assertions.assertThat(e.getMessage()).contains(\"veryCoolSpy\");\n\n        }\n\n    }\n"
      }
    }
  },
  "Compress-39": {
    "id": "Compress-39",
    "project": "Compress",
    "number": "39",
    "buggy_function": "public static String sanitize(String s) {\n        final char[] chars = s.toCharArray();\n        final int len = chars.length;\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            final char c = chars[i];\n            if (!Character.isISOControl(c)) {\n                Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n                if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n                    sb.append(c);\n                    continue;\n                }\n            }\n            sb.append('?');\n        }\n        return sb.toString();\n    }",
    "fixed_function": "public static String sanitize(String s) {\n        final char[] cs = s.toCharArray();\n        final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH);\n        if (cs.length > MAX_SANITIZED_NAME_LENGTH) {\n            for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) {\n                chars[i] = '.';\n            }\n        }\n        final int len = chars.length;\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            final char c = chars[i];\n            if (!Character.isISOControl(c)) {\n                Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n                if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n                    sb.append(c);\n                    continue;\n                }\n            }\n            sb.append('?');\n        }\n        return sb.toString();\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java",
      "first_line": 272,
      "last_line": 288
    },
    "javadoc": "/**\n* Returns a \"sanitized\" version of the string given as arguments,\n* where sanitized means non-printable characters have been\n* replaced with a question mark and the outcome is not longer\n* than 255 chars.\n*\n* <p>This method is used to clean up file names when they are\n* used in exception messages as they may end up in log files or\n* as console output and may have been read from a corrupted\n* input.</p>\n*\n* @param s the string to sanitize\n* @return a sanitized version of the argument\n* @since Compress 1.12\n*/",
    "failing_tests": {
      "org.apache.commons.compress.ArchiveUtilsTest::sanitizeShortensString": {
        "source": "    public void sanitizeShortensString() {\n\n        String input = \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\";\n\n        String expected = \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n\n            + \"012345678901...\";\n\n        assertEquals(expected, ArchiveUtils.sanitize(input));\n\n    }\n"
      }
    }
  },
  "Math-61": {
    "id": "Math-61",
    "project": "Math",
    "number": "61",
    "buggy_function": "public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }",
    "fixed_function": "public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }",
    "replacement_info": {
      "file": "src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java",
      "first_line": 92,
      "last_line": 100
    },
    "javadoc": "/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/",
    "failing_tests": {
      "org.apache.commons.math.distribution.PoissonDistributionTest::testMean": {
        "source": "    public void testMean() {\n\n        PoissonDistribution dist;\n\n        try {\n\n            dist = new PoissonDistributionImpl(-1);\n\n            fail(\"negative mean: NotStrictlyPositiveException expected\");\n\n        } catch(NotStrictlyPositiveException ex) {\n\n            // Expected.\n\n        }\n\n\n\n        dist = new PoissonDistributionImpl(10.0);\n\n        assertEquals(10.0, dist.getMean(), 0.0);\n\n    }\n"
      }
    }
  }
}